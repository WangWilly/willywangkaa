<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Algorithm - Computational geometry</title>
    <url>/willywangkaa/2018/10/15/Algorithm-Computational-geometry/</url>
    <content><![CDATA[<h1 id="computational-geometry">Computational geometry</h1>
<h2 id="the-rank-of-a-node">The rank of a node</h2>
<figure>
<img src="\willywangkaa\images\rankofnode.png" alt="rankofnode" /><figcaption aria-hidden="true">rankofnode</figcaption>
</figure>
<ul>
<li>Dominate and rank
<ul>
<li><span class="math inline">\(P_1 = (x_1, y_1)\)</span> dominates <span class="math inline">\(P_2 = (x_2, y_2)\)</span>：<span class="math inline">\(x_1 &gt; x_2\)</span> and <span class="math inline">\(y_1 \geq y_2\)</span></li>
<li>Rank (<span class="math inline">\(P_1\)</span>)：The number of node that <span class="math inline">\(P_1\)</span> dominated</li>
</ul></li>
<li>Input
<ul>
<li>2-D 平面上的點集合 S</li>
</ul></li>
<li>Output
<ul>
<li>每個底的「Rank」</li>
</ul></li>
<li>Native approach
<ul>
<li>對任意點檢查其它有幾個點可以「Dominate」</li>
<li>Time complexity：<span class="math inline">\(\Theta(n^2)\)</span></li>
</ul></li>
</ul>
<h3 id="divide-and-conquer">Divide and conquer</h3>
<figure>
<img src="\willywangkaa\images\rankcomputation.png" alt="rankcomputation" /><figcaption aria-hidden="true">rankcomputation</figcaption>
</figure>
<ol type="1">
<li>先令 m 是集合 S 中每個元素之 x 座標的<strong>中位數 ( median )</strong>，將 S 分成：
<ul>
<li><span class="math inline">\(S_L\)</span>：S 集合中 x 座標小於 m 之元素</li>
<li><span class="math inline">\(S_R\)</span>：S 集合中 x 座標大於 m 之元素</li>
</ul></li>
<li>將 <span class="math inline">\(S_L\)</span> 和 <span class="math inline">\(S_R\)</span> 中每個點的「Rank」求出 ( 遞迴 )
<ul>
<li><strong>終止條件</strong>：若平面上只有一點，則設其「Rank」為零</li>
</ul></li>
<li>對於每個在 <span class="math inline">\(S_R\)</span> 中的點 P 修正其 Rank
<ul>
<li>Rank(P) = Rank(P) + 「在 <span class="math inline">\(S_L\)</span> 中 y 座標比 P 小的點個數」</li>
</ul></li>
<li>回傳 <span class="math inline">\(S_L\)</span> 中點之 Rank 加 <span class="math inline">\(S_R\)</span> 中所有點之 Rank</li>
</ol>
<ul>
<li>Time complexity
<ul>
<li>Step1：<span class="math inline">\(\Theta(n)\)</span></li>
<li>Step2：<span class="math inline">\(2T(\frac n2)\)</span></li>
<li>Step3：<span class="math inline">\(\Theta(n)\)</span></li>
<li><span class="math inline">\(T(n) = 2T(\frac n2) + \Theta(n) = \Theta(n\log n)\)</span></li>
</ul></li>
</ul>
<h2 id="maximal-points">Maximal points</h2>
<figure>
<img src="\willywangkaa\images\maximalpoint.png" alt="maximalpoint" /><figcaption aria-hidden="true">maximalpoint</figcaption>
</figure>
<p>「沒有被任何點 dominate」的點稱為 Maximal point</p>
<figure>
<img src="\willywangkaa\images\maximalpointalgorithm.png" alt="maximalpointalgorithm" /><figcaption aria-hidden="true">maximalpointalgorithm</figcaption>
</figure>
<ol type="1">
<li>先令 m 是集合 S 中每個元素之 x 座標的中位數 ( median )，將 S 分成：
<ul>
<li><span class="math inline">\(S_L\)</span>：S 集合中 x 座標小於 m 之元素</li>
<li><span class="math inline">\(S_R\)</span>：S 集合中 x 座標大於 m 之元素</li>
</ul></li>
<li>將 <span class="math inline">\(S_L\)</span> 和 <span class="math inline">\(S_R\)</span> 中每個點的「Maximal point」求出 ( 遞迴 )
<ul>
<li><strong>終止條件</strong>：若平面上只有一點，則此點即為 Maximal point</li>
</ul></li>
<li>將所有在 <span class="math inline">\(S_L\)</span> 和 <span class="math inline">\(S_R\)</span> 中的「Maximal point」投影到 L 上。並且依照其 Y 值由大到小用線性搜尋的方式找出每一個在 <span class="math inline">\(S_L\)</span> 中的「Maximal point」且其 y 座標比某個 <span class="math inline">\(S_R\)</span> 中的「Maximal point」的 y 座標小者，將其捨去</li>
<li>回傳 <span class="math inline">\(S_R\)</span> 中「Maximal point」與 <span class="math inline">\(S_L\)</span>中剩下的「Maximal point」</li>
</ol>
<ul>
<li>Time complexity
<ul>
<li>Step1：<span class="math inline">\(\Theta(n)\)</span></li>
<li>Step2：<span class="math inline">\(2T(\frac n2)\)</span></li>
<li>Step3：<span class="math inline">\(\Theta(n)\)</span></li>
<li><span class="math inline">\(T(n) = 2T(\frac n2) + \Theta(n) = \Theta(n\log n)\)</span></li>
</ul></li>
</ul>
<h2 id="closest-pairs">Closest pairs</h2>
<p>2-D 平面上的點集合 S，找 S 中距離最小的距離</p>
<ul>
<li>概念
<ul>
<li>計算「有可能Closest pair」兩點的距離，<strong>不計算完全不可能的兩點之距離</strong></li>
</ul></li>
</ul>
<h3 id="divide-and-conquer-1">Divide and conquer</h3>
<ol type="1">
<li>先令 m 是集合 S 中每個元素之 x 座標的中位數 ( median )，將 S 分成：
<ul>
<li><span class="math inline">\(S_L\)</span>：S 集合中 x 座標小於 m 之元素</li>
<li><span class="math inline">\(S_R\)</span>：S 集合中 x 座標大於 m 之元素</li>
</ul></li>
<li>將 <span class="math inline">\(S_L\)</span> 和 <span class="math inline">\(S_R\)</span> 中的 Closest pair 的距離 <span class="math inline">\(d_L\)</span>, <span class="math inline">\(d_R\)</span> 求出 (遞迴)
<ul>
<li><strong>終止條件</strong>：若平面上只有一點，則「Closest pair」的距離為無限大。</li>
</ul></li>
</ol>
<figure>
<img src="\willywangkaa\images\closestpairalgorithm.png" alt="closestpairalgorithm" /><figcaption aria-hidden="true">closestpairalgorithm</figcaption>
</figure>
<ol start="3" type="1">
<li><p>令 d = <span class="math inline">\(min(d_L, d_R)\)</span> (不跨 <span class="math inline">\(S_L、S_R\)</span>) （1）對於在 <span class="math inline">\(S_L\)</span> 中且 <strong>x 座標在 m-d ~ m 中的所有點</strong> p = <span class="math inline">\((x_p, y_p)\)</span> （2）與在 <span class="math inline">\(S_R\)</span> 中且 <strong>x 座標在 m ~ m+d、y 座標在</strong> <span class="math inline">\(y_p -d\)</span> ~ <span class="math inline">\(y_p + d\)</span> <strong>的所有點</strong> g 計算 <span class="math inline">\(min_p\)</span> = min( dist(p, q)<span class="math inline">\(\forall q \in S_R\)</span>) （3）最後令 d' = min( <span class="math inline">\(min_p, \forall p \in S_L\)</span> )</p></li>
<li><p>回傳 min(d, d')</p></li>
</ol>
<ul>
<li>Time complexity
<ul>
<li>Step1：<span class="math inline">\(\Theta(n)\)</span></li>
<li>Step2：<span class="math inline">\(2T(\frac n2)\)</span></li>
<li>Step3：<span class="math inline">\(\frac n2 \times \Theta(1) = \Theta(n)\)</span></li>
<li><span class="math inline">\(T(n) = 2T(\frac n2) + \Theta(n) = \Theta(n\log n)\)</span></li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>Step3 <strong>根據鴿籠原理</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\closestpointnote_1.png" alt="closestpointnote_1" /><figcaption aria-hidden="true">closestpointnote_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\closestpointnote.png" alt="closestpointnote" /><figcaption aria-hidden="true">closestpointnote</figcaption>
</figure>
</blockquote>
<h2 id="convex-hull">Convex hull</h2>
<p>算出 2D 平面上所有點的最小凸多邊形。</p>
<ul>
<li>名詞
<ul>
<li>順時針：Clockwise ；Right-turn</li>
<li>逆時針：Counterclockwise；Left-turn</li>
</ul></li>
</ul>
<h3 id="naive-algorithm">Naive Algorithm</h3>
<ol type="1">
<li><p>令目前平面上 x 座標最小的點為 P ( 必定在凸包上 )</p></li>
<li><p>P 與平面上每一點算出向量</p></li>
<li><p>取其與 x 軸夾角最大的點 V</p></li>
<li><p><strong>旋轉平面使 V 的 x 座標最小化（使 (P,V) 垂直）成為 P'，重複第一步</strong></p></li>
</ol>
<ul>
<li><p>直到回到最一開始的 P 為止</p></li>
<li><p>演示</p>
<ul>
<li>左：P</li>
<li>次：V</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\convexhull_1.png" alt="convexhull_1" /><figcaption aria-hidden="true">convexhull_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\convexhull_2.png" alt="convexhull_2" /><figcaption aria-hidden="true">convexhull_2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\convexhull_3.png" alt="convexhull_3" /><figcaption aria-hidden="true">convexhull_3</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\convexhull_4.png" alt="convexhull_4" /><figcaption aria-hidden="true">convexhull_4</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\convexhull_5.png" alt="convexhull_5" /><figcaption aria-hidden="true">convexhull_5</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\convexhull_6.png" alt="convexhull_6" /><figcaption aria-hidden="true">convexhull_6</figcaption>
</figure>
<ul>
<li>Time complexity
<ul>
<li>若有 n 點必須重複上述動作 n 遍，其中每一遍需要：
<ul>
<li>Step1 算出與其餘點的所有向量：<span class="math inline">\(O(n)\)</span></li>
<li>Step2 找出與 x 軸夾角最大的 V 點：<span class="math inline">\(O(n)\)</span></li>
<li>Step3 旋轉平面：<span class="math inline">\(O(n)\)</span></li>
</ul></li>
<li><span class="math inline">\(\Rightarrow O(n^2)\)</span></li>
</ul></li>
</ul>
<h3 id="graham-scan">Graham scan</h3>
<ol type="1">
<li><p>找出點 <span class="math inline">\(p_0\)</span> ：2D 平面上做有點中 y 座標最小者 ( 若有多個最小點取其中最左者 )</p></li>
<li><p>找出有序集 <span class="math inline">\(＜P_1, P_2, \ldots, P_n＞\)</span>：依照從 <span class="math inline">\(P_0\)</span> 對每個點取向量之<strong>角度</strong>由小到大排列</p>
<ul>
<li>若兩個以上的點角度相同，則保留離 <span class="math inline">\(p_0\)</span> 最近的點</li>
</ul></li>
<li><p>建構一個空的「堆疊( Stack )」 <span class="math inline">\(S\)</span> ( <strong>最後凸包的接點</strong> )</p>
<ul>
<li>建構完後 <strong>push(</strong><span class="math inline">\(p_0, S\)</span><strong>)、push(</strong><span class="math inline">\(p_1, S\)</span><strong>)、push(</strong><span class="math inline">\(p_2, S\)</span><strong>)</strong></li>
</ul></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. (第四步)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">	a = <span class="built_in">second</span>(S);</span><br><span class="line">	b = <span class="built_in">top</span>(S);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cross_product</span>(<span class="built_in">vector</span>(p_i, a), <span class="built_in">vector</span>(p_i, b)) != <span class="string">&quot;left_turn&quot;</span>) &#123;</span><br><span class="line">		<span class="built_in">pop</span>(S);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push</span>(p_i, S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>外積 ( Cross porduct )</li>
</ul>
<p>給定兩向量 <span class="math inline">\(\vec{p_1} = (x_1, y_1), \vec{p_2} = (x_2, y_2)\)</span></p>
<p>其外積為 <span class="math inline">\(\vec{p_1} \times \vec{p_2} = det \begin{bmatrix}x_1 &amp; x_2\\ y_1 &amp; y_2 \end{bmatrix}\)</span></p>
<p><span class="math inline">\(\vec{p_1} \times \vec{p_2} &gt; 0\)</span>：稱 <span class="math inline">\(\vec{p_1}\)</span> 往 <span class="math inline">\(\vec{p_2}\)</span> 為「Right turn」</p>
<p><span class="math inline">\(\vec{p_1} \times \vec{p_2} &lt; 0\)</span>：稱 <span class="math inline">\(\vec{p_1}\)</span> 往 <span class="math inline">\(\vec{p_2}\)</span> 為「Left turn」</p>
</blockquote>
<ul>
<li>Time complexity
<ul>
<li>Step1：<span class="math inline">\(\Theta(n)\)</span></li>
<li>Step2：<span class="math inline">\(\Theta(n\lg n)\)</span></li>
<li>Step3：<span class="math inline">\(\Theta(1)\)</span></li>
<li><strong>Step4</strong>：<span class="math inline">\(\Theta(n)\)</span>
<ul>
<li>每一個點一定會被「push stack」一次</li>
<li>而最多會被「pop stack 」 一次，且再也不會重新「push stack」</li>
<li>所以對於 stack 來說「push」會做 n 次，「pop」最多 n 次，所以最多 2n 次</li>
</ul></li>
</ul></li>
</ul>
<h4 id="應用">應用</h4>
<ul>
<li>(92 台大) 在 2-D 空間中給定點集合 <span class="math inline">\(S = ｛(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)｝\)</span> 一判斷是否有三點為共線 ( collinear )，使用一個 <span class="math inline">\(O(n^2 \log n)\)</span> 演算法解之</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">collinear</span> <span class="params">(G)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		set A = &#123;&#125;;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n ; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(j != i) &#123;</span><br><span class="line">				vector_2D tmp = <span class="built_in">vec</span>(S[i], S[j]);</span><br><span class="line">				<span class="built_in">push</span>(tmp, A);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">sort</span>(A); <span class="comment">// 以斜率排序 O(nlogn)</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n ; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>( <span class="built_in">slope</span>(A[j]) == <span class="built_in">slope</span>(A[j+<span class="number">1</span>]) )</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>(97 台大)找到 farthest pair
<ul>
<li>2D 平面上最遠的兩點必為在 Convex hull 上的某兩點</li>
</ul></li>
</ul>
<p>最遠的兩點必定「互相排斥」，意思是說通過該兩點的兩條平行線會使的其他所有點都在這個之內 ( 紅點、綠點；紅點、黃點 )</p>
<figure>
<img src="\willywangkaa\images\farthestpair_1.png" alt="farthestpair_1" /><figcaption aria-hidden="true">farthestpair_1</figcaption>
</figure>
<ul>
<li>如何找到「凸包上面哪個點會和哪個點<strong>互相排斥</strong>」？</li>
</ul>
<figure>
<img src="\willywangkaa\images\farthestpair_2.png" alt="farthestpair_2" /><figcaption aria-hidden="true">farthestpair_2</figcaption>
</figure>
<p>在該點 ( 紅點 ) 兩鄰邊 ( 黃邊、綠邊 ) 之「最遠點」之間( <strong>黃點與綠點之間的藍點</strong> )<strong>的所有點都有可以與紅點互相排斥</strong></p>
<figure>
<img src="\willywangkaa\images\farthestpair_3.png" alt="farthestpair_3" /><figcaption aria-hidden="true">farthestpair_3</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\farthestpair_4.png" alt="farthestpair_4" /><figcaption aria-hidden="true">farthestpair_4</figcaption>
</figure>
<blockquote>
<p>如何求邊的最遠點？</p>
<ul>
<li>名詞
<ul>
<li>「Bitonic sequence」：在碰到「Bitonic point」之前的序列「單調上升」；之後「單調下降」</li>
</ul></li>
</ul>
<p>( 假設要幫黃邊找最遠點<strong>黃點</strong> ) 將除了黃邊上之外的點對黃邊做<em>點到邊的距離</em>並且依序記錄成一個「Bitonic sequence」，接著在該序列中找到中找「Bitonic point」( 也就是我們要找的最遠點黃點 )</p>
<ul>
<li>Time complexity
<ul>
<li>在「Bitonic sequence」找「Bitonic point」其實只要使用「Binary search」<span class="math inline">\(O(\log n)\)</span> 即可
<ul>
<li><span class="math inline">\(finBT(arr, L, R)\xrightarrow{mid = \frac{L + R}{2}}\left\{\begin{matrix} mid, if \; arr[mid-1] &lt; arr[mid] \; ＆ \; arr[mid] &gt; arr[mid+1] \\findBT(arr, mid+1, R), if\;arr[mid] &lt; arr[mid+1] \\findBT(arr, L, mid), if\;arr[mid] &gt; arr[mid+1]\end{matrix}\right.\)</span></li>
</ul></li>
</ul></li>
<li>相鄰兩頂點共用 <span class="math inline">\(O(1)\)</span> 個「排斥點」( 下圖<strong>綠邊</strong>上的藍點與紅點有共同「排斥點」<strong>綠點</strong>；有可能不只一個 )</li>
</ul>
<figure>
<img src="\willywangkaa\images\farthestpair_6.png" alt="farthestpair_6" /><figcaption aria-hidden="true">farthestpair_6</figcaption>
</figure>
</blockquote>
<p>演算法 (假設平面上有 n 個點)</p>
<ol type="1">
<li>使用「Graham scan algorithm」將<strong>有 m 個頂點的凸包</strong>找出</li>
<li>在使用「Find bitonic point algorithm」將每邊的<strong>最遠點</strong>找出</li>
<li>使用最遠點將凸包上的頂點<strong>分成 m 片段</strong></li>
<li>使用凸包片段列出 <span class="math inline">\(O(m)\)</span> 對「互相排斥」的點並找出最遠的一個</li>
<li>使用 <span class="math inline">\(O(m)\)</span> 線性找出最遠的一組</li>
</ol>
<p>Time complexity</p>
<p>Step1 <span class="math inline">\(O(n\log n)\)</span></p>
<p>Step2 <span class="math inline">\(O(n\log n)\)</span></p>
<p>加總 <span class="math inline">\(O(n\log n)\)</span></p>
<ul>
<li>(100 政大) 判斷多邊形是 Convex 或 Concase
<ul>
<li>使用 Graham scan 判斷連續三點是否形成凹角即可</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Computational geometry</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - Approximation algorithm</title>
    <url>/willywangkaa/2018/10/15/Algorithm-Approximation-algorithm/</url>
    <content><![CDATA[<h1 id="approximation-ratio">Approximation ratio</h1>
<p>A ：「Approximation algorithm」</p>
<p>OPT ：「Optimal algorithm」</p>
<ul>
<li>對任何輸入 x</li>
<li>∣A(x)∣ ≦ α×∣OPT(x)∣
<ul>
<li>稱 A 的「Approximation ratio」為 α</li>
</ul></li>
</ul>
<p><strong>（下方討論皆以「最小化問題」處理）</strong></p>
<blockquote>
<ul>
<li>A(x)：以 x 為輸入產生的輸出大小
<ul>
<li><strong>∣A(x)∣ ≦ α×∣OPT(x)∣ 意旨</strong>
<ul>
<li><strong>「近似演算法解決方案之值」小於等於 「α × 最佳解決方案之值」</strong></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h1 id="approximation-algorithm-for-minimum-vertex-cover-problem">Approximation algorithm for minimum vertex cover problem</h1>
<figure>
<img src="\willywangkaa\images\vertexcoverproblem.png" alt="vertexcoverproblem" /><figcaption aria-hidden="true">vertexcoverproblem</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vertex cover algorithm</span></span><br><span class="line"><span class="comment">// input G</span></span><br><span class="line"><span class="function">set <span class="title">vertex_cover_approximation</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    c  = ∅;                            <span class="comment">// 建立一空集合用來儲存「Vertex cover」</span></span><br><span class="line">    E′ = G.E;</span><br><span class="line">    <span class="keyword">while</span>(E′ ≠ ∅) &#123;</span><br><span class="line">        (u, v) = <span class="built_in">get_element</span>(E′);      <span class="comment">// 從 E′ 集合中取任意一邊</span></span><br><span class="line">        c      = c ∪ &#123;u,v&#125;;</span><br><span class="line">        E′     = <span class="built_in">differ</span>(E′,u,v);       <span class="comment">// 將 E′ 所有含有頂點 u、v 的邊去除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="\willywangkaa\images\vertexcoverapproxi.png" alt="vertexcoverapproxi" /><figcaption aria-hidden="true">vertexcoverapproxi</figcaption>
</figure>
<ul>
<li><strong>Time complexity</strong>
<ul>
<li>在 <code>while</code> 每回合<strong>至少</strong>去除一條邊
<ul>
<li>G 中總共有 ∣E∣ 條邊
<ul>
<li><span class="math inline">\(\Theta(∣E∣)\)</span></li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Approximation ratio</strong>
<ul>
<li><strong>「Vertex cover problem」</strong>
<ul>
<li>此問題欲找一頂點集合<strong>涵蓋圖中所有的邊</strong></li>
<li><strong>任挑</strong>圖中一邊
<ul>
<li><strong>連接該邊其中一點必存在「Minimum vertex cover」集合</strong></li>
</ul></li>
</ul></li>
<li><strong>近似演算法分析</strong>
<ul>
<li>每回合任挑一邊並將其兩頂點加入 c 集合
<ul>
<li><strong>最差情況下只有一頂點亦存在於「Minimum vertex cover」</strong></li>
<li><strong>|c| ≦ 2 × |Minimum vertex cover|</strong></li>
</ul></li>
<li><strong>Approximation ratio（α）： 2</strong></li>
</ul></li>
</ul></li>
</ul>
<h1 id="approximation-algorithm-for-euclidean-traveling-salesman-problem">Approximation algorithm for euclidean traveling salesman problem</h1>
<blockquote>
<p>在<strong>歐式空間</strong>上探討「Traveling salesman problem」（TSP）</p>
<ul>
<li>給歐式平面與平面上 n 個頂點，求
<ul>
<li>一<strong>環路（Cycle）</strong>經過每個點恰一次</li>
<li><strong>其「Euclidean distance」總和最小</strong></li>
</ul></li>
</ul>
</blockquote>
<figure>
<img src="\willywangkaa\images\EDTSP.png" alt="EDTSP" /><figcaption aria-hidden="true">EDTSP</figcaption>
</figure>
<p>步驟</p>
<ol type="1">
<li>選一頂點 v 作根節點（Root）
<ul>
<li>將歐式空間上每點兩兩相連成「完全圖」（<span class="math inline">\(G\)</span>）</li>
</ul></li>
<li>以 v 為起點作「<strong>Prim's algorithm</strong>」算 <span class="math inline">\(G\)</span> 的「最小生成樹」 <span class="math inline">\(T\)</span></li>
<li>令 <span class="math inline">\(L\)</span> 為 <span class="math inline">\(T\)</span> 之「Preorder traversal」序列（Sequence）
<ul>
<li>依 L 的順序將點相連，以求取其環路 <span class="math inline">\(C\)</span></li>
</ul></li>
</ol>
<ul>
<li><strong>Time complexity</strong>
<ul>
<li>Step 1
<ul>
<li>任選一頂點
<ul>
<li><span class="math inline">\(\Theta(1)\)</span></li>
</ul></li>
<li>將平面上點兩兩相連
<ul>
<li><span class="math inline">\(\Theta(∣V∣^2)\)</span></li>
</ul></li>
</ul></li>
<li>Step 2
<ul>
<li>使用「Prim's algorithm」
<ul>
<li><span class="math inline">\(\Theta(∣V∣^2)\)</span></li>
</ul></li>
</ul></li>
<li>Step 3
<ul>
<li>「Preorder traversal」
<ul>
<li><span class="math inline">\(\Theta(∣V∣)\)</span></li>
</ul></li>
<li>求環路
<ul>
<li><span class="math inline">\(\Theta(∣V∣)\)</span></li>
</ul></li>
</ul></li>
<li><strong>時間複雜度總和</strong>
<ul>
<li><span class="math inline">\(\Rightarrow \Theta(∣V∣^2)\)</span></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\EDTSPapproxi.png" alt="EDTSPapproxi" /><figcaption aria-hidden="true">EDTSPapproxi</figcaption>
</figure>
<ul>
<li><strong>Approximation ratio </strong>（100 中央資工）
<ul>
<li><strong>假設</strong>
<ul>
<li><span class="math inline">\(C^＊\)</span>
<ul>
<li>TSP 之「最佳環路」</li>
</ul></li>
<li><span class="math inline">\(T\)</span>
<ul>
<li>第二步求出的「最小生成樹」</li>
</ul></li>
<li><span class="math inline">\(W\)</span>（路徑序列）
<ul>
<li>「Full walk」（以前序遍歷 <span class="math inline">\(T\)</span> 的每個頂點）</li>
<li>完整走完 <span class="math inline">\(T\)</span> 每條樹邊兩次</li>
</ul></li>
</ul></li>
<li><strong>證明</strong>
<ul>
<li>若去除 <span class="math inline">\(C^＊\)</span> 任一邊
<ul>
<li><strong>則形成一生成樹 </strong><span class="math inline">\(T&#39;\)</span></li>
<li>因為 <span class="math inline">\(T\)</span> 為最小生成樹
<ul>
<li>則 distance(<span class="math inline">\(T\)</span>) ≦ distance(<span class="math inline">\(T&#39;\)</span>) ≦ <strong>cost(</strong><span class="math inline">\(C^＊\)</span><strong>)</strong>...（1）</li>
</ul></li>
<li><span class="math inline">\(W\)</span> 將 <span class="math inline">\(T\)</span> 所有邊走過兩次
<ul>
<li>則 cost(<span class="math inline">\(W\)</span>) = 2×cost(<span class="math inline">\(T\)</span>)...（2）</li>
</ul></li>
</ul></li>
<li>以路經序列 <span class="math inline">\(W\)</span> 求<strong>近似解</strong>之環路序列 <span class="math inline">\(C\)</span>
<ul>
<li><strong>保留頭尾</strong></li>
<li>自前至後將「已追蹤過點」去除</li>
<li>因三角不等式（dist(a,b) ≦ dist(a,c) + dist(c,b)）
<ul>
<li>cost(<span class="math inline">\(C\)</span>) ≦ cost(<span class="math inline">\(W\)</span>)<strong>...（3）</strong></li>
</ul></li>
</ul></li>
<li>從（2）、（3）可知
<ul>
<li>cost(<span class="math inline">\(C\)</span>) ≦ 2×cost(<span class="math inline">\(T\)</span>)...（4）</li>
</ul></li>
<li>從（1）、（4）可知
<ul>
<li>cost(<span class="math inline">\(C\)</span>) ≦ 2×cost(<span class="math inline">\(C^＊\)</span>)</li>
</ul></li>
<li><strong>Approximation ratio（α）：2</strong></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\triangleinequality.png" alt="triangleinequality" /><figcaption aria-hidden="true">triangleinequality</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\EDTSP_optimalsol.png" alt="EDTSP_optimalsol" /><figcaption aria-hidden="true">EDTSP_optimalsol</figcaption>
</figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Approximation algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - Dynamic programming</title>
    <url>/willywangkaa/2018/09/23/Algorithm-Dynamic-programming/</url>
    <content><![CDATA[<h1 id="dynamic-programming">Dynamic programming</h1>
<p>將已<strong>計算的結果</strong>記錄在<strong>表格中</strong>的技巧，目的是為了要避免<strong>重複計算相同子問題</strong>，以<strong>「Button up」</strong>的方式實踐。</p>
<ul>
<li>為何要使用這種方法，以<strong>費氏數列程式</strong>開始討論。</li>
</ul>
<p><span class="math display">\[
F_n = \left\{\begin{matrix}
0 &amp; , if \; n = 0\\
1 &amp; , if \; n = 1\\
F_{n-1} + F_{n-2} &amp; , if \; n \geq 2   
\end{matrix}\right.
\]</span> 欲求出 <span class="math inline">\(F_5\)</span> ，以遞迴程式執行，會造成「Overlapping subproblem」，如下圖 <span class="math inline">\(F_2\)</span> 重複計算了 3 次，<span class="math inline">\(F_3\)</span> 重複計算 2 次。</p>
<figure>
<img src="\willywangkaa\images\overlappingsubproblem.png" alt="overlappingsubproblem" /><figcaption aria-hidden="true">overlappingsubproblem</figcaption>
</figure>
<p>使用動態表格執行之，可以省去很多不必要的重複計算，如下圖。</p>
<figure>
<img src="\willywangkaa\images\fibonassidp.png" alt="fibonassidp" /><figcaption aria-hidden="true">fibonassidp</figcaption>
</figure>
<ul>
<li>構思動態規劃題目的流程
<ul>
<li>Optimal substructure：一個<strong>母問題的最佳解</strong>如何由<strong>其子問題的最佳</strong>解構成。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\observedp.png" alt="observedp" /><figcaption aria-hidden="true">observedp</figcaption>
</figure>
<h2 id="shortest-path-problem">Shortest path problem</h2>
<ul>
<li><strong>Optimal substructure</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\shortestpathproblem_subproblem.png" alt="shortestpathproblem_subproblem" /><figcaption aria-hidden="true">shortestpathproblem_subproblem</figcaption>
</figure>
<blockquote>
<p>(98 交大資工) 問 longest path problem 有無 optimal substructure。</p>
<p>無，所以不可以使用動態規劃解此問題。</p>
<figure>
<img src="\willywangkaa\images\longestpathproblem.png" alt="longestpathproblem" /><figcaption aria-hidden="true">longestpathproblem</figcaption>
</figure>
<p><strong>但是</strong>如果此圖加上「Acyclic」、「Direct」等條件限制之後，可以用動態規劃解「longest path problem」。</p>
</blockquote>
<blockquote>
<p>通常要在各種條件之下都可以使用<strong>動態規劃解此問題</strong>，才可以<strong>宣稱此問題可以使用動態規劃解</strong>。</p>
</blockquote>
<ul>
<li>Ex (99 交大)
<ul>
<li>下列何者<strong>正確</strong>？
<ul>
<li>（a）Dynamic programming always provides polynominal time algorithm.</li>
<li>（b）Huffman coding for compresion is a typical dynamic programming algorithm.</li>
<li>（c）Dynamic programming use the table to design the algorithm.</li>
<li>（d）Optimal is a important element in the dynamic programming.</li>
<li>（e）<strong>Single source all shortest path problem</strong> has optimal substructure.</li>
</ul></li>
<li>Ans
<ul>
<li>（a）：false。反例為 Subset-sum problem (暴力法：<span class="math inline">\(O(2^n)、動態規劃法：\)</span><span class="math inline">\(O(n2^{\frac n2})\)</span>)</li>
<li>（b）：false。為典型的 Greedy algorithm。</li>
<li><strong>（c）</strong></li>
<li><strong>（d）</strong></li>
<li><strong>（e）</strong></li>
</ul></li>
</ul></li>
</ul>
<h2 id="knapsack-problem">Knapsack problem</h2>
<h3 id="fractional-knapsack-problem">Fractional knapsack problem</h3>
<blockquote>
<ol type="1">
<li>此方法僅限於物品重量為正整數時</li>
<li>0/1 KP 為 NP - Completed 問題</li>
</ol>
</blockquote>
<ul>
<li>Input：
<ul>
<li>n 個物件
<ul>
<li>第 i 個重量為 <span class="math inline">\(w_i\)</span> ，價值為 <span class="math inline">\(v_i\)</span>。</li>
</ul></li>
<li>背包最大負重
<ul>
<li><span class="math inline">\(W\)</span></li>
</ul></li>
</ul></li>
<li>Output：
<ul>
<li>最大的獲利值</li>
</ul></li>
<li>限制條件：
<ul>
<li>取得物品的總重量 <span class="math inline">\(\leq\)</span> W</li>
<li>可取物品的<strong>部分</strong></li>
</ul></li>
<li>想法
<ul>
<li><strong>Greedy</strong>：從目前 <span class="math inline">\(\frac{v_i}{w_i}\)</span> 最高的物品開始拿取，直到物品取完，或是取得物品負重已達 W。</li>
</ul></li>
<li>Time Complexity
<ul>
<li><span class="math inline">\(\Theta(n\log n)\)</span></li>
</ul></li>
<li>Ex ( W = 5 )</li>
</ul>
<table>
<thead>
<tr class="header">
<th>Item</th>
<th><span class="math inline">\(v_i\)</span></th>
<th><span class="math inline">\(w_i\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>10</td>
<td>2</td>
</tr>
<tr class="even">
<td>2</td>
<td>6</td>
<td>1</td>
</tr>
<tr class="odd">
<td>3</td>
<td>12</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><span class="math display">\[
\frac{v_2}{w_2} = 6 \geq \frac{v_1}{w_1} = 5 \geq \frac{v_3}{w_3} = 4
\]</span></p>
<ol type="1">
<li>取物品 2，取該物品之 1 單位重量，背包剩餘空間 4 單位重量，獲利 6 單位價值。</li>
<li>取物品 1，取物品之 2 單位重量，背包剩餘空間 2 單位重量，獲利 16 單位價值。</li>
<li>取物品 3，取物品之 2 單位重量，背包剩餘空間 0 單位重量，<strong>獲利 24 單位價值</strong>。</li>
</ol>
<figure>
<img src="\willywangkaa\images\kpdp.png" alt="kpdp" /><figcaption aria-hidden="true">kpdp</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>0</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0</td>
<td>6</td>
<td>10</td>
<td>16</td>
<td>16</td>
<td>16</td>
</tr>
<tr class="even">
<td>3</td>
<td>0</td>
<td>6</td>
<td>10</td>
<td>16</td>
<td>18</td>
<td><strong>22</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>Ex ( 98 交大 ) P.3-66 ex10
<ul>
<li>Maximize <span class="math inline">\(\sum_{i = 1}^n v_ix_i \; subject\; to \sum_{i = 1}^n w_ix_i \leq W, 0 \leq x_i \leq 1\)</span></li>
<li>Greedy choise property ( <span class="math inline">\(\frac{v_1}{w_1} \geq \frac{v_2}{w_2} \geq\ldots\)</span> )</li>
<li>最佳解的 <span class="math inline">\(x_1\)</span> 需取多少。</li>
</ul></li>
</ul>
<p><span class="math display">\[
x_n = \left\{\begin{matrix}
1 &amp; , if \; w_1 \leq W \\
\frac{W}{w_1} &amp; , if \; w1 &gt; W \\   
\end{matrix}\right.
\]</span></p>
<h3 id="knapsack-problem-1">0-1 Knapsack problem</h3>
<ul>
<li><p>Input：</p>
<ul>
<li>n 個物件
<ul>
<li>第 i 個重量為 <span class="math inline">\(w_i\)</span> ，價值為 <span class="math inline">\(v_i\)</span>。</li>
</ul></li>
<li>背包最大負重
<ul>
<li><span class="math inline">\(W\)</span></li>
</ul></li>
</ul></li>
<li><p>Output：</p>
<ul>
<li>最大的獲利值</li>
</ul></li>
<li><p>限制條件：</p>
<ul>
<li>取得物品的總重量 <span class="math inline">\(\leq\)</span> W</li>
<li>只能取物品的<strong>整體</strong></li>
</ul></li>
<li><p>想法</p>
<ul>
<li><p>無法使用 Greedy method 解決</p></li>
<li><p><strong>使用動態規劃解決，物品的重量必為正整數</strong></p>
<ul>
<li>遞迴結構：(令 <span class="math inline">\(C[i][k]\)</span> 在負重 k 之下考慮物品 1 ... i 之最大獲利</li>
</ul>
<p><span class="math display">\[
C[i][k] = \left\{\begin{matrix}
0 &amp; , if \;i = 0\;OR\; k = 0 \\
max(C[i-1][k-w_i]+v_i, C[i-1][k] )&amp; , if \; w_i \leq k \\
C[i-1][k] &amp; , if \; w_i &gt; k \\
\end{matrix}\right.
\]</span></p></li>
</ul></li>
<li><p>Algorithm ( Bottom up )</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for k &lt;- 0 to w</span><br><span class="line">	c[0, k] &lt;- 0</span><br><span class="line">for i &lt;- 1 to n</span><br><span class="line">&#123;</span><br><span class="line">    c[i, 0] &lt;- 0</span><br><span class="line">    for k &lt;- 1 to w</span><br><span class="line">    &#123;</span><br><span class="line">        if k &lt; w_i</span><br><span class="line">        	c[i, k] &lt;- c[i-1, k]</span><br><span class="line">        else</span><br><span class="line">        	c[i, k] &lt;- max(c[i-1, k], c[i-1, k-w_i]+v_i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li><span class="math inline">\(\Theta( nW )\)</span> <strong>Pseudo-polynominal</strong></li>
</ul></li>
<li>Space complexity
<ul>
<li><span class="math inline">\(\Theta( nW )\)</span></li>
</ul></li>
</ul>
<h3 id="branch-and-bound-解-0-1-knapsack-problem">Branch and bound 解 0-1 Knapsack problem</h3>
<blockquote>
<ul>
<li>對於一個 NP-Completed 問題來說，可以使用「Branch and bound」來解決</li>
<li>「Branch and bound」演算法中，<strong>「Bounding function」</strong>的設計會是影響整體效能最大的關鍵 ( 收斂快慢 )。</li>
<li>Time complexity：O( 葉節點個數 )
<ul>
<li>葉節點個數取決問題本身。
<ul>
<li>組合性問題：<span class="math inline">\(2^n\)</span></li>
<li>排列性問題：<span class="math inline">\(n!\)</span></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li><p>將球最佳解的過程視為在一個「State space tree」中尋找最好的節點。</p></li>
<li><p>實務上，通常是設計一 個<strong>「Bounding function」</strong>以估計目前狀態可到最佳解的可能性。</p>
<ul>
<li>建構「State space tree」時，每次都先<strong>展開「Bounding function」的節點。( Branch )</strong></li>
<li>在每次展開的過程中，都可以得到一個<strong>目前最佳解 (葉節點)，接著，之後不展開「Bounding function 值</strong> <span class="math inline">\(\leq\)</span> <strong>目前最佳解」</strong>的內部節點。<strong>( Bound )</strong></li>
</ul></li>
<li><p>以 Branch and bound 解 0-1 Knapsack problem</p>
<ul>
<li>每個節點須紀錄
<ul>
<li><strong>目前的獲利</strong></li>
<li><strong>目前的負重</strong></li>
<li><strong>「Bounding function」算出的值</strong></li>
</ul></li>
</ul></li>
</ul>
<ol type="1">
<li>為了計算「Bounding funciton」括號中要估計「Fractional knapsack」的未來最大值，需要將物品依照 <span class="math inline">\(\frac{v_i}{w_i}\)</span> 排序。</li>
</ol>
<p><span class="math inline">\(w = 4\)</span></p>
<table>
<thead>
<tr class="header">
<th>Item</th>
<th><span class="math inline">\(v_i\)</span></th>
<th><span class="math inline">\(w_i\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>6</td>
<td>1</td>
</tr>
<tr class="even">
<td>2</td>
<td>10</td>
<td>2</td>
</tr>
<tr class="odd">
<td>3</td>
<td>12</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><span class="math display">\[
\frac{v_2}{w_2} = 6 \geq \frac{v_1}{w_1} = 5 \geq \frac{v_3}{w_3} = 4
\]</span></p>
<ol start="2" type="1">
<li><strong>設計「Bounding function」。(括號部分就是用來估計以目前節點拓展，獲利的上限)</strong></li>
</ol>
<p><span class="math display">\[
Bounding \;funciotn(目前的節點)\\
= 在「目前的節點」上可得的獲利 + \\
(將背包剩餘的重量以「Fractional \;knapsack \;problem」拿取剩下的物品的獲利)
\]</span></p>
<figure>
<img src="\willywangkaa\images\KPstatesearchtree.png" alt="KPstatesearchtree" /><figcaption aria-hidden="true">KPstatesearchtree</figcaption>
</figure>
<ol start="3" type="1">
<li>拓展節點
<ol type="1">
<li>展開 <strong>Root</strong></li>
<li>因為該節點「Bounding function」最大，所以展開 <strong>A</strong></li>
<li>展開節點 <strong>C</strong></li>
<li><strong>E</strong> 節點因為超重所以為「Infeasiable solution」</li>
<li><strong>F</strong> 為一可能解，使 <span class="math inline">\(Max = 16\)</span></li>
<li>因為節點 <strong>D</strong> 在樹中較深處，先展開之</li>
<li><strong>G</strong> 與 <strong>H</strong> 均為一解，設 <span class="math inline">\(Max = 18\)</span></li>
<li>因為節點 <strong>B</strong> 的「Bounding function」<span class="math inline">\(\leq\)</span> <strong>Max</strong>，不展開該節點</li>
</ol></li>
<li>Ans：18 ( 取<strong>物品一</strong>與<strong>物品三</strong> )</li>
</ol>
<h2 id="longest-common-subsequence">Longest Common Subsequence</h2>
<ul>
<li>Sequence
<ul>
<li>X = ＜a, b, c, a＞</li>
</ul></li>
<li>Subsequence
<ul>
<li>＜a, c＞ 為 X 的「Subsequence」</li>
</ul></li>
<li>Prefix ( 前綴 )
<ul>
<li><span class="math inline">\(X_3 = ＜a, b, c＞\)</span></li>
</ul></li>
<li>Common subsequence
<ul>
<li>Y = ＜a, c, b, c＞</li>
<li>則＜a, c＞為 X 與 Y 的「Common subsequence」</li>
</ul></li>
<li>Longest common subsequence
<ul>
<li>＜a, b, c＞ 為 X 與 Y 的「LCS」</li>
</ul></li>
</ul>
<blockquote>
<p>「LCS」不一定唯一</p>
</blockquote>
<ul>
<li>遞迴結構
<ul>
<li>令 <span class="math inline">\(c[i , j]\)</span> 為 <span class="math inline">\(LCS(X_i, Y_j)\)</span> 的長，則：</li>
</ul></li>
</ul>
<p><span class="math display">\[
c[i, j] = \left\{\begin{matrix}
0 &amp; , if \;i = 0\;OR\; j = 0 &amp; \\
c[i-1, j-1] + 1 &amp; , if \; X[i] = Y[j] &amp; \\
max(c[i-1, j], c[i, j-1])&amp; , if \; X[i] \ne Y[j] \; &amp; （該兩個字絕對不會同時出現在LCS）
\end{matrix}\right.
\]</span></p>
<ul>
<li>演算法 ( Bottom-up )</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for j &lt;- 0 to n</span><br><span class="line">	c[0, j] &lt;- 0</span><br><span class="line">for i &lt;- 0 to m</span><br><span class="line">	c[i, 0] &lt;- 0</span><br><span class="line">for i &lt;- 1 to m</span><br><span class="line">	for j &lt;- 1 to n</span><br><span class="line">	&#123;</span><br><span class="line">        if(X[i] = Y[i])</span><br><span class="line">        	c[i, j] = c[i-1, j-1] + 1</span><br><span class="line">        else</span><br><span class="line">        	c[i, j] = max(c[i-1, j], c[i, j-1])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li><span class="math inline">\(\Theta(mn)\)</span></li>
</ul></li>
<li>Space complexity
<ul>
<li><span class="math inline">\(\Theta(mn)\)</span></li>
</ul></li>
<li>Ex
<ul>
<li>X = ＜a, b, a, c＞</li>
<li>Y = ＜a, b, c, a＞</li>
<li>求「LCS」</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">-</th>
<th style="text-align: center;">-</th>
<th style="text-align: center;">-</th>
<th style="text-align: center;">"a"</th>
<th style="text-align: center;">"b"</th>
<th style="text-align: center;">"a"</th>
<th style="text-align: center;">"c"</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>-</strong></td>
<td style="text-align: center;"><strong>-</strong></td>
<td style="text-align: center;"><strong>0</strong></td>
<td style="text-align: center;"><strong>1</strong></td>
<td style="text-align: center;"><strong>2</strong></td>
<td style="text-align: center;"><strong>3</strong></td>
<td style="text-align: center;"><strong>4</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>-</strong></td>
<td style="text-align: center;"><strong>0</strong></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>"a"</strong></td>
<td style="text-align: center;"><strong>1</strong></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1（↖）</td>
<td style="text-align: center;">1（←）</td>
<td style="text-align: center;">1（↖）</td>
<td style="text-align: center;">1（←）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>"b"</strong></td>
<td style="text-align: center;"><strong>2</strong></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1（↑）</td>
<td style="text-align: center;">2（↖）</td>
<td style="text-align: center;">2（←）</td>
<td style="text-align: center;">2（←）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>"c"</strong></td>
<td style="text-align: center;"><strong>3</strong></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1（↑）</td>
<td style="text-align: center;">2（↑）</td>
<td style="text-align: center;">2（←）</td>
<td style="text-align: center;">3（↖）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>"a"</strong></td>
<td style="text-align: center;"><strong>4</strong></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1（↖）</td>
<td style="text-align: center;">2（↑）</td>
<td style="text-align: center;">3（↖）</td>
<td style="text-align: center;">3（←）</td>
</tr>
</tbody>
</table>
<h3 id="longest-increasing-subsequence">Longest Increasing Subsequence</h3>
<ul>
<li>Ex
<ul>
<li>X = ＜5, 1, 3, 2, 4＞</li>
<li>LIS(X) = ＜1, 2, 4＞</li>
</ul></li>
<li>演算法
<ol type="1">
<li>Y &lt;- sort(X)</li>
<li>LCS(X, Y)</li>
</ol></li>
<li>Time complexity
<ul>
<li><span class="math inline">\(\Theta(n^2)\)</span>
<ul>
<li>排序：<span class="math inline">\(\Theta(n\lg n)\)</span></li>
<li>LCS：<span class="math inline">\(\Theta(n^2)\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="longest-common-substring">Longest Common Substring</h3>
<ul>
<li>Ex
<ul>
<li>X = ＜a, b, a, c＞</li>
<li>Y = ＜a, b, c, a＞</li>
<li><strong>Output：＜a, b＞</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
c[i, j] = \left\{\begin{matrix}
0 &amp; , if \;i = 0\;OR\; j = 0 &amp; \\
c[i-1, j-1] + 1 &amp; , if \; X[i] = Y[j] &amp; \\
0&amp; , if \; X[i] \ne Y[j] \; &amp; （該兩個字絕對不會同時出現在LCS）
\end{matrix}\right.
\]</span></p>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// X[1...n]</span><br><span class="line">// Y[1...m]</span><br><span class="line">lcstring = &#123;&#125;</span><br><span class="line">length = 0</span><br><span class="line">// initialize</span><br><span class="line">for i &lt;- 0 to n</span><br><span class="line">    c[0, i] &lt;- 0</span><br><span class="line">for i &lt;- 0 to m</span><br><span class="line">    c[i, 0] &lt;- 0</span><br><span class="line"></span><br><span class="line">for i &lt;- 1 to m</span><br><span class="line">    for j &lt;- 1 to n &#123;</span><br><span class="line">        if(X[i] != Y[i])</span><br><span class="line">            c[i, j] = 0</span><br><span class="line">        else &#123;</span><br><span class="line">            c[i, j] = c[i-1, j-1] + 1</span><br><span class="line">            if(length &lt; c[i, j]) &#123;</span><br><span class="line">                length = c[i, j]</span><br><span class="line">                lcstring = X[(i-length+1)...i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="matrix-chain-multiplication">Matrix Chain Multiplication</h2>
<ul>
<li>Input：
<ul>
<li><strong>n</strong> 個矩陣的<strong>大小 P[0 ... n]</strong> ( 其中<span class="math inline">\(A_i\)</span> 的大小為 <span class="math inline">\(P_{i-1}\times P_i\)</span> )</li>
</ul></li>
<li>Output：
<ul>
<li>算出 <span class="math inline">\(A_1 \times A_2 \times \ldots \times A_n\)</span> 所需最少的<strong>純量乘法數</strong></li>
</ul></li>
</ul>
<blockquote>
<p>n 個矩陣的「Matrix chain」有 <span class="math inline">\(C_{n-1} = \frac{1}{(n-1)+1}\binom{2(n-1)}{(n-1)}\)</span> 相異種乘法可能，所以列出所有乘法順序需要<strong>指數時間</strong>。</p>
</blockquote>
<ul>
<li>Ex. 給定三個矩陣的大小如下
<ul>
<li><span class="math inline">\(A_1：10 \times 100\)</span></li>
<li><span class="math inline">\(A_2：100 \times 5\)</span></li>
<li><span class="math inline">\(A_3：5 \times 50\)</span></li>
<li>求算出 <span class="math inline">\(A_1 \times A_2 \times A_3\)</span> 所需最少的純量乘法數。</li>
</ul></li>
</ul>
<blockquote>
<p>若每一個矩陣均為相同大小的「方陣」，改變乘法的順序無法影響所需的純量乘法數，只能使用<strong>「Strassen's algorithm」以加速。</strong></p>
</blockquote>
<ul>
<li>遞迴結構
<ul>
<li>令 m[i, j] 為算出 <span class="math inline">\(A_i \times \ldots \times A_j\)</span> 所需最少乘法數</li>
</ul></li>
</ul>
<p><span class="math display">\[
m[i, j] = \left\{\begin{matrix}
0 &amp; , if \;i \geq j\\
MIN_{i\leq k \leq j-1}(m[i, k] + m[k+1, j] + P_i\times P_k \times P_j) &amp; , if \; i &lt; j
\end{matrix}\right.
\]</span></p>
<ul>
<li>演算法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i &lt;- 1 to n (「Matrix chain」長度為一)</span><br><span class="line">	m[i, i] &lt;- 0</span><br><span class="line">for l &lt;- 2 to n (「Matrix chain」長度為二以上)</span><br><span class="line">	for i &lt;- 1 to n-l+1 (起點)</span><br><span class="line">		&#123;</span><br><span class="line">            j &lt;- i+l-1 (終點)</span><br><span class="line">            m[i, j] &lt;- infinity</span><br><span class="line">            for k &lt;- i to j-1</span><br><span class="line">            &#123;</span><br><span class="line">            	tmp &lt;- m[i, k] + m[k+1, j] + P_i-1 * P_k * P_j</span><br><span class="line">                if tmp &lt; m[i, j]</span><br><span class="line">                	m[i, j] &lt;- tmp  (純量乘法數)</span><br><span class="line">                	s[i, j] &lt;- k    (切點)</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li><span class="math inline">\(\Theta(n^3)\)</span>：<span class="math inline">\(\sum_{l=2}^n \sum_{i = 1}^{n-l+1}\sum_{k = i}^{i+l-2} 1\)</span></li>
</ul></li>
<li>Space complexity
<ul>
<li><span class="math inline">\(\Theta(n^2)\)</span></li>
</ul></li>
<li>Ex
<ul>
<li><span class="math inline">\(A_1：3 \times 3\)</span></li>
<li><span class="math inline">\(A_2：3 \times 7\)</span></li>
<li><span class="math inline">\(A_3：7 \times 2\)</span></li>
<li><span class="math inline">\(A_4：2 \times 9\)</span></li>
<li><span class="math inline">\(A_5：9 \times 4\)</span></li>
<li>算出 <span class="math inline">\(A_1 \times A_2 \times \ldots \times A_5\)</span> 最少的乘法數。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\matrixchaindp.png" alt="matrixchaindp" /><figcaption aria-hidden="true">matrixchaindp</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\martixchainproblem_2.png" alt="martixchainproblem_2" /><figcaption aria-hidden="true">martixchainproblem_2</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th>m (乘法數)</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>63（←）</td>
<td>60（←）</td>
<td>114（↓）</td>
<td><strong>156</strong>（↓）</td>
</tr>
<tr class="even">
<td>2</td>
<td></td>
<td>0</td>
<td>42（←）</td>
<td>96（↓）</td>
<td>138（↓）</td>
</tr>
<tr class="odd">
<td>3</td>
<td></td>
<td></td>
<td>0</td>
<td>126（←）</td>
<td>128（←）</td>
</tr>
<tr class="even">
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>72（←）</td>
</tr>
<tr class="odd">
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>s (切點)</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="even">
<td>2</td>
<td></td>
<td>2</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="odd">
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
</tr>
<tr class="even">
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>4</td>
</tr>
</tbody>
</table>
<p>最少乘法數：156</p>
<p>最佳乘法順序：<span class="math inline">\((A_1\times (A_2 \times A_3)) \times (A_4 \times A_5)\)</span></p>
<h1 id="補充例題">補充例題</h1>
<p>Example（107交通大學資料結構與演算法）</p>
<ul>
<li>We define the maximum subarray of an array A to be the nonempty, contiguous subarray of A whose value have the largest sum</li>
<li>Fill in the blank (a), (b) in the following c++ function so that it returns value are placed in A[1], A[2], …, A[n-1]</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubarray</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        A[i] += A[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,  (a)  );</span><br><span class="line">        k = <span class="built_in">min</span>(k,      (b)  );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>考慮一個「Maximum subarray」為 A[x…y]</p>
<ul>
<li>A[x…y] = A[1…y] - A[1…x]</li>
<li>若欲使 A[x…y] 最大化
<ul>
<li>A[1…y] 必為最大</li>
<li>A[1…x] 必為最小</li>
</ul></li>
</ul>
<p>(a)：<code>A[i]-k</code></p>
<p>(b)：<code>A[i]</code></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Algorithm - Minimum edit cost problem</title>
    <url>/willywangkaa/2019/01/18/Algorithm-Minimum-edit-cost-problem/</url>
    <content><![CDATA[<h1 id="minimum-edit-cost-problem">Minimum edit cost problem</h1>
<p>最常使用在檔案的<strong>比較</strong>以及<strong>更新</strong>上，若在系統上有多個類似的檔案，可以輕鬆比較差異，而若系統中有若干個不同版本的檔案，亦可以藉由此辦法儲存其差異而非整個檔案，如此一來便可以節省其儲存空間。</p>
<p>問題敘述</p>
<ul>
<li>給定兩個字串 A[1...n]、B[1...m]，在下列三種運算之下，使用最小運算成本將字串 A 轉換成字串 B
<ol type="1">
<li>插入：在字串中插入一個字元</li>
<li>刪除：在字串中刪除一個字元</li>
<li>替換：將字串中的某一個字元轉換成「指定的字元」</li>
</ol></li>
<li>Optimal substructure （以最後一個字元做討論）
<ul>
<li>假設將 A 轉換為 B 的<strong>最少運算序列為 R[1...k]</strong>，若 A[n] ≠ B[m]，則當 R[k] 為
<ol type="1">
<li>「刪除 A 尾端的 A[n]」時，則 R[k-1] 為「A[1...n-1] 轉換為 B[1...m]」的<strong>最少運算序列</strong></li>
<li>「 A[n] 中插入一個字元」時，則 R[k-1] 為「A[1...n] 轉換為 B[1...m-1]」的<strong>最少運算序列</strong></li>
<li>「將 A[n] 替換成 B[m]」時，則 R[k-1] 為「A[1...n-1] 轉換為 B[1...m-1]」的<strong>最少運算序列</strong></li>
</ol></li>
<li>若 A[n] = B[m]，則 R[k] 為「A[1...n-1] 轉換為 B[1...m-1]」的<strong>最少運算序列</strong></li>
</ul></li>
<li>Recursion（c[i,j]：A[1..i] 轉換成 B[1..j] 之最大成本）
<ul>
<li>若 <strong>A[i] ≠ B[j]</strong>
<ul>
<li><span class="math inline">\(min \left\{\begin{matrix} c[i-1, j]+1 &amp; ,刪除\;A\; 尾端的 \;A[i] \\ c[i, j-1]+1 &amp; , 在\;A[1..i]\;尾端插入B[j] \\ c[i-1, j-1]+1 &amp; ,直接將\; A[i]\; 轉換成 \;B[i] \end{matrix}\right.\)</span></li>
</ul></li>
<li>若 <strong>A[i] = B[j]</strong>
<ul>
<li><span class="math inline">\(c[i-1, j-1] \quad , 為\;A[1...i-1] \;與 \;B[1...j-1] \; 的最少運算序列\)</span></li>
</ul></li>
<li><span class="math inline">\(\forall i, \quad c[i,0] = i \quad：將\;A[1..i] \;轉換成\; \phi \;的最短運算序列\)</span>
<ul>
<li>等價於 C[i-1,0]+1；遞迴刪除 A[i] 的末端字元</li>
</ul></li>
<li><span class="math inline">\(\forall j, \quad c[0,j] = j \quad：將 \;\phi\; 轉換成\; B[1..j] \; 的最短運算子序列\)</span>
<ul>
<li>等價於 C[0,j-1]+1；遞迴在 <span class="math inline">\(\phi\)</span> 末端新增 B[j] 字元</li>
</ul></li>
</ul></li>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">MED</span><span class="params">(<span class="keyword">char</span>* A, <span class="keyword">char</span>* B, n, m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">1</span> to n &#123;</span><br><span class="line">        c[i,<span class="number">0</span>]      =  i;</span><br><span class="line">        label[i,<span class="number">0</span>]  = <span class="string">&#x27;↑&#x27;</span>; <span class="comment">// 等價於 C[i-1,0]+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">1</span> to m &#123;</span><br><span class="line">        c[<span class="number">0</span>,i]      =  i;</span><br><span class="line">        label[<span class="number">0</span>,i]  = <span class="string">&#x27;←&#x27;</span>; <span class="comment">// 等價於 C[0,j-1]+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">1</span> to n &#123;</span><br><span class="line">        <span class="keyword">for</span> j from <span class="number">1</span> to m &#123;</span><br><span class="line">            <span class="keyword">if</span> A[i] != B[j]</span><br><span class="line">                c[i,j] = <span class="built_in">min</span>(c[i<span class="number">-1</span>,j]  +<span class="number">1</span>, <span class="comment">// 刪除 A[i] 的字元</span></span><br><span class="line">                             c[i,j<span class="number">-1</span>]  +<span class="number">1</span>, <span class="comment">// 在 A[1..i] 字串末端插入 B[j] 字元</span></span><br><span class="line">                             c[i<span class="number">-1</span>,j<span class="number">-1</span>]+<span class="number">1</span>);<span class="comment">// 將 A[i] 直接轉換成 B[j] 字元</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                c[i,j] = <span class="built_in">min</span>(c[i<span class="number">-1</span>,j]  +<span class="number">1</span>, <span class="comment">// 刪除 A[i] 的字元</span></span><br><span class="line">                             c[i,j<span class="number">-1</span>]  +<span class="number">1</span>, <span class="comment">// 在 A[1..i] 字串末端插入 B[j] 字元</span></span><br><span class="line">                             c[i<span class="number">-1</span>,j<span class="number">-1</span>]);  <span class="comment">// 不做任何運算</span></span><br><span class="line">            <span class="comment">// 依照上面的運算決定 lebel[i,j] 的性質</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ex （87 年交大資工）</p>
<p>A = acbabca；B = babcbac ，使用最少轉換將字串 A 轉換成 B 字串</p>
<ul>
<li>Recursion（c[i,j]：A[1..i] 轉換成 B[1..j] 之最大成本）
<ul>
<li>若 <strong>A[i] ≠ B[j]</strong>
<ul>
<li><span class="math inline">\(min \left\{\begin{matrix} c[i-1, j]+D[i] &amp; ,刪除\;A\; 尾端的 \;A[i] \\ c[i, j-1]+I[j] &amp; , 在\;A[1..i]\;尾端插入B[j] \\ c[i-1, j-1]+C[i,j] &amp; ,直接將\; A[i]\; 轉換成 \;B[i] \end{matrix}\right.\)</span></li>
</ul></li>
<li><span class="math inline">\(\forall i, \quad c[i,0] = \sum_{k =1}^iD[k] \quad：將\;A[1..i] \;轉換成\; \phi \;的最短運算序列\)</span>
<ul>
<li>等價於 c[i-1,0] + D[i]；遞迴刪除 A[i] 的末端字元</li>
</ul></li>
<li><span class="math inline">\(\forall j, \quad c[0,j] = \sum_{k=1}^jI[k] \quad：將 \;\phi\; 轉換成\; B[1..j] \; 的最短運算子序列\)</span>
<ul>
<li>等價於 c[0,j-1] + I[j]；遞迴在 <span class="math inline">\(\phi\)</span> 末端新增 B[j] 字元</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1547791902730.png" alt="1547791902730" /><figcaption aria-hidden="true">1547791902730</figcaption>
</figure>
<p>Ex （轉換的成本不一致）</p>
<p>給定兩序列 A[1..3]，B[1..4]，以最少成本將 A 序列轉換成 B 序列</p>
<ul>
<li>轉換成本
<ul>
<li>刪除 A[i] 字元 D[1..3]
<ul>
<li><span class="math inline">\(\begin{bmatrix} 6 &amp; 1 &amp; 2 \end{bmatrix}\)</span></li>
</ul></li>
<li>插入 B[i] 字元 I[1..4]
<ul>
<li><span class="math inline">\(\begin{bmatrix} 5 &amp; 3 &amp; 1 &amp; 1 \end{bmatrix}\)</span></li>
</ul></li>
<li>將 A[i] 字元轉換成 B[j] 字元 C[1..3, 1...4]
<ul>
<li><span class="math inline">\(\begin{bmatrix} 1 &amp; 2 &amp; 1 &amp; 1\\ 2 &amp; 1 &amp; 2 &amp; 2\\ 3 &amp; 1 &amp; 2 &amp; 4 \end{bmatrix}\)</span></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1547794356093.png" alt="1547794356093" /><figcaption aria-hidden="true">1547794356093</figcaption>
</figure>
<h2 id="dna-comparsion-problem">DNA comparsion problem</h2>
<p>Ex（生物資訊比較問題）</p>
<p>在生物資訊學科裡，會給定兩個 DNA 序列 A[1..n]、B[1..m]，並以下列<strong>「運算/比較 — 權重」</strong>來決定兩個序列之相似度</p>
<ul>
<li>相似度權重
<ul>
<li>A[i] = B[j]：比對直接命中
<ul>
<li>相似度加 2</li>
</ul></li>
<li>A[i] ≠ B[j]：比對失敗
<ul>
<li>相似度減 3</li>
</ul></li>
<li><strong>在 A[i] 前插入空字元 ∅ （意旨跳過 B[i] 字元的比較）讓 A[i..n] 與 B[i+1..m] 達到最大相似度</strong>
<ul>
<li>相似度減 1</li>
</ul></li>
<li><strong>將 A[i] 字元刪除（意旨跳過 A[i] 字元的比較）讓 A[i+1..n] 與 B[i..m] 達到最大相似度</strong>
<ul>
<li>相似度減 1</li>
</ul></li>
</ul></li>
<li>Recursion（<strong>w[i,j]：A[1..i] 與 B[1..j] 比對的最大相似度</strong>）
<ul>
<li>$ max{
<span class="math display">\[\begin{matrix}
w[i-1, j-1]+2 &amp; A[i]\;與\;B[j]\; 相等，其剩餘最大相似度等於\;w[i-1, j-1]\\ 
w[i-1, j-1]-3 &amp; A[i]\;與\;B[j] \;不等，其剩餘最大相似度等於\;w[i-1, j-1] \\ 
w[i-1, j]-1 &amp; 跳過對 \;A[i]\; 的比較，其剩餘最大相似度等於\;w[i-1, j] \\ 
w[i, j-1]-1 &amp; 跳過對 \;B[i]\; 的比較，其剩餘最大相似度等於\;w[i, j-1]\end{matrix}\]</span>
.$</li>
</ul></li>
</ul>
<p>給定兩個 DNA 序列 A = ACGCTGA；B = AACTGT，使用最少<strong>「運算/比較 — 權重」</strong>以比較 A、B 字串：</p>
<figure>
<img src="\willywangkaa\images\1547798815815.png" alt="1547798815815" /><figcaption aria-hidden="true">1547798815815</figcaption>
</figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - NP-completeness</title>
    <url>/willywangkaa/2018/10/15/Algorithm-NP-completeness/</url>
    <content><![CDATA[<h1 id="基本概念">基本概念</h1>
<ul>
<li>目的
<ul>
<li>將問題依照<strong>難度</strong>做分類</li>
<li><strong>如何定義 A 問題比 B 問題難？</strong></li>
<li><strong>如何分類？</strong></li>
<li><strong>分幾類？</strong></li>
</ul></li>
</ul>
<h2 id="decision-problem">Decision problem</h2>
<p>答案只有 <strong>Yse/No</strong> 的問題</p>
<ul>
<li>Ex
<ul>
<li>一個圖中<strong>有無</strong>「Hamiltonian cycle」？</li>
</ul></li>
</ul>
<p>每一個<strong>最佳化問題 ( Optimization problem )</strong> 均可用<strong>參數化</strong>的方式化成一<strong>對應的「Decision problem」</strong></p>
<ul>
<li>Ex
<ul>
<li>KP-optimal problem：給定一背包負重 W 以及 n 個物件，問<strong>最大的獲利是多少</strong>？</li>
<li>KP-decision problem：給定一背包負重 W 以及 n 個物件與一個<strong>整數 k</strong>，問<strong>獲利是否可大於 k</strong>？</li>
</ul></li>
</ul>
<blockquote>
<p>當輸出只有 0 或 1 時，稱之為「Language」</p>
</blockquote>
<ul>
<li>為何要化成「Decision problem」？
<ul>
<li>將原本問題的輸出 ( Output ) <strong>一致化</strong>，轉換成只有「Yes (1)/No (0)」的輸出方便比較<strong>原問題是否相同</strong></li>
<li>利用每個<strong>「Decision problem」</strong>互相比較難度</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\decisionproblem.png" alt="decisionproblem" /><figcaption aria-hidden="true">decisionproblem</figcaption>
</figure>
<h2 id="reduce">Reduce</h2>
<blockquote>
<p>當 A 可以「Polynominal time reduce」至 B，記做，<span class="math inline">\(A \leq_P B\)</span></p>
</blockquote>
<ul>
<li>令 A、B 為兩個問題，當 A 可以「Polynominal time reduce」至 B，則滿足：
<ol type="1">
<li>存在一個函數 f ：A 的<strong>輸入(input)</strong> → B 的<strong>輸入(input)</strong>；Transformation</li>
<li>f 為<strong>「Polynominal time computable」；多項式時間</strong></li>
<li>對於任何一個 A 的輸入 x <span class="math inline">\(A(x) = Yes \Leftrightarrow B(f(x)) = Yes\)</span></li>
</ol></li>
</ul>
<figure>
<img src="\willywangkaa\images\reduce_1.png" alt="reduce_1" /><figcaption aria-hidden="true">reduce_1</figcaption>
</figure>
<ul>
<li>若 <span class="math inline">\(A \leq_P B\)</span> 代表可以用<strong>解決 B 問題的演算法</strong>，來實作<strong>解決 A 問題的演算法</strong></li>
<li>若 <span class="math inline">\(A \leq_P B\)</span> 代表<strong>A 問題的難度小於 B 問題的難度 ( B 至少比 A 難 )</strong>
<ul>
<li>若 B 問題可以解決同時代表 A 問題也可以被解決</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\reduce_2.png" alt="reduce_2" /><figcaption aria-hidden="true">reduce_2</figcaption>
</figure>
<h1 id="pnpnp-hardnp-complete">P、NP、NP-hard、NP-complete</h1>
<blockquote>
<ul>
<li>「Deterministic algorithm」
<ul>
<li>使用該演算法碰到子問題時，只會有一種解答，不會有多種解答。(有限狀態機)</li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>P 問題集合
<ul>
<li>問題皆有一個「Deterministic algorithm」可以在「Polynominal time」中<strong>解決( Solve )</strong>。</li>
</ul></li>
</ul>
<p>Ex：「排序問題」<span class="math inline">\(\in\)</span> P；存在一個演算法 ( Quick sort ) 可以在 <span class="math inline">\(\Theta(n\lg n)\)</span> 中解決</p>
<blockquote>
<ul>
<li><p><strong>NP 非「Non-polynomial time」</strong></p></li>
<li><p><strong>P</strong> <span class="math inline">\(\subset\)</span> <strong>NP</strong></p></li>
</ul>
</blockquote>
<ul>
<li><strong>NP 問題集合</strong>
<ul>
<li>問題皆有一個「Non-deterministic algorithm」可以在「Polynominal time」中解決。</li>
<li>給一個<strong>可能的解</strong>，若可以在「Polynominal time」中<strong>判斷( Verify )</strong>是否為該問題的解，則此問題屬於 NP 集合。</li>
</ul></li>
<li>NP-hard 問題集合
<ul>
<li><span class="math inline">\(\forall Q \in NP, Q \leq_P A \Leftrightarrow A \in NP–hard\)</span></li>
</ul></li>
</ul>
<blockquote>
<p>在 NP 集合中的問題均有演算法可以解決，所以<strong>在 NPC 集合即為「有可用演算法解的最難問題」</strong></p>
</blockquote>
<blockquote>
<p>NPC 集合的問題在<strong>「Worst case」</strong>下沒有<strong>「Polynominal time」</strong>的演算法可解決 (<strong>至少都要「Exponential time」</strong>)</p>
<ul>
<li>非「Any case」</li>
<li><strong>有「演算法」可以解</strong></li>
</ul>
</blockquote>
<ul>
<li>NP-complete 問題集合
<ul>
<li><span class="math inline">\(A \in NP–complete \Leftrightarrow A \in NP \;且\; A \in NP–hard\)</span></li>
</ul></li>
</ul>
<h2 id="集合關係">集合關係</h2>
<figure>
<img src="\willywangkaa\images\nprelation.png" alt="nprelation" /><figcaption aria-hidden="true">nprelation</figcaption>
</figure>
<ul>
<li>Ex ( true or false )
<ul>
<li><span class="math inline">\(P \supset NP\)</span>；True</li>
<li><span class="math inline">\(P \supset NP\)</span>；Unknown</li>
<li><span class="math inline">\(P = NP\)</span>；Unknown</li>
<li><span class="math inline">\(P \neq NP\)</span>；Unknown</li>
</ul></li>
<li>有一個在 NPC 集合的問題之「Worst case」若可被「Polynominal time」的演算法解決
<ul>
<li><span class="math inline">\(\Leftrightarrow P = NP\)</span></li>
</ul></li>
</ul>
<h1 id="證明問題是否為-np-complete">證明問題是否為 NP-complete</h1>
<p>令 A 為一問題，欲證明 <span class="math inline">\(A \in NPC\)</span></p>
<ol type="1">
<li>證明 <span class="math inline">\(A \in NP\)</span></li>
<li>任找一個 <span class="math inline">\(B \in NPC\)</span>，證明 <span class="math inline">\(B \leq_P A\)</span>
<ul>
<li><span class="math inline">\(\Leftrightarrow\)</span> <strong>證明</strong> <span class="math inline">\(A \in NP–hard\)</span></li>
</ul></li>
</ol>
<ul>
<li>(94 交大) ( True or False )
<ul>
<li>已知 Clique 問題屬於 NPC 集合，Vertex-cover 問題屬於 NP 集合，欲證明 Vertex-cover 屬於 NPC 集合，則將 Vertex-cover <span class="math inline">\(\leq_P\)</span> Clique 即可；False。</li>
</ul></li>
<li>(99 政大)
<ul>
<li>欲證明 A 問題屬於 NPC 集合，則將一個 B 屬於 NPC 「Reduce」到 A 即可；False。</li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>不知道 A 是否屬於 NP 集合，否則 A 有可能為 NP-hard 集合 (無演算法可以解)。</li>
</ul>
</blockquote>
<h2 id="sat-problem">SAT problem</h2>
<p><strong>第一個 NP-complete 問題</strong></p>
<p>給定一個「Conjection normal form」<span class="math inline">\(F\)</span> ，問<strong>有無</strong>一組「Assignment」可使 <span class="math inline">\(F\)</span> 輸出為 True。</p>
<blockquote>
<p>令 <span class="math inline">\(F = (x_1 \vee \bar{x_2} \vee \bar{x_3}) \wedge (\bar{x_1} \vee x_3) \wedge (x_2 \vee \bar{x_3})\)</span></p>
<p>當給定 <span class="math inline">\(x_1 = true、x_2 = true、x_3 = true\)</span> ，<span class="math inline">\(F\)</span> 的輸出也為 True， 所以 <span class="math inline">\(F\)</span> 在 SAT problem 的輸入，則其解為 True。</p>
</blockquote>
<blockquote>
<p>該問題使用了一個「Non-deterministic algorithm」解決。</p>
</blockquote>
<h2 id="常見的證明流程">常見的證明流程</h2>
<p><span class="math display">\[
「SAT」 \leq_P 「3-SAT」 \leq_P 「Clique」 \leq_P 「Vertex–cover」\\
\leq_P Hamilton \; cycle \leq_P \left\{\begin{matrix}
Hamilton \; path\leq_P Longest \; path \\ 
Traveling \; salesman \; prblem
\end{matrix}\right.
\]</span></p>
<h3 id="證明-longest-path-problem-屬於-npc-集合">證明 Longest path problem 屬於 NPC 集合</h3>
<blockquote>
<p>給定一個圖 G = (V, E) 與 <strong>k</strong>，問 G 中<strong>有無</strong>長度大於 <strong>k</strong> 的「Simple path」。</p>
</blockquote>
<ol type="1">
<li>Claim：Longest path problem 屬於 NP
<ol type="1">
<li>(<strong>給定可能的解</strong>) 給定一組 Longest path 的輸入 (G, k) 與任意一條「Simple path」<span class="math inline">\(P\)</span></li>
<li>(<strong>在「Polynominal time」內可以確認其解</strong>) 則可以在「Polynominal time」中判斷 P 是否為 G 中長度大於等於 k 的「Simple path」</li>
<li>所以「Longest path problem」屬於 NP 集合。</li>
</ol></li>
</ol>
<blockquote>
<p>給定 <span class="math inline">\(P = ＜u_1, u_2, \ldots, u_m＞\)</span> 為一條「Path」</p>
<ol type="1">
<li>確認 m 是否大於等於 k+1 ？
<ul>
<li><span class="math inline">\(\Theta(1)\)</span></li>
</ul></li>
<li>確認 <span class="math inline">\((u_i, u_{i+1}) \in E\)</span> ？
<ul>
<li>若 G 使用「Adjacency matrix」儲存，若要判斷一邊是否屬於 E ；<span class="math inline">\(\Theta(1)\)</span></li>
</ul></li>
</ol>
</blockquote>
<ol start="2" type="1">
<li>Claim：Hamilton path <span class="math inline">\(\leq_P\)</span> Longest path
<ol type="1">
<li>給定一個 Hamilton path problem 的輸入：G = (V, E)， 定義一個函數 f ：G → (G, k = |V|-1)，則 (G, |V|-1) 為 Longest path problem 的輸入</li>
<li>f 顯然為「Polynominal time computable」</li>
<li>G 有 Hamilton path <span class="math inline">\(\Leftrightarrow\)</span> G 有長度大於等於 |V|-1 的「Simple path」 G 有 Hamilton path <span class="math inline">\(P\)</span> ，即：
<ul>
<li><span class="math inline">\(\Leftrightarrow P\)</span> 必過 G 中每一點恰一次，且 <span class="math inline">\(P\)</span> 為「Simple path」</li>
<li><span class="math inline">\(\Leftrightarrow P\)</span> 為 G 中長度大於等於 |V|- 1 的「Simple path」</li>
</ul></li>
</ol></li>
</ol>
<figure>
<img src="\willywangkaa\images\longestpathproblem_NPC.png" alt="longestpathproblem_NPC" /><figcaption aria-hidden="true">longestpathproblem_NPC</figcaption>
</figure>
<h3 id="證明-traveling-salesman-problem-屬於-npc-集合">證明 Traveling salesman problem 屬於 NPC 集合</h3>
<blockquote>
<p>給定一個無向、有權重的<strong>完全圖</strong> G = (V, E) 與 <strong>k</strong> ，問 G 中有無總權重<strong>小於等於 k</strong> 的「Hamilton cycle」？</p>
</blockquote>
<ol type="1">
<li>Claim：Traveling salesman problem 屬於 NP
<ol type="1">
<li>(<strong>給定可能的解</strong>) 給定一個無向、有權重的<strong>完全圖</strong> G = (V, E) 與 <strong>k</strong>，與一個 G 上的一個 Hamilton cycle <span class="math inline">\(C\)</span></li>
<li>(<strong>在「Polynominal time」內可以確認其解</strong>) 則可以在「Polynominal time」中驗證 <span class="math inline">\(C\)</span> 的權重和是否<strong>小於等於 k</strong> ，所以 TSP 問題屬於 NP 集合</li>
</ol></li>
<li>Claim：Hamilton cycle problem <span class="math inline">\(\leq_P\)</span> Traveling salesman problem
<ol type="1">
<li><strong>給定一個 Hamilton 的輸入：G = (V, E)，定義一個 f：G → (G', k = |V|)，</strong> <strong>其中 G' 的定義如下：G' = (V, E')，</strong> <span class="math inline">\(\left\{\begin{matrix} (u, v) \in E&#39;, weight(u, v) = 1, if \;(u, v)\in E \\ (u, v) \in E&#39;, weight(u, v) = 2, if \;(u, v)\notin E \end{matrix}\right.\)</span></li>
<li>f 顯然為「Polynominal time computable」</li>
<li><strong>G 有 Hamilton cycle</strong> <span class="math inline">\(\Leftrightarrow\)</span> <strong>G' 有一「Hamilton cycle」且其總權重 ≦ |V|</strong></li>
</ol></li>
</ol>
<figure>
<img src="\willywangkaa\images\TSP_NPC.png" alt="TSP_NPC" /><figcaption aria-hidden="true">TSP_NPC</figcaption>
</figure>
<blockquote>
<p>(<span class="math inline">\(\Rightarrow\)</span>)</p>
<p>G 若有一個「Hamilton cycle」<span class="math inline">\(C\)</span></p>
<p><span class="math inline">\(\because (u, v) \in E&#39;, weight(u, v) = 1, if \;(u, v)\in E\)</span></p>
<p><span class="math inline">\(\Rightarrow\)</span> G' 必也有一個相對應的「Hamilton cycle」<span class="math inline">\(C&#39;\)</span> 其權重總和 ≦ |V|</p>
<p>(<span class="math inline">\(\Leftarrow\)</span>)</p>
<p>G' 若有「Hamilton cycle」<span class="math inline">\(C\)</span> 且權重總和 ≦ |V|</p>
<p><span class="math inline">\(\because (u, v) \in E&#39;, weight(u, v) = 2, if \;(u, v)\notin E\)</span></p>
<p><span class="math inline">\(\Rightarrow C\)</span> 上的每一邊在 G' 的權重必為 1</p>
<p><span class="math inline">\(\because (u, v) \in E&#39;, weight(u, v) = 1, if \;(u, v)\in E\)</span></p>
<p><span class="math inline">\(\Rightarrow C\)</span> 通過 G 每節點一次</p>
<p><span class="math inline">\(\Rightarrow C\)</span> 為一個在 G 中的「Hamilton cycle」</p>
</blockquote>
<h1 id="補充例題">補充例題</h1>
<p>Example（107交通大學資料結構與演算法）</p>
<ul>
<li>A Hamiltonian path of a graph G is a path that visits each node in G exactly once</li>
<li>Suppose that there is an <span class="math inline">\(O(n^7)\)</span>-time algorithm that decides HamP(G) for any n-node graph G
<ul>
<li>HamP(G)</li>
<li>Input：an undirected graph G</li>
<li>Output："Yes", if G has a Hamiltonian path; "No", otherwise</li>
</ul></li>
<li>Give an <span class="math inline">\(O(n^7)\)</span>-time algorithm that decides HamEx(G, x) for any n-node graph G, and prove the correctness of your algorithm</li>
<li>Note that your algorithm must have running time <span class="math inline">\(O(n^7)\)</span></li>
<li>No partial credit will be given if your algorithm runs asymptotically slowr
<ul>
<li>HamEx(G, x)</li>
<li>Input：an undirected graph G, and a node x in G</li>
<li>Output："Yes", if G has a Hamiltonian path from node u to v so that u≠x and v≠x; "No", otherwise</li>
</ul></li>
</ul>
<p>（參考：<a href="https://www.ptt.cc/bbs/Grad-ProbAsk/M.1548560644.A.EB0.html">Re: ［理工］ 107 交大資演10 - 看板Grad-ProbAsk - 批踢踢實業坊</a>）</p>
<blockquote>
<p>令 G' = (V', E')，其中</p>
<ul>
<li>V' = V ∪ {s, t, s', t'}
<ul>
<li>|V'| = O(|V|)</li>
</ul></li>
<li>E' = E ∪ {(s, s'), (t, t')} ∪ {(s', y) | for all y != x)} ∪ {(z, t') | for all z != x)}</li>
</ul>
<p><strong>證明HamEx(G, x) = "Yes" iff HamP(G') = "Yes"</strong></p>
<ul>
<li>If HamEx(G, x) = "Yes", then HamP(G') = "Yes"
<ul>
<li>G 中的「Hamiltonian path」頭尾不為 x</li>
<li>因為 s' 與 G 中所有不是 x 的點相連且 t' 跟 G 中所有不是 x 的點相連</li>
<li>則 ( s, s' ,HP in G, t', t ) 必是一條 G' 上的「Hamiltonian path」</li>
</ul></li>
<li>If HamP(G') = "Yes", then HamEx(G, x) = "Yes"
<ul>
<li>令 HP 為 G' 中的「Hamiltonian path」</li>
<li>因為 s 和 t 在 G' 中的 Degree 只有 1
<ul>
<li><strong>G' 中的「Hamiltonian path」頭尾必為 s 和 t</strong></li>
</ul></li>
<li>s 和 t 只分別跟 s' 和 t' 相連
<ul>
<li>「Hamiltonian path」在 G' 中必為 ( s, s', HP in G, t', t )</li>
</ul></li>
<li>s' 和 t' 都不與 x 相連
<ul>
<li><strong>在 G 中的「Hamiltonian path」頭尾必不為 x</strong></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<p>Example（101交通大學資料結構與演算法）</p>
<p><strong>Problem I</strong>: Given a graph G=(V,E), is there a minimum-degree spanning tree T of <strong>maximum degree two</strong>, where the minimum-degree means that the maximum degree is maximized?</p>
<blockquote>
<p>其問題為一個「Hamiltonian path」問題</p>
</blockquote>
<p><strong>Problem II</strong>: Given an undirected graph and a positive integer K, is there a path of length at <strong>most</strong> K, <strong>where each edge has weight 1 and each vertex is visited exactly once（Simple path）</strong>?</p>
<blockquote>
<p>其問題為一個「Shortest path」問題</p>
</blockquote>
<p><strong>Problem III</strong>: Given an undirected graph and a positive integer K, is there a path of length at <strong>least</strong> K, <strong>where each edge has weight 1 and each vertex is visited at most once（Simple path）</strong>?</p>
<blockquote>
<p>其問題為一個「Longest path」問題</p>
</blockquote>
<ul>
<li>Which of the following statements is wrong?
<ul>
<li>（A）A problem is NP-complete, if it belongs to the class NP and all the other members in NP can be reduced to it in polynomial time.</li>
<li>（B）Problem I belongs to NP.</li>
<li>（C）Problem III belongs to NP.</li>
<li>（D）Problem III is NP-complete.</li>
<li><strong>（E）If we change the graph in Problem III to directed graph, then it belongs to P.</strong></li>
</ul></li>
<li>Which of the followings is wrong?
<ul>
<li>（A）If a spanning tree has the maximum degree as 2, then it is a Hamiltonian path.</li>
<li>（B）If Problem III can be solved in polynomial time, then we can find a Hamiltonian path in polynomial time.</li>
<li><strong>（C）Problem I can be solved with the Prim's algorithm.</strong></li>
<li>（D）A graph can have more than one spanning tree.</li>
<li>（E）If P=NP, then Problem II can be solved in polynomial time.</li>
</ul></li>
<li>Continuing the previous question, which of the following is wrong?
<ul>
<li>（A）Problem II can be solved with the Floyd-Warshall algorithm.</li>
<li>（B）<em>An algorithm for Problem III can be used to find the longest path of a graph.</em></li>
<li>（C）If there is an algorithm that can find the longest path in a graph in polynomial time, then Problem III can solved in polynomial time.</li>
<li><strong>（D）Problem III can be reduced to Problem II by making each weight negative and thus can be solved with the Bellman-Ford algorithm.</strong></li>
<li>（E）If Problem III can be solved in polynomial time, then P=NP.</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>NP-Complete</tag>
        <tag>Reduce</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - Range query problem</title>
    <url>/willywangkaa/2018/10/03/Algorithm-Range-query-problem/</url>
    <content><![CDATA[<h1 id="segement-tree">Segement tree</h1>
<p>用來存放紀錄在特定區間內 ( segement, interval ) 的資訊。</p>
<ul>
<li>Pros
<ul>
<li>可以動態的更新欲求數組之元素。</li>
<li>數組區間的查詢
<ul>
<li>區間求和值</li>
<li>區間最大值</li>
<li>區間最小值</li>
<li>區間<strong>異或值 ( Exclusive or；XOR )</strong></li>
</ul></li>
</ul></li>
<li>Cons
<ul>
<li>無法刪除數值</li>
</ul></li>
</ul>
<blockquote>
<p>線段樹無法新增節點，只能更新節點的數值並保持區間的最大最小值仍保持正確。</p>
</blockquote>
<h2 id="實現">實現</h2>
<ul>
<li>特性
<ul>
<li>完全二元樹</li>
<li>節點保存<strong>特定區間的訊息</strong></li>
<li>採取 Buttom-up 的方式建構，從每一個葉節點建構</li>
</ul></li>
</ul>
<blockquote>
<figure>
<img src="\willywangkaa\images\STree_1.png" alt="STree_1" /><figcaption aria-hidden="true">STree_1</figcaption>
</figure>
<ul>
<li>上面的分段樹根節點保存 0 ~ 7 的資訊，2 號節點保存 0 ~ 3 的資訊，以此類推。</li>
</ul>
</blockquote>
<h3 id="初始化">初始化</h3>
<p>在建構的過程中，內部節點之建構會使用兩個子節點的資訊，而建構的方式以處理的問題而作法不同 ( 最大、最小、和、XOR )。</p>
<ul>
<li>Segement create ( 求區間最小值 )
<ul>
<li>ST：線段樹</li>
<li>A：欲判斷之數組資料</li>
<li>線段樹因為為<strong>完全二元樹</strong>所以通常以陣列製作
<ul>
<li>陣列大小需求：<span class="math inline">\(2 \times 2^{\lfloor\lg N\rfloor + 1}\)</span>，N 為數組大小 (見下圖)</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\STree_2.png" alt="STree_2" /><figcaption aria-hidden="true">STree_2</figcaption>
</figure>
<ul>
<li>程式碼 ( c++ )</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ST:segement tree; A: target number array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_create</span><span class="params">(vi &amp;ST, <span class="keyword">const</span> vi &amp;A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">2</span>&lt;&lt;(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) - __buildin_clz((<span class="keyword">unsigned</span> <span class="keyword">int</span>)A.<span class="built_in">size</span>()));</span><br><span class="line">	ST.<span class="built_in">assign</span>(len, <span class="number">0</span>); <span class="comment">// 線段樹歸零</span></span><br><span class="line">	<span class="built_in">st_build</span>(ST, A, <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">int</span>) A.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_build</span><span class="params">(vi &amp;ST, <span class="keyword">const</span> vi &amp;A, <span class="keyword">int</span> vetex, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;     </span><br><span class="line">	<span class="keyword">if</span> (L==R)</span><br><span class="line">        ST[vertex] = L;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> nL =  vertex &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> nR = (vertex &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">		<span class="built_in">st_build</span>(ST, A, nL, L           , ((L+R)&gt;&gt;<span class="number">1</span>));</span><br><span class="line">		<span class="built_in">st_build</span>(ST, A, nR, ((L+R)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>, R         ); </span><br><span class="line">			</span><br><span class="line">		<span class="keyword">int</span> lContent=ST[nL], rContent=ST[nR];</span><br><span class="line">		<span class="keyword">int</span> lValue=A[lContent], rValue=A[rContent];</span><br><span class="line">		ST[vertex]=(lValue &lt;= rValue)? lContent : rContent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>時間複雜度
<ul>
<li><span class="math inline">\(\Theta(\log n)\)</span></li>
</ul></li>
</ul>
<h3 id="更新">更新</h3>
<p>與建立線段樹的方法相同，將位於數組 <code>i</code> 的數字更新後，即從此葉節點向上執行更新至根節點。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以數值 v 更新 A[p]</span></span><br><span class="line"><span class="comment">// x: 數根</span></span><br><span class="line"><span class="comment">// L: 數組左端</span></span><br><span class="line"><span class="comment">// R: 數組右端</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span> <span class="params">(vi &amp;ST, vi &amp;A, <span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> mid=L+(R-L)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (L == R)</span><br><span class="line">		A[x] = v;</span><br><span class="line">	<span class="keyword">else</span> &#123;     </span><br><span class="line">		<span class="keyword">if</span> (p &lt;= mid)</span><br><span class="line">			<span class="built_in">update</span>(ST, A, x*<span class="number">2</span>  , L    , mid, p, v); <span class="comment">// 更新左子樹</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">update</span>(ST, A, x*<span class="number">2</span>+<span class="number">1</span>, mid+<span class="number">1</span>, R  , p, v); <span class="comment">// 更新右子樹</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ST[x] = (A[ST[x*<span class="number">2</span>]]&lt;=A[ST[x*<span class="number">2</span>+<span class="number">1</span>]])? ST[x*<span class="number">2</span>]:ST[x*<span class="number">2</span>+<span class="number">1</span>]; <span class="comment">// 以左右子樹的資訊更新母節點</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查詢">查詢</h3>
<p>分為三種情形討論，若<strong>當前節點所代表的區間</strong></p>
<ul>
<li><strong>完全位於</strong>欲求取之區間之<strong>外</strong></li>
<li><strong>完全位於</strong>欲求取之區間之<strong>內</strong></li>
<li><strong>部分位於</strong>欲求取之區間</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(vi &amp;ST, <span class="keyword">const</span> vi &amp;A, <span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>, ans = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 當前節點完全位於欲求取之區間之內</span></span><br><span class="line">	<span class="keyword">if</span> (L&gt;=ql &amp;&amp; R&lt;=qr)</span><br><span class="line">		<span class="comment">// 取出該區間值最小的位址</span></span><br><span class="line">		<span class="keyword">return</span> ST[x];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 當前節點部分或無位於欲求取之區間之內</span></span><br><span class="line">	<span class="keyword">if</span> (ql&lt;=mid) &#123;</span><br><span class="line">		<span class="comment">// 取出左區間</span></span><br><span class="line">		ans = <span class="built_in">query</span>(ST, A, x*<span class="number">2</span>  , L    , mid, ql, qr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (qr&gt;mid) &#123;</span><br><span class="line">		<span class="comment">// 取出右區間以及比較</span></span><br><span class="line">		<span class="keyword">int</span> tmp = </span><br><span class="line">		      <span class="built_in">query</span>(ST, A, x*<span class="number">2</span>+<span class="number">1</span>, mid+<span class="number">1</span>, R  , ql, qr);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (ans == <span class="number">-1</span>)</span><br><span class="line">			ans = tmp;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ans = (A[ans] &lt; A[tmp])? ans:tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="其它實現">其它實現</h2>
<p><a href="https://www.youtube.com/watch?v=Oq2E2yGadnU">Efficient Segment Tree Tutorial</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SegmentTree</span>(<span class="keyword">int</span> count) &#123;</span><br><span class="line">		n = count;</span><br><span class="line">		data = std::vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span> * n, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SegmentTree</span>(std::vector&lt;<span class="keyword">int</span>&gt; <span class="keyword">const</span> &amp;values) &#123;</span><br><span class="line">		n = values.<span class="built_in">size</span>();</span><br><span class="line">		data = std::vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span> * n);</span><br><span class="line">		std::<span class="built_in">copy</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), &amp;data[<span class="number">0</span>] + n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> idx = n - <span class="number">1</span>; idx &gt; <span class="number">0</span>; idx--)</span><br><span class="line">			data[idx] = std::<span class="built_in">min</span>(data[idx * <span class="number">2</span>], data[idx * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		idx += n;</span><br><span class="line">		data[idx] = value;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (idx &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			idx /= <span class="number">2</span>;</span><br><span class="line">			data[idx] = std::<span class="built_in">min</span>(data[<span class="number">2</span> * idx], data[<span class="number">2</span> * idx + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">minimum</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123; <span class="comment">// interval [left, right)</span></span><br><span class="line">		<span class="keyword">int</span> ret = std::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">		left += n;</span><br><span class="line">		right += n;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">			<span class="keyword">if</span> (left &amp; <span class="number">1</span>) ret = std::<span class="built_in">min</span>(ret, data[left++]);</span><br><span class="line">			<span class="keyword">if</span> (right &amp; <span class="number">1</span>) ret = std::<span class="built_in">min</span>(ret, data[--right]);</span><br><span class="line">			left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">			right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	std::vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">SegmentTree <span class="title">st</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; st.<span class="built_in">minimum</span>(i, i+<span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; st.<span class="built_in">minimum</span>(<span class="number">1</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">	std::cout &lt;&lt; st.<span class="built_in">minimum</span>(<span class="number">1</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; st.<span class="built_in">minimum</span>(<span class="number">0</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	std::cout &lt;&lt; st.<span class="built_in">minimum</span>(<span class="number">1</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; st.<span class="built_in">minimum</span>(<span class="number">0</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">SegmentTree <span class="title">st2</span><span class="params">(&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="sparse-table">Sparse table</h1>
<blockquote>
<p>「Sparse table」為古代之稱，如今詞不達意</p>
</blockquote>
<ul>
<li>Pros
<ul>
<li>數組區間的查詢
<ul>
<li>區間最大值</li>
<li>區間最小值</li>
</ul></li>
</ul></li>
<li>Cons
<ul>
<li>不能更新、插入、刪除值</li>
<li><strong>浪費空間</strong></li>
<li>無法數組區間的
<ul>
<li>求和值</li>
<li><strong>異或值 ( Exclusive or；XOR )</strong></li>
</ul></li>
</ul></li>
</ul>
<h3 id="實現-1">實現</h3>
<h4 id="初始化-1">初始化</h4>
<ul>
<li>Construct sparse table
<ul>
<li>N：資料量</li>
<li>value[N]：數組</li>
<li>cnt［logN］[N]：Sparse table</li>
</ul></li>
</ul>
<p>依序先求出寬度為 <span class="math inline">\(2^0, 2^1, 2^2, \ldots, 2^{\lfloor\lg N\rfloor}\)</span> 的區間<strong>最小值</strong>，區間的所有可能位置都要算一遍。兩個窄區間可以快速合成出一個寬區間。</p>
<figure>
<img src="\willywangkaa\images\STable_1.png" alt="STable_1" /><figcaption aria-hidden="true">STable_1</figcaption>
</figure>
<p>將所有區間算完存入 Sparse table</p>
<figure>
<img src="\willywangkaa\images\STable_2.png" alt="STable_2" /><figcaption aria-hidden="true">STable_2</figcaption>
</figure>
<blockquote>
<p>實作時，通常表格中記錄的是索引值、指標，而不是直接記錄數值的最小值。(如下程式碼)</p>
</blockquote>
<ul>
<li>程式碼 (c++)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span>; <span class="comment">//No. of elements</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> logN = <span class="built_in">ceil</span>(<span class="built_in">log</span>(N));</span><br><span class="line"><span class="comment">//const int logN = sizeof(unsigned int) - __builtin_clz((unsigned int)dist) - 1;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value[N];</span><br><span class="line"><span class="keyword">int</span> cnt[logN][N]; <span class="comment">//cnt[i][j]: RMQ index</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_ST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//Initialization</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; ++i)</span><br><span class="line">		cnt[<span class="number">0</span>][i] = i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2^i - 1 &lt; N &lt;=&gt; i &lt; ceil(log(N))</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; (<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span> &lt; N; i++)</span><br><span class="line">        <span class="comment">// j + (2^i-1) &lt; N ; buttom-up 建立</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j+(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span> &lt; N; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> L = cnt[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="keyword">int</span> R = cnt[i<span class="number">-1</span>][j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))];</span><br><span class="line">			cnt[i][j] = (value[L] &lt;= value[R])? L : R;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>時間複雜度
<ul>
<li><span class="math inline">\(\Theta(N\log N)\)</span></li>
</ul></li>
<li>空間複雜度
<ul>
<li><span class="math inline">\(\Theta(N \log N)\)</span></li>
</ul></li>
</ul>
<h4 id="查詢-1">查詢</h4>
<p>從表格中找到寬度略短於（相等於）查詢區間的區間，以靠左、靠右的兩條等寬區間，求得查詢區間的最小值：</p>
<figure>
<img src="\willywangkaa\images\STable_3.png" alt="STable_3" /><figcaption aria-hidden="true">STable_3</figcaption>
</figure>
<ul>
<li>如何知道要查「Range」大小為何的表？
<ul>
<li>令 <span class="math inline">\(k\)</span> 為我們所求 → <span class="math inline">\(k = \lfloor \lg N \rfloor\)</span></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dist = <span class="built_in">abs</span>(b - a) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 2^i &lt; N &lt;=&gt; i &lt; cel(logN) ; 區間計算</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) - __builtin_clz((<span class="keyword">unsigned</span> <span class="keyword">int</span>)dist) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> L = cnt[i][a];          <span class="comment">// 左區間</span></span><br><span class="line">	<span class="keyword">int</span> R = cnt[i][b-(<span class="number">1</span>&lt;&lt;i)+<span class="number">1</span>]; <span class="comment">// 右區間</span></span><br><span class="line">	<span class="keyword">return</span> value[L] &lt;= value[R]? L : R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>時間複雜度
<ul>
<li><span class="math inline">\(\Theta(1)\)</span></li>
</ul></li>
</ul>
<h1 id="參考">參考</h1>
<ul>
<li><p><a href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/79599809">线段树（segment tree)，看这一篇就够了</a></p></li>
<li><p>輔大張信宏老師講義</p></li>
<li><p><a href="http://www.csie.ntnu.edu.tw/~u91029/Sequence2.html#5">演算法筆記</a></p></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Sequence</tag>
        <tag>Sparse table</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - Pseudo polynomial time complexity</title>
    <url>/willywangkaa/2019/01/26/Algorithm-Pseudo-polynomial-time-complexity/</url>
    <content><![CDATA[<h1 id="pseudo-polynomial-time-complexity">Pseudo polynomial time complexity</h1>
<p>如果一個演算法的<strong>傳統時間複雜度</strong>位於多項式時間，而<strong>標準時間複雜度</strong>不在多項式時間</p>
<p>則我們稱這個演算法位於<strong>偽多項式時間</strong>，以下探討</p>
<blockquote>
<p><strong>多項式時間複雜度是甚麼？</strong></p>
<p><span class="math inline">\(O(n^k), k \;is\; constant\)</span></p>
<ul>
<li>Selection sort
<ul>
<li><span class="math inline">\(O(n^2)\)</span>，為「Polynomial time」</li>
</ul></li>
<li>Travel salesman problem
<ul>
<li>Brutal force：<span class="math inline">\(O(n\cdot n!)\)</span>，為「Non polynomial time」</li>
</ul></li>
</ul>
</blockquote>
<p>通常認為輸入變數 n 代表<strong>數據規模</strong></p>
<ul>
<li>Selection sort
<ul>
<li>n 代表欲排序的數據組元素個數</li>
</ul></li>
<li>Travel salesman problem
<ul>
<li>n 表示圖中節點的數量</li>
</ul></li>
</ul>
<p>但是上述的數據規模，為直觀的定義<strong>並不夠嚴謹</strong>，所以需要<strong>標準化輸入的數據規模</strong></p>
<ul>
<li>輸入的數據規模
<ul>
<li>保存輸入數據<strong>所需的 Bit 位數</strong></li>
</ul></li>
<li>針對<strong>排序</strong>的輸入
<ul>
<li>n 個「32-bit 整數」數組</li>
<li>其數據規模為 32×n，n 為數組中的元素個數</li>
</ul></li>
<li>針對<strong>圖論</strong>的輸入
<ul>
<li>n 個點、m 個邊</li>
<li>其數據規模為 <span class="math inline">\(\Omega(n+m)\)</span></li>
</ul></li>
</ul>
<blockquote>
<p>「Polynomial time complexity」的標準定義：</p>
<ul>
<li>在輸入<strong>數據規模為 x</strong> 的清況下，存在一個演算法能在 <span class="math inline">\(O(x^k)\)</span> （k 為一<strong>常數</strong>）的時間複雜度能解決問題</li>
</ul>
<p>所以，再來討論剛才的時間複雜度</p>
<ul>
<li>Selection sort
<ul>
<li>輸入
<ul>
<li>n 個「32-bit 整數」數組</li>
<li>其數據規模為 32×n，n 為數組中的元素個數</li>
</ul></li>
<li>時間複雜度
<ul>
<li><span class="math inline">\(x = 32n\)</span></li>
<li>傳統的時間複雜度為 <span class="math inline">\(O(n^2)\)</span></li>
<li>則 <span class="math inline">\(n = \frac{1}{32}x \Rightarrow O(\frac{1}{1024}x^2) = O(x^2)\)</span>，為「Polynomial time complexity」</li>
</ul></li>
</ul></li>
<li>Depth first search
<ul>
<li>輸入
<ul>
<li>n 個點、m 個邊</li>
<li>其數據規模為 <span class="math inline">\(\Omega(n+m)\)</span></li>
</ul></li>
<li>時間複雜度
<ul>
<li>$x = (n+m) $</li>
<li>傳統的時間複雜度為 <span class="math inline">\(O(n+m)\)</span></li>
<li>則 <span class="math inline">\(O(x)\)</span>，為「Polynomial time complexity」</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<p>接著，對「質數演算法」進行討論：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i = <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>質數演算法
<ul>
<li>輸入
<ul>
<li>這種輸入規模會隨著 n 的大小而改變
<ul>
<li><span class="math inline">\(x = \lg n\)</span></li>
</ul></li>
<li>與排序的規模相比排序的 n 為元素多寡，但是每個元素皆為 32-bit 或是其他<strong>固定大小</strong>的整數範圍
<ul>
<li>（排序的輸入規模）<span class="math inline">\(x = c \cdot n\)</span>，<strong>c 必為一常數</strong></li>
</ul></li>
</ul></li>
<li>時間複雜度
<ul>
<li><span class="math inline">\(x = \lg n\)</span></li>
<li>傳統的時間複雜度為 <span class="math inline">\(O(n)\)</span></li>
<li>則 <span class="math inline">\(n = 2^x \Rightarrow O(2^x)\)</span> ，為「Non-polynomial time complexity」</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>進一步體會</p>
<ul>
<li>一個二進位數（<strong>1010 1011</strong>）
<ul>
<li>其「質數演算法」的<strong>真實複雜度</strong>為 <span class="math inline">\(2^8\)</span></li>
</ul></li>
<li>另一個二進位數（<strong>1 1010 1011</strong>）
<ul>
<li>其「質數演算法」的<strong>真實複雜度</strong>為 <span class="math inline">\(2^9\)</span></li>
</ul></li>
</ul>
<p>可以發現僅增加一個 bit 就會使的演算法的運行時間倍增</p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Time complexity</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - String matching</title>
    <url>/willywangkaa/2019/02/07/Algorithm-String-matching/</url>
    <content><![CDATA[<h1 id="algorithm---string-matching">Algorithm - String matching</h1>
<p>給兩個字串 T 和 P，找出 T 當中是否有一段字串正好是 P，並且找出其位置</p>
<blockquote>
<p>字串搜尋當中，通常將兩字串的象徵符號取做 T 和 P</p>
<ul>
<li>T 意指 Text</li>
<li>P 意指 Pattern</li>
</ul>
<p>可以想作是從長篇文字 T 之中搜索小段文字 P</p>
</blockquote>
<ul>
<li>若 P 在平移 s 個單位後（<strong>T [s+1 … s+m] = P [1 … m]</strong>，0 ≦ s ≦ n-m）
<ul>
<li>可以在 T 中該片段被找到
<ul>
<li>稱為「合法平移」（Valid shift）</li>
</ul></li>
<li>無法在 T 中該片段被找到
<ul>
<li>稱為「非法平移」（Invalid shift）</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1549517694185.png" alt="1549517694185" /><figcaption aria-hidden="true">1549517694185</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Preprocessing time</th>
<th>Matching time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Native</td>
<td>0</td>
<td>O( (∣T∣-∣P∣+1) ×∣P∣)</td>
</tr>
<tr class="even">
<td>Rabin-Karp</td>
<td>θ(∣P∣)</td>
<td>O( (∣T∣-∣P∣+1) ×∣P∣)</td>
</tr>
<tr class="odd">
<td>Morris-Pratt Automaton</td>
<td>O(∣P∣×∣Σ∣)</td>
<td>θ(∣T∣)</td>
</tr>
<tr class="even">
<td>Knuth-Morris-Pratt</td>
<td>θ(∣P∣)</td>
<td>θ(∣T∣)</td>
</tr>
</tbody>
</table>
<h2 id="naive-string-matching窮舉法">Naive string matching（窮舉法）</h2>
<p>最直覺的算法</p>
<ol type="1">
<li>挪動 P 以對準 T 的各個位置</li>
<li>逐一比對字元、判斷是否相等</li>
</ol>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\1549518031466.png" alt="1549518031466" /><figcaption aria-hidden="true">1549518031466</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1549518053082.png" alt="1549518053082" /><figcaption aria-hidden="true">1549518053082</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1549518063746.png" alt="1549518063746" /><figcaption aria-hidden="true">1549518063746</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1549518076863.png" alt="1549518076863" /><figcaption aria-hidden="true">1549518076863</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Nativestrinmatcher</span><span class="params">(string T,string P)</span> </span>&#123;</span><br><span class="line">    n = T.<span class="built_in">length</span>();</span><br><span class="line">    m = P.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> s = <span class="number">0</span> to n-m &#123;</span><br><span class="line">        <span class="keyword">if</span>(P[<span class="number">1.</span>.m] == T[s+<span class="number">1.</span>.s+m])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Pattern occurs with shift&quot;</span>+ s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>時間複雜度
<ul>
<li>O( (|T|-|P|+1)×|P| )
<ul>
<li><strong>O( |T||P| )</strong></li>
</ul></li>
</ul></li>
<li>空間複雜度
<ul>
<li>O(1)</li>
</ul></li>
</ul>
<h2 id="rabin-karp-演算法">Rabin-Karp 演算法</h2>
<p>由 Michael O. Rabin 及 Richard M. Karp 在 1987 年發展利用<strong>雜湊作字串判斷</strong>，帶有數學味道的演算法</p>
<ul>
<li>一個長度為 m 的模板字串 P
<ul>
<li>視為一個 d 進制（d = ∣Σ∣）的數字 p</li>
<li>令 <span class="math inline">\(t_s\)</span> 為 T[s+1…s+m] 轉換後的結果</li>
</ul></li>
<li>問題轉換成「是否存在一個 k(0 ≤ k ≤ n − m)，使得 <span class="math inline">\(p = t_k\)</span>」</li>
</ul>
<blockquote>
<p>p = ∣Σ∣(P[m-1]+(∣Σ∣(P[m-2]+… (∣Σ∣(P[2]+∣Σ∣P[1]) …))) + P[m]</p>
<p><span class="math inline">\(\Rightarrow p = ｜Σ｜^{m-1}P[1]+｜Σ｜^{m-2}P[2]+\ldots+｜Σ｜^{0}P[m]\)</span></p>
<p><span class="math inline">\(t_{s+1} = ｜Σ｜(t_s - ｜Σ｜^{m-1}T[s+1])+T[s+m+1]\)</span></p>
</blockquote>
<p>Example</p>
<p>Σ = ｛0, 1, …, 9｝，d = ∣Σ∣ = 10</p>
<ul>
<li>Pattern P[1…m]
<ul>
<li>p 為對應的十進位數字</li>
</ul></li>
<li>Text T[1…n]
<ul>
<li><span class="math inline">\(t_s\)</span> 為<strong>長度為 m 子字串</strong>（T[s+1…s+m]，s = 0, 1, …, n-m）中對應的十進位數字</li>
</ul></li>
<li>字串 ［3 1 4 1 5 2］
<ul>
<li>轉換後為 314,152</li>
</ul></li>
</ul>
<blockquote>
<p><span class="math inline">\(t_{s+1}\)</span> 與 <span class="math inline">\(t_s\)</span> 的關係</p>
<p><span class="math inline">\(t_{s+1} = 10(t_s - 10^{m-1}T[s+1])+T[s+m+1]\)</span></p>
<p>所以，上述表示為</p>
<p>T = ［3 1 4 1 5 2］、m = 5、d = 10</p>
<p><span class="math inline">\(t_s = t_0 = 31,415\)</span></p>
<p><span class="math inline">\(\Rightarrow t_{s+1} = t_1 = 10(31,415-10^{5-1}\cdot3)+2 = 14,152\)</span></p>
</blockquote>
<blockquote>
<ul>
<li>因為 p 以及 <span class="math inline">\(t_k\)</span> <strong>可能非常大</strong>
<ul>
<li>因此比較時間不能視為常數</li>
</ul></li>
<li>通常將其 mod 一個大質數 q
<ul>
<li>因為如此當 <span class="math inline">\(p = t_k\)</span> 時，不一定匹配成功，須再作進一步驗證
<ul>
<li>Spurious hit（假性命中）
<ul>
<li><span class="math inline">\(p = t_k\)</span> 但 P[1…m] <strong>≠</strong> T[s+1…s+m]</li>
</ul></li>
<li>Valid hit（完全命中）
<ul>
<li><span class="math inline">\(p = t_k\)</span> 與 P[1…m] <strong>=</strong> T[s+1…s+m]</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<p>Example</p>
<ul>
<li>P[1…5] = 31,415
<ul>
<li>p = <strong>31,415 mod 13</strong> = 7</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1549521217587.png" alt="1549521217587" /><figcaption aria-hidden="true">1549521217587</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rabinkarpmatcher</span> <span class="params">(T,P,d,q)</span> </span>&#123;</span><br><span class="line">    n = T.<span class="built_in">length</span>();</span><br><span class="line">    m = T.<span class="built_in">length</span>();</span><br><span class="line">    h = <span class="built_in">pow</span>(d,m<span class="number">-1</span>) % q;</span><br><span class="line">    t[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Preprocessing</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to m &#123;</span><br><span class="line">        p = (d*p + P[i]) % q;</span><br><span class="line">        t[<span class="number">0</span>] = (d*t_0 + T[i]) % q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Matching</span></span><br><span class="line">    <span class="keyword">for</span> s = <span class="number">0</span> to n-m &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == t[s])&#123;</span><br><span class="line">            <span class="keyword">if</span>(P[<span class="number">1.</span>.m] == T[s+<span class="number">1.</span>.s+m])&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Pattern occurs with shift&quot;</span>+ s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Next substring</span></span><br><span class="line">        <span class="keyword">if</span>(s &lt; n-m)&#123;</span><br><span class="line">            t[s+<span class="number">1</span>] = (d*(t[s]-T[s+<span class="number">1</span>]*h)+T[s+m+<span class="number">1</span>]) % q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>時間複雜度
<ul>
<li>預處理
<ul>
<li>θ (∣P∣)</li>
</ul></li>
<li>比對程序
<ul>
<li><strong>O( (∣T∣-∣P∣+1)×∣P∣ )</strong></li>
<li>發生在「Worst case」情況</li>
<li>在多數比對次數少、q 大於 m 的情況為線性複雜度</li>
</ul></li>
</ul></li>
<li>空間複雜度
<ul>
<li>O(1)</li>
</ul></li>
</ul>
<h2 id="knuth-morris-pratt-演算法">Knuth-Morris-Pratt 演算法</h2>
<p>由 Donald Knuth、Vaughan Pratt、J. H. Morris 三人於西元 1977 年共同聯合發表，<strong>最差情況為 O(n) 的字串匹配演算法</strong></p>
<blockquote>
<p><strong>觀察暴力演算法</strong></p>
<ul>
<li>存在不必要的工作
<ul>
<li>從左往右一一比對字元，一旦發現字元不同，將 P 往右挪動一位</li>
<li>往右挪動 P 之前，當下比對成功的字串片段，可以不必花時間在上面</li>
</ul></li>
</ul>
<p>Example</p>
<ul>
<li>T = [aabzabzabcz]</li>
<li>P = [abzabc]</li>
</ul>
<p>（從左往右一一比對字元，一旦發現字元不同，將 P 往右挪動一位）</p>
<figure>
<img src="\willywangkaa\images\1549522985570.png" alt="1549522985570" /><figcaption aria-hidden="true">1549522985570</figcaption>
</figure>
<p>（在往右挪動 P 之前，當下比對成功的字串片段「abzab」可以加以利用）</p>
<figure>
<img src="\willywangkaa\images\1549523718157.png" alt="1549523718157" /><figcaption aria-hidden="true">1549523718157</figcaption>
</figure>
<p>（繼續往右挪動 P，挪動一個位置、挪動兩個位置、…）</p>
<figure>
<img src="\willywangkaa\images\1549523787809.png" alt="1549523787809" /><figcaption aria-hidden="true">1549523787809</figcaption>
</figure>
<p>觀察上述行為</p>
<ul>
<li>挪動一個位置
<ul>
<li>比較『abzab 的<strong>後四個字元</strong>』與『abzab 的<strong>前四個字元</strong>』</li>
</ul></li>
<li>挪動兩個位置
<ul>
<li>比較『abzab 的<strong>後三個字元</strong>』與『abzab 的<strong>前三個字元</strong>』</li>
</ul></li>
<li>因此若預先知道『 abzab 之「次長相同前綴後綴」是 ab』
<ul>
<li><strong>可大幅挪動 P</strong>
<ul>
<li>從「V」處繼續向右一一比對字元</li>
<li>每當比對失敗，就從當前比對成功的字串片段，取其「次長的相同前綴後綴」大幅挪動 P</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1549524105095.png" alt="1549524105095" /><figcaption aria-hidden="true">1549524105095</figcaption>
</figure>
<p><strong>「相同前綴後綴」</strong>（Prefix-suffix）</p>
<figure>
<img src="\willywangkaa\images\1549524327132.png" alt="1549524327132" /><figcaption aria-hidden="true">1549524327132</figcaption>
</figure>
<p><strong>「次長相同前綴後綴」</strong></p>
<ul>
<li>一個字串的「最長相同前綴後綴」為<strong>原字串</strong></li>
<li>「最短相同前綴後綴」為<strong>空字串</strong></li>
<li>「次長相同前綴後綴」就是第二長的「相同前綴後綴」</li>
</ul>
<figure>
<img src="\willywangkaa\images\1549524493648.png" alt="1549524493648" /><figcaption aria-hidden="true">1549524493648</figcaption>
</figure>
<p>窮舉法的過程當中，<strong>當前比對成功的字串片段是 P 的前綴</strong></p>
<ul>
<li>因為無法預測是 P 的哪個前綴
<ul>
<li>所以<strong>預先計算 P 每個前綴的「次長的相同前綴後綴」</strong></li>
<li>衍生出了「Failure function」</li>
</ul></li>
</ul>
</blockquote>
<p>步驟</p>
<ol type="1">
<li>預先計算 P 的每種前綴的「次長相同前綴後綴」
<ul>
<li>意旨算出 P 的「Failure function」</li>
</ul></li>
<li>從左往右依序比對字元
<ul>
<li>比對成功時
<ul>
<li>繼續比對下個字元</li>
</ul></li>
<li>比對失敗時
<ul>
<li>從比對成功的<strong>字串片段取其「次長的相同前綴後綴」以大幅挪動 P</strong></li>
</ul></li>
<li>當全部比對成功搜尋到 P 時
<ul>
<li><strong>取 P「次長的相同前綴後綴」以大幅挪動 P</strong></li>
</ul></li>
</ul></li>
</ol>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pattern[0..m]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetFailureFunction</span><span class="params">(string pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span> to pattern.size &#123;</span><br><span class="line">        i = failure[k<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( pattern[k] != pattern[i+<span class="number">1</span>]   <span class="comment">// P[k] != P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">              &amp;&amp; i&gt;=<span class="number">0</span> )&#123;                    <span class="comment">// P[ F[...F[k-1]] ] 仍存在『次長的相同前綴後綴』</span></span><br><span class="line">            i = failure[i];                 <span class="comment">// 以 F[...F[k-1]] 繼續尋找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern[k] == pattern[i+<span class="number">1</span>])&#123;     <span class="comment">// P[k] == P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">            failure[k] = i+<span class="number">1</span>;               <span class="comment">// F[k] = F[...F[k-1]]+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Morris_Pratt</span><span class="params">(string T, string P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> P.size &gt; T.size</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="built_in">GetFailureFunction</span>(P);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 進行字串搜尋，時間複雜度：O(T)</span></span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span> to T.size &#123;</span><br><span class="line">        s = <span class="number">-1</span>;                                      <span class="comment">// 目前 P 字元比對已成功的位置</span></span><br><span class="line">        <span class="comment">// 比對 P 的下一個尚未比對位置（s+1）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若 T[k] != P[s+1]，尋找大幅挪動的步伐數</span></span><br><span class="line">        <span class="comment">// 在 P 中找出 P[1..s] == T[k-s..k] 以大幅挪動 P</span></span><br><span class="line">        <span class="keyword">while</span> ( P[s+<span class="number">1</span>] != T[k]                       <span class="comment">// T[k] != P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">              &amp;&amp; s &gt;= <span class="number">0</span> ) &#123;                          <span class="comment">// P[ F[...F[k-1]] ] 仍存在『次長的相同前綴後綴』</span></span><br><span class="line">            s = failure[s];                          <span class="comment">// 以 F[...F[k-1]] 繼續尋找</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// T[k] 與 P[s+1] 比對成功</span></span><br><span class="line">        <span class="keyword">if</span> (P[s+<span class="number">1</span>] == T[k]) &#123;                         </span><br><span class="line">            s++;                                     <span class="comment">// P 字元比對已成功的位置後移一位 </span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s == P.size<span class="number">-1</span>) &#123;                        <span class="comment">// P 字元比對已成功的位置已移完</span></span><br><span class="line">            <span class="built_in">print</span>( <span class="string">&quot; P出現的位置&quot;</span> + (s-P.size+<span class="number">1</span>) );</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            s = failure[s];                         <span class="comment">// 如果字串結尾不是&#x27;\0&#x27;的時候，就必須挪動 P</span></span><br><span class="line">                                                    <span class="comment">// 如果字串結尾是&#x27;\0&#x27;的時候，就能省略這一行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="時間複雜度分析均攤分析">時間複雜度分析（均攤分析）</h3>
<p>以「Multipop stack」概念作均攤分析，以<strong>字元兩兩比對總次數</strong>作為時間複雜度</p>
<p>（1）進行字串搜尋的過程中</p>
<ul>
<li>「Stack」S 的元素
<ul>
<li>當下比對成功的字串片段 S
<ul>
<li><strong>一開始 S 長度是零</strong></li>
</ul></li>
</ul></li>
<li><strong>若字元比對成功</strong>
<ul>
<li>S 增加一字元，<strong>視為「Push stack」</strong></li>
</ul></li>
<li><strong>若字元比對失敗</strong>
<ul>
<li>大幅挪動 P，S 只剩下「次長的相同前綴後綴」，<strong>視為「Multipop」</strong></li>
<li>實際上 S 瞬間大幅變短只需要 O(1) ，時間複雜度遠比「Multipop」小</li>
</ul></li>
</ul>
<ol type="1">
<li><p>最多有 T 個字元放入 S（S 增加一字元）</p></li>
<li><p>最多有 T 個字元彈出 S（大幅挪動 P，S 只剩下「次長的相同前綴後綴」）</p></li>
</ol>
<p><span class="math inline">\(\Rightarrow\)</span><strong>字元兩兩比對的總次數不超過 2T 次</strong></p>
<p>（2）計算 P 的「Failure function」過程中</p>
<p>原理相同，字元兩兩比對的總次數不超過 2P 次</p>
<ul>
<li><strong>總時間複雜度</strong>
<ul>
<li>O(∣T∣+∣P∣)</li>
</ul></li>
</ul>
<h3 id="failure-function">Failure function</h3>
<p>在比對失敗時會使用之</p>
<p>因為函數的<strong>定義域</strong>是 Prefix，又稱作 Prefix function</p>
<p>因為此函數的<strong>值域</strong>是 Border，又稱作 Border function</p>
<ul>
<li><strong>字串函數</strong>
<ul>
<li>輸入字串的其中一個前綴，<strong>輸出該前綴的「次長的相同前綴後綴」</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1549524903137.png" alt="1549524903137" /><figcaption aria-hidden="true">1549524903137</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1549529928795.png" alt="1549529928795" /><figcaption aria-hidden="true">1549529928795</figcaption>
</figure>
<ul>
<li>計算「Failure function」
<ul>
<li>Dynamic Programming</li>
<li>分割問題
<ul>
<li>P[0...i] 除去尾端字元 P[i]</li>
<li>利用已知 P[0...i-1] 的「次長相同前綴後綴」</li>
<li>得到 P[0...i] 的「次長相同前綴後綴」</li>
</ul></li>
</ul></li>
</ul>
<p>F[k]：P[0...k] 之「次長的相同前綴後綴」<strong>長度</strong></p>
<p>（1）將 F[0] 初始化為 -1</p>
<ul>
<li>長度為 1 的子字串，不存在「次長相同前綴後綴」</li>
</ul>
<p>（2）F[k]：<strong>探討 P[1...k-1] 與 P[k] 之間的關係</strong></p>
<figure>
<img src="\willywangkaa\images\1549530552160.png" alt="1549530552160" /><figcaption aria-hidden="true">1549530552160</figcaption>
</figure>
<ul>
<li><strong>P[ F[k-1]+1 ] == P[k]</strong>
<ul>
<li>意旨「<strong>第 k 個字元</strong>」與「<strong>P[1...k-1] 之『次長的相同前綴後綴』下一個字元</strong>」相等</li>
<li><span class="math inline">\(\Rightarrow\)</span> <strong>F[k] = F[k-1]+1</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1549530722575.png" alt="1549530722575" /><figcaption aria-hidden="true">1549530722575</figcaption>
</figure>
<blockquote>
<p><strong>對「P[1...k-1] 之『次長的相同前綴後綴』」作探討</strong></p>
<figure>
<img src="\willywangkaa\images\1549534207507.png" alt="1549534207507" /><figcaption aria-hidden="true">1549534207507</figcaption>
</figure>
</blockquote>
<ul>
<li>P[ F[k-1]+1 ] ≠ P[k]
<ul>
<li>「<strong>第 k 個字元</strong>」與「P[1...k-1] 之『次長的相同前綴後綴』下一個字元」相異</li>
</ul></li>
</ul>
<p><strong>若存在 P[ F...[F[k-1]]+1 ] == P[k]，則 F[k] = F...[F[k-1]]+1</strong></p>
<figure>
<img src="\willywangkaa\images\1549535284950.png" alt="1549535284950" /><figcaption aria-hidden="true">1549535284950</figcaption>
</figure>
<p><strong>若不存在 P[ F...[F[k-1]]+1 ] == P[k]，則 F[k] = -1</strong></p>
<figure>
<img src="\willywangkaa\images\1549535607960.png" alt="1549535607960" /><figcaption aria-hidden="true">1549535607960</figcaption>
</figure>
<p>上述可以表達為：</p>
<ul>
<li><p><span class="math inline">\(f[k]\left\{\begin{matrix} -1 &amp; if \;k = 0\\ f^m[k-1] +1 &amp; 最小的整數\; m\;使得\; P[f^m[k-1]+1] == P[k] \\ -1 &amp; 不存在整數\; m \;可以使得 P[f^m[k-1]+1] == P[k]\end{matrix}\right.\)</span></p></li>
<li><p>Algorithm</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pattern[0..m]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetFailureFunction</span><span class="params">(string pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span> to pattern.size &#123;</span><br><span class="line">        i = failure[k<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((pattern[k]!=pattern[i+<span class="number">1</span>]) &amp;&amp; <span class="comment">// P[k] != P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">              i&gt;=<span class="number">0</span>)&#123;                        <span class="comment">// P[ F[...F[k-1]] ] 仍存在『次長的相同前綴後綴』</span></span><br><span class="line">            i = failure[i];                 <span class="comment">// 以 F[...F[k-1]] 繼續尋找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern[k] == pattern[i+<span class="number">1</span>])&#123;     <span class="comment">// P[k] == P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">            failure[k] = i+<span class="number">1</span>;               <span class="comment">// F[k] = F[...F[k-1]]+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="morris-pratt-automaton">Morris-Pratt Automaton</h3>
<p>此演算法可以化作自動機，轉化的時間複雜度為 O( ∣P∣×∣Σ∣ )</p>
<ul>
<li>Σ 為字元集合</li>
</ul>
<blockquote>
<p>化作自動機之後，字串搜尋的過程就變得更簡單了，甚至可以設計成電子迴路</p>
<p>轉化的原理，是針對每個狀態，都找出經由「Failure function」能到達的狀態們，然後建立轉移邊，連到那些狀態們的下一個狀態</p>
</blockquote>
<figure>
<img src="\willywangkaa\images\1549541112414.png" alt="1549541112414" /><figcaption aria-hidden="true">1549541112414</figcaption>
</figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String matching</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - Z 演算法</title>
    <url>/willywangkaa/2018/03/19/Algorithm-Z-%E6%BC%94%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="z-演算法">Z 演算法</h1>
<p>可以線性時間在一段<strong>文本（Text）</strong> 裡面找到所有我們欲求的<strong>段落（Pattern）</strong></p>
<ul>
<li>文本（Text）的長度為 <span class="math inline">\(n\)</span></li>
<li>段落（Pattern）為 <span class="math inline">\(m\)</span></li>
</ul>
<p>搜尋過程需要線性等級的時間複雜度：<span class="math inline">\(O(m+n)\)</span></p>
<blockquote>
<p>雖然這個演算法需要的空間（Space complexity）與時間複雜度（Time complexity）都與<strong>KMP algorithm</strong>一致，但是這個演算法比起「KMP algorithm」還要容易了解</p>
<p>KMP algorithm：每個前綴與其後綴的次長共同前綴（最長的後綴） Z algorithm：每個後綴與母字串的最長共同前綴（單純的長度）</p>
<p>首先，我們需要一個 <span class="math inline">\(Z\)</span>陣列（<span class="math inline">\(Z\)</span> array）</p>
</blockquote>
<h2 id="z-陣列"><span class="math inline">\(Z\)</span> 陣列</h2>
<p>當我們將欲檢索的文本存為一個字串 $ str[0 n-1] $ 時，同時也建立一個與字串一樣長的<span class="math inline">\(Z\)</span>陣列。 在<span class="math inline">\(Z\)</span>陣列中，第 <span class="math inline">\(i\)</span> 元素紀錄「<strong>最長共同前總和 (Longest Common Prefix)</strong>的長度」，而 <em>LCP 的長度</em> 是由「從 <span class="math inline">\(i\)</span> 開始的後總和 (Postfix)」與「該文本」共同決定。 ( <strong>注意： </strong> <span class="math inline">\(Z[0]\)</span> <strong>毫無意義可言，因為從第0個開始的後總和(Postfix) 必與原本的文本字串相同。</strong> )</p>
<p>大致上我們可以看成如下的函式：</p>
<figure>
<img src="\willywangkaa\images\Z演算法的表示法.png" alt="Z演算法的表示法" /><figcaption aria-hidden="true">Z演算法的表示法</figcaption>
</figure>
<p><span class="math inline">\(Ex.\)</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Index            0   1   2   3   4   5   6   7   8   9  10  11 </span><br><span class="line">Text             a   a   b   c   a   a   b   x   a   a   a   z</span><br><span class="line">Z values             1   0   0   3   1   0   0   2   2   1   0 </span><br></pre></td></tr></table></figure> <span class="math inline">\(More\)</span> <span class="math inline">\(ex.\)</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str  = &quot;aaaaaa&quot;</span><br><span class="line">Z[]  = &#123;x, 5, 4, 3, 2, 1&#125;</span><br><span class="line"></span><br><span class="line">str = &quot;aabaacd&quot;</span><br><span class="line">Z[] = &#123;x, 1, 0, 2, 1, 0, 0&#125;</span><br><span class="line"></span><br><span class="line">str = &quot;abababab&quot;</span><br><span class="line">Z[] = &#123;x, 0, 6, 0, 4, 0, 2, 0&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="z-陣列如何幫助演算法加速"><span class="math inline">\(Z\)</span> 陣列如何幫助演算法加速?</h2>
<p>這個演算法的想法是將段落(pattern)與文本字串(text string)連接起來，若視段落(pattern)為「P」，視文本字串(text string)為「T」，並加上一個從未在段落與文本中出現過的<em>字元</em>「\$」再產生出如「P$T」的字串。</p>
<p>最後，我們再產生一個屬於「P$T」的 Z陣列，在 Z陣列之中，若該 Z值等於段落(pattern)的長度，段落出現在該處。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Pattern P = &quot;aab&quot;,  Text T = &quot;baabaa&quot;</span><br><span class="line"></span><br><span class="line">The concatenated string is</span><br><span class="line">&quot;a, a, b, $, b, a, a ,b ,a, a&quot;.</span><br><span class="line">Z array for above concatenated string is </span><br><span class="line">&#123;x, 1, 0, 0, 0, 3, 1, 0, 2, 1&#125;.</span><br><span class="line">                ^</span><br><span class="line">Since length of pattern is 3, the value 3 in Z array </span><br><span class="line">indicates presence of pattern.</span><br></pre></td></tr></table></figure>
<h2 id="如何建立-z陣列">如何建立 <span class="math inline">\(Z\)</span>陣列</h2>
<p>最簡單的就是使用兩個迴圈，外層迴圈將整個「P$T」跑過一遍，內層迴圈則是看看到底 i 位置的<strong>後總和</strong>與「P$T」的LCP長度為何。 <span class="math inline">\(Time\)</span> <span class="math inline">\(complexity:\)</span> <span class="math display">\[O(n^2)\]</span></p>
<p>我們當然可以使用另一種方法讓建立陣列的時間複雜度降低。 此演算法的關鍵在於要維護一個區間<span class="math inline">\([L \ldots R]\)</span>，<span class="math inline">\(R\)</span> 的位置代表由 <span class="math inline">\(L\)</span> 處之後可以和整個字串最長的<strong>前總和</strong>重疊到的最後一個位置( 換句話說：<span class="math inline">\([L \ldots R]\)</span>是整個字串的<strong>前綴子字串</strong> )，若完全不重疊，則 <span class="math inline">\(L\)</span> 與 <span class="math inline">\(R\)</span>相等。</p>
<ul>
<li>步驟 (<span class="math inline">\(i\)</span> 為當前位置)</li>
</ul>
<ol type="1">
<li>若 <span class="math inline">\(i &gt; R\)</span> ，就代表當前 <span class="math inline">\(i\)</span> 沒有經過任何<strong>「P$S」的前綴子字串</strong>，所以重置 <span class="math inline">\(L\)</span> 與 <span class="math inline">\(R\)</span> 的位置(<span class="math inline">\(L = i, R = i\)</span>)，經由比對<strong>「P$S」的前綴</strong>與 <strong><span class="math inline">\(i\)</span> 之後的前綴</strong>，並找出最長的子字串(<span class="math inline">\(R\)</span> 的位置)，計算新的 <span class="math inline">\(L\)</span> 與 <span class="math inline">\(R\)</span> 的位置，也一併將 <span class="math inline">\(Z[i]\)</span>值算出來(<span class="math inline">\(= R - L + 1\)</span>)。</li>
<li>若 <span class="math inline">\(i \leq R\)</span> ，令 <span class="math inline">\(K = i - L\)</span> ，再來我們知道 <span class="math inline">\(Z[i] \geq min(Z[K], R-i+1)\)</span> 因為<span class="math inline">\(String[i \ldots]\)</span>與<span class="math inline">\(String[K\ldots]\)</span>共同前<span class="math inline">\(R-i+1\)</span>個字元必然為[P$T]的<strong>前綴子字串</strong>。現在有兩種情形會發生：</li>
</ol>
<ul>
<li>case1： 若<span class="math inline">\(Z[K] &lt; R-i+1\)</span> ，代表沒有任何<strong>「P$S」的前綴子字串</strong> 從 <span class="math inline">\(i\)</span> 位置開始(否則 <span class="math inline">\(Z[K]\)</span> 的值會更大)，所以也意味著<span class="math inline">\(Z[i] = Z[K]\)</span>，還有區間<span class="math inline">\([L\ldots R]\)</span>不變。</li>
<li>case2： 若<span class="math inline">\(Z[K] \geq R-i+1\)</span>，代表<span class="math inline">\(String[i \ldots]\)</span>可以和<span class="math inline">\(String[0\ldots]\)</span> 繼續比對相同的字元，也就意味有可能拓展<span class="math inline">\([L \ldots R]\)</span> 區間，因此，我們會設 <span class="math inline">\(L = i\)</span> ，接著從 <span class="math inline">\(R\)</span> 之後開始繼續比對<strong>「P$S」的前綴子字串</strong>，最後我們會得到新的<span class="math inline">\(R\)</span>，並更新<span class="math inline">\([L \ldots R]\)</span> 區間與計算 <span class="math inline">\(Z[i]\)</span> <span class="math inline">\(( = R - L + 1)\)</span>。</li>
</ul>
<p>想要了解上述的演算法可以經由這個連結觀看<a href="http://www.utdallas.edu/~besp/demo/John2010/z-algorithm.htm">動畫</a>。</p>
<p><strong>小視窗</strong></p>
<figure>
<img src="\willywangkaa\images\Z演算法的子問題.png" alt="Z演算法的子問題" /><figcaption aria-hidden="true">Z演算法的子問題</figcaption>
</figure>
<p>如果一個位置 <span class="math inline">\(i\)</span> 位於之前比過的那段 <span class="math inline">\([L, R]\)</span> 當中，他是否跟 <span class="math inline">\(Z[i − L]\)</span> 相同呢？我們可以分成三種情形： 1. 要比的後綴根本不在以前比過的範圍<span class="math inline">\([L, R]\)</span>內 → 就去比吧！ 2. 要比的後綴在以前比過的範圍<span class="math inline">\([L, R]\)</span>但長度未知 → 還是去比吧！ 3. 要比的後綴在以前比過的範圍<span class="math inline">\([L, R]\)</span>但長度已知 → 直接記錄囉！</p>
<h1 id="程式碼實作">程式碼實作</h1>
<hr />
<h2 id="台大資工ppt-by-nkng"><a href="https://www.csie.ntu.edu.tw/~sprout/algo2016/ppt_pdf/Z_value.pdf">台大資工PPT by nkng</a></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S, <span class="keyword">int</span> *Z)</span> </span>&#123;</span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; S[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Z[bst] + bst &lt; i) Z[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> Z[i] = <span class="built_in">min</span>(Z[bst]+bst-i, Z[i-bst]);</span><br><span class="line">        <span class="keyword">while</span>(S[Z[i]] == S[i+Z[i]]) Z[i]++;</span><br><span class="line">        <span class="keyword">if</span>(Z[i] + i &gt; Z[bst] + bst) bst = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="z-algorithm---geeksforgeeks"><a href="https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/">Z algorithm - GeeksforGeeks</a></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A C++ program that implements Z algorithm for pattern searching</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getZarr</span><span class="params">(string str, <span class="keyword">int</span> Z[])</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  prints all occurrences of pattern in text using Z algo</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(string text, string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create concatenated string &quot;P$T&quot;</span></span><br><span class="line">    string concat = pattern + <span class="string">&quot;$&quot;</span> + text;</span><br><span class="line">    <span class="keyword">int</span> l = concat.<span class="built_in">length</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Construct Z array</span></span><br><span class="line">    <span class="keyword">int</span> Z[l];</span><br><span class="line">    <span class="built_in">getZarr</span>(concat, Z);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//  now looping through Z array for matching condition</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if Z[i] (matched region) is equal to pattern</span></span><br><span class="line">        <span class="comment">// length  we got the pattern</span></span><br><span class="line">        <span class="keyword">if</span> (Z[i] == pattern.<span class="built_in">length</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Pattern found at index &quot;</span></span><br><span class="line">                 &lt;&lt;  i - pattern.<span class="built_in">length</span>() <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  Fills Z array for given string str[]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getZarr</span><span class="params">(string str, <span class="keyword">int</span> Z[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> L, R, k;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// [L,R] make a window which matches with prefix of s</span></span><br><span class="line">    L = R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if i&gt;R nothing matches so we will calculate.</span></span><br><span class="line">        <span class="comment">// Z[i] using naive way.</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; R)</span><br><span class="line">        &#123;</span><br><span class="line">            L = R = i;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// R-L = 0 in starting, so it will start</span></span><br><span class="line">            <span class="comment">// checking from 0&#x27;th index. For example,</span></span><br><span class="line">            <span class="comment">// for &quot;ababab&quot; and i = 1, the value of R</span></span><br><span class="line">            <span class="comment">// remains 0 and Z[i] becomes 0. For string</span></span><br><span class="line">            <span class="comment">// &quot;aaaaaa&quot; and i = 1, Z[i] and R become 5</span></span><br><span class="line">            <span class="keyword">while</span> (R&lt;n &amp;&amp; str[R-L] == str[R])</span><br><span class="line">                R++;</span><br><span class="line">            Z[i] = R-L;</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// k = i-L so k corresponds to number which</span></span><br><span class="line">            <span class="comment">// matches in [L,R] interval.</span></span><br><span class="line">            k = i-L;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// if Z[k] is less than remaining interval</span></span><br><span class="line">            <span class="comment">// then Z[i] will be equal to Z[k].</span></span><br><span class="line">            <span class="comment">// For example, str = &quot;ababab&quot;, i = 3, R = 5</span></span><br><span class="line">            <span class="comment">// and L = 2</span></span><br><span class="line">            <span class="keyword">if</span> (Z[k] &lt; R-i+<span class="number">1</span>)</span><br><span class="line">                 Z[i] = Z[k];</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// For example str = &quot;aaaaaa&quot; and i = 2, R is 5,</span></span><br><span class="line">            <span class="comment">// L is 0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  else start from R  and check manually</span></span><br><span class="line">                L = i;</span><br><span class="line">                <span class="keyword">while</span> (R&lt;n &amp;&amp; str[R-L] == str[R])</span><br><span class="line">                    R++;</span><br><span class="line">                Z[i] = R-L;</span><br><span class="line">                R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Driver program</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;GEEKS FOR GEEKS&quot;</span>;</span><br><span class="line">    string pattern = <span class="string">&quot;GEEK&quot;</span>;</span><br><span class="line">    <span class="built_in">search</span>(text, pattern);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="建國中學-2012-年資訊能力競賽培訓講義---08"><a href="http://pisces.ck.tp.edu.tw/~peng/index.php?action=showfile&amp;file=fab7c1879e544bcefffb4b8717f2747436e1c425c">建國中學 2012 年資訊能力競賽培訓講義 - 08</a></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z_maker</span><span class="params">( <span class="keyword">int</span> z[], <span class="keyword">char</span> s[], <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    z[<span class="number">0</span>] = n;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>, i, x;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt; n ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>( R &lt; i || z[i-L] &gt;= R-i+<span class="number">1</span> )&#123;</span><br><span class="line">            R &lt; i ? x = i : x = R+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( x &lt; n &amp;&amp; s[x] == s[x-i] ) x++;</span><br><span class="line">            z[i] = x-i; <span class="keyword">if</span>( i &lt; x )&#123; L = i; R = x<span class="number">-1</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> z[i] = z[i-L];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="z-algorithm---codeforces"><a href="http://codeforces.com/willywangkaa/entry/3107">Z algorithm - codeforces</a></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; R) &#123;</span><br><span class="line">    L = R = i;</span><br><span class="line">    <span class="keyword">while</span> (R &lt; n &amp;&amp; s[R-L] == s[R]) R++;</span><br><span class="line">    z[i] = R-L; R--;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> k = i-L;</span><br><span class="line">    <span class="keyword">if</span> (z[k] &lt; R-i+<span class="number">1</span>) z[i] = z[k];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      L = i;</span><br><span class="line">      <span class="keyword">while</span> (R &lt; n &amp;&amp; s[R-L] == s[R]) R++;</span><br><span class="line">      z[i] = R-L; R--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="z-algorithm1---日月卦長的模板庫"><a href="http://sunmoon-template.blogspot.tw/2015/05/z-algorithm-linear-time-pattern.html">Z algorithm1 - 日月卦長的模板庫</a></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">z_alg1</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> len,<span class="keyword">int</span> *z)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">	z[<span class="number">0</span>]=len;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</span><br><span class="line">		z[i]=r&gt;i?<span class="built_in">min</span>(r-i+<span class="number">1</span>,z[z[l]-(r-i+<span class="number">1</span>)]):<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i+z[i]&lt;len&amp;&amp;s[z[i]]==s[i+z[i]])++z[i];</span><br><span class="line">		<span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r)r=i+z[i]<span class="number">-1</span>,l=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="z-algorithm2---日月卦長的模板庫"><a href="http://sunmoon-template.blogspot.tw/2015/05/z-algorithm-linear-time-pattern.html">Z algorithm2 - 日月卦長的模板庫</a></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">z_alg2</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> len,<span class="keyword">int</span> *z)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">	z[<span class="number">0</span>]=len;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</span><br><span class="line">		z[i]=i&gt;r?<span class="number">0</span>:(i-l+z[i-l]&lt;z[l]?z[i-l]:r-i+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(i+z[i]&lt;len&amp;&amp;s[i+z[i]]==s[z[i]])++z[i];</span><br><span class="line">		<span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r)r=i+z[i]<span class="number">-1</span>,l=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="培訓-4-字串--tioj"><a href="https://tioj.infor.org/uploads/attachment/11/43/4.pdf">培訓-4 字串- tioj</a></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S,<span class="keyword">int</span> *z)</span></span>&#123;</span><br><span class="line">    z[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bst=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(z[bst]+bst&lt;i) z[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> z[i]=std::<span class="built_in">min</span>(z[bst]+bst−i,z[i−bst]);</span><br><span class="line">        <span class="keyword">while</span>(S[z[i]]==S[i+z[i]]) z[i]++;</span><br><span class="line">        <span class="keyword">if</span>(z[i]+i&gt;z[bst]+bst) bst=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例題">例題</h1>
<hr />
<p><a href="http://codingbeans.blogspot.tw/2016/03/tioj-1725z-algorithm-massacre-at-camp.html">TIOJ 1725_Z algorithm_Massacre at Camp Happy</a></p>
<h1 id="參考">參考</h1>
<hr />
<p><a href="https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/">Z algorithm - GeeksforGeeks</a></p>
<p><a href="http://pisces.ck.tp.edu.tw/~peng/index.php?action=showfile&amp;file=fab7c1879e544bcefffb4b8717f2747436e1c425c">建國中學 2012 年資訊能力競賽培訓講義 - 08</a></p>
<p><a href="https://tioj.infor.org/uploads/attachment/11/43/4.pdf">培訓-4 字串- tioj</a></p>
<p><a href="https://www.csie.ntu.edu.tw/~sprout/algo2016/ppt_pdf/Z_value.pdf">台大資工講義 by nkng</a></p>
<p><a href="http://codeforces.com/willywangkaa/entry/3107">Z algorithm - codeforces</a></p>
<p><a href="http://momo-funnycodes.blogspot.tw/2012/07/gusfield-algorithm.html">Gusfield algorithm - momo funny codes</a></p>
<p><a href="http://sunmoon-template.blogspot.tw/2015/05/z-algorithm-linear-time-pattern.html">Z algorithm - 日月卦長的模板庫</a></p>
<h1 id="待補充">待補充</h1>
<hr />
<h2 id="kmp-字串比對演算法">KMP 字串比對演算法</h2>
<p>http://mropengate.blogspot.tw/2016/01/leetcode-kmpimplement-strstr.html</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Substring</tag>
        <tag>Z Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - Recursive time function</title>
    <url>/willywangkaa/2018/10/21/Algorithm-Recursive-time-function/</url>
    <content><![CDATA[<h1 id="substution-method">Substution method</h1>
<ul>
<li>Example 1</li>
</ul>
<p><span class="math display">\[
T(n) = T(\sqrt n) + 1 \\
\Rightarrow T(n^{\frac 14}) + 1 + 1 = T(n^{\frac 14}) + 2 \\
\Rightarrow T(n^{\frac 18}) + 3 \\
\vdots \\
\Rightarrow T(2) + \lg (\lg n) = 1 + \lg \lg n \\
\therefore T(n) = O(\lg \lg n)
\]</span></p>
<blockquote>
<p><span class="math display">\[
n^{\frac 1{k} } = 2 \\
\Rightarrow \frac 1k \cdot \lg n = 1 \\
\Rightarrow k = \lg n
\]</span></p>
</blockquote>
<ul>
<li>Example 2</li>
</ul>
<p><span class="math display">\[
T(n) = 2\cdot T(\sqrt n) + \log n, T(2) = 1 \\
\Rightarrow 2\cdot(2\cdot T(2^{\frac 14}) + \log \sqrt n) + \log n \\
\Rightarrow 4\cdot T(n^\frac 14) + 2\log n \\
\vdots \\
\Rightarrow \lg n \cdot T(2) + (\lg \lg n )\cdot \log n \\
\Rightarrow \lg n + \lg \lg n \cdot \lg n \\
\therefore T(n) = O(\lg \lg n \cdot \lg n)
\]</span></p>
<ul>
<li>Example 3 (無法使用「<strong>Master theory</strong>」)</li>
</ul>
<p><span class="math display">\[
T(n) = 2\cdot T(\frac n2) + n \log n, T(1) = 1 \\
\Rightarrow 2\cdot (2 \cdot T(\frac n4) + \frac n2\log \frac n2) + n\log n \\
\Rightarrow 4\cdot T(\frac n4) + n(\log n - 1) + n(\log n) \\
\vdots \\
\Rightarrow n \cdot T(1) + n(\lg n - (\lg n-1)) +\ldots+n(\log n - 1) + n(\log n)\\
\Rightarrow n + n(1 + 2 + \ldots +\log n - 1+\log n) \\
\Rightarrow n + n\frac {(1+\lg n)\lg n}{2} \\
\Rightarrow n + \frac {n\lg n + n(\lg n)^2}{2} \\
\therefore T(n) = O(n\lg^2 2)
\]</span></p>
<blockquote>
<p><span class="math display">\[
\frac n {2^k} = 1 \\
\Rightarrow k = \lg n
\]</span></p>
</blockquote>
<ul>
<li>Example 4 (無法使用「<strong>Master theory</strong>」)</li>
</ul>
<p><span class="math display">\[
T(n) = 2\cdot T(\frac n2) + \frac {n}{\log n}, T(1) = 1 \\
\Rightarrow 2\cdot (2\cdot T(\frac n4)+\frac{\frac n2}{\log \frac n2}) + \frac {n}{\log n} \\
\Rightarrow 4\cdot T(\frac n4) + \frac {n}{\log n - 1} + \frac {n}{\log n} \\
\vdots \\
\Rightarrow  n\cdot T(1) + \frac {n}{\log n - (\log n -1)} + \cdots+\frac {n}{\log n - 1} + \frac {n}{\log n} \\
\Rightarrow  n+ n(\frac {1}{1} + \cdots+\frac {1}{\log n - 1} + \frac {1}{\log n}) \\
\Rightarrow  n+ n\log\log n \quad （調和級數）\\
\therefore T(n) = O(n\log\log n)
\]</span></p>
<ul>
<li>Example 5 (無法使用「<strong>Master theory</strong>」)</li>
</ul>
<p><span class="math display">\[
T(n) = 8\cdot T(\frac n2) + n^3 \cdot \log^2 n \\
\Rightarrow 8\cdot(8 \cdot T(\frac n4) + (\frac n2)^3\cdot \log^2(\frac n2))+n^3 \cdot \log^2 n\\
= 64 \cdot T(\frac n4) + n^3 \cdot \log ^2 (\frac n2)+n^3 \cdot \log^2 n \\
\Rightarrow 512\cdot T(\frac n8) + n^3 \cdot \log ^2 (\frac n4) + n^3 \cdot \log ^2 (\frac n2)+n^3 \cdot \log^2 n\\
= 512\cdot T(\frac n8) + n^3 \cdot (\log ^2 (\frac n4) + \log ^2 (\frac n2)+ \log ^2 n) \\
 = 512\cdot T(\frac n8) + n^3 \cdot ((\log n - 2)^2 + (\log n - 1)^2+ (\log n)^2) \\
 \vdots \\
 \Rightarrow n \cdot T(1) + n^3 \cdot ((1)^2 + \ldots + (\log n - 1)^2+ (\log n)^2) \\
 \Rightarrow n + n^3 \cdot (\log n)^3 \\
 \therefore T(n) = O(n^3\log^3 n)
\]</span></p>
<h1 id="recursive-tree">Recursive tree</h1>
<p>主要見 <a href="https://wangwilly.github.io/willywangkaa/2018/09/01/Algorithm-Recurrence/">Algorithm-Recurrence</a></p>
<ul>
<li><strong>＜近似＞</strong></li>
</ul>
<p><span class="math display">\[
T(n) = T(\lceil\frac n2 \rceil + 17) + n \\
當\; n \rightarrow \infty \Rightarrow \lceil\frac n2 \rceil + 17 = \frac n2 \\
\therefore T(n) = T(\frac n2) + n \Rightarrow T(n) = \Theta(n)
\]</span></p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Time complexity</tag>
        <tag>Function</tag>
        <tag>Recursive</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - Time Complexity</title>
    <url>/willywangkaa/2018/08/28/Algorithm-Time-Complexity/</url>
    <content><![CDATA[<h1 id="time-complexity">Time complexity</h1>
<ul>
<li>重點
<ul>
<li>Asymptotic notation 考點著重
<ul>
<li>定義</li>
<li>特性</li>
<li><strong>證明題</strong>、<strong>選擇題</strong></li>
</ul></li>
<li>Time complexity 的比較
<ul>
<li>定義法</li>
<li>極值法 ( limit )：以大資料的手法比較演算法的優劣</li>
<li>對數法 ( log )：當該算法的等級差距大時方便判斷與解釋</li>
</ul></li>
<li>計算題要點 ( 離散數學 )
<ul>
<li><span class="math inline">\(H _n = \Theta(\lg n)\)</span></li>
<li><span class="math inline">\(\log (n !) = \Theta (n \lg n)\)</span></li>
<li><span class="math inline">\(( \log_a n )^b = o (n ^k), k &gt; 0\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="asymptotic-notation">Asymptotic notation</h2>
<p>當輸入資料變大時，程式執行的時間以何種趨勢成長</p>
<h3 id="符號定義">符號定義</h3>
<ul>
<li><span class="math inline">\(f(n) = O(g(n))\)</span>
<ul>
<li><span class="math inline">\(\exists C, n_0 &gt; 0 , \ni f(n) \leq C \times g(n) , n \geq n_0\)</span></li>
<li>稱 <span class="math inline">\(g(n)\)</span> 為 <span class="math inline">\(f(n)\)</span> 的 Asymptotic upper bound</li>
<li>f(n) 的 Order 會<strong>小於</strong> g(n) 的 Order</li>
</ul></li>
<li>$f(n) = (g(n)) $
<ul>
<li><span class="math inline">\(\exists C , n_0 &gt; 0 \ni f(n) \geq C \times g(n) , n \geq n_0\)</span></li>
<li>稱 <span class="math inline">\(g(n)\)</span> 為 <span class="math inline">\(f(n)\)</span> 的 Asymptotic lower bound</li>
<li>f(n) 的 Order 會<strong>大於</strong> g(n) 的 Order</li>
</ul></li>
<li>$f(n) = (g(n)) $
<ul>
<li><span class="math inline">\(\exists C_1 , C_2, n_0 &gt; 0 \ni C_1 \times g(n) \leq f(n) \leq C_2 \times g(n) , n \geq n_0\)</span></li>
<li>稱 <span class="math inline">\(g(n)\)</span> 為 <span class="math inline">\(f(n)\)</span> 的 Asymptotic tight bound</li>
<li>f(n) 的 Order 會<strong>等於</strong> g(n) 的 Order</li>
</ul></li>
<li>$f(n) = o (g(n)) $
<ul>
<li>以比較 Order 的上面來看，是<strong>絕對小於</strong>的意義</li>
<li>用極值法的方式方便解釋</li>
<li>Ex：true or false
<ul>
<li><span class="math inline">\(n = o(2n)\)</span>：false</li>
<li><span class="math inline">\(n = o(n^2)\)</span>：true</li>
<li><span class="math inline">\(n = O(2n)\)</span>：true</li>
<li>$n = O(n^2) $：true</li>
</ul></li>
</ul></li>
<li><span class="math inline">\(f(n) = \omega(g(n))\)</span>
<ul>
<li>以比較 Order 的上面來看，是<strong>絕對大於</strong>的意義</li>
<li>用極值法的方式方便解釋。
<ul>
<li><span class="math inline">\(2n = \omega(n)\)</span>：false</li>
<li><span class="math inline">\(n^2 = \omega(n)\)</span>：true</li>
</ul></li>
</ul></li>
</ul>
<p><strong>＜Note＞</strong></p>
<ul>
<li>？若固定 <span class="math inline">\(g(n)\)</span>，可以將<strong>所有函數</strong>作以下分類：
<ul>
<li>Ex：<span class="math inline">\(g(n) = n^3\)</span></li>
</ul></li>
<li>考古題 ( 99政大資料科學 )
<ul>
<li>Q
<ul>
<li>寫出 2 個在 <span class="math inline">\(O(n^3)\)</span> 中但不在 <span class="math inline">\(o(n^3)\)</span> 的函數</li>
</ul></li>
<li>A
<ul>
<li>題目亦等於在問舉出兩個函數在 <span class="math inline">\(\Theta(n^3)\)</span> 的函數 ，所以 <span class="math inline">\(f(n) = n^3、2n^3\)</span></li>
</ul></li>
</ul></li>
<li>考古題 ( 100 交大 )
<ul>
<li>Q
<ul>
<li>NCTU：<span class="math inline">\(\Theta(n)\)</span>、CS：<span class="math inline">\(\Omega(n)\)</span> 下列何者正確？
<ul>
<li>（a） NCTU 總是比 CS 快</li>
<li>（b） 當 n <span class="math inline">\(\geq\)</span> 1000000000000 時 NCTU 比 CS 快</li>
<li>（c） 兩者執行時間相同</li>
<li>（d） 稱 CS 的複雜度為 <span class="math inline">\(\Theta(n)\)</span></li>
<li>（e） 以上皆非</li>
</ul></li>
</ul></li>
<li>A
<ul>
<li>（e）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="特性">特性</h3>
<ul>
<li><span class="math inline">\(f(n) = O (g(n)) \Rightarrow f(n)+g(n) = O(g(n))\)</span>
<ul>
<li>Ex (98 交大資工)</li>
<li><span class="math inline">\(P(n) = \sum_{i = 0}^{d} a_in^i\)</span> 是 d 次多項式，下方表格何者正確？</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th>是否屬於右側集合</th>
<th><span class="math inline">\(O(n^k)\)</span></th>
<th><span class="math inline">\(o(n^k)\)</span></th>
<th><span class="math inline">\(\Omega(n^k)\)</span></th>
<th><span class="math inline">\(\omega(n^k)\)</span></th>
<th><span class="math inline">\(\Theta(n^k)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P(n)</td>
<td><span class="math inline">\(k&gt;d\)</span></td>
<td>true</td>
<td>true</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: center;">P(n)</td>
<td><span class="math inline">\(k &lt; d\)</span></td>
<td></td>
<td></td>
<td>true</td>
<td>true</td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: center;">P(n)</td>
<td><span class="math inline">\(k = d\)</span></td>
<td>true</td>
<td></td>
<td>true</td>
<td></td>
<td>true</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>Ex (98 交大資工)</li>
</ul>
<p>寫出 <span class="math inline">\(O(n^2) + \Theta(n^2)\)</span> 最適合的等級 (理解： <span class="math inline">\(\exists f(n) \in O(n^2) , \exists g(n) \in \Theta(n^2) \quad f(n) + g(n) \in ？\)</span>) <span class="math display">\[
O(n^2) + \Theta(n^2) = \Theta(n^2)
\]</span></p>
</blockquote>
<blockquote>
<ul>
<li>Ex (100 中央)</li>
</ul>
<p>Prove or disprove：<span class="math inline">\(f(n) + g(n) = \Theta(\;max｛f(n), g(n)｝)\)</span></p>
<p>Proof：(以定義證明) <span class="math display">\[
\exists C_1 = 1, C_2 = 2, n_0 = 1 \\ \ni n \geq n_0, C_1(\;max｛f(n), g(n)｝) \leq f(n) + g(n) \leq C_2(\;max｛f(n), g(n)｝)
\]</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(f(n) = O(g(n)) 且 f(n) = \Omega (g(n)) \Leftrightarrow f(n) = \Theta(g(n))\)</span>
<ul>
<li>Ex (95 台大資工) <strong>(離散數學)</strong>
<ul>
<li>Q <span class="math inline">\(\sum_{i = 0}^n i^5 = \Theta(n^a), a = ？\)</span></li>
<li>A
<ol type="1">
<li>Prove：<span class="math inline">\(\sum_{i = 0}^n = O(n^6)\)</span></li>
<li>Prove：<span class="math inline">\(\sum_{i = 0}^n = \Omega(n^6)\)</span></li>
</ol></li>
</ul></li>
</ul></li>
</ul>
<h3 id="函數比較等級">函數比較等級</h3>
<blockquote>
<ul>
<li><p><strong>L'Hôpital's rule 的使用</strong></p>
<ul>
<li>若 <span class="math inline">\(\lim_{n\rightarrow\infty}\frac{f(n)}{g(n)}\)</span> 是<strong>不定型 (相除為 0 或 無限大)</strong>，則該函數等於 <span class="math inline">\(\lim_{n\rightarrow\infty}\frac{f&#39;(n)}{g&#39;(n)}\)</span></li>
</ul></li>
<li><p><span class="math inline">\((\ln x)&#39; = \frac{1}{x}\)</span></p></li>
<li><p>log n 的底只要是<strong>常數</strong>其<strong>等級均相同</strong>。</p>
<ul>
<li>Ex
<ul>
<li><span class="math inline">\(\ln n, \lg n, \log n, \log_{100}n\)</span>等級均相等</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h4 id="定義法">定義法</h4>
<ul>
<li>適用時機
<ul>
<li><strong>題目分數多。</strong></li>
<li><strong>函數的型態簡單帶值可算。</strong></li>
</ul></li>
<li>Ex (96 成大資工)
<ul>
<li>True or false (10%)</li>
<li>Q
<ul>
<li><span class="math inline">\(n^2 + n\lg n + \frac{n}{2} = O(n^8)\)</span></li>
</ul></li>
<li>A
<ul>
<li><span class="math inline">\(\exists C = 5, n_0 = 10\ni n\geq n_0, n^2 + n \lg n + \frac{n}{2} \leq c \times n^8\)</span></li>
</ul></li>
</ul></li>
<li>Ex (91 交大資工)
<ul>
<li>Prove the following is incorrect</li>
<li>Q
<ul>
<li><span class="math inline">\(\frac{n^2}{\log n} = \Theta(n^2)\)</span></li>
</ul></li>
<li>A
<ul>
<li>(矛盾證明法)</li>
<li><span class="math inline">\(\frac{n^2}{\log n} = \Theta(n^2) \Rightarrow \frac{n^2}{\log n} = O(n^2), \frac{n^2}{\log n} = \Omega(n^2)\)</span> ，後者明顯錯誤所以從後者開始證明。</li>
<li>設<span class="math inline">\(\frac{n^2}{\log n} = \Omega(n^2)\)</span>成立，則 <span class="math inline">\(\exists C, n_0 &gt; 0 \ni n &gt; n_0, \frac{n^2}{\log n} \geq C \times n^2\)</span></li>
<li><span class="math inline">\(\Rightarrow \frac{1}{\log n} \geq C (\rightarrow\leftarrow)\)</span>，當 <span class="math inline">\(n\)</span> 成長時<span class="math inline">\(\frac{1}{\log n}\)</span> 會無限靠近 0 ，導致不存在 C &gt; 0 所以矛盾。</li>
</ul></li>
</ul></li>
<li>Ex (100 中央資工)
<ul>
<li>Prove or disprove</li>
<li><span class="math inline">\(f(n) = \Theta(g(n)) \Rightarrow h(f(n)) = \Theta(h(g(n)))\)</span>，其中 <span class="math inline">\(h(*)\)</span> 為<strong>遞增函數</strong>。</li>
<li>false， 直接舉例 <span class="math inline">\(f(n) = 2n, g(n) = n \Rightarrow f(n) = \Theta(g(n))\)</span></li>
<li>而取 <span class="math inline">\(h(n) = 2^{n}\)</span> 為遞增函數，但 <span class="math inline">\(h(f(n)) \ne O(h(g(n)))\)</span></li>
</ul></li>
</ul>
<h4 id="極值法">極值法</h4>
<ul>
<li>適用時機
<ul>
<li>函數<strong>型態複雜</strong>，但可藉由<strong>微分</strong>使之容易分析。</li>
<li>證明 <span class="math inline">\(o, \omega\)</span> 時可當作<strong>該集合之定義以分析</strong>。</li>
</ul></li>
<li>使用方法
<ul>
<li><span class="math inline">\(\lim_{n\rightarrow\infty} \frac{f(n)}{g(n)} = 0 \Leftrightarrow f(n) = o(g(n))\)</span></li>
<li><span class="math inline">\(\lim_{n\rightarrow\infty} \frac{f(n)}{g(n)} = \infty \Leftrightarrow f(n) = \omega(g(n))\)</span></li>
<li>$ L &gt; 0 ;is ;constant _{n}  = L f(n) = (g(n))$</li>
</ul></li>
<li>Ex
<ul>
<li><span class="math inline">\(f(n) = \log_34n, g(n) = \log_43n\)</span>，問 <span class="math inline">\(f(n)\)</span> 在 <span class="math inline">\(g(n)\)</span> 的會在哪個等級集合 (<span class="math inline">\(O, \Omega, \Theta\)</span>) 之中？</li>
<li><span class="math inline">\(\lim_{n\rightarrow\infty}\frac{log_34n}{\log_43n} =_{微分} \lim_{n\rightarrow\infty}\frac{(\frac{\ln 4n}{\ln3})&#39;}{(\frac{\ln 3n}{\ln 4})&#39;}\)</span></li>
<li><span class="math inline">\(\Rightarrow lim_{n \rightarrow \infty} \frac{ \frac{4}{4n\ln3} }{\frac{3}{3n\ln4}} \Rightarrow \frac{\ln4}{\ln3}\)</span> 為常數，所以 <span class="math inline">\(f(n) = \Theta ,\Omega , O (g(n))\)</span>。</li>
</ul></li>
<li>Ex ( 96 成大資工 ) (10%)
<ul>
<li>True or false</li>
<li><span class="math inline">\(n^b = o(a^n)\)</span>, 其中 <span class="math inline">\(a &gt; 1, b \in \mathbb{R}\)</span></li>
<li>true，<span class="math inline">\(\lim_{n\rightarrow \infty} \frac{n^b}{a^n} =_{兩邊取微分} \lim_{n\rightarrow \infty} \frac{b \times n^{b-1}}{\ln a\times a^n} = \ldots = \lim_{n\rightarrow\infty} \frac{b!}{(\ln a)^n\times a^n} = 0\)</span> 所以正確。</li>
</ul></li>
<li><strong>Ex ( 98 台大電機 )</strong>
<ul>
<li>true or false</li>
<li>對任何<strong>正數</strong> a, b 而言 <span class="math inline">\(n^b = o(a^n)\)</span> 。</li>
<li><strong>False，陷阱！</strong>因為題目只有說 a, b 為正數而非正整數，所以當 a 為<strong>分數</strong>時，此命題錯誤。</li>
</ul></li>
</ul>
<h4 id="對數法">對數法</h4>
<ul>
<li><p>適用時機</p>
<ul>
<li>題目分數少的計算題。</li>
<li>函數為指數函數型態。</li>
<li>函數為階乘型態。(<span class="math inline">\(\log n! = \Theta(n\log n)\)</span>)</li>
</ul></li>
<li><p>定義</p>
<ul>
<li><span class="math inline">\(\log(f(n)) = o, \omega(\log(g(n))) \Rightarrow f(n) = o, \omega (g(n))\)</span></li>
<li>而 <span class="math inline">\(\log(f(n)) = \Theta(\log(g(n)))\)</span> 則<strong>無法判斷等級</strong>，因為等級過於相同 ，取對數後無法判斷，要使用別的方法。</li>
</ul></li>
<li><p>Ex</p>
<ul>
<li>比較 <span class="math inline">\(f(n) = 1.1^{0.01n}, g(n) = n^{100}\)</span> 的等級。</li>
<li><span class="math inline">\(\log(f) = 0.01n \times log 1.1, log(g) = 100 \times log n \Rightarrow \lim_{n\rightarrow\infty}\frac{\log(f)}{\log(g)} = \infty\)</span>，所以 <span class="math inline">\(f(n) = \omega(g(n))\)</span>。</li>
</ul></li>
<li><p>Ex (98 交大)</p>
<ul>
<li>Prove：(log n)! 不是 Polyniminally bounded ( = O(<span class="math inline">\(n^k\)</span>))。</li>
<li>＜分析＞ 若 f(n) 是 Polyniminally bounded，則 <span class="math inline">\(\exists k \in R \ni f(n) = O(n^k)\)</span>； <span class="math inline">\(\log f = O(\log n^k) = O(\log n)\)</span> ，若為 Polyniminally bounded 則等級小於 log n <span class="math inline">\(\log((\log n)!) = \Theta(\log n (\log\log n))\)</span> 其等級大於 log n 也就是 <span class="math inline">\(\log(\log n)! = \omega(\log n)\)</span></li>
</ul></li>
</ul>
<h2 id="複雜度計算">複雜度計算</h2>
<h3 id="theta-集合的求取"><span class="math inline">\(\Theta\)</span> 集合的求取</h3>
<h4 id="close-form-的求取">Close form 的求取</h4>
<ul>
<li><strong>Close form 最高次項即為其 Tight bound。</strong>
<ul>
<li><span class="math inline">\(T(n) = 1 + ...+n = \frac{n(1+n)}{2} = \frac{n^2+n}{2} = \Theta(n^2)\)</span></li>
</ul></li>
<li>並不是所有函數都有 Close form。</li>
</ul>
<h4 id="使用-upper-bound-與-lower-bound-的夾擊">使用 Upper bound 與 Lower bound 的夾擊</h4>
<ul>
<li><p>若 <span class="math inline">\(f(n) = O, \Omega (g(n))\)</span> 同時成立，稱 <span class="math inline">\(g(n)\)</span> 為 <span class="math inline">\(f(n)\)</span> 的 Asymptotic tight bound。</p>
<ul>
<li>Ex <span class="math inline">\(T(n) = \sum_{i=1}^n i^5 = \Theta(n^a)\)</span>，求 a = ？</li>
<li>先證明 <span class="math inline">\(T(n) = \sum_{i=1}^n i^5 = O(n^6)\)</span>、再證明<span class="math inline">\(T(n) = \sum_{i=1}^n i^5 = \Omega(n^a)\)</span> 即可。</li>
</ul></li>
<li><p>調和級數( <span class="math inline">\(\mathbb{H}_n = 1 + \frac{1}{2} + \frac{1}{3} + ... +\frac{1}{n}= \Theta(\lg n)\)</span> )因為調和級數沒有 Close form，必須使用<strong>夾擠法</strong></p>
<ul>
<li><span class="math inline">\(\because \mathbb{H}_n - 1 = \sum_{i = 1}^n \frac{1}{i} - 1 \leq \int_1^n \frac{1}{n} dx = (\lg n - \lg 1) = \lg n \\ \therefore \mathbb{H}_n \leq \ln n + 1 \leq 2 \times \ln n \Rightarrow \exists C = 2, n_0 \geq 3 \ni n \geq n_0 , \\ \mathbb{H}_n \leq C \times \lg n \\ \Rightarrow \mathbb{H}_n = O(\lg n) \\ \because \mathbb{H}_n = \sum_{i = 1}^n \frac{1}{n} \geq \int_1^n \frac{1}{n} dx = \ln n \\ \therefore \mathbb{H}_n \geq \ln n \Rightarrow \exists C = 1, n_0 \geq 1 \ni n \geq n_0 , \mathbb{H}_n \geq C \times \lg n \\ \Rightarrow \mathbb{H}_n = \Omega(\lg n) \\ \Rightarrow \mathbb{H}_n = \Theta(\lg n)\)</span></li>
</ul></li>
<li><p><strong>＜Note＞ 收斂(Converge)的級數</strong></p>
<ul>
<li><span class="math inline">\(T(n) = 1^a + \frac{1}{2^a} + \frac{1}{3^a} + \ldots = \sum_{i = 1}^n \frac{1}{i^a} = \frac{\pi^2}{6}, for\; some\; a = 2, 3 ...\)</span></li>
<li><span class="math inline">\(\Rightarrow T(n) = \Theta(1)\)</span></li>
<li><a href="https://www.quora.com/What-is-1-1-2-+-1-2-2-+-1-3-2-till-infinity">複變分析證明</a></li>
</ul></li>
<li><p><span class="math inline">\(\log n! = \Theta(n\lg n)\)</span></p>
<ul>
<li>證明：
<ol type="1">
<li>Prove <span class="math inline">\(\log(n!) = O(n\lg n)\)</span>
<ul>
<li><span class="math inline">\(\log n! = \log ( \Pi_{i = 1}^n i ) = \sum_{i = 1}^n \log i \leq \sum_{i = 1}^n \log n = n \log n\)</span></li>
<li><span class="math inline">\(\therefore \exists C = 1, n_0 = 1 \ni n\geq n_0, \log n \leq n \log n \Rightarrow \log n! = O(n\lg n)\)</span></li>
</ul></li>
<li>Prove <span class="math inline">\(\log(n!) = \Omega(n\lg n)\)</span> ( 離散筆記本 P.118 )
<ul>
<li><span class="math inline">\(\log n! = \log ( \Pi_{i = 1}^n i ) \\ = \sum_{i = 1}^n \log i \geq \sum_{i = 1}^{ceil(\frac{n}{2})} \log ceil( \frac{n}{2}) \geq \frac{n}{2} \log \frac{n}{2} \\ = \frac{n}{2} (\log n - \log 2)\approx \frac{1}{2}n\log n\)</span></li>
<li><span class="math inline">\(\therefore \exists C = \frac{1}{2}, n_0 = 1 \\ \ni n\geq n_0, \log n \geq \frac{1}{2}n \log n \Rightarrow \log n! = \Omega(n\lg n)\)</span></li>
</ul></li>
<li><span class="math inline">\(\therefore \log n! = \Theta(n\lg n)\)</span></li>
</ol></li>
</ul></li>
<li><p><strong>Ex (96 台大資工)</strong></p>
<ul>
<li><span class="math inline">\(T(n) = \sum_{k = 1}^n k^2(\log k)^3 = \Theta(n^d(\log n)^e)\)</span>，d = ？、e = ？</li>
<li>＜想法＞：拆開 <span class="math inline">\(1^2(\log 1)^3 + 2^2(\log 2)^3 + ... +n^2(\log n)^3 \Rightarrow_{\leq} 1^2(\log n)^3 + 2^2(\log n)^3 + ... +n^2(\log n)^3\)</span> 提出 <span class="math inline">\((\log n)^3 \times \sum_{i = 1}^n i^2 = O(n^3(\log n)^3)\)</span> 所以 d = 3, e = 3</li>
</ul></li>
<li><p><span class="math inline">\((\log_an)^b = o(n^k), k &gt; 0\)</span></p>
<ul>
<li>Ex：<span class="math inline">\((\lg n)^{100} = o(n^{0.0000001})\)</span></li>
<li><strong>Ex (96 輔大資工)</strong>
<ul>
<li>Prove <span class="math inline">\((\log n)^3 = O(n^\frac{1}{16})\)</span></li>
<li>(函數<strong>型態複雜</strong>不適合使用定義證明，這裡採取<strong>極值法</strong>) <span class="math inline">\(\lim_{n\rightarrow\infty} \frac{(\log n)^3}{n^{\frac{1}{16}}} \\ =_{同取微分} \lim_{n\rightarrow\infty} \frac{\frac{3}{n (\ln 10)^3}\cdot (\ln n)^2}{\frac{1}{16}\cdot n^{\frac{-15}{16}}} \\ =_{整理} Constant\cdot \lim_{n\rightarrow\infty}\frac{(\ln n)^2}{n^{\frac{1}{16}}} =\ldots \\ \Rightarrow_{趨近於, n \rightarrow \infty} 0 \\ \Rightarrow (\log n)^3 = o(n^\frac{1}{16}) \Rightarrow_{?} (\log n)^3 = O(n^\frac{1}{16})\)</span></li>
</ul></li>
</ul></li>
<li><p><strong>Ex</strong> 比較 <span class="math inline">\(n^{1 + \epsilon}\)</span> 與 <span class="math inline">\(\frac{n^2}{\log n}\)</span> 的等級，其中 <span class="math inline">\(0&lt;\epsilon &lt; 1\)</span>。</p>
<ul>
<li>＜猜測＞：<strong>後者比較大</strong></li>
<li>＜分析＞：<span class="math inline">\(n^{1+\epsilon} = n^{2-\delta}, 0&lt;\delta&lt;1 \Rightarrow \frac{n^2}{n^\delta} \\ \because \log n = o(n^\delta) \\ \therefore n^{1 + \epsilon} = O(\frac{n^2}{\log n})\)</span></li>
</ul></li>
</ul>
<h1 id="補充例題">補充例題</h1>
<p>Example（101交通大學資料結構與演算法）</p>
<p>Consider the following three problem. <strong>Assume that the only operations allowed on the data are</strong></p>
<ul>
<li><em>comparing the values of two floating-point numbers and identifying the larger value</em>;</li>
<li><em>comparing the distance between two array entries (the absolute value of the difference between the two array entries) with the distance between two other array entries</em>;</li>
<li><em>swapping two entries in the array</em>.</li>
</ul>
<p>Further assume that <strong>each allowed operation has unit cost</strong>. What are the worst-case optimal asymptotic running times for algorithms that solve these problems?</p>
<ul>
<li>（1）<strong>Nearest neighbors</strong>: given an <strong>unsorted array</strong> of n floating-point numbers as input, return two of the numbers that are closest in value to each other.
<ul>
<li>（A）<span class="math inline">\(O(n\log n)\)</span></li>
<li>（B）<span class="math inline">\(O(\log n)\)</span></li>
<li>（C）<span class="math inline">\(O(n^2)\)</span></li>
<li>（D）<span class="math inline">\(O(n^3)\)</span></li>
<li>（E）<span class="math inline">\(O(n)\)</span></li>
</ul></li>
</ul>
<p>排序後元素兩兩算出距離 d，再從所有距離裡找出最小值</p>
<p><span class="math inline">\(\Rightarrow O(n\log n) + O(n) + O(n) = O(n\log n)\)</span></p>
<ul>
<li><p>（2）<strong>Farthest neighbors</strong>: given an <strong>unsorted array</strong> of n floating-point numbers as input, return two of the numbers that are farthest in value from each other.</p>
<ul>
<li><p>（A）<span class="math inline">\(O(n\log n)\)</span></p></li>
<li><p>（B）<span class="math inline">\(O(\log n)\)</span></p></li>
<li><p>（C）<span class="math inline">\(O(n^2)\)</span></p></li>
<li><p>（D）<span class="math inline">\(O(n^3)\)</span></p></li>
<li><p>（E）<span class="math inline">\(O(n)\)</span></p></li>
</ul></li>
</ul>
<p>找最大值、最小值</p>
<p><span class="math inline">\(\Rightarrow O(n) + O(n) = O(n)\)</span></p>
<ul>
<li><p>（3）Given a floating-point number to find a closest value in a <strong>sorted array</strong> of n floating-point numbers.</p>
<ul>
<li><p>（A）<span class="math inline">\(O(n\log n)\)</span></p></li>
<li><p>（B）<span class="math inline">\(O(\log n)\)</span></p></li>
<li><p>（C）<span class="math inline">\(O(n^2)\)</span></p></li>
<li><p>（D）<span class="math inline">\(O(n^3)\)</span></p></li>
<li><p>（E）<span class="math inline">\(O(n)​\)</span></p></li>
</ul></li>
</ul>
<p>使用「Binary search」找到最接近的值</p>
<p><span class="math inline">\(\Rightarrow O(\log n)\)</span></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Time Complexity</tag>
      </tags>
  </entry>
  <entry>
    <title>Calculus - 指對數</title>
    <url>/willywangkaa/2018/03/15/Calculus-%E6%8C%87%E5%B0%8D%E6%95%B8/</url>
    <content><![CDATA[<h1 id="ex"><span class="math inline">\(e^x\)</span></h1>
<figure>
<img src="\willywangkaa\images\exp.png" alt="exp" /><figcaption aria-hidden="true">exp</figcaption>
</figure>
<h2 id="緣起">緣起</h2>
<ul>
<li>複利公式
<ul>
<li>一年後的本利和 = <span class="math inline">\((1+\frac{年利率}{期數})^{期數}\)</span>
<ul>
<li><strong>期數：一年期間內複利次數</strong>
<ul>
<li>若為「逐月複利」則期數為 12</li>
</ul></li>
</ul></li>
<li>若有 1 份借貸以「x 年利率」並<strong>「逐月複利」</strong>
<ul>
<li>則<strong>每個月為前一月</strong>總值乘以 <span class="math inline">\(1 + \frac{x}{12}\)</span>，<strong>一年</strong>的總增值為 <span class="math inline">\((1 + \frac{x}{12})^{12}\)</span></li>
</ul></li>
<li>若有 1 份借貸以「x 年利率」並<strong>「逐日複利」</strong>
<ul>
<li>則<strong>每天為前一天</strong>總值乘以 <span class="math inline">\(1 + \frac{x}{365}\)</span>，<strong>一年</strong>的總增值為 <span class="math inline">\(\left (1+ \frac{x}{365} \right)^{365}\)</span></li>
</ul></li>
</ul></li>
<li>歐拉數 <span class="math inline">\(e\)</span> 進而被提出
<ul>
<li>若一開始存 1 元、年利率是100%、<strong>「逐秒複利」</strong>
<ul>
<li>則一年後的利息約為 2.71828 元（1 年 = 31,556,926 秒）</li>
</ul></li>
<li>若一開始存 1 元、年利率是100%、<strong>複利期數期數無限大</strong>
<ul>
<li>則一年後的利息為 <span class="math inline">\(e = \lim_{n \to \infty}\left ( 1 + \frac{1}{n} \right )^{n}\)</span> 元</li>
</ul></li>
</ul></li>
<li><strong>當複利期數為無限大時，為歐拉提出「指數函數」的定義</strong>，由上式可以知道
<ul>
<li><span class="math inline">\(\lim_{n \to \infty}\left ( 1 + \frac xn \right )^n = \lim_{n \to \infty} \left ( \left ( 1 + \frac{1}{\frac nx} \right )^{\frac nx} \right)^x \approx e^x\)</span>
<ul>
<li>對 n 與 x 進行探討，當 n <strong>趨近於無限大</strong>時 x 相對來說為一定值，所以 <span class="math inline">\(\frac nx\)</span> 亦<strong>趨近無限大</strong>
<ul>
<li><span class="math inline">\(\lim_{n \to \infty} \left ( 1 + \frac{1}{\frac nx} \right )^{\frac nx} \approx e^1 = e\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>指數函數基本恆等式</strong></p>
<ul>
<li>下方兩式等價
<ul>
<li><span class="math inline">\(e^{x+y} = e^{x} \cdot e^{y}\)</span></li>
<li><span class="math inline">\(\exp\left ( x + y \right ) = \exp\left ( x \right ) \cdot \exp\left ( y \right )\)</span></li>
</ul></li>
</ul>
</blockquote>
<h2 id="性質">性質</h2>
<ul>
<li>歐拉數 <span class="math inline">\(e\)</span> 的性質，對 <span class="math inline">\(\forall x, y\in \mathrm{R}\)</span>
<ul>
<li><span class="math inline">\(e^{0}=1\)</span></li>
<li><span class="math inline">\(e^{1}=e\)</span></li>
<li><span class="math inline">\(e^{x+y}=e^{x}e^{y}\)</span></li>
<li><span class="math inline">\(e^{x \cdot y}=\left(e^{x}\right)^{y}\)</span></li>
<li><span class="math inline">\(e^{-x}={1 \over e^{x}}\)</span></li>
</ul></li>
</ul>
<h2 id="微分">微分</h2>
<ol type="1">
<li>假設 <span class="math inline">\(y = e^x\)</span> 可微
<ul>
<li>根據其定義<strong>「應變數的微分」</strong><span class="math inline">\(\mathrm dy = f&#39;(x) \cdot \mathrm dx\)</span>
<ul>
<li>其中 <span class="math inline">\(f(x) = e^x\)</span>，而 <span class="math inline">\(f&#39;(x)\)</span> 為<strong>「導函數」</strong></li>
<li><span class="math inline">\(\mathrm dx\)</span> 為<strong>「自變數的微分」</strong></li>
</ul></li>
</ul></li>
<li>探討 <span class="math inline">\(\Delta x\)</span> 與 <span class="math inline">\(\Delta y\)</span> 的「比例」以求其<strong>「導函數」</strong>
<ul>
<li>根據定義 <span class="math inline">\(\Delta y = f(x+\Delta x) - f(x)\)</span>
<ul>
<li>$y = e^{x+x} - e^{x}\ = e^x e^{x} - e^x \ = (e^{x} - 1) e^{x} .......（1） $</li>
</ul></li>
<li>當 <span class="math inline">\(\Delta x\)</span> 很小時，對 <span class="math inline">\(e^{\Delta x}\)</span> 進行探討
<ul>
<li><span class="math inline">\(e^{\Delta x} \Rightarrow \lim_{n \to \infty} e^{\frac 1n} \approx \lim_{n \to \infty}\left(\left(1 + \frac1n\right)^n\right)^{\frac 1n} \\ = \lim_{n \to \infty} \left(1 + \frac1n\right) = 1 + \Delta x \quad ......（2）\)</span></li>
</ul></li>
</ul></li>
<li>將式（2）帶入式（1）可得知其<strong>「導函數」</strong>
<ul>
<li><span class="math inline">\(\Delta y = (e^{\Delta x} - 1) e^{x} \approx (1+\Delta x -1)e^x = e^x\Delta x\)</span>
<ul>
<li>則 <span class="math inline">\(f&#39;(x) = \lim_{\Delta x \to \infty} \frac {\Delta y}{\Delta x} = e^x\)</span></li>
<li><span class="math inline">\(\Rightarrow \frac {\mathrm dy}{\mathrm dx} = e^x \\ \Rightarrow dy = e^{x}\cdot dx\)</span></li>
</ul></li>
</ul></li>
</ol>
<p><strong>Example</strong></p>
<ul>
<li>對 <span class="math inline">\(y = e^{-x^2}\)</span> 微分
<ul>
<li><span class="math inline">\(\mathrm dy = (e^{-x^2}) \cdot \mathrm d(-x^2)\)</span></li>
<li><span class="math inline">\(\mathrm dy= (-2x e^{-x^2}) \cdot dx\)</span></li>
</ul></li>
</ul>
<p><strong>Example</strong></p>
<ul>
<li>對 $y = a^x $ 微分
<ul>
<li><span class="math inline">\(\Rightarrow y = e^{\ln{a^x}} = e^{x\cdot\ln a}\)</span></li>
<li>對 <span class="math inline">\(y\)</span> 作微分
<ul>
<li><span class="math inline">\(\Rightarrow \mathrm dy= e^{x\cdot\ln a} \cdot \mathrm d(x \ln a )\)</span></li>
<li><span class="math inline">\(\Rightarrow \mathrm dy= (\ln a\cdot a^x) \cdot \mathrm dx\)</span></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>求 <span class="math inline">\(y = a^x\)</span> 之「導函數」</strong></p>
<ul>
<li><span class="math inline">\(\frac{\mathrm dy}{\mathrm dx} = \lim_{\Delta x \to 0} \frac {a^{x+\Delta x}-a^x}{\Delta x} = (\lim_{\Delta x \to 0} \frac {a^{\Delta x}-1}{\Delta x})a^x\)</span></li>
</ul>
<p>其「導函數」為「原函數」乘上<strong>與自己成正比</strong>之值</p>
<ul>
<li>對 <span class="math inline">\(\lim_{\Delta x \to 0} \frac {a^{\Delta x}-1}{\Delta x}\)</span> 進行探討，將 <span class="math inline">\(a\)</span> 以 <span class="math inline">\(e\)</span> 代入可得
<ul>
<li><span class="math inline">\(\lim_{\Delta x \to 0} \frac {e^{\Delta x}-1}{\Delta x} \approx \lim_{\Delta \to 0} \frac {(1+ \Delta x)-1}{\Delta x} = \lim_{\Delta \to 0} \frac {\Delta x}{\Delta x} = 1\)</span>
<ul>
<li>推估此式為反函數：<span class="math inline">\(\log_e x = \lim_{n \to 0} \frac {x^n-1}{n} \equiv \lim_{n\to\infty} n(x^{\frac 1n}-1)\)</span></li>
<li>亦為<strong>「歐拉對自然對數的定義」</strong></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h1 id="ln-x"><span class="math inline">\(\ln x\)</span></h1>
<figure>
<img src="\willywangkaa\images\log.png" alt="log" /><figcaption aria-hidden="true">log</figcaption>
</figure>
<p><span class="math display">\[
y = \log_{e}{x} = \ln{x} \quad, x = e^{y}
\]</span></p>
<p><span class="math display">\[
\ln (a) = \int_1^a \frac{1}{x} dx
\]</span></p>
<figure>
<img src="\willywangkaa\images\log2.png" alt="log2" /><figcaption aria-hidden="true">log2</figcaption>
</figure>
<p><strong>Proof</strong>：<span class="math inline">\(\ln x = \int_1^x \frac{1}{x} dx\)</span></p>
<ol type="1">
<li><span class="math inline">\(\frac{\mathrm d}{\mathrm dx}(\ln x) = \lim_{\Delta x \to 0} (\frac{\ln(x+\Delta x) - \ln x}{\Delta x})\)</span>
<ul>
<li><span class="math inline">\(\Leftrightarrow \lim_{\Delta x \to 0} (\frac 1{\Delta x}\cdot \ln(\frac{x+\Delta x}{x})) \\ \Leftrightarrow \lim_{\Delta x \to 0} (\ln (1+\frac{\Delta x}{x})^{\frac{1}{\Delta x}})\)</span></li>
</ul></li>
<li>令 <span class="math inline">\(u = \frac {\Delta x}{x}、\Delta x = ux\)</span>
<ul>
<li>欲使 <span class="math inline">\(\Delta x \to 0\)</span> 時
<ul>
<li>則必使 <span class="math inline">\(u \to 0\)</span></li>
</ul></li>
<li><span class="math inline">\(\Rightarrow \lim_{u \to 0} (\ln (1+u)^{\frac{1}{u x}} ) = \lim_{u \to 0} (\ln(((1+u)^{\frac{1}{u}})^\frac{1}{x}))\\ \Leftrightarrow \lim_{u \to 0} (\frac 1x \cdot ln (1+u)^{\frac 1u}) \\ \Leftrightarrow \frac 1x \lim_{u \to 0} (\ln(1+u)^{\frac 1u})\)</span></li>
</ul></li>
<li>令 <span class="math inline">\(n = \frac 1u\)</span>
<ul>
<li>欲使 <span class="math inline">\(u \to 0\)</span>
<ul>
<li>則必使 <span class="math inline">\(n \to \infty\)</span></li>
</ul></li>
<li><span class="math inline">\(\Rightarrow \frac 1x lim_{n \to \infty} (\ln (1 + \frac 1n)^n) \\ \Leftrightarrow \frac 1x \ln( \lim_{n \to \infty} (1 + \frac 1n)^n ) \\ \Leftrightarrow \frac 1x \ln e \Leftrightarrow \frac 1x\)</span>
<ul>
<li>則 <span class="math inline">\(\frac{\mathrm d}{\mathrm dx}(\ln x) = \frac 1x = \frac{\mathrm d}{\mathrm dx} \int_1^x \frac 1t \mathrm dt\)</span></li>
<li>根據「微積分第一基本定理」，表明不定積分是微分的逆運算，其保證某連續函數之原函數的存在性
<ul>
<li><span class="math inline">\(\frac{\mathrm d}{\mathrm dx} (\ln x) = \frac{\mathrm d}{\mathrm dx} (\int_1^x \frac{1}{t} \mathrm dt) \\ \Leftrightarrow \ln x = \int_1^x \frac{1}{t} \mathrm dt\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<blockquote>
<p><span class="math inline">\(\ln x\)</span> <strong>的微分</strong></p>
<ul>
<li>$y = x $
<ul>
<li>$x = e^y $</li>
<li>$dx = e^y dy $
<ul>
<li>（對 <span class="math inline">\(e^{y}\)</span> 作移項）</li>
<li>$dy =  dx =  dx $</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<p><strong>Example</strong></p>
<ul>
<li>對 $y=_a x $ 作微分
<ul>
<li>$ y = $
<ul>
<li><span class="math inline">\(\Rightarrow dy= (\frac{1}{\ln a} \cdot \frac 1x) \cdot dx\)</span></li>
</ul></li>
</ul></li>
</ul>
<h1 id="補充例題">補充例題</h1>
<p><strong>Example</strong></p>
<ul>
<li>對 <span class="math inline">\(y = f \left( x\right) = x^x\)</span> 作微分
<ul>
<li><strong>兩側取自然對數函數</strong>
<ul>
<li><span class="math inline">\(\ln ( f ( x ) ) = x \cdot \ln x\)</span></li>
</ul></li>
<li><strong>對兩側取微分</strong>
<ul>
<li><span class="math inline">\(\frac{f&#39;(x)}{f(x)} = \left( 1 \cdot \ln{x} \right) + \left( x \cdot \frac{1}{x}\right)\)</span></li>
</ul></li>
<li><strong>對兩側乘上</strong> <span class="math inline">\(f(x)\)</span>
<ul>
<li><span class="math inline">\(f&#39;(x) = \left( \left( 1 \cdot \ln{x} \right) + \left( x \cdot \frac{1}{x}\right) \right) \cdot f(x) \\ \Rightarrow f&#39;(x) = \left( \ln{x} + 1 \right) \cdot \left( x^x \right)\)</span></li>
</ul></li>
</ul></li>
</ul>
<h1 id="參考">參考</h1>
<p><a href="http://moodle.ncku.edu.tw/mod/wiki/view.php?pageid=363">成大微積分指對數函數的微分（第四週共筆）</a></p>
<p><a href="https://zh.wikipedia.org/wiki/E_%28%E6%95%B0%E5%AD%A6%E5%B8%B8%E6%95%B0%29">維基百科 - e （數學常數）</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0">維基百科 - 指數函數</a></p>
<p><a href="http://aca.cust.edu.tw/online/custcalculusi/10/07_03_10.html">中華科大 - PART 10：指數與對數微分公式彙整</a></p>
]]></content>
      <categories>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>Exponent</tag>
        <tag>Logarithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Calculus - Integration</title>
    <url>/willywangkaa/2018/05/01/Calculus-Integration/</url>
    <content><![CDATA[<p><strong>分部積分法</strong>是種<a href="https://zh.wikipedia.org/wiki/%E7%A9%8D%E5%88%86">積分</a>的技巧常應用於微積分數學與數值分析之中。它是由<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E5%88%86">微分</a>的<a href="https://zh.wikipedia.org/wiki/%E4%B9%98%E6%B3%95%E5%AE%9A%E5%88%99">乘法定則</a>和<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86">微積分基本定理</a>推導而來的。其基本思路是將不易求得結果的積分形式，轉化為等價的但易於求出結果的積分形式。</p>
<h1 id="規則">規則</h1>
<hr />
<p>當 <span class="math inline">\(u = u(x)\)</span> 、 <span class="math inline">\(du = u&#39;(x)dx\)</span> 、 <span class="math inline">\(v = v(x)\)</span> 與 <span class="math inline">\(dv = v&#39;(x)dx\)</span> ， 那分部積分就可以寫為：</p>
<p><span class="math display">\[
\int_a^b u(x)v&#39;(x)dx=[u(x)v(x)]_a^b-\int_a^b u&#39;(x)v(x)dx
\]</span></p>
<p><span class="math display">\[
\Leftrightarrow u(b)v(b)-u(a)v(a)-\int_a^b u&#39;(x)v(x)dx
\]</span></p>
<p>或是以更常見的簡寫：</p>
<p><span class="math display">\[
\int u \; dv = uv - \int v \; du
\]</span></p>
<h1 id="定理">定理</h1>
<hr />
<p>假設 <span class="math inline">\(u(x)\)</span> 與 <span class="math inline">\(v(x)\)</span> 是兩個連續可導函數 (<a href="https://en.wikipedia.org/wiki/Continuously_differentiable">continuously differentiable</a> <a href="https://en.wikipedia.org/wiki/Function_(mathematics)">functions</a>). 由乘法定理 (<a href="https://en.wikipedia.org/wiki/Product_rule">product rule</a>) 可知(用來布尼茲表示法 <a href="https://en.wikipedia.org/wiki/Leibniz%27s_notation">Leibniz's notation</a>)：</p>
<p><span class="math inline">\(\frac{d}{dx} ( u(x) \cdot v(x) ) = \frac{d(u(x))}{dx}\cdot v(x) + u(x)\cdot \frac{d(v(x))}{dx}\)</span></p>
<p>對兩側求不定積分：</p>
<p><span class="math inline">\(uv = \int (\frac{d(u(x))}{dx}\cdot v(x) + u(x)\cdot \frac{d(v(x))}{dx})dx\)</span><br><br><span class="math inline">\(\Leftrightarrow \int d(u(x))\cdot v(x) + \int u(x)\cdot d(v(x))\)</span><br><br><span class="math inline">\(\Rightarrow \int u \; dv = uv - \int v \; du\)</span></p>
<h1 id="常用的分部積分">常用的分部積分</h1>
<hr />
<h2 id="int-lnx-dx-xlnx---x-c"><span class="math inline">\(\int \ln(x) dx = x\ln(x) - x + C\)</span></h2>
<p><span class="math inline">\(\int \ln(x)dx\)</span></p>
<p>令 <span class="math inline">\(u = \ln(x)\)</span> 、 <span class="math inline">\(dv = dx\)</span> ， 則 <span class="math inline">\(du = \frac{1}{x} dx\)</span> 、 <span class="math inline">\(v = x\)</span></p>
<p>帶入：</p>
<p><span class="math inline">\(\int \ln(x) dx = \ln(x) \cdot x - \int x\cdot \frac{1}{x}dx\)</span></p>
<p><span class="math inline">\(\Leftrightarrow \ln(x)\cdot x - \int(1)dx\)</span></p>
<p><span class="math inline">\(\Leftrightarrow \ln(x)\cdot x - x + C\)</span></p>
<h2 id="int-log-x-dx-xcdot-log-x---fracxln-10-c"><span class="math inline">\(\int \log (x) dx = x\cdot \log (x) - \frac{x}{\ln 10} + C\)</span></h2>
<p>令 <span class="math inline">\(u = \log (x)\)</span> 、 <span class="math inline">\(dv = dx\)</span> ，</p>
<p>則 <span class="math inline">\(du= d(\log (x)) \Leftrightarrow d(\frac{\ln x}{\ln 10})\)</span></p>
<p><strong>＜乘法定理＞：</strong> 上微下不微 + 下微上不微</p>
<p><span class="math inline">\(\Leftrightarrow d(ln x)\cdot \frac{1}{\ln 10} + \ln x\cdot d(\ln 10)\)</span></p>
<p><span class="math inline">\(\Leftrightarrow \frac{1}{x}\cdot \frac{1}{\ln 10} + \ln x \cdot 0\)</span></p>
<p><span class="math inline">\(\Leftrightarrow \frac{1}{x\ln 10}\)</span></p>
<p>接著 <span class="math inline">\(v = x\)</span> 。</p>
<p><span class="math inline">\(\int \log x dx = \log x \cdot x - \int x \cdot \frac{1}{x \ln 10} dx\)</span></p>
<p><span class="math inline">\(\Leftrightarrow x\cdot \log x - \int \frac{1}{\ln 10} dx\)</span></p>
<p><span class="math inline">\(\Leftrightarrow x\cdot \log x - x\cdot\frac{1}{\ln 10} + C\)</span></p>
<h1 id="參考">參考</h1>
<hr />
<p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E9%83%A8%E7%A9%8D%E5%88%86%E6%B3%95">Wiki - 分部積分法</a></p>
<p><a href="http://math2.org/math/integrals/more/ln.htm">Math2.org Math Tables: <em>Integral ln(x)</em></a></p>
<p><a href="https://www.emathzone.com/tutorials/calculus/derivative-of-log-x.html">Derivative of Log X</a></p>
]]></content>
      <categories>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>Integration</tag>
        <tag>Partial Integration</tag>
        <tag>Integration By Parts</tag>
        <tag>logarithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - 字串名詞簡介</title>
    <url>/willywangkaa/2018/03/21/Algorithm-%E5%AD%97%E4%B8%B2%E5%90%8D%E8%A9%9E%E7%B0%A1%E4%BB%8B/</url>
    <content><![CDATA[<ol type="1">
<li>字元 (character)：</li>
</ol>
<p>孤單的一個符號。’7’,’1’, ’ 阿’, ’2’, ’ a’, ’ X’ 2. 字元集 (Alphabet)：</p>
<p>由字元組成的集合，通常會用<span class="math inline">\(\sum\)</span>表示。 3. 字串 (String)：</p>
<p>由字元集中的字元構成的序列。”7122” 4. 子字串 (Substring)：</p>
<p>字串中的一段連續字元。”71” in ”7122” 5. 子序列 (Subsequence)：</p>
<p>字串中不需連續的一斷字元。”72” in ”7122” 6. 前綴 (Prefix)：</p>
<p>一個子字串包含第一個字元。”7”, ”71”, ”712”, ”7122” in ”7122”，在這裡所有文章我會命名為<strong>前總和</strong>，方便閱讀。 7. 後綴 (Suffix)：</p>
<p>一個子字串包含最後一個字元。”2”, ”22”, ”122”, ”7122” in ”7122”，，在這裡所有文章我會命名為<strong>後總和</strong>，方便閱讀。 8. 字典序 (Alphabetical Order)：</p>
<p>定義字串間的大小。先定義字元間的大小：<span class="math display">\[’\,’ &lt; ’a’ &lt; ’b’ &lt; ’c’ &lt; ’d’ &lt; …&lt; ’z’\]</span>通常就是照著 ASCII 碼的編排順序，要注意的是 <em>空字元</em> 比其他字元都小 接下來從第一個位置一位一位比對，<strong>由左而右比對方小</strong>的就是比較小的<strong>字串</strong>。 9. 後綴數組 (Suffix Array)：</p>
<p>將一個字串的所有後綴<strong>(後總和)</strong> ，照<strong>字典序</strong>排序後，所得的名次陣列。<span class="math display">\[Sa[i]: 第i個後綴\]</span> 10. 排名數組 (Rank Array)：</p>
<p>為<strong>後綴數組</strong>的<em>逆數組</em>。<span class="math display">\[Ra[i]: 第 i 個後綴是*第幾名*\]</span> 11. 最長共同前綴 (Longest Common Prefix)：</p>
<p>兩個字串，從第一位一位一位比對，直到不一樣就停止 <span class="math inline">\(ex:\)</span> <br> ’712221212’ 和’712222222’ 的LCP(最長共同前綴)：’71222’。 12. lcp(I, J)：</p>
<p>對於一個字串，他的<strong>第 I 個</strong>後綴和<strong>第 J 個</strong>後綴的 LCP 有多長 13. LCP(I, J)：</p>
<p>對於一個字串，他的<strong>第 I 名</strong>後綴與<strong>第 J 名</strong>後綴的 LCP 有多長 14. height[i]：</p>
<p>對於一個字串，LCP(i − 1, i) 15. h[i]：</p>
<p>對於一個字串，LCP(Ra[i] − 1, Ra[i])</p>
<p># 參考</p>
<hr />
<p><a href="http://pisces.ck.tp.edu.tw/~peng/index.php?action=showfile&amp;file=fab7c1879e544bcefffb4b8717f2747436e1c425c">建國中學 2012 年資訊能力競賽培訓講義 - 08</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - 特殊時間函數</title>
    <url>/willywangkaa/2018/10/15/Algorithm-%E7%89%B9%E6%AE%8A%E6%99%82%E9%96%93%E5%87%BD%E6%95%B8/</url>
    <content><![CDATA[<h1 id="特殊的函數">特殊的函數</h1>
<ul>
<li><span class="math inline">\((\log n)^{\log n}\)</span></li>
</ul>
<p><span class="math display">\[
\Rightarrow n^{\log \log n} \\
 令 \;d \;為一常數\\
\because d\times \log n &lt; \log \log n\times \log n \\
\log \log n \times \log n&lt; \log n \times \log n \\
\log n \times \log n &lt; n \\
n &lt; n \times \log 2 \\
\therefore n^{\log \log n} &gt; n^d \\
n^{\log \log n} &lt; 2^n
\]</span></p>
<ul>
<li><span class="math inline">\((\log n)!\)</span></li>
</ul>
<p><span class="math display">\[
\because n! \approx n^{n+\frac{1}{2}} \cdot e^{-n} \quad(Stirling \;approximation)\\
\therefore (\log n)! \approx (\log n)^{\log n + \frac 12}\cdot e^{-\log n} \\
\Rightarrow (\log n)^{\log n + \frac 12}\cdot n^{-\log e} \\
\Rightarrow (\log n)^{\log n + \frac 12}\cdot n^{-1} \\
\Rightarrow n^{\log \log n} \cdot (\log n)^{\frac12}\cdot n^{-1} \\
\therefore (\log n)! &lt; (\log n)^{\log n}
\]</span></p>
<ul>
<li><span class="math inline">\(n^{\frac {1}{\log n}}\)</span></li>
</ul>
<p><span class="math display">\[
\because n = 2^{\log n} \\
\therefore (2^{\log n})^{\frac{1}{\log n}} \Rightarrow 2^{\log n \cdot \frac{1}{\log n}} \\
\Rightarrow 2^1 = 2
\]</span></p>
<ul>
<li><span class="math inline">\(2^{\sqrt{2 \log n}}\)</span></li>
</ul>
<p><span class="math display">\[
2 = n^{\frac{1}{\log n}} \\
\Rightarrow n ^{\frac{\sqrt{2\log n}}{\log n}} \\
\because 0 &lt; \frac{\sqrt{2\log n}}{\log n} &lt; 1 \\
\therefore \log n &lt; n^{\frac{\sqrt{2\log n}}{\log n}} &lt; n^c, \forall c \in Z^+ , c \geq 1
\]</span></p>
<ul>
<li><span class="math inline">\((\log \log n)!\)</span></li>
</ul>
<blockquote>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">f(n)</th>
<th style="text-align: center;">log f(n)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">n!</td>
<td style="text-align: center;"><span class="math inline">\(n\log n \notin O(\log n)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(2^n\)</span></td>
<td style="text-align: center;"><span class="math inline">\(n\log 2 \notin O(\log n)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\((\log n)!\)</span></td>
<td style="text-align: center;"><span class="math inline">\((\log n)\cdot \log \log n \notin O(\log n)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(n^2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2\log n \in O(\log n)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\log n\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\log \log n \in O(\log n)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(2^4\)</span></td>
<td style="text-align: center;"><span class="math inline">\(4\log 2 \in O(\log n)\)</span></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(\Rightarrow\)</span> f(n) 為「Polynominal bound」<span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\log f(n) \in O(\log n)\)</span></p>
</blockquote>
<p><span class="math display">\[
\Rightarrow \log((\log \log n)!) = (\log \log n)\cdot(\log \log \log n) \\
\Rightarrow (\log \log n)\cdot(\log \log \log n) \leq (\log \log n)^2 \\
\Rightarrow (\log \log n)\cdot(\log \log \log n) = O(\log n) \\
\therefore (\log \log n)! \;為\;「Polynominal \;bound」
\]</span></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Time complexity</tag>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title>Data structure - Theoretical evaluation of overflow techniques</title>
    <url>/willywangkaa/2019/02/02/Data-structure-Theoretical-evaluation-of-overflow-techniques/</url>
    <content><![CDATA[<h1 id="data-structure---theoretical-evaluation-of-overflow-techniques未完成">Data structure - Theoretical evaluation of overflow techniques（未完成）</h1>
<h2 id="the-basic-of-hashing">The basic of hashing</h2>
<p>資料儲存機制，當資料 x 要在此結構存取時，需經過「Hashing function」求出「Hashing address」（H(x)），再以「Hashing address」視為此資料在此結構的定位點</p>
<ul>
<li>「Hash table」
<ul>
<li>「Bucket」
<ul>
<li>定位點</li>
</ul></li>
<li>「Slot」
<ul>
<li>每個定位點中有多少存儲空間</li>
</ul></li>
<li>「Hash table size」
<ul>
<li>「Bucket」×「Slot」</li>
</ul></li>
</ul></li>
<li>「Identifier」：識別字；資料區分的編碼
<ul>
<li>「Identifier density」
<ul>
<li>T：「Identifier」總數</li>
<li>n：「Identifier」<strong>目前正在使用中（目前在「Hash table」中被保存）</strong>的數量</li>
<li>B×S：「Hash table」大小</li>
<li>「Identifier density」 = <span class="math inline">\(\frac{n}{T}\)</span></li>
</ul></li>
<li>「Loading density」
<ul>
<li>T：「Identifier」總數</li>
<li>n：「Identifier」<strong>目前正在使用中（目前在「Hash table」中被保存）</strong>的數量</li>
<li>B×S：「Hash table」大小</li>
<li>「Loading density」 = <span class="math inline">\(\frac{n}{b\times s}\)</span> （通常以 <span class="math inline">\(\alpha\)</span> 表示）</li>
</ul></li>
</ul></li>
<li><strong>「Collision」</strong>
<ul>
<li>出現兩個不同的資料 X、Y，<strong>經過「Hashing function」計算後，得到相同的「Hashing address」</strong></li>
</ul></li>
<li><strong>「Overflow」</strong>
<ul>
<li>當「Collision」發生並<strong>且該「Bucket」無「Slot」可儲存</strong></li>
</ul></li>
</ul>
<blockquote>
<p>發生「Collision」不一定會造成「Overflow」，但是當每個「Bucket」由一個「Slot」所組成，則發生「Collision」等價於「Overflow」</p>
</blockquote>
<h3 id="analysis-of-linear-probing">Analysis of linear probing</h3>
<p>又稱為「Open addressing mode」，當 H(x) 發生「Overflow」，則探測 H(x)+1、H(x)+2 …H(x)-1，直到找到尚有空間之「Bucket」或是「Hash table」額滿為止</p>
<blockquote>
<p>缺點</p>
<ul>
<li>容易形成群聚（Clustering）現象，這將會增加未來搜尋資料的探測次數</li>
<li>插入與尋找的探測成本取決於「群聚鍊大小」</li>
<li>平均的「群聚鍊大小」為 <span class="math inline">\(\frac{n}{m}\)</span>
<ul>
<li><strong>識別字容易雜湊到群長聚鍊較長的位置</strong></li>
<li><strong>最差的狀態就是所有識別字都雜湊到同一個群聚鍊</strong></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>每次探測
<ul>
<li>遇到碰撞的機率：<span class="math inline">\(\alpha\)</span> （Loading factor）</li>
<li>遇到可用空間的機率：<span class="math inline">\(1-\alpha\)</span></li>
</ul></li>
<li>探測過程中
<ul>
<li><strong>恰兩次</strong>探測找到可用空間的機率
<ul>
<li><span class="math inline">\(\alpha \times(1-\alpha)\)</span></li>
</ul></li>
<li><strong>恰 K 次</strong>探測找到可用空間的機率
<ul>
<li><span class="math inline">\(\alpha^{k-1}(1-\alpha)\)</span></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>n：「Identifier」<strong>目前正在使用中（目前在「Hash table」中被保存）</strong>的數量</p>
<p>m：可使用空間量</p>
<ul>
<li>假設一個「Hash table」T，則 T[0]（Bucket）為空的機率
<ul>
<li>減去「被占用的機率」</li>
<li><span class="math inline">\(1 - \frac nm\)</span></li>
<li>此機率亦為任何一個「Bucket」為空的機率</li>
</ul></li>
<li>假設 T[0]、T[k+1] 皆為空，且 T[1]…T[k] 皆被占用，則機率
<ul>
<li>恰 k 個識別字被雜湊到 T[0]…T[k]
<ul>
<li>T[0] 在假設中仍為空</li>
<li>機率 $ = (被占用的機率)^k(未使用的機率) \ = (m)^k(1-k{k+1})$</li>
</ul></li>
<li>恰 n-k 個識別字會被雜湊到 T[k+1]…T[m-1]
<ul>
<li>T[k+1] 在假設中仍為空</li>
<li>機率 $ = (被占用的機率)^{n-k}(未使用的機率)$</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>探測失敗
<ul>
<li><span class="math inline">\(\frac 12 (1+\frac 1{(1-\alpha)^2}) = \frac 12(1+2\alpha+3\alpha^2+ 4\alpha^3+\ldots)\)</span></li>
</ul></li>
<li>搜尋成功
<ul>
<li><span class="math inline">\(\frac 12(1+\frac 1{1-\alpha}) = 1+\frac 12(\alpha+\alpha^2+\alpha^3+\alpha^4+\ldots)\)</span></li>
</ul></li>
</ul>
<h3 id="analysis-of-quadratic-probing">Analysis of quadratic probing</h3>
<blockquote>
<p>「Uniform probing」模型</p>
<p>由 W.W.Peterson 於1957年提出</p>
<ul>
<li>假設所有的「Identifier」（Key）以非常平均的方式分布於「Hashing table」
<ul>
<li>假設「Hashing table」的大小為 m</li>
<li>「Identifier」占用的大小為 n</li>
<li>所以有 <span class="math inline">\(\binom{m}{n}\)</span> 種可能的佔用方式</li>
</ul></li>
<li><strong>忽略「Primary clustering」與「Secondary clustering」的影響</strong>
<ul>
<li>初次探測（First prob）與碰撞（Collision）之後的探測皆假設為<strong>「隨機探測」</strong></li>
<li>每次的探測各自為<strong>獨立事件（Independent event）</strong></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>每次探測
<ul>
<li>遇到碰撞的機率：<span class="math inline">\(\alpha\)</span> （Loading factor）</li>
<li>遇到可用空間的機率：<span class="math inline">\(1-\alpha\)</span></li>
</ul></li>
<li>探測過程中
<ul>
<li><strong>恰兩次</strong>探測找到可用空間的機率
<ul>
<li><span class="math inline">\(\alpha \times(1-\alpha)\)</span></li>
<li><strong>恰 K 次</strong>探測找到可用空間的機率</li>
</ul></li>
<li><span class="math inline">\(\alpha^{k-1}(1-\alpha)\)</span></li>
</ul></li>
<li><strong>探測失敗</strong>（<span class="math inline">\(U(\alpha)\)</span>）
<ul>
<li><strong>觀點一</strong>
<ul>
<li>探測失敗的機率等價於自「恰 1 次探測失敗的機率」累加至「<strong>恰無限次探測失敗的機率</strong>」</li>
<li><span class="math inline">\(U(\alpha) = \sum_{K = 1}^\infty \binom K1\alpha^{K-1}(1-\alpha) = \sum_{K = 1}^\infty K\cdot\alpha^{K-1}(1-\alpha)\)</span></li>
<li>利用生成函數 <span class="math inline">\(\Rightarrow (1-\alpha)(\sum_{K = 1}^\infty K\cdot \alpha^{K-1}) = (1-\alpha)\frac{1}{(1-\alpha)^2} = \frac{1}{1-\alpha}\)</span></li>
</ul></li>
<li><strong>觀點二</strong>
<ul>
<li>累加所有「<strong>探測失敗的機率</strong>」</li>
<li><span class="math inline">\(U(\alpha) = 1 + \alpha + \alpha^2 + \alpha^3 + \ldots = \frac{1}{1-\alpha}\)</span></li>
</ul></li>
</ul></li>
<li><strong>探測成功</strong>（<span class="math inline">\(S(\alpha)\)</span>）
<ul>
<li><strong>插入第 k+1 個資料最多需要探測</strong> <span class="math inline">\(\frac{1}{1-\frac{j}{m}}\)</span></li>
<li>插入 n 筆資料探測成功的<strong>平均次數</strong>為
<ul>
<li><span class="math inline">\(S(\alpha) = \frac{1}{n}\sum_{k = 0}^{n-1}\frac{1}{1-\frac km} = \frac{m}{n}\sum_{k = 0}^{n-1}\frac{1}{m-k}\\ \Rightarrow \frac{1}{\alpha}(\sum_{k = 1}^m\frac 1k - \sum_{k = 1}^{m-n}\frac 1k)\\ \Rightarrow \frac 1\alpha (H_m - H_{m-n}) \\ \leq \frac{1}{\alpha}(\ln m - \ln(m-n)) \\ = \frac1\alpha (\ln\frac{m}{m-n}) = \frac 1\alpha(\ln\frac1{1-\alpha})\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="analysis-of-chaining">Analysis of chaining</h3>
<ul>
<li>每個串列
<ul>
<li>預期大小：<span class="math inline">\(\alpha\)</span> （Loading factor）</li>
</ul></li>
<li>探測失敗（<span class="math inline">\(U(\alpha)\)</span>）
<ul>
<li>等價於預期串列大小</li>
<li><span class="math inline">\(U(\alpha) = \alpha\)</span></li>
</ul></li>
<li>探測成功
<ul>
<li>當第 n 個識別字要插入到「Hash table」時
<ul>
<li>每個串列的預期大小為 <span class="math inline">\(\frac{n-1}{m}\)</span></li>
</ul></li>
<li></li>
</ul></li>
</ul>
<h1 id="補充試題">補充試題</h1>
<p>Example（105 交通大學資料結構與演算法）</p>
<p>Given a hash table of size m, please answer following questions.</p>
<ul>
<li>Under the uniform hashing assumption, if we use the hash table with open addressing to hash 3 keys, the probability that the third inserted key needs exactly three probes before being inserted into the table ts exactly
<ul>
<li>（A）<span class="math inline">\(\frac 2m\)</span></li>
<li>（B）<span class="math inline">\(\frac 2{m-1}\)</span></li>
<li><strong>（C）</strong><span class="math inline">\(\frac 2{m(m-1)}\)</span></li>
<li>（D）<span class="math inline">\(\frac 1{m-1}\)</span></li>
<li>（E）<span class="math inline">\(\frac 1{m(m-1)}\)</span></li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>第三個鍵值插入時
<ul>
<li>碰撞到兩個已插入的機率： <span class="math inline">\(\frac 2{m}\)</span></li>
<li>假設不會再撞到第一次碰撞的值，作探測後再次碰撞的機率： <span class="math inline">\(\frac 1{m-1}\)</span></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>We use the hash table with open addressing to hash n keys, where n is less than m. Under the uniform hashing assumption, the expected cost to insert another element into the table is at most
<ul>
<li>（A）<span class="math inline">\(1+\frac nm\)</span></li>
<li><strong>（B）</strong><span class="math inline">\(\frac 1{1-\frac nm}\)</span></li>
<li>（C）<span class="math inline">\(\frac nm\)</span></li>
<li>（D）<span class="math inline">\(\frac 1{\frac nm}\)</span></li>
<li>（E）<span class="math inline">\(1-\frac nm\)</span></li>
</ul></li>
<li>After hashing n keys into the hash table that uses chaining to handle collisions, we hash two new keys <span class="math inline">\(k_1\)</span> and <span class="math inline">\(k_2\)</span>. Under the simple uniform hashing assumption, the probability that <span class="math inline">\(k_1\)</span> and <span class="math inline">\(k_2\)</span> are hashed into the same table location is exactly
<ul>
<li>（A）<span class="math inline">\(\frac 1n​\)</span></li>
<li><strong>（B）</strong><span class="math inline">\(\frac 1m\)</span></li>
<li>（C）<span class="math inline">\(\frac 1{nm}\)</span></li>
<li>（D）<span class="math inline">\(\frac nm\)</span></li>
<li>（E）<span class="math inline">\(\frac mn\)</span></li>
</ul></li>
</ul>
<p><strong>Example（106 成功大學程式設計；翻譯）</strong></p>
<ul>
<li>Suppose there 11 slots available from 250, please give the hashing function to insert the keys, 42, 77, 85, 113, 315, 433, 474, 479, 574, 582, 698, to the 11 slots without collision by using the division method, and show the hashing table.</li>
<li>（中譯）假設從編號 250 後有連續 11 格可用的空間在此雜湊表，依序插入 42、77、85、113、315、433、474、479、574、582、698 到此 11 可用空間中，求出一使用除法的雜湊函數，使這些插入值不會碰撞，並展示插入完成的雜湊表</li>
</ul>
]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep learning - Linear algebra</title>
    <url>/willywangkaa/2019/04/19/Deep-learning-Linear-algebra/</url>
    <content><![CDATA[<h1 id="deep-learning---linear-algebra">Deep learning - Linear algebra</h1>
<h2 id="矩陣的正定性positive-definiteness">矩陣的正定性（Positive definiteness）</h2>
<blockquote>
<p><strong>Eigen decomposition</strong> 矩陣的特徵值分解</p>
<ul>
<li>一個矩陣 <span class="math inline">\(A\)</span> 可作特徵值分解
<ul>
<li>若且唯若矩陣 <span class="math inline">\(A\)</span> 的「代數重根數」（特徵根）等於其「幾何重根數」（特徵向量）</li>
</ul></li>
<li>矩陣的特徵值分解<strong>不一定唯一</strong>
<ul>
<li>當有兩個或多個特徵向量屬於同一個特徵值時</li>
<li>取其原始「特徵向量組」之拓展空間（Span；亦為該 <span class="math inline">\(\lambda\)</span> 的特徵空間）的其他「正交向量組」亦為該 <span class="math inline">\(\lambda\)</span> 的「特徵向量組」</li>
</ul></li>
<li><span class="math inline">\(A \in \mathbf R^{n\times n} \quad A = A^T\)</span>
<ul>
<li>則其可被分解成 <span class="math inline">\(Q\mathrm{diag}(\lambda)Q^T\)</span></li>
<li><span class="math inline">\(\lambda \in \mathbf R^n\)</span> 為 <span class="math inline">\(A\)</span> 的特徵根</li>
<li><span class="math inline">\(Q = [v^{(1)}, \ldots, v^{(n)}]\)</span> 為正交矩陣（Orthogonal matrix），其中每一行（Column）為對應 <span class="math inline">\(\lambda\)</span> 的特徵向量</li>
</ul></li>
</ul>
<p><strong>證明對於相異的特徵根之特徵向量相互正交</strong></p>
<p>矩陣 <span class="math inline">\(A\)</span> 在可對角化的情況下</p>
<p>假設 <span class="math inline">\(A : n\times n, A^T = A, \lambda_1\neq\lambda_2\in\lambda(A)\)</span></p>
<ol type="1">
<li>假設 <span class="math inline">\(x_1, x_2\)</span> 為 <span class="math inline">\(A\)</span> 相對於 <span class="math inline">\(\lambda_1, \lambda_2\)</span> 的特徵向量
<ul>
<li>則 <span class="math inline">\(Ax_1 = \lambda_1 x_1, Ax_2 = \lambda_2x_2\)</span></li>
</ul></li>
<li><span class="math inline">\(\lambda_1＜x_1, x_2＞ = ＜\lambda_1x_1, x_2＞ \\ = ＜Ax_1, x_2＞ = ＜x_1, A^Hx_2＞ = ＜x_1, A^Tx_2＞ \\ = ＜x_1, Ax_2＞ = ＜x_1, \lambda_2x_2＞ = \bar{\lambda_2}＜x_1, x_2＞ = \\ \lambda_2＜x_1, x_2＞\)</span>
<ul>
<li>因為 <span class="math inline">\(\lambda_1 \neq \lambda_2\)</span> 所以 <span class="math inline">\(＜x_1, x_2＞ = 0\)</span></li>
</ul></li>
<li>所以 <span class="math inline">\(x_1, x_2\)</span> 正交</li>
</ol>
<p>而對應於同一特徵根的特徵向量可以作「Gram-Schimidt」正交化，故可以找出一組正交基底可對矩陣 <span class="math inline">\(A\)</span> 作對角化</p>
<ul>
<li><span class="math inline">\(A \in \mathbf R^{n\times n} \quad A = A^T \Rightarrow A = Q\mathrm{diag}(\lambda)Q^T\)</span>
<ul>
<li><span class="math inline">\([x_0&#39;, x_1&#39;] = A [x_0,x_1]\)</span></li>
<li>因為 <span class="math inline">\(Q = [v^{(1)}, \ldots, v^{(n)}]\)</span> 為正交矩陣，因為其<strong>鋼性</strong>，所以對向量作用時，<strong>不改變其向量的長度</strong>
<ul>
<li>可以將 <span class="math inline">\(A\)</span> 視為「對該特徵向量 <span class="math inline">\(v^{(i)}\)</span> 之方向伸縮 <span class="math inline">\(\lambda\)</span> 倍」</li>
</ul></li>
<li>令下圖的 <span class="math inline">\(v^{(1)}、v^{(2)}\)</span> 為 <span class="math inline">\(A\)</span> 的特徵向量
<ul>
<li>對該平面以 <span class="math inline">\(Q^T = [v^{(1)}, v^{(2)}]^T\)</span> 作用，則此平面系統會以 <span class="math inline">\(v^{(1)}, v^{(2)}\)</span> 向量組重新參考</li>
<li>接著對此平面以舉陣 <span class="math inline">\(\mathrm{diag}(\lambda)\)</span> 作用會伸縮 <span class="math inline">\(v^{(1)}, v^{(2)}\)</span> 方向 <span class="math inline">\(\lambda_1, \lambda_2\)</span> 倍</li>
<li>最後在對該平面以 <span class="math inline">\(Q = [v^{(1)}, v^{(2)}]\)</span> 作用，還原平面向量參考系統</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1553931898849.png" alt="1553931898849" /><figcaption aria-hidden="true">1553931898849</figcaption>
</figure>
<p><strong>Theorem</strong></p>
<p>Rayleigh's quotient</p>
<ul>
<li>給定一對稱矩陣 <span class="math inline">\(A\in \mathbf R^{n\times n}\)</span>，對於所有向量 <span class="math inline">\(x\in\mathbf R^{n}\)</span>
<ul>
<li><span class="math inline">\(\lambda_{min} \leq \frac{x^TAx}{x^Tx}\leq\lambda_{max}\)</span></li>
<li><span class="math inline">\(\lambda_{min}、\lambda_{max}\)</span> 分別為 <span class="math inline">\(A\)</span> 最小與最大的特徵向量</li>
</ul></li>
</ul>
<p><em>（直觀想法）</em></p>
<p>以 <span class="math inline">\(A\)</span> 矩陣對上圖平面作用時，對所有在該平面向量 <span class="math inline">\(x\)</span> 最長只會伸縮 <span class="math inline">\(\lambda_{max}\)</span> 倍，最短只會伸縮 <span class="math inline">\(\lambda_{min}\)</span> 倍</p>
</blockquote>
<ul>
<li><span class="math inline">\(A\)</span> 有「半正定性」（Positive semidifinite；標記為 <span class="math inline">\(A \succeq O\)</span>）
<ul>
<li>若且唯若其特徵值皆非負</li>
<li><span class="math inline">\(x^TAx \geq 0 , \forall x\)</span></li>
</ul></li>
<li><span class="math inline">\(A\)</span> 有「正定性」（Positive definite；標記為 <span class="math inline">\(A \succ O\)</span>）
<ul>
<li>若且唯若其特徵直皆大於 0</li>
<li>任意非零向量 <span class="math inline">\(x\)</span> ，<span class="math inline">\(x^TAx \neq 0\)</span></li>
</ul></li>
</ul>
<h2 id="quadretic-function">Quadretic function</h2>
<ul>
<li>一個二次函數（Qusdretic function）
<ul>
<li>若且唯若可寫成 <span class="math inline">\(f(x) = \frac12x^TAx-b^Tx +c\)</span></li>
<li>上述 <span class="math inline">\(A\)</span> 為<strong>對稱矩陣</strong></li>
</ul></li>
</ul>
<p><strong>Example</strong></p>
<p><span class="math inline">\(f(x)= x^2+x+1 = \frac12[x]^T[2][x]-[-1]^Tx+c\)</span></p>
<ul>
<li><span class="math inline">\(x^TAx\)</span> 稱作<strong>「二次式」（Quadertic form）</strong>
<ul>
<li>觀察其「正定性質」以判斷其函數的「凹性」</li>
</ul></li>
<li>令 <span class="math inline">\(x = \begin{bmatrix} x_1\\ x_2\end{bmatrix}\)</span> 則 <span class="math inline">\(f(x) = x^TAx\)</span> 可作成下圖
<ul>
<li><span class="math inline">\(x_1、x_2\)</span> 之平面為該函數的輸入（Input）</li>
<li><span class="math inline">\(f(x)\)</span> 為該函數的輸出（Output）</li>
</ul></li>
<li>（a）當 <span class="math inline">\(A\)</span> 為「正定矩陣」
<ul>
<li>如果此時 <span class="math inline">\(x \in \mathbf R\)</span>，代表 <span class="math inline">\(A\)</span> 為 x 的係數（<span class="math inline">\(xAx = Ax^2\)</span>；為一元二次方程式）</li>
<li>若 <span class="math inline">\(A &gt; 0\)</span> 則此二次式的圖會上凹（碗型）</li>
</ul></li>
<li>（b）當 <span class="math inline">\(A\)</span> 為「負定矩陣」
<ul>
<li>如果此時 <span class="math inline">\(x \in \mathbf R\)</span>，代表 <span class="math inline">\(A\)</span> 為 x 的係數（<span class="math inline">\(xAx = Ax^2\)</span>；為一元二次方程式）</li>
<li>若 <span class="math inline">\(A &lt; 0\)</span> 則此二次式的圖會下凹</li>
</ul></li>
<li>（c）當 <span class="math inline">\(A\)</span> 為「半正定矩陣」（奇異矩陣；Sigular matrix）
<ul>
<li>代表在某些特徵向量的<strong>方向</strong>之下其特徵值為 0 ，則<strong>在該方向的輸入值輸出必為 0</strong>（上凹峽谷型）</li>
</ul></li>
<li>（d）當 <span class="math inline">\(A\)</span> 有「未定矩陣」（Indefinite matrix）
<ul>
<li>其特徵值包含大於 0 與小於 0 之值</li>
<li>某些特徵向量方向上凹，某些特徵向量下凹</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1553933848943.png" alt="1553933848943" /><figcaption aria-hidden="true">1553933848943</figcaption>
</figure>
<h2 id="singular-value-decomposition">Singular value decomposition</h2>
<ul>
<li>所有 m×n 矩陣 <span class="math inline">\(A \in \mathbf R^{m\times n}\)</span> 可作「奇異值分解」（Singular value decomposition）
<ul>
<li><span class="math inline">\(A = UDV^T\)</span></li>
<li><span class="math inline">\(U \in \mathbf R^{m\times m}, D \in \mathbf R^{m\times n}, V \in \mathbf R^{n\times n}\)</span></li>
<li><span class="math inline">\(U, V\)</span> 為正交矩陣，各自的行向量分別稱為<strong>「左奇異向量」（Left-singular vector）與「右奇異向量」（Right-singular vector）</strong></li>
<li>在 <span class="math inline">\(D\)</span> 矩陣上對角線元素稱為「奇異值」（Singular value）</li>
</ul></li>
<li><span class="math inline">\(A\)</span> 的「左奇異向量」為 <span class="math inline">\(AA^T\)</span> 的「特徵向量」</li>
<li><span class="math inline">\(A\)</span> 的「左奇異向量」為 <span class="math inline">\(A^TA\)</span> 的「特徵向量」</li>
<li><span class="math inline">\(A\)</span> 的所有非零「奇異值」為 <span class="math inline">\(AA^T\)</span> （或 <span class="math inline">\(A^TA\)</span>）的<strong>「非零特徵值」</strong></li>
</ul>
<h3 id="moore-penrose-pseudoinverse虛反矩陣">Moore-Penrose pseudoinverse（虛反矩陣）</h3>
<blockquote>
<ul>
<li>反矩陣只定義在方陣上</li>
</ul>
</blockquote>
<ul>
<li>欲對矩陣 <span class="math inline">\(A \in \mathbf R^{m\times n}\)</span> 找到一個「左反矩陣」<span class="math inline">\(B \in \mathbf R^{n\times m}\)</span>，對線性方程組 <span class="math inline">\(Ax = y\)</span> 兩側左乘 <span class="math inline">\(B\)</span> 以解出 <span class="math inline">\(x = By\)</span>
<ul>
<li>若 m &gt; n
<ul>
<li>則可能因為 <span class="math inline">\(y \notin \mathrm{col}(A)\)</span>，所以 <span class="math inline">\(B\)</span> 矩陣不存在</li>
</ul></li>
<li>若 m &lt; n
<ul>
<li>則可能會有多個符合的 <span class="math inline">\(B\)</span> 矩陣</li>
</ul></li>
</ul></li>
<li>若 <span class="math inline">\(B\)</span> 為<strong>「Moore-Penrose pseudoinverse」</strong><span class="math inline">\(A^+\)</span>
<ul>
<li>當 m = n 且 <span class="math inline">\(A^{-1}\)</span> 存在時，<span class="math inline">\(A^+\)</span> 退化成 <span class="math inline">\(A^{-1}\)</span></li>
<li>當 m &gt; n 且 <span class="math inline">\(\hat x = A^+y\)</span>，則 <span class="math inline">\(\forall x, ∥Ax-y∥_2 \geq ∥A\hat x-y∥_2\)</span>
<ul>
<li>因為 <span class="math inline">\(A\)</span> 為 n 維映射至 m 維所對應的矩陣，則有可能向量 <span class="math inline">\(y \notin Ax, \forall x\)</span>，目標找到與其最相似的向量 <span class="math inline">\(A\hat x\)</span></li>
<li><span class="math inline">\(A\hat x\)</span> 為 <span class="math inline">\(\mathrm{col}(A)\)</span> 中距離 <span class="math inline">\(y\)</span> 最短的向量</li>
</ul></li>
<li>當 m &lt; n 且 <span class="math inline">\(\hat x = A^+y\)</span>，則 <span class="math inline">\(\forall x \in ｛x｜Ax = y｝, ∥x∥ \geq ∥\hat x∥\)</span>
<ul>
<li><span class="math inline">\(\hat x\)</span> 為 <span class="math inline">\(Ax = y\)</span> 的最小長度解（Minimal Eudlidean norm solution）</li>
</ul></li>
</ul></li>
<li>「Moore-Penrose psedoinverse」的定義
<ul>
<li><span class="math inline">\(A^+ = \lim_{a \to 0}(A^TA+\alpha I_n)^{-1}+A^T\)</span></li>
</ul></li>
<li>在實作上是以 <span class="math inline">\(A^+ = VD^+U^T\)</span> 計算，其 <span class="math inline">\(UDV^T = A\)</span>
<ul>
<li><span class="math inline">\(D^+ \in \mathbf R^{n\times m}\)</span> 為將 <span class="math inline">\(D\)</span> 矩陣中的非零對角元素<strong>取其乘法反元素</strong>，再對其<strong>作轉置</strong></li>
</ul></li>
</ul>
<h2 id="trace矩陣的跡">Trace（矩陣的跡）</h2>
<ul>
<li><span class="math inline">\(\mathrm{tr}(A) = \Sigma_i A_{i, i}\)</span></li>
<li><span class="math inline">\(\mathrm{tr}(A) = \mathrm{tr}(A^T)\)</span></li>
<li><span class="math inline">\(∥A∥^2_F = \mathrm{tr}(AA^T) = \mathrm{tr}(A^TA)\)</span>
<ul>
<li>（矩陣的長度）</li>
</ul></li>
<li><span class="math inline">\(\mathrm{tr}(ABC) = \mathrm{tr}(BCA) = \mathrm{tr}(CAB)\)</span>
<ul>
<li>因為 <span class="math inline">\(\mathrm{tr}(AB) = \mathrm{tr}(BA)\)</span> （可暴力正明其正確性）則 <span class="math inline">\(\mathrm{tr}(A(BC)) = \mathrm{tr}((BC)A)\)</span></li>
</ul></li>
</ul>
<h2 id="determinant矩陣的行列式">Determinant（矩陣的行列式）</h2>
<ul>
<li>行列式 <span class="math inline">\(\det(\cdot)\)</span> 為一函數將方陣 <span class="math inline">\(A \in \mathbf R^{n \times n}\)</span> 映射至<strong>實數域</strong>
<ul>
<li><span class="math inline">\(\det(A) = \Sigma_i(-1)^{i+1}A_{1,i}\det(A_{-1,-i})\)</span><strong>（此亦為降階求行列式的定義）</strong>
<ul>
<li><span class="math inline">\(A_{-1,-i}\)</span> 為減去<strong>第 1 列</strong>與<strong>第 i 行</strong>的 (n-1)×(n-1) <strong>矩陣</strong></li>
<li><span class="math inline">\(A_{1,i}\)</span> 為第 1 列第 i 行的<strong>元素</strong></li>
</ul></li>
</ul></li>
<li><span class="math inline">\(\det(A^T) = \det(A)\)</span></li>
<li><span class="math inline">\(\det(A^{-1}) = \frac 1{\det(A)}\)</span></li>
<li><span class="math inline">\(\det(AB) = \det(A)\det(B)\)</span></li>
<li><span class="math inline">\(\det(A) = \prod_i \lambda_i\)</span>
<ul>
<li>當一個矩陣可作「特徵值分解」時，可藉由特徵值 <span class="math inline">\(\lambda\)</span> 發現矩陣 <span class="math inline">\(A\)</span> 所對應的函數 <span class="math inline">\(T\)</span> 作用後，在其特徵向量 <span class="math inline">\(x\)</span> 的「方向」上伸縮的倍率</li>
<li>由此可見 <span class="math inline">\(A\)</span> 的行列式為這些倍率的「總乘」</li>
<li>其幾何意義可視為：當被作用的輸入向量可形成一個「超單位矩體」（Image of the unit square）時，則 <span class="math inline">\(T\)</span> 的行列值為「<span class="math inline">\(T\)</span> 作用之後而形成『超矩體』之<strong>體積</strong>」</li>
</ul></li>
</ul>
<p><strong>Example</strong></p>
<ul>
<li>令 <span class="math inline">\(A = \begin{bmatrix} a &amp; b \\ c &amp; d\end{bmatrix}\)</span> ，有兩單位向量 <span class="math inline">\(e_1 = \begin{bmatrix} 1 \\ 0 \end{bmatrix}, e_2 = \begin{bmatrix} 0 \\ 1 \end{bmatrix}\)</span>
<ul>
<li>經過矩陣 <span class="math inline">\(A\)</span> 作用後 <span class="math inline">\(Ae_1 = \begin{bmatrix} a \\ c \end{bmatrix} \\ Ae_2 = \begin{bmatrix} b \\ d \end{bmatrix}\)</span></li>
<li>下圖中的平行四邊形為標準基底向量經過 <span class="math inline">\(A\)</span> 矩陣後而成，行列式值為其面積</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1553944007423.png" alt="1553944007423" /><figcaption aria-hidden="true">1553944007423</figcaption>
</figure>
<ul>
<li>一個函數 <span class="math inline">\(T\)</span> 的行列式值比「特徵值分解」更能簡潔表達其函數的<strong>伸縮性</strong></li>
<li>若 <span class="math inline">\(\det(A) = 0\)</span>，代表經過此函數作用後會比原本維度至少<strong>少一個維度以上</strong>
<ul>
<li>由高維度的空間映射至低維度的空間
<ul>
<li>該函數不能取其「反函數」</li>
</ul></li>
<li>在特徵值上，也就是說有一特徵值等於 0，其對應的特徵向量的方向伸縮為 0，其「超體」亦退化成「超面」導致『超矩體』之<strong>體積</strong>退化成 0</li>
</ul></li>
<li>若 <span class="math inline">\(\det(A) = 0\)</span>，代表經過此函數 <span class="math inline">\(T\)</span> 的轉換後，其『超矩體』之<strong>體積</strong>不變</li>
</ul>
]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
  </entry>
  <entry>
    <title>Deep learning - Probability and Information theories IV</title>
    <url>/willywangkaa/2019/04/19/Deep-learning-Probability-and-Information-theories-IV/</url>
    <content><![CDATA[<h1 id="deep-learning---probability-and-information-theories-iv">Deep learning - Probability and Information theories IV</h1>
<h2 id="common-probability-distribution">Common probability distribution</h2>
<h3 id="multivariate-gaussian-distribution多元常態分佈continuous">Multivariate Gaussian distribution（多元常態分佈；Continuous）</h3>
<blockquote>
<p><span class="math inline">\(\mathrm{X～Gaussian}(\mu, \sigma)\quad f_{\mathrm X}(x) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\)</span></p>
<p>常態分佈亦可推廣至 <span class="math inline">\(\mathbb R^n\)</span> 空間，稱作<strong>多元常態分佈</strong></p>
</blockquote>
<p><span class="math display">\[
\mathrm {X～Gaussian}(\boldsymbol \mu, \Sigma)
\]</span></p>
<ul>
<li>機率密度函數（Probability density function）
<ul>
<li><span class="math inline">\(f_X(\boldsymbol x) = \sqrt{\frac{1}{(2\pi)^d\det(\Sigma)}}e^{-\frac12(\boldsymbol x-\boldsymbol \mu)^T\Sigma^{-1}(\boldsymbol x-\boldsymbol \mu)}\)</span></li>
</ul></li>
</ul>
<blockquote>
<ul>
<li><span class="math inline">\(\boldsymbol \mu = \begin{bmatrix}\mu_1 \\ \vdots \\ \mu_d\end{bmatrix} \in \mathbb R^d\)</span> 為平均數向量</li>
<li><span class="math inline">\(\Sigma \in \mathbb R^{n\times n}\)</span> 共變異數矩陣（Covariance matrix）</li>
</ul>
</blockquote>
<ul>
<li>若 <span class="math inline">\(\mathrm {X～Gaussian}(\boldsymbol \mu, \Sigma)\)</span>
<ul>
<li>則每個隨機變數 <span class="math inline">\(X_i\)</span> 為單變量常態分佈</li>
<li><strong>反向不成立</strong></li>
</ul></li>
<li>但是若 <span class="math inline">\(X_1, \ldots, X_d\)</span> 為 i.i.d. 且 <span class="math inline">\(X_i～\mathrm{Gaussian}(\mu_i,\sigma_i)\)</span>
<ul>
<li>則 <span class="math inline">\(\mathrm {X～Gaussian}(\boldsymbol \mu, \Sigma)\)</span></li>
<li><span class="math inline">\(\boldsymbol \mu = \begin{bmatrix}\mu_1 \\ \vdots \\ \mu_d\end{bmatrix}\)</span></li>
<li><span class="math inline">\(\Sigma = \mathrm{diag}(\sigma_1^2,\ldots,\sigma_d^2)\)</span></li>
</ul></li>
</ul>
<blockquote>
<p><strong>運用矩陣分解可以從另一個角度認識常態分布和共變異數矩陣</strong></p>
<ul>
<li><span class="math inline">\(\Sigma\)</span> 的正交對角化表達式為 <span class="math inline">\(\Sigma=Q\Lambda Q^T=BB^T\)</span>
<ul>
<li>其中 <span class="math inline">\(B=Q\Lambda^{1/2}\)</span> 稱為極分解（見“<a href="https://ccjou.wordpress.com/2009/09/09/%E6%A5%B5%E5%88%86%E8%A7%A3/">極分解</a>”）</li>
<li><span class="math inline">\(Q\)</span> 是一個正交矩陣表示<strong>旋轉或鏡射</strong></li>
<li><span class="math inline">\(\Lambda^{1/2}=\hbox{diag}(\sqrt{\lambda_1},\ldots,\sqrt{\lambda_n})\)</span> 是一個正定矩陣表示<strong>伸縮</strong></li>
</ul></li>
<li>馬氏距離可表示成
<ul>
<li><span class="math inline">\(\Delta^2=(\mathbf{x}-\boldsymbol{\mu})^T(B^{-1})^TB^{-1}(\mathbf{x}-\boldsymbol{\mu}) \\=\Vert B^{-1}(\mathbf{x}-\boldsymbol{\mu})\Vert^2=\Vert\Lambda^{-1/2}Q^T(\mathbf{x}-\boldsymbol{\mu})\Vert^2\)</span></li>
<li><span class="math inline">\(\mathbf{z}=\Lambda^{-1/2}Q^T(\mathbf{x}-\boldsymbol{\mu})\)</span>，即有 <span class="math inline">\(\Delta^2=\mathbf{z}^T\mathbf{z}\)</span>
<ul>
<li>隨機向量 <span class="math inline">\(\mathbf{z}\)</span> 的機率密度函數</li>
<li><span class="math inline">\(p(\mathbf{z})=\frac{1}{(2\pi)^{n/2}}\exp\left\{-\frac{1}{2}\mathbf{z}^T\mathbf{z}\right\}=\prod_{i=1}^n\frac{1}{\sqrt{2\pi}}\exp\left\{-\frac{z_i^2}{2}\right\}\)</span>
<ul>
<li>稱為標準常態分布</li>
<li>平均數向量是 <span class="math inline">\(\boldsymbol{\mu}=\mathbf{0}\)</span></li>
<li>共變異數矩陣是 <span class="math inline">\(\Sigma=I\)</span></li>
</ul></li>
</ul></li>
<li>一般常態分布的隨機向量 <span class="math inline">\(\mathbf{x}\)</span>其生成過程可表示為<strong>仿射變換</strong>
<ul>
<li><span class="math inline">\(\mathbf{x}=Q\Lambda^{1/2}\mathbf{z}+\boldsymbol{\mu}\)</span></li>
<li>先伸縮標準常態分布的隨機向量 <span class="math inline">\(\mathbf{z}\)</span> 各個變數（乘以 <span class="math inline">\(\Lambda^{1/2}\)</span>）</li>
<li>再旋轉（乘以 <span class="math inline">\(Q\)</span>）</li>
<li>最後平移（加上 <span class="math inline">\(\boldsymbol{\mu}\)</span>），<strong>如下圖</strong></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1555650665915.png" alt="1555650665915" /><figcaption aria-hidden="true">1555650665915</figcaption>
</figure>
<p><strong>共變異數矩陣</strong> <span class="math inline">\(\Sigma\)</span> <strong>的作用在於決定常態分布的伸縮</strong> <span class="math inline">\(\Lambda^{1/2}\)</span> <strong>和旋轉</strong> <span class="math inline">\(Q\)</span></p>
</blockquote>
<figure>
<img src="\willywangkaa\images\1555650853286.png" alt="1555650853286" /><figcaption aria-hidden="true">1555650853286</figcaption>
</figure>
<ul>
<li>隨著 <span class="math inline">\(\mathrm{Cov}[X_1,X_2]\)</span> 增長，會將等高線沿著 45 度伸長</li>
<li>隨著 <span class="math inline">\(\mathrm{Cov}[X_1,X_2]\)</span> 減少，會將等高線沿著 -45 度伸長</li>
</ul>
<figure>
<img src="\willywangkaa\images\1555651404197.png" alt="1555651404197" /><figcaption aria-hidden="true">1555651404197</figcaption>
</figure>
<ul>
<li>上圖高度為 <span class="math inline">\(f_X(\boldsymbol x) = \sqrt{\frac{1}{(2\pi)^d\det(\Sigma)}}e^{-\frac12(\boldsymbol x-\boldsymbol \mu)^T\Sigma^{-1}(\boldsymbol x-\boldsymbol \mu)}\)</span> 的輸出
<ul>
<li>高度與馬氏距離成反比</li>
<li>若 <span class="math inline">\(\Sigma=\sigma^2I\)</span> 則該常態分佈具有<strong>等向性（Isotropic）</strong></li>
</ul></li>
</ul>
<h4 id="特性">特性</h4>
<ul>
<li>若 <span class="math inline">\(\mathrm {X～Gaussian}(\boldsymbol \mu, \Sigma)\)</span>
<ul>
<li>對於任意常數向量 <span class="math inline">\(\mathbf w\in\mathbb R^d\)</span></li>
<li><span class="math inline">\(\mathrm {w^TX～Gaussian}(\mathbf w^T\boldsymbol \mu, \mathbf w^T\Sigma\mathbf w)\)</span></li>
</ul></li>
<li>廣義的說給定 <span class="math inline">\(\mathbf W\in \mathbb R^{d\times k}, k\leq d\)</span>
<ul>
<li><span class="math inline">\(\mathbf W^T\mathrm {X～Gaussian}(\mathbf W^T\boldsymbol \mu, \mathbf W^T\Sigma\mathbf W)\)</span> 為 <span class="math inline">\(k\)</span> 變量常態分佈</li>
<li>將隨機向量 <span class="math inline">\(\mathbf x\)</span> 投影至 <span class="math inline">\(k\)</span> 為空間<strong>仍然為常態分佈</strong></li>
</ul></li>
</ul>
<h4 id="mahalanobis-distance馬氏距離">Mahalanobis distance（馬氏距離）</h4>
<p><strong>常態分佈</strong>的機率密度函數由下列二次型決定： <span class="math display">\[
\Delta^2 = (\boldsymbol x-\boldsymbol\mu)^T\Sigma^{-1}(\boldsymbol x-\boldsymbol\mu)
\]</span></p>
<ul>
<li><span class="math inline">\(\Delta\)</span> 稱為 <span class="math inline">\(\boldsymbol \mu\)</span> 與 <span class="math inline">\(\boldsymbol x\)</span> 的馬氏距離</li>
<li>若 <span class="math inline">\(\Sigma = I_d\)</span> ，則 <span class="math inline">\(\Sigma^2 = \Vert \boldsymbol x -\boldsymbol \mu\Vert^2\)</span>
<ul>
<li>馬氏距離退化為歐氏距離（Euclidean distance）</li>
</ul></li>
<li>通過解析馬氏距離的二次型表達式
<ul>
<li>可以瞭解常態分布的<strong>幾何型態</strong></li>
</ul></li>
</ul>
<blockquote>
<p>不失一般性原則下，假設 <span class="math inline">\(\Sigma\)</span> 為一個實對稱矩陣</p>
<ul>
<li>考慮特徵方程 <span class="math inline">\(\Sigma\mathbf{q}_i=\lambda_i\mathbf{q}_i\)</span></li>
<li><span class="math inline">\(\Vert\mathbf{q}_i\Vert=1\)</span>，<span class="math inline">\(i=1,\ldots,d\)</span></li>
<li>實對稱矩陣可正交對角化（<a href="https://ccjou.wordpress.com/2011/02/09/%E5%AF%A6%E5%B0%8D%E7%A8%B1%E7%9F%A9%E9%99%A3%E5%8F%AF%E6%AD%A3%E4%BA%A4%E5%B0%8D%E8%A7%92%E5%8C%96%E7%9A%84%E8%AD%89%E6%98%8E/">實對稱矩陣可正交對角化的證明</a>）
<ul>
<li>令 <span class="math inline">\(Q=\begin{bmatrix} \mathbf{q}_1&amp;\cdots&amp;\mathbf{q}_d \end{bmatrix}\)</span> 且 <span class="math inline">\(\Lambda=\mathrm{diag}(\lambda_1,\ldots,\lambda_d)\)</span></li>
<li><span class="math inline">\(\Sigma=Q\Lambda Q^T=\begin{bmatrix} \mathbf{q}_1&amp;\cdots&amp;\mathbf{q}_d \end{bmatrix}\begin{bmatrix} \lambda_1&amp;&amp;\\ &amp;\ddots&amp;\\ &amp;&amp;\lambda_d \end{bmatrix}\begin{bmatrix} \mathbf{q}_1^T\\ \vdots\\ \mathbf{q}_d^T \end{bmatrix}=\displaystyle\sum_{i=1}^d\lambda_i\mathbf{q}_i\mathbf{q}_i^T\)</span></li>
</ul></li>
</ul>
</blockquote>
<p>將正交對角化分解後的式子代入馬氏距離公式 <span class="math display">\[
\Delta^2=(\mathbf{x}-\boldsymbol{\mu})^TQ\Lambda^{-1}Q^T(\mathbf{x}-\boldsymbol{\mu})=\mathbf{y}^T\Lambda^{-1}\mathbf{y}=\displaystyle\sum_{i=1}^d\frac{y_i^2}{\lambda_i}
\]</span></p>
<ul>
<li>令 <span class="math inline">\(\mathbf{y}=Q^T(\mathbf{x}-\boldsymbol{\mu})\)</span></li>
<li><span class="math inline">\(\mathbf{x}-\boldsymbol{\mu}=Q\mathbf{y}=\begin{bmatrix} \mathbf{q}_1&amp;\cdots&amp;\mathbf{q}_d \end{bmatrix}\begin{bmatrix} y_1\\ \vdots\\ y_d \end{bmatrix}=y_1\mathbf{q}_1+\cdots+y_d\mathbf{q}_d\)</span>
<ul>
<li><span class="math inline">\(\mathbf{x}-\boldsymbol{\mu}\)</span> 在<strong>參考基底</strong> <span class="math inline">\(\{\mathbf{q}_1,\ldots,\mathbf{q}_d\}\)</span> 上的座標（向量）為 <span class="math inline">\(\mathbf y=\begin{bmatrix} y_1\\ \vdots\\ y_d \end{bmatrix}\)</span></li>
<li>可以解讀為 <span class="math inline">\(\mathbf{y}\)</span> 至 <span class="math inline">\(\mathbf{x}\)</span> 的仿射變換</li>
<li><span class="math inline">\(\mathbf{y}\)</span> 經過旋轉或鏡射 <span class="math inline">\(Q\)</span>，再平移 <span class="math inline">\(\boldsymbol{\mu}\)</span> 得到 <span class="math inline">\(\mathbf{x}\)</span></li>
</ul></li>
</ul>
<h4 id="contour-line等高線">Contour line（等高線）</h4>
<blockquote>
<p>透過<strong>等高線</strong>可<strong>視覺化常態分布的型態</strong></p>
<p>方便說明考慮 <span class="math inline">\(d=2\)</span> 的情形</p>
</blockquote>
<ul>
<li>若 <span class="math inline">\(\Delta=1\)</span>，馬氏距離公式給出
<ul>
<li><span class="math inline">\(\left(\frac{y_1}{\sqrt{\lambda_1}}\right)^2+\left(\frac{y_2}{\sqrt{\lambda_2}}\right)^2=1\)</span></li>
</ul></li>
<li>如果 <span class="math inline">\(\lambda_1\geq\lambda_2&gt;0\)</span>，在新座標系統 <span class="math inline">\((y_1,y_2)\)</span> 中（下圖）
<ul>
<li>等高線的軌跡為一個標準橢圓
<ul>
<li>長軸（即 <span class="math inline">\(y_1\)</span> 軸）半徑等於 <span class="math inline">\(\sqrt{\lambda_1}\)</span></li>
<li>短軸（即 <span class="math inline">\(y_2\)</span> 軸）半徑等於 <span class="math inline">\(\sqrt{\lambda_2}\)</span></li>
</ul></li>
<li>在標準座標系統 <span class="math inline">\((x_1,x_2)\)</span>
<ul>
<li>特徵向量 <span class="math inline">\(\mathbf{q}_1\)</span> 指向長軸方向</li>
<li><span class="math inline">\(\mathbf{q}_2\)</span> 指向短軸方向</li>
</ul></li>
<li>橢圓上的任何一個點 <span class="math inline">\(\mathbf{x}\)</span> 至 <span class="math inline">\(\boldsymbol{\mu}\)</span> 的馬氏距離都等於 <span class="math inline">\(1\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1555580591425.png" alt="1555580591425" /><figcaption aria-hidden="true">1555580591425</figcaption>
</figure>
<blockquote>
<p>在實作上經常<strong>限制共變異數矩陣的型態</strong></p>
<ul>
<li><strong>（a）</strong>一般共變異數矩陣</li>
<li><strong>（b）</strong>共變異數矩陣是對角矩陣
<ul>
<li><span class="math inline">\(\Sigma=\mathrm{diag}(\sigma_1^2,\ldots,\sigma_n^2)\)</span></li>
<li><span class="math inline">\(\sigma_i^2\)</span> 代表隨機變數 <span class="math inline">\(X_i\)</span> 的變異數</li>
</ul></li>
<li><strong>（c）</strong>所有隨機變數 <span class="math inline">\(X_i\)</span> 有相同的共變異數
<ul>
<li><span class="math inline">\(\Sigma=\sigma^2I\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1555580920252.png" alt="1555580920252" /><figcaption aria-hidden="true">1555580920252</figcaption>
</figure>
</blockquote>
<h4 id="moment動差">Moment（動差）</h4>
<blockquote>
<p><strong>考慮單變量常態分佈的動差：</strong></p>
<ul>
<li>令隨機變數 <span class="math inline">\(W = X-\mu\)</span>
<ul>
<li>則 <span class="math inline">\(W～\mathrm{Gaussian}(0,\sigma)\)</span> 的機率密度函數會對稱於 <span class="math inline">\(W = 0\)</span></li>
</ul></li>
<li>期望值公式為 <span class="math inline">\(\mathrm E[X] = \int_{-\infty}^{\infty}xf_X(x)\mathrm dx\)</span>
<ul>
<li><span class="math inline">\(\text{E}[X]=\frac{1}{\sqrt{2\pi}\sigma}\int\exp\left\{-\frac{(x-\mu)^2}{2\sigma^2}\right\}xdx\\ =\frac{1}{\sqrt{2\pi}\sigma}\int\exp\left\{-\frac{w^2}{2\sigma^2}\right\}(w+\mu)dw\\=\frac{1}{\sqrt{2\pi}\sigma}(\int\exp\left\{-\frac{w^2}{2\sigma^2}\right\}wdw+\mu\int\exp\left\{-\frac{w^2}{2\sigma^2}\right\}dw.....（＊）\\ =\mu\frac{1}{\sqrt{2\pi}\sigma}\int\exp\left\{-\frac{w^2}{2\sigma^2}\right\}dw=\mu\)</span>
<ul>
<li>（＊）式中的指數函數 <span class="math inline">\(\exp\)</span> 為 <span class="math inline">\(w\)</span> 的偶函數，乘上 <span class="math inline">\(w\)</span> 後變成奇函數，且積分範圍為 <span class="math inline">\((-\infty, \infty)\)</span>，根據對稱性前式為 0</li>
</ul></li>
</ul></li>
<li>變異數公式為 <span class="math inline">\(\mathrm{Var}(X) = \mathrm E[(X-\mu)^2] = \int_{-\infty}^{\infty}(x-\mu)^2f_X(x)\mathrm dx \\=\int_{-\infty}^{\infty}\frac{(x-\mu)^2}{\sqrt{2\pi}\sigma}\exp\left\{-\frac{(x-\mu)^2}{2\sigma^2}\right\}\mathrm dx\)</span>
<ul>
<li><strong>已知</strong> <span class="math inline">\(\int\exp\left\{-\frac{(x-\mu)^2}{2\sigma^2}\right\}dx=\sqrt{2\pi}\sigma\)</span></li>
<li>對 <span class="math inline">\(\sigma\)</span> 求導數可得 <span class="math inline">\(\int\frac{(x-\mu)^2}{\sigma^3}\exp\left\{-\frac{(x-\mu)^2}{2\sigma^2}\right\}dx=\sqrt{2\pi}\)</span>
<ul>
<li>將上式兩側同乘以 <span class="math inline">\(\frac{\sigma^2}{\sqrt{2\pi}}\)</span></li>
<li>可得 <span class="math inline">\(\int_{-\infty}^{\infty}\frac{(x-\mu)^2}{\sqrt{2\pi}\sigma}\exp\left\{-\frac{(x-\mu)^2}{2\sigma^2}\right\}\mathrm dx = \mathrm E[(X-\mu)^2] = \sigma^2\)</span></li>
</ul></li>
</ul></li>
</ul>
<p><strong>說明單變量常態分布的「參數」</strong> <span class="math inline">\(\mu\)</span> <strong>是平均數，</strong><span class="math inline">\(\sigma^2\)</span> <strong>是變異數</strong></p>
</blockquote>
<p><strong>討論多變量常態分布的動差：</strong></p>
<ul>
<li>令隨機變數 <span class="math inline">\(W = X-\boldsymbol\mu\)</span></li>
<li>期望值公式為 <span class="math inline">\(\mathrm E[X] = \int_{-\infty}^{\infty}\boldsymbol xf_X(\boldsymbol x)\mathrm dx\)</span>
<ul>
<li><span class="math inline">\(\text{E}[\mathbf{X}]=\frac{1}{(2\pi)^{n/2}\vert\Sigma\vert^{1/2}}\int\exp\left\{-\frac{1}{2}(\mathbf{x}-\boldsymbol{\mu})^T\Sigma^{-1}(\mathbf{x}-\boldsymbol{\mu})\right\}\mathbf{x}d\mathbf{x}\\ =\frac{1}{(2\pi)^{n/2}\vert\Sigma\vert^{1/2}}\int\exp\left\{-\frac{1}{2}\mathbf{w}^T\Sigma^{-1}\mathbf{w}\right\}(\mathbf{w}+\boldsymbol{\mu})d\mathbf{w}\\ =\frac{1}{(2\pi)^{n/2}\vert\Sigma\vert^{1/2}}\left(\int\exp\left\{-\frac{1}{2}\mathbf{w}^T\Sigma^{-1}\mathbf{w}\right\}\mathbf{w}d\mathbf{w}+\boldsymbol{\mu}\int\exp\left\{-\frac{1}{2}\mathbf{w}^T\Sigma^{-1}\mathbf{w}\right\}d\mathbf{w}\right)\)</span></li>
<li>指數函數 <span class="math inline">\(\exp\)</span> 是 <span class="math inline">\(\mathbf{w}\)</span> 的偶函數，且積分範圍是 <span class="math inline">\((-\infty,\infty)\)</span>，根據對稱性可知上式第一項等於零，故得
<ul>
<li><span class="math inline">\(\text{E}[\mathbf{x}]=\boldsymbol{\mu}\int\mathcal{N}(\mathbf{w}\vert\mathbf{0},\Sigma)d\mathbf{w}=\boldsymbol{\mu}\)</span></li>
<li>因此稱 <span class="math inline">\(\boldsymbol{\mu}\)</span> 是常態分布的平均數向量</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>考慮二階動差</strong></p>
<ul>
<li>對於單變量二階動差
<ul>
<li>由 <span class="math inline">\(\text{E}[X^2]\)</span> 給定</li>
</ul></li>
<li>對於多變量
<ul>
<li>共有 <span class="math inline">\(n^2\)</span> 個二階動差 <span class="math inline">\(\text{E}[X_iX_j]\)</span>，<span class="math inline">\(i,j=1,\ldots,n\)</span></li>
<li>因為期望值是<strong>線性運算</strong>，所有的二階動差可合併為一個 <span class="math inline">\(n\times n\)</span> 階矩陣 <span class="math inline">\(\text{E}[\mathbf{x}\mathbf{x}^T]\)</span></li>
</ul></li>
</ul>
</blockquote>
<p><span class="math display">\[
\displaystyle \begin{aligned}  \text{E}\left[\mathbf{x}\mathbf{x}^T\right]&amp;=\frac{1}{(2\pi)^{n/2}\vert\Sigma\vert^{1/2}}\int\exp\left\{-\frac{1}{2}(\mathbf{x}-\boldsymbol{\mu})^T\Sigma^{-1}(\mathbf{x}-\boldsymbol{\mu})\right\}\mathbf{x}\mathbf{x}^Td\mathbf{x}\\  &amp;=\frac{1}{(2\pi)^{n/2}\vert\Sigma\vert^{1/2}}\int\exp\left\{-\frac{1}{2}\mathbf{w}^T\Sigma^{-1}\mathbf{w}\right\}(\mathbf{w}+\boldsymbol{\mu})(\mathbf{w}+\boldsymbol{\mu})^Td\mathbf{w}.  \end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\((\mathbf{w}+\boldsymbol{\mu})(\mathbf{w}+\boldsymbol{\mu})^T=\mathbf{w}\mathbf{w}^T+\mathbf{w}\boldsymbol{\mu}^T+\boldsymbol{\mu}\mathbf{w}^T+\boldsymbol{\mu}\boldsymbol{\mu}^T\)</span>
<ul>
<li>根據對稱性，交互項 <span class="math inline">\(\mathbf{w}\boldsymbol{\mu}^T\)</span> 和 <span class="math inline">\(\boldsymbol{\mu}\mathbf{w}^T\)</span> 的積分等於零</li>
<li><span class="math inline">\(\boldsymbol{\mu}\boldsymbol{\mu}^T\)</span> 可提出，剩下的機率密度函數積分等於 <span class="math inline">\(1\)</span></li>
<li><span class="math inline">\(\boldsymbol{\mu}\boldsymbol{\mu}^T\int\frac{1}{(2\pi)^{n/2}\vert\Sigma\vert^{1/2}}\exp\left\{-\frac{1}{2}\mathbf{w}^T\Sigma^{-1}\mathbf{w}\right\}d\mathbf{w}=\boldsymbol{\mu}\boldsymbol{\mu}^T\)</span></li>
<li>考慮包含 <span class="math inline">\(\mathbf{w}\mathbf{w}^T\)</span> 的積分
<ul>
<li><span class="math inline">\(\Sigma=Q\Lambda Q^T=\begin{bmatrix} \mathbf{q}_1&amp;\cdots&amp;\mathbf{q}_d \end{bmatrix}\begin{bmatrix} \lambda_1&amp;&amp;\\ &amp;\ddots&amp;\\ &amp;&amp;\lambda_d \end{bmatrix}\begin{bmatrix} \mathbf{q}_1^T\\ \vdots\\ \mathbf{q}_d^T \end{bmatrix}=\displaystyle\sum_{i=1}^d\lambda_i\mathbf{q}_i\mathbf{q}_i^T\)</span></li>
<li>令 <span class="math inline">\(\mathbf{v}=Q^T\mathbf{w}\)</span>， <span class="math inline">\(\mathbf{w}=Q\mathbf{v}=\sum_{i=1}^nv_i\mathbf{q}_i\)</span>
<ul>
<li>則 <span class="math inline">\(\mathbf{w}\mathbf{w}^T=Q\mathbf{v}\mathbf{v}^TQ^T=\sum_{i=1}^n\sum_{j=1}^nv_iv_j\mathbf{q}_i\mathbf{q}_j^T\)</span></li>
<li><span class="math inline">\(\mathbf{w}^T\Sigma^{-1}\mathbf{w}=\mathbf{v}^TQ^T\Sigma^{-1} Q\mathbf{v}=\mathbf{v}^T\Lambda^{-1}\mathbf{v}=\sum_{k=1}^nv_k^2/\lambda_k\)</span></li>
</ul></li>
<li><span class="math inline">\(\frac{1}{(2\pi)^{n/2}\vert\Sigma\vert^{1/2}}\int\exp\left\{-\frac{1}{2}\mathbf{w}^T\Sigma^{-1}\mathbf{w}\right\}\mathbf{w}\mathbf{w}^Td\mathbf{w}\\ =\sum_{i=1}^n\sum_{j=1}^n\mathbf{q}_i\mathbf{q}_j^T\frac{1}{(2\pi)^{n/2}(\lambda_1\cdots\lambda_n)^{1/2}}\int\exp\left\{-\sum_{k=1}^n\frac{v_k^2}{2\lambda_k}\right\}v_iv_jd\mathbf{v}\\ =\sum_{i=1}^n\mathbf{q}_i\mathbf{q}_i^T\left(\prod_{k=1\atop k\neq i}^n\frac{1}{(2\pi\lambda_k)^{1/2}}\int\exp\left\{-\frac{v_k^2}{2\lambda_k}\right\}dv_k\cdot\frac{1}{(2\pi\lambda_i)^{1/2}}\int\exp\left\{-\frac{v_i^2}{2\lambda_i}\right\}v_i^2dv_i\right)\\ =\sum_{i=1}^n\mathbf{q}_i\mathbf{q}_i^T\lambda_i=\Sigma\)</span>
<ul>
<li>當 <span class="math inline">\(i\neq j\)</span>，根據對稱性可知積分為零，並使用單變量變異數 <span class="math inline">\(\hbox{E}\left[v_i^2\right]=\lambda_i\)</span></li>
</ul></li>
<li><span class="math inline">\(\hbox{E}\left[\mathbf{x}\mathbf{x}^T\right]=\boldsymbol{\mu}\boldsymbol{\mu}^T+\Sigma\)</span></li>
</ul></li>
<li><span class="math inline">\(\hbox{cov}[\mathbf{x}]= \hbox{E}\left[\mathbf{x}\mathbf{x}^T-\mathbf{x}\boldsymbol{\mu}^T-\boldsymbol{\mu}\mathbf{x}^T+\boldsymbol{\mu}\boldsymbol{\mu}^T\right]\\ =\hbox{E}\left[\mathbf{x}\mathbf{x}^T\right]-\text{E}[\mathbf{x}]\boldsymbol{\mu}^T-\boldsymbol{\mu}\text{E}\left[\mathbf{x}\right]^T+\boldsymbol{\mu}\boldsymbol{\mu}^T\\ =\hbox{E}\left[\mathbf{x}\mathbf{x}^T\right]-\boldsymbol{\mu}\boldsymbol{\mu}^T=\Sigma\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>Probability</tag>
        <tag>Information theories</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep learning - Probability and Information theories VI</title>
    <url>/willywangkaa/2019/04/24/Deep-learning-Probability-and-Information-theories-VI/</url>
    <content><![CDATA[<h1 id="deep-learning---probability-and-information-theories-vi">Deep learning - Probability and Information theories VI</h1>
<h2 id="applicationdecision-tree決策樹-and-random-forest隨機森林">Application：Decision tree（決策樹） and random forest（隨機森林）</h2>
<ul>
<li>廣泛使用的一種<strong>歸納推理演算法</strong></li>
<li><strong>對於干擾直相當敏感</strong></li>
</ul>
<h3 id="impurity-measure亂度的測量">Impurity measure（亂度的測量）</h3>
<p><span class="math display">\[
\arg \underset{j,v}{\max}\left(\mathrm{Impurity(\mathbb X^{parent})-Impurity(\mathbb X^{left},\mathbb X^{right})}\right)
\]</span></p>
<blockquote>
<p><strong>亂度為熵的非正式定義</strong></p>
<ul>
<li>給定一組<strong>標記過</strong>的樣本資料組
<ul>
<li><span class="math inline">\(\mathbb X = \{(\boldsymbol x^{(i)}, y^{(i)})\}_{i = 1}^N\)</span></li>
<li><span class="math inline">\(\boldsymbol x\)</span> 為一個向量， <span class="math inline">\(j–th\)</span> 維度該樣本的一個<strong>特徵（Attribute）</strong>
<ul>
<li>向量元素 <span class="math inline">\(x_j\)</span> 代表著一個該資料對應該特徵的一個<strong>狀態（State of j-th attribute）</strong></li>
</ul></li>
<li><span class="math inline">\(y\)</span> 為 <span class="math inline">\(\boldsymbol x\)</span> 經過一個隨機變數 <span class="math inline">\(X\)</span> 所對應的一個<strong>標記狀態</strong>
<ul>
<li>由於隨機變數 <span class="math inline">\(X\)</span> 是人決定的，所以可以將這個對應稱為一種<strong>標記</strong></li>
</ul></li>
</ul></li>
<li>欲經一樹狀函數 <span class="math inline">\(f\)</span>（<em>規則</em>），將樣本的<strong>特徵狀態</strong> <span class="math inline">\(\boldsymbol x^{(i)}\)</span> 可以映射到<strong>人為標記狀態</strong> <span class="math inline">\(y^{(i)}\)</span> （Label）
<ul>
<li><span class="math inline">\(f(\boldsymbol x^{(i)}) = y^{(i)}\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1556032997160.png" alt="1556032997160" /><figcaption aria-hidden="true">1556032997160</figcaption>
</figure>
<ul>
<li><span class="math inline">\(\mathbb X^{\mathrm{parent}}\)</span> 為決策樹裡其中一個<strong>父節點</strong>
<ul>
<li>代表一組<strong>子樣本資料</strong>
<ul>
<li><span class="math inline">\(\mathbb X^{\mathrm{parent}} \subseteq \mathbb X\)</span></li>
</ul></li>
</ul></li>
<li><span class="math inline">\(\mathbb X^{\mathrm{left}}、\mathbb X^{\mathrm{right}}\)</span> 為對應於上述<strong>父節點</strong>的左右子節點
<ul>
<li>代表一組<strong>子樣本資料</strong>
<ul>
<li><span class="math inline">\(\mathbb X^{\mathrm{left}} \subseteq \mathbb X \\\mathbb X^{\mathrm{right}} \subseteq \mathbb X\)</span></li>
<li><span class="math inline">\(\mathbb X^{\mathrm{left}}+\mathbb X^{\mathrm{right}}=\mathbb X^{\mathrm{parent}}\)</span></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li><p><span class="math inline">\(\mathrm{Impurity}(\mathbb X^{\mathrm{parent}}) = \mathrm H[Y～\mathrm{Empirical(\mathbb X^{\mathrm{parent}})}]\)</span></p>
<ul>
<li>「父節點的亂度」為 <span class="math inline">\(Y～\mathrm{Empirical(\mathbb X^{\mathrm{parent}})}\)</span> 的<strong>熵</strong></li>
<li><span class="math inline">\(P_Y(y)=\mathbb X^{\mathrm{parent}} 中的被標記比例為\;y \;的比例\)</span></li>
</ul></li>
<li><p><span class="math inline">\(\mathrm{Impurity(\mathbb X^{left},\mathbb X^{right})} = \sum_{i = \mathrm{left,right}}\frac{\vert\mathbb X^{(i)}\vert}{\vert\mathbb X^{\mathrm{parent}}\vert}\mathrm H[Y～\mathrm{Empirical(\mathbb X^{(i)})}]\)</span></p>
<ul>
<li><span class="math inline">\(\vert\mathbb X^{(i)}\vert\)</span> 為該樣本資料組的數量</li>
<li>「子節點的亂度」為左右子點對 <span class="math inline">\(Y～\mathrm{Empirical(\mathbb X^{(i)})}\)</span> 的熵，並依比對父點的資料量比例加總
<ul>
<li><strong>「子節點的亂度」≦「父節點的亂度」</strong></li>
<li>目標是找到一種父節點的資料分類方法，將「子節點的亂度」最小化</li>
</ul></li>
</ul></li>
<li><p><span class="math inline">\(\mathrm{Impurity(\mathbb X^{parent})-Impurity(\mathbb X^{left},\mathbb X^{right})}\)</span> 稱作<strong>「資訊獲利」（Information gain）</strong></p>
<ul>
<li>越大代表「子節點的亂度」越小</li>
<li>資料分類方法的一種效能評鑑</li>
</ul></li>
<li><p><span class="math inline">\((j,v)\)</span> ：斷點</p>
<ul>
<li><p>在 <span class="math inline">\(\boldsymbol x\)</span> 還沒判斷的<strong>特徵空間</strong>中找到 <span class="math inline">\(j–th\)</span> 維度，選擇一個定值 <span class="math inline">\(v\)</span></p></li>
<li><p>節點中的資料必須符合 <span class="math inline">\(\mathrm{Rule}\)</span> 的規則</p></li>
<li><p>將父節點 <span class="math inline">\(\mathbb X^{\mathrm{parent}}=\{(\boldsymbol x^{(i)}, y^{(i)})：\mathrm{Rule}\}\)</span> 分支為兩個節點</p>
<ul>
<li><span class="math inline">\(\mathbb X^{\mathrm{left}} = \{(\boldsymbol x^{(i)}, y^{(i)})：\mathrm{Rule}\cup\{x_j^{(i)}&lt;v\}\}\)</span></li>
<li><span class="math inline">\(\mathbb X^{\mathrm{right}} = \{(\boldsymbol x^{(i)}, y^{(i)})：\mathrm{Rule}\cup\{x_j^{(i)}\geq v\}\}\)</span></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1556075449719.png" alt="1556075449719" /><figcaption aria-hidden="true">1556075449719</figcaption>
</figure>
<h3 id="decision-tree">Decision tree</h3>
<p><strong>Training a decision tree</strong></p>
<ol type="1">
<li>建構一根節點 <span class="math inline">\(\{(\boldsymbol x^{(i)}, y^{(i)})：\mathrm{Rule = \varnothing }\}\)</span>
<ul>
<li>節點中的資料必須符合 <span class="math inline">\(\mathrm{Rule}\)</span> 的規則</li>
<li>最開始不設定規則 $$，所以此點資料等於 <span class="math inline">\(\mathbb X\)</span></li>
</ul></li>
<li>往下分支兩個子節點 <span class="math inline">\(\mathbb X^{\mathrm{left}}、\mathbb X^{\mathrm{right}}\)</span>
<ul>
<li>以 <span class="math inline">\(\arg \underset{j,v}{\max}\left(\mathrm{Impurity(\mathbb X^{parent})-Impurity(\mathbb X^{left},\mathbb X^{right})}\right)\)</span> 為依據，找到符合的 <span class="math inline">\(\mathrm{Rule}\)</span></li>
<li>對其子節點遞迴此步驟，直到該節點的亂度等於 <span class="math inline">\(0\)</span>（Pure），也就是其節點的<strong>人為標記狀態</strong>全部相等</li>
</ul></li>
</ol>
<h3 id="random-forests">Random forests</h3>
<blockquote>
<p>隨機森林為多個決策樹所構成</p>
<ul>
<li>決策樹模型可能會被訓練得非常高
<ul>
<li>越高的節點其 <span class="math inline">\(\mathrm{Rule}\)</span> 會越嚴格</li>
<li>在<strong>訓練資料樣本</strong>可以判斷很好，但是在<strong>測試資料樣本</strong>最壞可能完全無法利用</li>
<li>解決此問題讓決策樹可以更廣泛應用（Generalizability）
<ul>
<li>剪枝（Pruning）：限制決策樹的高度，但可能葉節點中的<strong>標記狀態</strong>不會全部相等</li>
<li><strong>隨機森林</strong>：多棵剪枝過的決策樹之<strong>集成</strong></li>
</ul></li>
</ul></li>
<li>機器學習中的「集成」（Ensemble）
<ul>
<li>一般機器學習演算法只使用單一模型來學習，可能在該樣本之外會無法利用</li>
<li>結合多個<strong>弱機器學習</strong>以建構一個<strong>強穩的模型</strong>，避免<strong>過適現象（Overfit）</strong>的發生</li>
</ul></li>
</ul>
</blockquote>
<p><strong>Training a random forest</strong></p>
<ol type="1">
<li>取得一個<strong>自助樣本（Bootstrap sample）</strong>
<ul>
<li><strong>自助樣本</strong>：在原始的訓練資料集中<strong>隨機挑選</strong> <span class="math inline">\(M\)</span> 個樣本（挑選過可以重新再挑選）</li>
</ul></li>
<li>使用自助養本，訓練過程中
<ol type="1">
<li><strong>隨機挑選</strong> <span class="math inline">\(K\)</span> <strong>個特徵</strong></li>
<li>在該範圍找到最好的斷點 <span class="math inline">\((j,v)\)</span> 來分支</li>
</ol></li>
<li>重複第一第二步得到 <span class="math inline">\(T\)</span> 個決策樹</li>
</ol>
<ul>
<li>由 <span class="math inline">\(T\)</span> 個決策樹以<strong>多數決（Majority vote）</strong>來判斷<strong>測試資料樣本</strong>
<ul>
<li>每個決策樹對樣本有不同的見解，取其多數以判斷</li>
</ul></li>
<li>隨機森林的訓練與決策樹的訓練有些許的不同
<ul>
<li>第一步與第二之一步</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1556079393095.png" alt="1556079393095" /><figcaption aria-hidden="true">1556079393095</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1556079400721.png" alt="1556079400721" /><figcaption aria-hidden="true">1556079400721</figcaption>
</figure>
]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>Probability</tag>
        <tag>Information theories</tag>
      </tags>
  </entry>
  <entry>
    <title>Discrete mathematics - Chinese Remainder Theorem</title>
    <url>/willywangkaa/2018/05/08/Discrete-mathematics-Chinese-Remainder-Theorem/</url>
    <content><![CDATA[<h1 id="modular-反元素-模反元素數論倒數">Modular 反元素 (模反元素、數論倒數)</h1>
<hr />
<p>整數 <span class="math inline">\(a\)</span> 對同於 <span class="math inline">\(n\)</span> 之<strong>模反元素</strong>滿足以下：</p>
<p><span class="math display">\[a^{-1} \equiv b \quad (mod \; n)\]</span></p>
<p>等價於</p>
<p><span class="math display">\[a \cdot b \equiv 1 \quad (mod \; n)\]</span></p>
<p><strong>＜Note＞：</strong>整數 <span class="math inline">\(a\)</span> 對模數 <span class="math inline">\(n\)</span> 之模反元素存在的<strong>充分必要條件(iff)</strong>是"<span class="math inline">\(a\)</span>"與"<span class="math inline">\(n\)</span>"<strong>互質</strong>。</p>
<h2 id="求-modular-反元素">求 Modular 反元素</h2>
<ul>
<li>輾轉相除法( 歐基里德演算法 )
<ul>
<li>原理：<span class="math inline">\(a, b\)</span>兩整數最大公因數等於<strong>各自</strong><span class="math inline">\(( a , b )\)</span>與<strong>兩數相差( a - b )</strong>的最大公因數。</li>
<li><span class="math inline">\(Ex\)</span>： 252 與 105 的最大公因數為 21 <br><span class="math inline">\(252 = 21 \cdot 12 \quad 105 = 21 \cdot 5\)</span><br><span class="math inline">\((21 \cdot 12) - (21\cdot 5) = 21 \cdot (12 - 5) = 21 \cdot 7 = 147\)</span></li>
<li><span class="math inline">\(gcd(252, 105) = gcd(252, 147) = gcd(147, 105)\)</span></li>
</ul></li>
</ul>
<p>使用<strong>原理</strong>的過程之中，較大的數的最大公因數可以由較小的數所代表，所以繼續進行同樣的計算可以不斷縮小<span class="math inline">\(a, b\)</span>兩數，直到最後有一數變為 <span class="math inline">\(0\)</span> 。這時所剩下的<strong>非零數</strong>就是兩數的最大公因數。</p>
<p>由歐幾里得演算法的過程之中，可以推出兩數的最大公因數能用<strong>兩數的整數倍</strong>( <span class="math inline">\(\forall k \in \mathbb{Z}\)</span> )相加來表示，承上例：<br><span class="math inline">\(21 = 5 \cdot 105 + (-2) \cdot 252\)</span></p>
<h3 id="bézouts-lemma---貝組定理-丟番圖方程">Bézout's lemma - 貝組定理 (<a href="https://zh.wikipedia.org/wiki/%E4%B8%9F%E7%95%AA%E5%9C%96%E6%96%B9%E7%A8%8B">丟番圖方程</a>)</h3>
<p><span class="math inline">\(\forall a, b, m \in \mathbb{Z}\)</span> ，求未知數 <span class="math inline">\(x, y\)</span> 的<a href="https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E6%96%B9%E7%A8%8B">線性</a><a href="https://zh.wikipedia.org/wiki/%E4%B8%9F%E7%95%AA%E5%9C%96%E6%96%B9%E7%A8%8B">丟番圖方程式</a>（稱為<strong>貝祖等式</strong>）：</p>
<p><span class="math display">\[a \cdot x + b \cdot y = m\]</span></p>
<p>當 $x, y $有<strong>整數解</strong>時若且唯若( <span class="math inline">\(\Leftrightarrow\)</span> ) <span class="math inline">\(gcd(a, b)\; | \; m\)</span> 。此等式有解時必然有無窮多個解，每組解 <span class="math inline">\(x, y\)</span> 都稱為<strong>貝組數</strong>可用<a href="https://zh.wikipedia.org/wiki/%E6%93%B4%E5%B1%95%E6%AD%90%E5%B9%BE%E9%87%8C%E5%BE%97%E6%BC%94%E7%AE%97%E6%B3%95">擴展歐幾里得演算法</a>求得，也就是說若 <span class="math inline">\(a\)</span> 為負數<span class="math inline">\(a \cdot (-x) + b \cdot y = m\)</span> 有整數解時<span class="math inline">\(gcd(|a|, b) \;| \; m\)</span>。</p>
<ul>
<li>$Ex. $ 求 <span class="math inline">\(47 \cdot x + 30 \cdot y = 1\)</span>，求 <span class="math inline">\(x, y\)</span>？
<ul>
<li>$47 = 1  + 17 $ <br> <span class="math inline">\(\Rightarrow 30 = 1\cdot 17 + 13\)</span> <br> <span class="math inline">\(\Rightarrow 17 = 1 \cdot 13 + 4\)</span><br><span class="math inline">\(\Rightarrow 13 = 3\cdot 4 +1\)</span> <br> 我們得知 <span class="math inline">\(gcd(47, 30) = 1\)</span>且<span class="math inline">\(1 \; | \; 1\)</span>，所以接著改寫成「餘數等於」的形式<br><span class="math inline">\(17 = 1\cdot 47 - 1 \cdot 30\)</span> <br> <span class="math inline">\(13 = 1\cdot 30 - 1 \cdot 17\)</span> <br> <span class="math inline">\(4 = 1\cdot 17 - 1 \cdot 13\)</span><br><span class="math inline">\(1 = 1\cdot 13 - 3 \cdot 4\)</span><br>最後再反著倒寫回去<br><span class="math inline">\(1 = 1\cdot 13 - 3 \cdot 4\)</span><br><span class="math inline">\(\Rightarrow 1 = 1\cdot 13 - 3 \cdot (1\cdot 17 - 1\cdot 13)\)</span><br><span class="math inline">\(\Rightarrow 1 = (-3)\cdot 17 - 4 \cdot 13\)</span><br><span class="math inline">\(\Rightarrow 1 = (-3)\cdot 17 - 4 \cdot (1\cdot 30 - 1 \cdot 17)\)</span> <br> $ = 4 + (-7) $ <br> <span class="math inline">\(\Rightarrow 1 = 4\cdot 30 + (-7)\cdot ( 1 \cdot 47 - 1 \cdot 30 )\)</span> <br> <span class="math inline">\(\Rightarrow 1 = 47 \cdot (-7) + 30\cdot 11\)</span> <br>其中， <span class="math inline">\(x = -7\)</span> 與 <span class="math inline">\(y = 11\)</span> 為其中一組<strong>貝組數</strong>，其無限解為 <span class="math inline">\(x = -7 + 30\cdot k, y = 11 - 47 \cdot k, \forall k \in \mathbb{Z}\)</span></li>
</ul></li>
<li>Modular 反元素
<ul>
<li>若貝組等式 <span class="math inline">\(a \cdot x + b \cdot y = 1\)</span> (若 <span class="math inline">\(\neq 1\)</span> 則模反元素不存在)<br>則：<span class="math inline">\(a \cdot x = 1 - b\cdot y \Leftrightarrow a\cdot x \equiv 1 \quad (mod \; b)\)</span><br>所以<span class="math inline">\(a \cdot a^{-1} \equiv 1 \quad (mod \; b)\)</span> ，此時<span class="math inline">\(x\)</span>為<span class="math inline">\(a\)</span>的一個模反元素，其無限表示式為<span class="math inline">\(a^{-1} = x + k\cdot b, \forall k \in \mathbb{Z}\)</span>。</li>
</ul></li>
</ul>
<h1 id="modular---同餘的性質">Modular - 同餘的性質</h1>
<hr />
<ul>
<li>整除性
<ul>
<li><span class="math inline">\(a\equiv b \quad (\mod m) \Rightarrow c \cdot m = a - b , c \in \mathbb{Z}\)</span><br><span class="math inline">\(\Rightarrow a \equiv b\quad ( \mod m ) \Rightarrow m \; | \; a-b\)</span></li>
</ul></li>
<li>遞移性
<ul>
<li>若 <span class="math inline">\(a \equiv b \quad (\mod c) , b \equiv d \quad (\mod c)\)</span><br>則 <span class="math inline">\(a \equiv d (\mod c)\)</span></li>
</ul></li>
<li>保持基本運算
<ul>
<li><span class="math inline">\(\left \{ \begin{matrix} a \equiv b (\mod m)\\ c \equiv d (\mod m)\end{matrix}\right. \Rightarrow \left\{\begin{matrix}a \pm c \equiv b \pm d (\mod m)\\ a \cdot c \equiv b \cdot d (\mod m)\end{matrix}\right.\)</span></li>
</ul></li>
<li>放大縮小模數
<ul>
<li>令<span class="math inline">\(k \in \mathbb{Z}^+ , a \equiv b \quad (\mod m) \Leftrightarrow k \cdot a \equiv k \cdot b \quad (\mod k \cdot m)\)</span></li>
</ul></li>
<li>費馬小定理
<ul>
<li>假設 <span class="math inline">\(a \in \mathbb{Z}\)</span> 且 <span class="math inline">\(p\)</span> 是質數 <span class="math inline">\(\ni gcd (a, p) = 1\)</span>，則：<br><span class="math inline">\(a^p \equiv a \quad (\mod p)\)</span><br><span class="math inline">\(\Leftrightarrow a^{p-1} \equiv 1 \quad (\mod p)\)</span></li>
</ul></li>
<li>由拉 <span class="math inline">\(\phi\)</span> - 函數
<ul>
<li>假設 <span class="math inline">\(n \in \mathbb{Z}^+\)</span>，定義<span class="math inline">\(\phi (n)\)</span> 為 <span class="math inline">\(\\{ 1, 2, \ldots, n-1 \\}\)</span> 中與<span class="math inline">\(n\)</span>互質(coprime)的元素個數。</li>
<li>假設 <span class="math inline">\(m \in \mathbb{Z}, n \in \mathbb{Z}^+\)</span>且 <span class="math inline">\(gcd(m, n) = 1\)</span>，則：<br><span class="math inline">\(m^{\phi (n)} \equiv 1 \quad (\mod n)\)</span></li>
</ul></li>
</ul>
<h1 id="chinese-remainder-theorem---中國剩餘定理">Chinese Remainder Theorem - 中國剩餘定理</h1>
<hr />
<p>用例子來推演整個過程：</p>
<ul>
<li><span class="math inline">\(Ex.\)</span> 求</li>
</ul>
<p><span class="math display">\[
\left\{\begin{matrix} x &amp; \equiv &amp; 2 &amp; (  \mod 3 &amp; )\\ x &amp; \equiv &amp; 3 &amp; (  \mod 5 &amp; )\\ x &amp; \equiv &amp; 2 &amp; ( \mod 7 &amp; )\end{matrix}\right.
\]</span></p>
<ul>
<li>首先拆開來解方便計算：
<ul>
<li><span class="math inline">\(\left\{\begin{matrix} a_1 &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ a_1 &amp; \equiv &amp; 0 &amp; ( \mod 5 &amp; )\\ a_1 &amp; \equiv &amp; 0 &amp; ( \mod 7 &amp; )\end{matrix}\right. \Rightarrow a_1 = 35 \cdot n_1\)</span></li>
<li><span class="math inline">\(\left\{\begin{matrix} a_2 &amp; \equiv &amp; 0 &amp; ( \mod 3 &amp; )\\ a_2 &amp; \equiv &amp; 3 &amp; ( \mod 5 &amp; )\\ a_2 &amp; \equiv &amp; 0 &amp; ( \mod 7 &amp; )\end{matrix}\right. \Rightarrow a_2 = 21 \cdot n_2\)</span></li>
<li><span class="math inline">\(\left\{\begin{matrix} a_3 &amp; \equiv &amp; 0 &amp; ( \mod 3 &amp; )\\ a_3 &amp; \equiv &amp; 0 &amp; ( \mod 5 &amp; )\\ a_3 &amp; \equiv &amp; 2 &amp; ( \mod 7 &amp; )\end{matrix}\right. \Rightarrow a_3 = 15 \cdot n_3\)</span></li>
</ul></li>
<li>接著使用<strong>同餘的保持基本運算</strong>，令<span class="math inline">\(x = a_1 + a_2 + a_3\)</span>：<br><span class="math inline">\(x = a_1 + a_2 + a_3 \equiv 2 \quad (\mod 3)\)</span><br><span class="math inline">\(x = a_1 + a_2 + a_3 \equiv 3 \quad (\mod 5)\)</span><br><span class="math inline">\(x = a_1 + a_2 + a_3 \equiv 2 \quad (\mod 7)\)</span></li>
<li>計算 <span class="math inline">\(a_1\)</span>：<br><span class="math display">\[\left\{\begin{matrix} a_1 &amp; \equiv &amp; 2 &amp; (  \mod 3 &amp; )\\ a_1 &amp; \equiv &amp; 0 &amp; (  \mod 5 &amp; )\\ a_1 &amp; \equiv &amp; 0 &amp; ( \mod 7 &amp; )\end{matrix}\right.\]</span> ，<span class="math inline">\(a_1 = 35\cdot n_1 \equiv 2 \quad(\mod 3)\)</span>不好運算，轉成<span class="math inline">\(b_1 = 35\cdot m_1 \equiv 1 \quad(\mod 3)\)</span><br><span class="math inline">\(\Rightarrow 35 = 11 \cdot 3 + 2\)</span><br><span class="math inline">\(\Rightarrow 3 = 2 \cdot 1 + 1\)</span><br><span class="math inline">\(1 = 1 \cdot 3 - 1 \cdot 2\)</span><br><span class="math inline">\(\Leftrightarrow 1 = 1 \cdot 3 - 1 \cdot ( 1 \cdot 35 - 11 \cdot 3 )\)</span><br><span class="math inline">\(\Leftrightarrow 1 = (-1) \cdot 35 + 12 \cdot 3\)</span><br>令<span class="math inline">\(m_1 = -1 + 3 \cdot k\)</span> (模反元素)<br>所以，<span class="math inline">\(b_1 = 35\cdot m_1 \equiv 1 \quad(\mod 3) \Leftrightarrow 2 \cdot b_1 \equiv 2 \cdot 35 \cdot m_1 \equiv 2 \cdot 1 \quad (\mod 3)\)</span><br>則可以令<span class="math inline">\(a_1 = b_1\cdot 2\)</span>，取<span class="math inline">\(k = 1, b_1 = 35 \cdot 2 = 70 \Rightarrow a_1 = 140\)</span></li>
<li>計算<span class="math inline">\(a_2\)</span>：<br><span class="math display">\[\left\{\begin{matrix} a_2 &amp; \equiv &amp; 0 &amp; (  \mod 3 &amp; )\\ a_2 &amp; \equiv &amp; 3 &amp; (  \mod 5 &amp; )\\ a_2 &amp; \equiv &amp; 0 &amp; ( \mod 7 &amp; )\end{matrix}\right.\]</span> ，<span class="math inline">\(a_2 = 21\cdot n_2 \equiv 3 \quad(\mod 5)\)</span>不好運算，轉成<span class="math inline">\(b_2 = 21\cdot m_2 \equiv 1 \quad(\mod 5)\)</span><br><span class="math inline">\(\Rightarrow 21 = 4 \cdot 5 + 1\)</span><br><span class="math inline">\(1 = 21 \cdot 1 - 4 \cdot 5\)</span><br>令<span class="math inline">\(m_2 = 1 + 5 \cdot k\)</span> (模反元素)<br>所以，<span class="math inline">\(b_2 = 21 \cdot m_2 \equiv 1 \quad (\mod 5) \Leftrightarrow 3 \cdot b_2 = 3\cdot 21 \cdot m_2 \equiv 3 \cdot 1 \quad (\mod 5)\)</span><br>所以令<span class="math inline">\(a_2 = b_2 \cdot 3\)</span>，取<span class="math inline">\(k = 0, b_2 = 21 \cdot 1 = 21 \Rightarrow a_2 = 63\)</span></li>
<li>計算<span class="math inline">\(a_3\)</span>：<br><span class="math display">\[\left\{\begin{matrix} a_3 &amp; \equiv &amp; 0 &amp; (  \mod 3 &amp; )\\ a_3 &amp; \equiv &amp; 0 &amp; (  \mod 5 &amp; )\\ a_3 &amp; \equiv &amp; 2 &amp; ( \mod 7 &amp; )\end{matrix}\right.\]</span> ，<span class="math inline">\(a_3 = 15\cdot n_3 \equiv 2 \quad(\mod 7)\)</span>不好運算，轉成<span class="math inline">\(b_3 = 15\cdot m_3 \equiv 1 \quad(\mod 7)\)</span><br><span class="math inline">\(\Rightarrow 15 = 2 \cdot 7 + 1\)</span><br><span class="math inline">\(1 = 15 \cdot 1 - 2 \cdot 7\)</span><br>令<span class="math inline">\(m_3 = 1 + 7 \cdot k\)</span> (模反元素)<br>所以，<span class="math inline">\(b_3 = 15 \cdot m_3 \equiv 1 \quad (\mod 7) \Leftrightarrow 2 \cdot b_3 = 2\cdot 15 \cdot m_3 \equiv 2 \cdot 1 \quad (\mod 7)\)</span><br>所以令<span class="math inline">\(a_3 = b_3 \cdot 2\)</span>，取<span class="math inline">\(k = 0, b_3 = 15 \cdot 1 = 15 \Rightarrow a_3 = 30\)</span></li>
<li>最後計算 <span class="math inline">\(x = a_1 + a_2 + a_3 = 233\)</span>，驗算<br><span class="math inline">\(\left\{\begin{matrix} 233 &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ 233 &amp; \equiv &amp; 3 &amp; ( \mod 5 &amp; )\\ 233 &amp; \equiv &amp; 2 &amp; ( \mod 7 &amp; )\end{matrix}\right.\)</span> ，OK。</li>
</ul>
<h2 id="常見題目類型">常見題目類型</h2>
<h3 id="type-1-模數都互質">Type 1 (模數都互質)</h3>
<ul>
<li><span class="math inline">\(Ex.\)</span>(99 政大)
<ul>
<li><span class="math inline">\(\left\{\begin{matrix} x &amp; \equiv &amp; 5 &amp; ( \mod 7 &amp; )\\ x &amp; \equiv &amp; 4 &amp; ( \mod 9 &amp; )\\ x &amp; \equiv &amp; 3 &amp; ( \mod 13 &amp; )\end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<h3 id="type-2-模數不全是互質">Type 2 (模數不全是互質)</h3>
<ul>
<li><span class="math inline">\(Ex.\)</span>(97 台科大)
<ul>
<li><span class="math inline">\(\left\{\begin{matrix} x &amp; \equiv &amp; 1 &amp; ( \mod 2 &amp; )\\ x &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ x &amp; \equiv &amp; 8 &amp; ( \mod 15 &amp; )\end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<h3 id="type-3-模數重疊">Type 3 (模數重疊)</h3>
<ul>
<li><span class="math inline">\(Ex.\)</span>(97 高師大)
<ul>
<li><span class="math inline">\(\left\{\begin{matrix} x &amp; \equiv &amp; 1 &amp; ( \mod 3 &amp; )\\ x &amp; \equiv &amp; 13 &amp; ( \mod 16 &amp; )\\ x &amp; \equiv &amp; 73 &amp; ( \mod 81 &amp; )\end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<h3 id="type-4-矛盾---無解">Type 4 (矛盾 - 無解)</h3>
<ul>
<li><span class="math inline">\(Ex.\)</span>(97 台科大 - 改)
<ul>
<li><span class="math inline">\(\left\{\begin{matrix} x &amp; \equiv &amp; 1 &amp; ( \mod 2 &amp; )\\ x &amp; \equiv &amp; 2 &amp; ( \mod 3 &amp; )\\ x &amp; \equiv &amp; 10 &amp; ( \mod 15 &amp; )\end{matrix}\right.\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Discrete Mathematics</category>
      </categories>
      <tags>
        <tag>Chinese Remainder Theorem</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear algebra - LU分解</title>
    <url>/willywangkaa/2018/05/07/Linear-algebra-LU%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="linear-algebra---lu分解">Linear Algebra - LU分解</h1>
<hr />
<p>LU 分解的外表看似平淡無奇，但它可以用來解線性方程，逆矩陣和計算行列式，堪稱是最具實用價值的矩陣分解式之一。</p>
<p>令 <span class="math inline">\(A\)</span> 為一個 <span class="math inline">\(n\cdot n\)</span> 階矩陣。LU 分解是指將 <span class="math inline">\(A\)</span> 表示為兩個 <span class="math inline">\(n \cdot n\)</span> 階三角矩陣的乘積</p>
<p><span class="math display">\[
A = L\cdot U
\]</span> 其中 <span class="math inline">\(L\)</span> 是下三角矩陣，<span class="math inline">\(U\)</span> 是上三角矩陣，如下例，</p>
<p><span class="math display">\[
\begin{bmatrix}3 &amp; 1 &amp; 2 \\ 6 &amp; -1 &amp; 5 \\ -9 &amp; 7 &amp; 3\end{bmatrix} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 2 &amp; 1 &amp; 0 \\ -3 &amp; 4 &amp; 1 \end{bmatrix} \begin{bmatrix}3 &amp; -1 &amp; 2\\ 0 &amp; 1 &amp; 1\\ 0 &amp; 0 &amp; 5 \end{bmatrix}
\]</span></p>
<p>高斯消去法可以通過一連串的矩陣乘法來實現。每一個基本列運算等同於左乘一個基本矩陣，而對應列取代的基本矩陣 <span class="math inline">\(E_{ij}\)</span> 的 <span class="math inline">\((i, j)\)</span> 元即為 <span class="math inline">\(-l_{ij}\)</span>。</p>
<p>消去程序可用下列矩陣乘法表示：</p>
<p><span class="math display">\[
E{32}E{31}E_{21}A=U
\]</span></p>
<p>因為基本矩陣 <span class="math inline">\(E_{ij}\)</span> 都是可逆的</p>
<p><span class="math display">\[
A=E_{21}^{-1}E_{31}^{-1}E_{32}^{-1}U=LU
\]</span></p>
<h1 id="存在性">存在性</h1>
<hr />
<p>然而，並非任何可逆矩陣都具有 LU 分解形式，例如：<span class="math inline">\(A=\begin{bmatrix} 0&amp;2\\ 1&amp;3 \end{bmatrix}\)</span>。假若 <span class="math inline">\(A\)</span> 可以寫為</p>
<p><span class="math display">\[
A=LU=\begin{bmatrix}  1&amp;0\\  l_{21}&amp;1  \end{bmatrix}\begin{bmatrix}  u_{11}&amp;u_{12}\\  0&amp;u_{22}  \end{bmatrix}
\]</span></p>
<p>則必有 <span class="math inline">\(u_{11}=0\)</span>， <span class="math inline">\(U\)</span> 是不可逆的，這與 為 <span class="math inline">\(LU=A\)</span> 可逆矩陣的事實相互矛盾。矩陣 之所 <span class="math inline">\(A\)</span> 以不存在 分解的<span class="math inline">\(LU\)</span> 原因在於 <span class="math inline">\(0\)</span> 占據了 <span class="math inline">\((1,1)\)</span> 元，但軸元必須不為零才能產生乘數。根據這項觀察，即知可逆矩陣 <span class="math inline">\(A\)</span> 的 LU 分解存在條件是：列運算過程中，<span class="math inline">\(0\)</span> 不得在軸元位置。萬一碰上零軸元的情況，還是有補救辦法，那就是使用列交換運算設法產生其他非零軸元，不過 LU 分解要修改成 <span class="math inline">\(PA=LU\)</span>，<span class="math inline">\(P\)</span> 是排列矩陣。例如，</p>
<p><span class="math display">\[
\begin{aligned}  PA&amp;=\begin{bmatrix}  0&amp;1\\  1&amp;0  \end{bmatrix}\begin{bmatrix}  0&amp;2\\  1&amp;3  \end{bmatrix}=\begin{bmatrix}  1&amp;3\\  0&amp;2  \end{bmatrix}\\  &amp;=\begin{bmatrix}  1&amp;0\\  0&amp;1  \end{bmatrix}\begin{bmatrix}  1&amp;3\\  0&amp;2  \end{bmatrix}=LU.\end{aligned}
\]</span></p>
<h1 id="應用">應用</h1>
<hr />
<p>最後討論 LU 分解的應用。LU 分解不僅僅只是記錄消去過程，它還有一個非常重要的實際用途：LU 分解具備快速求解線性方程 <span class="math inline">\(A\mathbf{x}=\mathbf{b}​\)</span> 的良好結構。一旦得到了可逆矩陣 <span class="math inline">\(A​\)</span> 的 LU 分解 <span class="math inline">\(A=LU​\)</span>，我們大可把 <span class="math inline">\(A​\)</span> 拋棄，將 <span class="math inline">\(A\mathbf{x}=\mathbf{b}​\)</span> 改為 <span class="math inline">\(L(U\mathbf{x})=\mathbf{b}​\)</span>，再令 <span class="math inline">\(\mathbf{y}=U\mathbf{x}​\)</span>，原線性方程等價於兩組三角形系統：</p>
<p><span class="math display">\[
\begin{aligned}  L\mathbf{y}&amp;=\mathbf{b}\\  U\mathbf{x}&amp;=\mathbf{y}.  \end{aligned}
\]</span> 接著使用兩次迭代即可得到解。上例中，先以正向迭代解出 <span class="math inline">\(\mathbf{y}\)</span>，</p>
<p><span class="math display">\[
\left[\!\!\begin{array}{rcc}    1&amp;0&amp;0\\  2&amp;1&amp;0\\  -3&amp;4&amp;1  \end{array}\!\!\right]\begin{bmatrix}  y_1\\  y_2\\  y_3  \end{bmatrix}=\left[\!\!\begin{array}{r}    10\\  22\\  -7  \end{array}\!\!\right]\Rightarrow\begin{cases}  y_1=10&amp;\\  y_2=-2y_1+22=2&amp;\\  y_3=3y_1-4y_2-7=15&amp;  \end{cases}
\]</span></p>
<p>再以反向迭代解出 ，</p>
<p><span class="math display">\[
\left[\!\!\begin{array}{crc}    3&amp;-1&amp;2\\  0&amp;1&amp;1\\  0&amp;0&amp;5  \end{array}\!\!\right]\begin{bmatrix}  x_1\\  x_2\\  x_3  \end{bmatrix}=\left[\!\!\begin{array}{r}    10\\  2\\  15  \end{array}\!\!\right]\Rightarrow\begin{cases}  x_1=(x_2-2x_3+10)/3=1&amp;\\  x_2=-x_3+2=-1&amp;\\  x_3=15/5=3&amp;  \end{cases}
\]</span></p>
<p>對於 階矩陣 ，LU 分解耗費的乘法運算量大約是 <span class="math inline">\(\mathbf{O}(\frac{1}{3}n^3)\)</span>，與高斯消去法相同。這個數字其實不算太糟，因為兩個 <span class="math inline">\(n\)</span> 階方陣相乘就使用了 <span class="math inline">\(n^3\)</span> 次運算。另外，正向迭代或反向迭代的運算量都只有<span class="math inline">\(\mathbf{O}(\frac{1}{2}n^2)\)</span> ，遠比 LU 分解來的少。所以如果只要解出單一線性系統 ，直接用消去法化簡增廣矩陣 <span class="math inline">\(\begin{bmatrix} A\vert\mathbf{b} \end{bmatrix}\)</span> 和 LU 分解的兩段式解法兩者之間並沒有多大差別，但如果稍後還要解多個係數矩陣相同但常數向量改變的系統 ，LU 分解便能夠派上用場。舉例來說，LU 分解可以用來計算逆矩陣 <span class="math inline">\(A^{-1}\)</span>。將矩陣方程 看成三個線性方程：</p>
<p><span class="math display">\[
A\mathbf{x}_1=\begin{bmatrix}  1\\  0\\  0  \end{bmatrix},~ A\mathbf{x}_2=\begin{bmatrix}  0\\  1\\  0  \end{bmatrix},~ A\mathbf{x}_3=\begin{bmatrix}  0\\  0\\  1  \end{bmatrix}
\]</span></p>
<p>解出的未知向量 <span class="math inline">\(\mathbf{x}_i\)</span>，<span class="math inline">\(i=1,2,3\)</span>，就是逆矩陣 <span class="math inline">\(A^{-1}\)</span> 行向量。LU 分解還可以用來計算 <span class="math inline">\(n\times n\)</span> 階行列式。根據矩陣乘積的行列式可乘公式</p>
<p><span class="math display">\[
\det A=\det(LU)=(\det L)(\det U)
\]</span></p>
<p>三角矩陣的行列式等於主對角元乘積，因此 <span class="math inline">\(\mathrm{det}L=1\)</span>，推論</p>
<p><span class="math display">\[
\det A=\det U=\displaystyle\prod_{i=1}^nu_{ii}
\]</span></p>
<p>方陣 <span class="math inline">\(A\)</span> 的行列式即為消去法所得到的上三角矩陣 <span class="math inline">\(U\)</span> 主對角元之積 (關於其他行列式計算方法的介紹，請見“<a href="https://ccjou.wordpress.com/2009/11/24/%e5%8f%a6%e9%a1%9e%e8%a1%8c%e5%88%97%e5%bc%8f%e8%a8%88%e7%ae%97%e6%b3%95-chio-%e6%bc%94%e7%ae%97%e6%b3%95/">Chiò 演算法──另類行列式計算法</a>”)。</p>
<h1 id="參考">參考</h1>
<hr />
<p><a href="https://ccjou.wordpress.com/2010/09/01/lu-%E5%88%86%E8%A7%A3/">LU 分解| 線代啟示錄</a></p>
]]></content>
      <categories>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>LU分解</tag>
        <tag>LU Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title>Discrete mathematics - Catalan number</title>
    <url>/willywangkaa/2019/01/24/Discrete-mathematics-Catalan-number/</url>
    <content><![CDATA[<h1 id="discrete-mathematics---catalan-number">Discrete mathematics - Catalan number</h1>
<blockquote>
<p>給定兩個生成函數：</p>
<ul>
<li><span class="math inline">\(A(x) = \sum_{n = 0}^\infty a_nx^n\)</span></li>
<li><span class="math inline">\(B(x) = \sum_{n = 0}^\infty b_nx^n\)</span></li>
</ul>
<p>則：</p>
<ul>
<li><span class="math inline">\(A(x)\pm B(x) = \sum_{n = 0}^\infty(a_n+b_n)x^n\)</span></li>
<li><span class="math inline">\(\begin{aligned} A(x) \times B(x) = (a_0+a_1x+a_2x^2+\ldots)\times(b_0+b_1x+b_2x^2+\ldots) \\ \Rightarrow (a_0b_0) + (a_0b_1+a_1b_0)x + (a_2b_0+a_1b_1+a_0b_2)x^2+\ldots \end{aligned}\)</span></li>
</ul>
</blockquote>
<p>定義</p>
<ul>
<li><span class="math inline">\(c_n = a_n \otimes b_n = a_0b_n+a_1b_{n-1}+\ldots+a_nb_0\)</span>
<ul>
<li><span class="math inline">\(a_n、b_n\)</span> 為兩個遞迴函數</li>
</ul></li>
<li>稱 <span class="math inline">\(c_n\)</span> 為 <span class="math inline">\(a_n、b_n\)</span> 的「Convalution」
<ul>
<li><span class="math inline">\(c_n = a_n \otimes b_n \Rightarrow C(x) = A(x)\times B(x)\)</span></li>
<li><span class="math inline">\(c_n = a_n \otimes a_n \Rightarrow C(x) = A(x)\times A(x) = A(x)^2\)</span></li>
</ul></li>
</ul>
<h2 id="生成函數推導">「生成函數」推導</h2>
<p>令 Catalan number 等於 <span class="math display">\[
\left\{\begin{matrix} a_n = a_0a_{n-1} + a_1a_{n-2} + \ldots + a_{n-1}a_0 , n\geq 1 \\ a_0 = 1, a_1 = a_0a_0  = 1 \end{matrix}\right.
\]</span> 以「生成函數」求此遞迴函數的顯式</p>
<ol type="1">
<li><p>令 <span class="math inline">\(A(x) = \sum_{n = 0}^\infty a_n x^n\)</span></p>
<ul>
<li><p>因為由上式可以知道此遞迴<strong>從 n ≧ 1開始有意義</strong></p></li>
<li><p><span class="math inline">\(\sum_{n = 0}^\infty a_n x^n - a_0 = \sum_{n = 1}^\infty(a_0a_{n-1}+a_1a_{n-2}+\ldots +a_{n-1}a_0)x^n\)</span></p>
<ul>
<li><span class="math inline">\(\sum_{n = 1}^\infty(a_0a_{n-1}+a_1a_{n-2}+\ldots +a_{n-1}a_0)x^n \\ \Rightarrow x\cdot \sum_{n = 1}^\infty(a_0a_{n-1}+a_1a_{n-2}+\ldots +a_{n-1}a_0)x^{n-1} = x\cdot A(x)^2\)</span></li>
</ul></li>
<li><p><span class="math inline">\(A(x) - a_0 = x\cdot A(x)^2 \\ \Rightarrow xA(x)^2- A(x) +1 = 0\)</span></p></li>
</ul></li>
<li><p><span class="math inline">\(A(x) = \frac{1\pm \sqrt{1-4x}}{2x}\)</span></p>
<ul>
<li><span class="math inline">\((1-4x)^\frac12 = \sum_{r = 0}^\infty \binom{\frac12}{r}(-4x)^r\)</span>
<ul>
<li><span class="math inline">\(\sum_{r = 0}^\infty \binom{\frac12}{r}(-4x)^r = \sum_{n = 0}^\infty \frac{\frac12(\frac12 -1)\ldots (\frac12-r+1)}{r!}(-1)^r4^rx^r\)</span></li>
<li><span class="math inline">\(\Rightarrow \sum_{r = 0}^\infty \frac{\frac12(-\frac12)(-\frac32)\ldots (-\frac{2r-3}{2})}{r!}(-1)^r4^rx^r\)</span></li>
<li><span class="math inline">\(\Rightarrow \sum_{r = 0}^\infty (-1)^{r-1}(\frac12)^r\frac{1(1)(3)\ldots (2r-3)}{r!}(-1)^r4^rx^r\)</span></li>
<li><span class="math inline">\(\Rightarrow -\sum_{r = 0}^\infty \frac{(1)(3)\ldots (2r-3)}{r!}2^rx^r\)</span></li>
<li><span class="math inline">\(\Rightarrow \sum_{r = 0}^\infty \frac{(1)(2)(3)\ldots (2r-3)(2r-2)(2r-1)(2r)}{r!\cdot2^r\cdot r!\cdot(2r-1)}2^rx^r\)</span></li>
<li><span class="math inline">\(\Rightarrow -\sum_{r = 0}^\infty \frac{(2r)!}{r!\cdot r! (2r-1)}x^r\)</span></li>
<li><span class="math inline">\(\Rightarrow -\sum_{r = 0}^\infty \frac{1}{2r-1}\binom{2r}{r} x^r\)</span></li>
</ul></li>
</ul></li>
<li><p>因為 A(x) 會有兩個解，但是因為欲求之解不可能有負數情形，所以<strong>取其正解</strong></p></li>
</ol>
<ul>
<li><span class="math inline">\(A(x) = \frac{1-\sqrt{1-4x}}{2x} = \frac{1+\sum_{r = 0}^\infty \frac{1}{2r-1}\binom{2r}{r} x^r }{2x}\)</span>
<ul>
<li><span class="math inline">\(\Rightarrow \frac12 \sum_{r = 1}^\infty \frac1{2r-1}\binom{2r}{r}x^{r-1}\)</span>，取 <span class="math inline">\(x^n\)</span> 的係數</li>
<li>則 r = n+1，<span class="math inline">\(\Rightarrow \frac12 \cdot \frac1{2(n+1)-1} \binom{2(n+1)}{(n+1)}x^n\)</span></li>
<li><span class="math inline">\(\Rightarrow a_n = \frac{1}{2(2n+1)}\cdot\frac{(2n+2)\times(2n+1)}{(n+1)\times(n+1)}\cdot\binom{2n}{n} = \frac1{n+1}\binom{2n}{n}\)</span></li>
</ul></li>
</ul>
<ol start="4" type="1">
<li>Catalan number 為 <span class="math inline">\(\frac1{n+1}\binom{2n}{n}\)</span></li>
</ol>
<p>Example</p>
<p>求取 n 個節點的「Binary ordered tree」個數？</p>
<figure>
<img src="\willywangkaa\images\1548332494667.png" alt="1548332494667" /><figcaption aria-hidden="true">1548332494667</figcaption>
</figure>
<p>，k ≧ 0</p>
<p><span class="math inline">\(\Rightarrow\left\{\begin{matrix} a_n = a_0a_{n-1} + a_1a_{n-2} + \ldots + a_{n-1}a_0 , n\geq 1 \\ a_0 = 1 \end{matrix}\right. \\ \Rightarrow a_n = c_n = \frac{1}{n+1}\binom{2n}{n}\)</span></p>
<blockquote>
<p>變形</p>
<ul>
<li><span class="math inline">\(\left\{\begin{matrix} a_n = a_0a_{n-1} + a_1a_{n-2} + \ldots + a_{n-1}a_0 , n\geq 1 \\ a_0 = 1 \end{matrix}\right.​\)</span>
<ul>
<li><span class="math inline">\(a_n = c_n = \frac{1}{n+1}\binom{2n}{n}\)</span></li>
</ul></li>
<li><span class="math inline">\(\left\{\begin{matrix} a_n = a_1a_{n-1} + a_2a_{n-2} + \ldots + a_{n-1}a_1 , n\geq 1 \\ a_1 = 1 \end{matrix}\right.\)</span>
<ul>
<li><span class="math inline">\(a_n = c_{n-1} = \frac{1}{n}\binom{2(n-1)}{n-1}\)</span></li>
</ul></li>
<li><span class="math inline">\(\left\{\begin{matrix} a_n = a_2a_{n-1} + a_3a_{n-2} + \ldots + a_{n-1}a_2 , n\geq 1 \\ a_2 = 1 \end{matrix}\right.\)</span>
<ul>
<li><span class="math inline">\(a_n = c_{n-2} = \frac{1}{n+1}\binom{2(n-2)}{n-2}\)</span></li>
</ul></li>
</ul>
<p>Example</p>
<p>n 個變數 <span class="math inline">\(x_1, x_2, \ldots, x_n\)</span> 之合法的括號數有幾個？</p>
<figure>
<img src="\willywangkaa\images\1548332797656.png" alt="1548332797656" /><figcaption aria-hidden="true">1548332797656</figcaption>
</figure>
<p>，k ≧ 1</p>
<p><span class="math inline">\(\left\{\begin{matrix} a_n = a_1a_{n-1} + a_2a_{n-2} + \ldots + a_{n-1}a_1 , n\geq 1 \\ a_1 = 1 \end{matrix}\right. \Rightarrow c_{n-1} = \frac{1}{n}\binom{2(n-1)}{n-1}\)</span></p>
</blockquote>
<h2 id="組合證明推導">「組合證明」推導</h2>
<h3 id="前導">前導</h3>
<p>令 Catalan number 等於 <span class="math display">\[
\left\{\begin{matrix} a_n = a_0a_{n-1} + a_1a_{n-2} + \ldots + a_{n-1}a_0 , n\geq 1 \\ a_0 = 1, a_1 = a_0a_0  = 1 \end{matrix}\right.
\]</span> 則我們可以將此遞迴視為一個<strong>「合法路徑問題」</strong></p>
<ul>
<li>在一個二維空間下，從原點 (0, 0) 只能走下面兩種步伐至 (m, n)
<ul>
<li>步伐 R：(x, y) → (x+1, y)</li>
<li>步伐 U：(x, y) → (x, y+1)</li>
</ul></li>
<li>並且在路徑中，不能發生 U 大於 R 的情形
<ul>
<li>違法：(0,0)→R→R→U→U<strong>→U</strong>→R→...→(m,n)</li>
</ul></li>
<li>首先我們先將問題簡化成「Catalan number」可以解釋的問題，再來推廣
<ul>
<li>在一個二維空間下，從原點 (0, 0) 只能走下面兩種步伐至 <strong>(n, n)</strong>
<ul>
<li>步伐 R：(x, y) → (x+1, y)</li>
<li>步伐 U：(x, y) → (x, y+1)</li>
</ul></li>
<li>並且在路徑中，不能發生 U 大於 R 的情形</li>
</ul></li>
</ul>
<blockquote>
<p>討論</p>
<ul>
<li>若問題再進一步簡化成「自點(0, 0) 只能以規定的兩種步伐至 <strong>(0, 0)</strong>」
<ul>
<li>令該方法數為 <span class="math inline">\(a_0\)</span>，並且其方法數視為 1</li>
</ul></li>
<li>而當問題為「自點(0, 0) 只能以規定的兩種步伐至 <strong>(1, 1)</strong>」時
<ul>
<li>只有唯一種方法，就是 (0,0)→R→U→(1,1)</li>
<li>而我們更可以進一步將此看成
<ul>
<li><span class="math inline">\(a_1\)</span> = 「自(0,0)至(0,0)的方法數」×（唯一的走法：...→R→U→...）×「自(1,1)至(1,1)的方法數」</li>
<li><span class="math inline">\(a_1 = a_0\times1\times a_0 = a_0a_0\)</span></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<p>所以，在一個二維空間下，從原點 (0, 0) 只能以規定兩種步伐至 <strong>(n, n)</strong>的方法數為</p>
<ul>
<li><span class="math inline">\(a_n = a_0a_{n-1} + a_1a_{n-2} + \ldots + a_{n-1}a_0\)</span>，為以下方法數組成
<ul>
<li>(「自(0,0)至(0,0)的方法數」×（唯一的走法：...→R→U→...）×「自(1,1)至(n,n)的方法數」) +</li>
<li>(「自(0,0)至(1,1)的方法數」×（唯一的走法：...→R→U→...）×「自(2,2)至(n,n)的方法數」) +</li>
<li>....</li>
<li>(「自(0,0)至(n-1,n-1)的方法數」×（唯一的走法：...→R→U→...）×「自(n,n)至(n,n)的方法數」)</li>
</ul></li>
</ul>
<blockquote>
<p>由上方討論可以得知<strong>簡化的「合法路徑問題」</strong>與 <strong>n 個節點的「Binary ordered tree」個數問題</strong>等價</p>
</blockquote>
<h3 id="組合證明">組合證明</h3>
<p>一樣是上述的<strong>簡化的「合法路徑問題」</strong>，由下圖來討論</p>
<figure>
<img src="\willywangkaa\images\1548319123283.png" alt="1548319123283" /><figcaption aria-hidden="true">1548319123283</figcaption>
</figure>
<p>自 (0, 0) 至 (16, 16) 且不得超過<strong>中間雙線的部分（可觸及）</strong></p>
<p>合法示意圖：</p>
<figure>
<img src="\willywangkaa\images\1548319440435.png" alt="1548319440435" /><figcaption aria-hidden="true">1548319440435</figcaption>
</figure>
<p>非法示意圖：</p>
<figure>
<img src="\willywangkaa\images\1548319549796.png" alt="1548319549796" /><figcaption aria-hidden="true">1548319549796</figcaption>
</figure>
<blockquote>
<p>每個違法的路徑，必定會和下方紅色雙斜線接觸</p>
<figure>
<img src="\willywangkaa\images\1548320935256.png" alt="1548320935256" /><figcaption aria-hidden="true">1548320935256</figcaption>
</figure>
<p>將<strong>「開始違法的座標」之後的路徑</strong>對紅色雙斜線做對稱化，則最後到達的座標必定在 (15,17)，而這種轉換有幾個特性：</p>
<ul>
<li>1-1 對應</li>
<li>可逆
<ul>
<li>若再一次對稱回來，必定會對應到一個<strong>違法的路徑</strong>自(0,0)至(16,16)</li>
</ul></li>
</ul>
<p>所以自(0,0)至(15,17)的每種路徑，皆會對應到一個違法路徑</p>
<ul>
<li>合法路徑方法數
<ul>
<li><span class="math inline">\(\binom{32}{16} - \binom{32}{15} = \frac{1}{16+1}\binom{2\cdot16}{16}\)</span> 為「Catalan number」</li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>所以從(0, 0)至(n, n)的「合法路徑為」
<ul>
<li><span class="math inline">\(\binom{2n}{n}-\binom{2n}{n-1}\)</span></li>
</ul></li>
</ul>
<p>Example</p>
<p>有一場選舉，兩個候選人 A、B，假設知道 A 的票數一定比 B 多，假設 A 的總得票數為 p ，B 的總得票數為 q，請問有幾種開票的方法可保證每個當下 A 的得票數會大於 B 當下的得票數？</p>
<blockquote>
<p>分析</p>
<p>有別於上面的題目，此處 A 每個當下的得票數絕對會比 B 每個當下的得票數還多</p>
<ul>
<li><strong>不合法</strong>的開票方法：A→A→B<strong>→B</strong>→...</li>
</ul>
</blockquote>
<figure>
<img src="\willywangkaa\images\1548330759722.png" alt="1548330759722" /><figcaption aria-hidden="true">1548330759722</figcaption>
</figure>
<p>假設 A 得到 15 票，B 得到 11 票，則上圖中綠色為合法的開票方法，紅色虛線為不合法的開票方法，但是這樣討論之下，綠色的開票方法在尚未開票時其實也觸碰了紅色雙斜線，然而為何還是正確的開票方法，因為我們在尚未開票時不討論誰贏的比較多，所以我們可以將起點平移到 (1, 0) 處，代表第一章開出來的票一定是 A 得到，且亦不牴觸我們方才的假設</p>
<figure>
<img src="\willywangkaa\images\1548331206829.png" alt="1548331206829" /><figcaption aria-hidden="true">1548331206829</figcaption>
</figure>
<p>則<strong>每個非法路徑</strong>會唯一對應到「自 (1,0) 至 (11,15) 的開票方法」</p>
<figure>
<img src="\willywangkaa\images\1548332141506.png" alt="1548332141506" /><figcaption aria-hidden="true">1548332141506</figcaption>
</figure>
<ul>
<li>合法的開票方法為
<ul>
<li><span class="math inline">\(\binom{(15-1)+11}{15-1} - \binom{(11-1)+15}{11-1} = \binom{25}{14}-\binom{25}{10} = 1188640\)</span></li>
</ul></li>
<li>原本的問題之<strong>合法開票數</strong>為
<ul>
<li><span class="math inline">\(\binom{(p-1)+q}{p-1} - \binom{(q-1)+p}{q-1}\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Discrete Mathematics</category>
      </categories>
      <tags>
        <tag>Catalan Number</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear algebra - Orthogonal complement</title>
    <url>/willywangkaa/2018/10/27/Linear-algebra-Orthogonal-complement/</url>
    <content><![CDATA[<h1 id="minimal-solution">Minimal solution</h1>
<p>假設 <span class="math inline">\(A \in F^{m\times n}\)</span>，<span class="math inline">\(b \in F^{m\times 1}\)</span>，其中 Ax = b 有解，若 s 為 Ax = b 的<strong>某一解</strong>滿足：</p>
<p>「Ax = b 的其他解 u 使得 <span class="math inline">\(\left \| s \right \| \leq \left \| u \right \|\)</span>」，則稱 s 為 Ax = b 的極小解 ( Minimal solution )。</p>
<h2 id="theorem">Theorem</h2>
<p>假設 <span class="math inline">\(A \in F^{m\times n}​\)</span>，<span class="math inline">\(b \in F^{m}​\)</span>，若 Ax = b 有解，則</p>
<ul>
<li><strong>唯一存在</strong> <span class="math inline">\(s \in R(A^H)\)</span> 使得 s 為 Ax = b 的<strong>極小解</strong></li>
<li>若 u 滿足 <span class="math inline">\(AA^Hu = b\)</span> 則 s = <span class="math inline">\(A^H u\)</span></li>
</ul>
<figure>
<img src="\willywangkaa\images\minimalsol_1.png" alt="minimalsol_1" /><figcaption aria-hidden="true">minimalsol_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\minimalsol_2.png" alt="minimalsol_2" /><figcaption aria-hidden="true">minimalsol_2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\minimalsol_3.png" alt="minimalsol_3" /><figcaption aria-hidden="true">minimalsol_3</figcaption>
</figure>
<h3 id="猜想">猜想</h3>
<p>Example 求下列線性系統的極小解</p>
<p><span class="math inline">\(\left\{\begin{matrix} x + 2y + z = 4 \\ x - y +2z = -11 \\ x + 5y = 19\end{matrix}\right.\)</span></p>
<p><span class="math display">\[
[A|b] = \left[
\begin{array}{ccc|c}
1 &amp; 2 &amp; 1 &amp; 4 \\ 
1 &amp; -1 &amp; 2 &amp; -11 \\ 
1 &amp; 5 &amp; 0 &amp; 19 \\ 
\end{array}
\right] \\
\Rightarrow \left[
\begin{array}{ccc|c}
1 &amp; 2 &amp; 1 &amp; 4 \\ 
0 &amp; -3 &amp; 1 &amp; -15 \\ 
0 &amp; 3 &amp; -1 &amp; 15 \\ 
\end{array}
\right] \\
\Rightarrow \left[
\begin{array}{ccc|c}
1 &amp; 2 &amp; 1 &amp; 4 \\ 
0 &amp; 1 &amp; \frac {-1}{3} &amp; 5 \\ 
0 &amp; 0 &amp; 0 &amp; 0 \\ 
\end{array}
\right] \\
\Rightarrow \left[
\begin{array}{ccc|c}
1 &amp; 0 &amp; \frac 53 &amp; -6 \\ 
0 &amp; 1 &amp; \frac {-1}{3} &amp; 5 \\ 
0 &amp; 0 &amp; 0 &amp; 0 \\ 
\end{array}
\right]
\]</span> <span class="math inline">\(x = -6 - \frac53z \\ y = 5 + \frac 13 z \\ \Rightarrow \left[ \begin{array}{} -6 \\ 5 \\ 0 \end{array} \right] + \left[ \begin{array}{} -\frac53 \\ \frac 13 \\ 1 \end{array} \right]z, z\in R\)</span></p>
<blockquote>
<p><span class="math inline">\(\left[ \begin{array}{} -6 \\ 5 \\ 0 \end{array} \right]\)</span> 為特解向量，$ z, zR$ 為 Ker(A) ， 將特解向量投影至 Ker(A) 的分量為 <span class="math inline">\(-\left[ \begin{array}{} 5 \\ -1 \\ -3 \end{array} \right]\)</span> ， 所以 <span class="math inline">\(\left[ \begin{array}{} -6 \\ 5 \\ 0 \end{array} \right] + \left[ \begin{array}{} 5 \\ -1 \\ -3 \end{array} \right] = \left[ \begin{array}{} -1 \\ 4 \\ 3 \end{array} \right]\)</span> 為特解在 <span class="math inline">\(Im(A^T)\)</span> 的分量，即為極小解。</p>
</blockquote>
<p>使用上述解法與 <span class="math inline">\(AA^T u = b\)</span> 解出之 <span class="math inline">\(A^Tu = x\)</span> 一致。</p>
]]></content>
      <categories>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>Orthogonal complement</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning - KNN and Radial Basis Function</title>
    <url>/willywangkaa/2018/05/13/Machine%20Learning-KNN-and-Radial-Basis-Function/</url>
    <content><![CDATA[<h1 id="機器學習性質">機器學習性質</h1>
<hr />
<h2 id="eager-algorithm積極">Eager algorithm(積極)</h2>
<h3 id="性質">性質</h3>
<ul>
<li>將歷史資料做了很多分析與篩選( Mung )等預處理。</li>
<li>因為訓練出的假說很明確( Explicit )，所以自然判斷也比起 Lazy 方法更迅速。</li>
</ul>
<h3 id="ex."><span class="math inline">\(Ex.\)</span></h3>
<ul>
<li>Artificial neural network</li>
<li>Decision tree</li>
</ul>
<h2 id="lazy-algorithm被動">Lazy algorithm(被動)</h2>
<h3 id="性質-1">性質</h3>
<ul>
<li>簡單的處理訓練資料，不會將資料轉成其他方式表達，所以資料不會因為處理過後而喪失一些屬性。</li>
<li>這種訓練方法在「判斷」未知案例時，因為要做的比對處理比較多，比起利用歷史資料先處理的 Eager算法需時更長。</li>
<li>因為這種方法是將資料做區域化的處理( Localized )，所以每次判斷全域( Generalization )時都要重新花一次時間。</li>
</ul>
<h3 id="ex.-1"><span class="math inline">\(Ex.\)</span></h3>
<ul>
<li>KNN</li>
</ul>
<h1 id="knn-and-radial-basis-function">KNN and Radial Basis Function</h1>
<hr />
<h2 id="instance-based-learning">Instance-based Learning</h2>
<p>以先前的案例( 未做處理或修飾的 )建立假說空間。</p>
<h2 id="重點">重點</h2>
<ul>
<li>概念
<ul>
<li>只有將先前的案例完整的儲存起來，不要有任何的修飾或是處理。</li>
<li><span class="math display">\[&lt;x_i, f(x_i)&gt;\]</span></li>
</ul></li>
<li>最近鄰法 ( Nearest neighbor )
<ul>
<li>給定一個<strong>要判斷</strong>的案例 <span class="math inline">\(x_q\)</span>，接者我們在該案例空間中找到<strong>一個</strong>最靠近的先前案例以猜測之。</li>
<li><span class="math inline">\(\hat{f}(x_q) \leftarrow f(x_{Nearest \; neighbor})\)</span></li>
</ul></li>
<li>近 <span class="math inline">\(K\)</span> 鄰法 ( <em>KNN</em> )
<ul>
<li>給定一個<strong>要判斷</strong>的案例 <span class="math inline">\(x_q\)</span>，接著我們在近 <span class="math inline">\(K\)</span> 個鄰居之中做<strong>多數決選擇法</strong>。 ( 當目標結果 Target function 是離散值時 )</li>
<li>給定一個<strong>要判斷</strong>的案例 <span class="math inline">\(x_q\)</span>，接著我們在近 <span class="math inline">\(K\)</span> 個鄰居之中取其<strong>平均數</strong>決定。 ( 當目標結果是在實數值時 )</li>
<li><span class="math inline">\(i.e., \quad \hat{f}(x_q) = \frac{\sum_{i = 1}^k f(x_i)}{k}\)</span></li>
</ul></li>
</ul>
<h2 id="voronoi-diagram---沃羅諾伊圖">Voronoi Diagram - <a href="https://zh.wikipedia.org/wiki/%E6%B2%83%E7%BD%97%E8%AF%BA%E4%BC%8A%E5%9B%BE">沃羅諾伊圖</a></h2>
<ul>
<li>K-Nearest Neighbor</li>
</ul>
<figure>
<img src="\willywangkaa\images\knearestneighbor.png" alt="knearestneighbor" /><figcaption aria-hidden="true">knearestneighbor</figcaption>
</figure>
<ul>
<li>Voronoi Diagram (K= 1)</li>
</ul>
<figure>
<img src="\willywangkaa\images\voronoidiagram.png" alt="voronoidiagram" /><figcaption aria-hidden="true">voronoidiagram</figcaption>
</figure>
<h2 id="nearest-neighbor---最近鄰法">Nearest neighbor - 最近鄰法</h2>
<ul>
<li>重點性質
<ul>
<li>將所有的案例( Instance )儲存在一個 <span class="math inline">\(R^n\)</span> 案例空間之中。( <span class="math inline">\(n\)</span> 的多寡代表這些資料的 <strong>Attribute - 環境引響因素</strong>有多少 )</li>
<li>盡量將 <em>環境引響因素</em> 去蕪存菁，最好少於 <em>20 個</em> 。 <br><strong>＜Note＞：</strong> 引響的環境因素最好是<strong>具有意義實數</strong>且不可以太多。<br>舉例：假設今天有一筆資料同時可以被兩個與三個的<strong>環境因素</strong>所表達，但在有三個<strong>環境因素</strong>案例空間的資料間隔會更分散。</li>
</ul></li>
<li>Pros
<ul>
<li>訓練的時間很快。</li>
<li>可以學習很複雜的「目標<strong>函數 ( 概念 )</strong>」</li>
<li>不會捨去訓練資料的資訊。</li>
</ul></li>
<li>Cons
<ul>
<li>判斷新進的案例需時很長。</li>
<li>容易被不重要的<strong>環境因素</strong>所誤導。</li>
</ul></li>
</ul>
<h2 id="k-nearest-neighbor-learning---近-k-個鄰法">K-Nearest Neighbor Learning - 近 <span class="math inline">\(K\)</span> 個鄰法</h2>
<p>若今天給定資料案例 <span class="math inline">\(x\)</span> 是由 <span class="math inline">\(n\)</span> 個 <strong>attributes - 環境因素</strong>所構成，可以表達為：<span class="math inline">\(x = ＜a_1(x), \ldots, a_n(x)＞\)</span>。</p>
<p>接者，使用平常對於歐基里德空間最熟悉的兩點求距<strong>( Euclidean distance )</strong> <span class="math inline">\(d(i, j) = \sqrt{\sum_{r = 1}^n (a_r(x_i) - a_r(x_j))^2}\)</span></p>
<p>###Algorithm - 演算法</p>
<ul>
<li>給定一個要判斷的案例 <span class="math inline">\(x_q\)</span> 。
<ul>
<li>欲找到 <span class="math inline">\(k\)</span> 個與 <span class="math inline">\(x_q\)</span> 靠最近的 <span class="math inline">\(x_i\)</span> 。( 利用 <span class="math inline">\(d(x_i, x_q)\)</span> 判斷距離 )</li>
<li>選出 <span class="math inline">\(k\)</span> 個案例之中出現比較多次的結果作為 <span class="math inline">\(x_q\)</span> 的結果。( 當這份資料的結果是由離散的資料組成採用此方法 )    - 以下圖舉例 <br> <img src="\willywangkaa\images\knearestneighbor2.png" alt="knearestneighbor2" /><br><span class="math inline">\(k = 1\)</span> ，判定 <span class="math inline">\(x_q\)</span> 為正向輸出。<br><span class="math inline">\(k = 5\)</span> ，判定 <span class="math inline">\(x_q\)</span> 為負向輸出。</li>
<li>當資料的結果為連續的時數值時，我們判定 <span class="math inline">\(x_q\)</span> 的輸出為 <span class="math inline">\(k\)</span> 個鄰居的平均值。</li>
</ul></li>
</ul>
<h3 id="建立的假說空間">建立的假說空間</h3>
<ul>
<li>使用 KNN 時我們建立的假說空間 <span class="math inline">\(H\)</span> 不是明確的。</li>
</ul>
<h4 id="隱式的假說空間-h">隱式的假說空間 <span class="math inline">\(H\)</span></h4>
<ul>
<li>將所有的訓練資料( 案例 )都完整地保留在我們建立的假說之中。</li>
<li>要檢驗新的 <span class="math inline">\(x_q\)</span> 時，需要將所有的案例都檢查過一遍。</li>
<li>1-NN：<span class="math inline">\(H\)</span> = Voronoi Diagram</li>
</ul>
<figure>
<img src="\willywangkaa\images\voronoidiagram2.png" alt="voronoidiagram2" /><figcaption aria-hidden="true">voronoidiagram2</figcaption>
</figure>
<h2 id="距離權重近鄰法-distance---weighted-knn">距離權重近鄰法 Distance - Weighted <span class="math inline">\(K\)</span>NN</h2>
<ul>
<li>欲考慮比較近的鄰居佔比越重。( 所以距離與權重呈現倒數的關係 )
<ul>
<li><span class="math inline">\(\hat{f} \leftarrow \frac{\sum_{i = 1}^k w_if(x_i)}{\sum_{i = 1}^k w_i}\)</span></li>
<li><span class="math inline">\(w_i \equiv \frac{1}{d(x_q, x_i)^2}\)</span></li>
<li><span class="math inline">\(d(x_q, x_i)\)</span> 是 <span class="math inline">\(x_q\)</span> 與 <span class="math inline">\(x_i\)</span> 的距離。</li>
</ul></li>
<li>問題來了，那我們要選擇幾個鄰居作為參考值呢？
<ul>
<li>Shepard's Method ：將整個案例空間所有的 <span class="math inline">\(x_i\)</span> 都納入考量。</li>
</ul></li>
</ul>
<h2 id="curse-of-dimensionality---維度災難-閱讀更多">Curse of Dimensionality - 維度災難 (<a href="https://willywangkaa.csdn.net/ztf312/article/details/50894224">閱讀更多</a>)</h2>
<p>想像一個案例可以用20個環境變因( Attribute )所解釋，但是只有其中兩個變因是實際有影響的，若變因的維度太高可能會讓不重要的因素導致整個空間裡的案例之間的距離變得更稀疏，進而干擾我們最終呈現的「想法」。</p>
<h3 id="解決方法計算兩個案例之間的距離時對每個變因進行加權">解決方法：計算兩個案例之間的距離時對每個變因進行加權</h3>
<p>這樣的方法相當於按比例縮放歐式空間中的坐標軸，先決定哪些環境邊因對我們的訓練比較重要(Try and error)，縮短對應到相關不大之變因的坐標軸，拉長對應於相關較大之變因之座標軸。每個座標軸的伸縮量可以透過交叉驗證的方法自動決定。</p>
<h2 id="一些專有名詞">一些專有名詞</h2>
<ul>
<li>Regression - 回歸
<ul>
<li>逼近一個實數函數 <span class="math inline">\(f\)</span> ( 最終「想法」)</li>
</ul></li>
<li>Residual - 殘差
<ul>
<li>「某樣本的均值」與「所有樣本集均值」的均值之偏離，代表取樣的合理性即該樣本是否具代表意義。残差大，表明樣本不具代表性，也有可能由特徵值引起。 <br> <strong>＜Note＞：</strong>誤差: 所有「不同樣本集的均值」之均值與真實總體均值的偏離量。由於真實總體均值通常無法獲取或觀測，因此通常是假设總體為某一分部類型，則有 <span class="math inline">\(N\)</span> 個估算的均值；代表的是觀測/測量的精確度。誤差大，由變異數引起。表明數據可能有嚴重的測量錯誤，或者所選模型不合適。</li>
<li>要看一個模型是否合適，看誤差；要看所取樣本是否合適，看残差。</li>
<li><span class="math inline">\(\hat{f}(x) - f(x)\)</span></li>
</ul></li>
<li>Kernel function <span class="math inline">\(K\)</span> - 核心函數 <span class="math inline">\(K\)</span>
<ul>
<li>決定距離的函數，用於決定權重影響的比例。</li>
<li><span class="math inline">\(w_i = K(d(x_i, x_q))\)</span></li>
<li><span class="math inline">\(\Rightarrow w_i = K(d(x_i, x_q)) = \frac{1}{d(x_i, x_q)^2}\)</span></li>
</ul></li>
</ul>
<h1 id="locally-weighted-regrassion---區域加權回歸">Locally Weighted Regrassion - 區域加權回歸</h1>
<hr />
<blockquote>
<p><strong>＜Note＞：</strong>全域法 v.s 區域法：在估計 <span class="math inline">\(f(x_q)\)</span> 時，</p>
<ul>
<li>全域法
<ul>
<li>將所有的案例 <span class="math inline">\(＜x, f(x)＞\)</span> 納入參考。</li>
</ul></li>
<li>區域法
<ul>
<li>只將區域的( knn )鄰居納入參考。</li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>區域法</li>
<li>加權：由對應的案例 <span class="math inline">\(x_i\)</span> 與 <span class="math inline">\(x_q\)</span> 的距離產生的權重。</li>
<li>回歸：逼近一個實數的目標函式。</li>
</ul>
<h2 id="直觀">直觀</h2>
<ul>
<li><span class="math inline">\(K\)</span> - NN 對於目標函式 <span class="math inline">\(f(x)\)</span> ，有一個 <span class="math inline">\(x_q\)</span> 的需求時，產生一個區域型的逼近結果。</li>
<li>區域加權回歸其實就是泛化的 <span class="math inline">\(K\)</span> - NN 。</li>
<li>藉由 <span class="math inline">\(x_q\)</span> 劃出來的範圍 <span class="math inline">\(K\)</span> 直觀( explicit )的逼近目標函式 <span class="math inline">\(f(x)\)</span>。
<ul>
<li>舉例來說，可以一個「線性方程」表達 <span class="math inline">\(K\)</span> 個鄰居的加權影響值。</li>
</ul></li>
</ul>
<p><span class="math display">\[
\hat{f}(x) = w_0 + w_1a_1(x) + \ldots +w_na_n(x)
\]</span> <span class="math inline">\(a_i\)</span> 代表 <span class="math inline">\(x\)</span> 對應環境變因的值。</p>
<ul>
<li>特別的是，有可能可以用「非線性方程」來表達。
<ul>
<li>K 個鄰居以二次多項式( quadratic function )呈現權重值。</li>
</ul></li>
<li>以「分段近似法( piecewise approximation )」求取 <span class="math inline">\(f\)</span>。 ( 類似cubic spline的手法 )</li>
</ul>
<h2 id="以各種不同的殘差函式將殘差降到最低求取最終的-f">以各種不同的「殘差函式」將殘差降到最低求取最終的 <span class="math inline">\(f\)</span></h2>
<ul>
<li>在「 <span class="math inline">\(K\)</span> 個鄰居」之間可以找到 Sum Square Error (SSE)
<ul>
<li><span class="math inline">\(E_1(x_q) \equiv \frac{1}{2} \sum_{x \in k \; nearest \; nbr \; of \; x_q} (f(x) - \hat{f}(x))^2\)</span></li>
</ul></li>
<li>在「所有鄰居」之間可以找到<strong>距權</strong> Distance-Weighted SSE
<ul>
<li><span class="math inline">\(E_2(x_q) \equiv \frac{1}{2} \sum_{x \in D} (f(x) - \hat{f}(x))^2 \times K(d(x_q, x))\)</span></li>
</ul></li>
<li>將上面兩者合體後
<ul>
<li><span class="math inline">\(E_3(x_q) \equiv \frac{1}{2} \sum_{x \in k \; nearest \; nbr \; of \; x_q} (f(x) - \hat{f}(x))^2 \times K(d(x_q, x))\)</span></li>
</ul></li>
</ul>
<h1 id="radial-basis-function-networks-放射狀基底函數網路">Radial Basis Function Networks 放射狀基底函數網路</h1>
<hr />
<p>將所有的區域逼近組合成全域型地逼近目標函數 <span class="math inline">\(f\)</span>，通常用於影像、訊號分析。</p>
<p><strong>＜Note＞：</strong>這種網路模型是完全不相干於「Artificial Neural Network - 類神經網路」，相較起來比較與「距離加權回歸」相近，但是以積極的( Eager )的方式而不是以被動的( Lazy )的方式實現。</p>
<figure>
<img src="\willywangkaa\images\radialbasisfunction.png" alt="radialbasisfunction" /><figcaption aria-hidden="true">radialbasisfunction</figcaption>
</figure>
<p><span class="math display">\[
\hat{f}(x)  = w_0 + \sum_{u  = 1}^k w_u \times K_u (d(x_u, x))
\]</span> <span class="math inline">\(a_i\)</span>代表 <span class="math inline">\(x\)</span> 的第 <span class="math inline">\(i\)</span> 個環境變因，而 <span class="math inline">\(K_u (d(x_u, x))\)</span> 已經定義為當距離 <span class="math inline">\(d(x_u, x)\)</span> 變大時會隨之變小。</p>
<ul>
<li>常用的 <span class="math inline">\(K_n\)</span> ：Gaussian kernel function</li>
</ul>
<p><span class="math display">\[
K_u (d(x_u, x)) = e^{-\frac{1}{2 \times {\delta_u}^2} d^2(x_u, x)}
\]</span></p>
<p><strong>＜Note＞：</strong>常態分布( 又稱為高斯分布 ) <span class="math inline">\(y = p(x) = \frac{1}{\sqrt{2\pi \delta^2}}e^{-\frac{1}{2}(\frac{x-\mu}{\delta})^2}\)</span></p>
<h2 id="訓練-rbf-網路">* 訓練 RBF 網路</h2>
<ul>
<li>問題一：對於核心函式<span class="math inline">\(K_u(d(x_u, x))\)</span>，如何選定一個 <span class="math inline">\(x_u\)</span> ？
<ul>
<li><strong>問題亦是在問如何選定套用一個樣板( prototypes )當作訓練模型。</strong></li>
<li>確認何點為這個案例空間的「常態分布中心點」。</li>
<li>或是以其他的分布套用於該案例空間。</li>
</ul></li>
<li>問題二：如何訓練權重( 假設使用Gaussian <span class="math inline">\(K_u\)</span>的狀態下 )？
<ul>
<li>對於每個 <span class="math inline">\(K_u\)</span> 先設定為變異數( 或是平均數 )。</li>
<li>將 <span class="math inline">\(K_u\)</span> 固定，訓練出一個線性式的輸出層。</li>
</ul></li>
</ul>
<h1 id="參考">參考</h1>
<p><a href="https://www.quora.com/What-is-the-difference-between-eager-learning-and-lazy-learning#">Quora - What is the difference between eager learning and lazy learning?</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%B2%83%E7%BD%97%E8%AF%BA%E4%BC%8A%E5%9B%BE">沃羅諾伊圖</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22717928">K近邻算法(kNN) - 知乎专栏</a></p>
<p><a href="https://willywangkaa.csdn.net/ztf312/article/details/50894224">机器学习：维度灾难问题- CSDN博客</a></p>
<p><a href="https://willywangkaa.csdn.net/jmydream/article/details/8764869">残差residual VS 误差 error</a></p>
<p><a href="http://www.ycc.idv.tw/YCNote/post/36">機器學習技法學習筆記(7)：Radial Basis Function Network與Matrix Factorization</a></p>
<p><a href="https://zh.wikipedia.org/zh-tw/%E5%BE%84%E5%90%91%E5%9F%BA%E5%87%BD%E6%95%B0%E7%BD%91%E7%BB%9C">放射狀基底函數網路- 維基百科，自由的百科全書 - Wikipedia</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>KNN</tag>
        <tag>Radial Basis Function</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear algebra - Vandermonde matrix</title>
    <url>/willywangkaa/2019/01/22/Linear-algebra-Vandermonde-matrix/</url>
    <content><![CDATA[<h1 id="linear-algebra---vandermonde-matrix">Linear algebra - Vandermonde matrix</h1>
<ul>
<li>法國數學家范德蒙 (Alexandre-Théophile Vandermonde) 是<strong>行列式的奠基者</strong>之一，他在十八世紀提出行列式專有符號，將行列式應用於解線性方程組，並且對行列式理論進行了開創性的研究</li>
<li>兩百多年後，他的名字因為「Vandermonde 矩陣」而經常被提及，具有以下形式：
<ul>
<li><span class="math inline">\(A_n=\begin{bmatrix} 1&amp;x_1&amp;x_1^2&amp;\cdots&amp;x_1^{n-1} \\ 1&amp;x_2&amp;x_2^2&amp;\cdots&amp;x_2^{n-1} \\ \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 1&amp;x_n&amp;x_n^2&amp;\cdots&amp;x_n^{n-1} \end{bmatrix}，其中\; x_1, x_2, x_3, \ldots, x_n\;全相異\)</span></li>
<li><span class="math inline">\((A_n)^T\)</span> 也稱為 Vandermonde 矩陣</li>
</ul></li>
</ul>
<h2 id="推導">推導</h2>
<p>令 <span class="math inline">\(f(t) = V(x_1, x_2, \ldots, x_{n-1}, t) = A_n=\begin{bmatrix}1&amp;x_1&amp;x_1^2&amp;\cdots&amp;x_1^{n-1} \\1&amp;x_2&amp;x_2^2&amp;\cdots&amp;x_2^{n-1} \\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;t&amp;t^2&amp;\cdots&amp;t^{n-1} \end{bmatrix}​\)</span></p>
<blockquote>
<p>上面方程式可以視為一個 t 的函數</p>
</blockquote>
<ol type="1">
<li><p>對<strong>第 n 列作降階求行列式</strong>得到 <span class="math inline">\(c_0 + c_1t + \ldots + c_{n-1} t^{n-1}\)</span>，為一個「t 的 n-1 次多項式」</p></li>
<li><p>其中 <span class="math inline">\(c_0, c_1, \ldots, c_{n-1}\)</span> 為<strong>不含 t 的常數</strong></p>
<ul>
<li><span class="math inline">\(c_{n-1}\)</span> 為去除<strong>第 n 行與第 n 列</strong>後的行列式：</li>
<li>$c_{n-1} = V(x_1, x_2, , x_{n-1}) $</li>
</ul></li>
<li><p>用 <span class="math inline">\(x_1,\ldots , x_{n-1}\)</span> 代入 f</p>
<ul>
<li><p><span class="math inline">\(f(x_1) = \det\begin{bmatrix} 1&amp;x_1&amp;x_1^2&amp;\cdots&amp;x_1^{n-1} \\ 1&amp;x_2&amp;x_2^2&amp;\cdots&amp;x_2^{n-1} \\ \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 1&amp;x_1&amp;x_1^2&amp;\cdots&amp;x_1^{n-1} \end{bmatrix} = 0 = f(x_2) = \ldots = f(x_{n-1})\)</span></p></li>
<li><p>可以知道 f(t) <strong>有 n-1 個相異根</strong> <span class="math inline">\(x_1, x_2, \ldots, x_{n-1}\)</span></p>
<ul>
<li><span class="math inline">\(\Rightarrow f(t) = c_{n-1}(t-x_1)(t-x_2)\ldots(t-x_{n-1})\)</span></li>
<li>將 <span class="math inline">\(x_n\)</span> 代入：
<ul>
<li><span class="math inline">\(f(x_n) = V(x_1, x_2, \ldots, x_n) = V(x_1, x_2, \ldots, x_{n-1})(x_n-x_1)\ldots(x_n-x_{n-1})\)</span></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><span class="math inline">\(V(x_1, x_2, \ldots, x_n) = V(x_1, x_2, \ldots, x_{n-1})(x_n-x_1)(x_n-x_2)\ldots(x_n-x_{n-1})\)</span></p>
<ul>
<li><span class="math inline">\(\Rightarrow V(x_1, \ldots, x_{n-2})[(x_{n-1}-x_1)\ldots(x_{n-1}-x_{n-2})][(x_n-x_1)\ldots(x_n-x_{n-1})]\)</span></li>
<li><span class="math inline">\(\Rightarrow V(x_1, x_2)[(x_3-x_1)(x_3-x_2)]\ldots[(x_n-x_1)(x_n-x_2)...(x_n-x_{n-1})] \\\)</span></li>
<li><span class="math inline">\(\Rightarrow \prod_{1\leq i\leq j \leq n} (x_j-x_i)\)</span></li>
</ul></li>
</ol>
<h2 id="應用">應用</h2>
<ul>
<li>Vandermonde 矩陣常見於<strong>數值分析的內插</strong> (interpolation) 問題
<ul>
<li>給出 n 個資料點 <span class="math inline">\((x_i, y_i)\)</span>，<span class="math inline">\(i=1,2,\ldots,n\)</span>，求 n-1 次多項式
<ul>
<li><span class="math inline">\(p(x)=a_{n-1}x^{n-1}+a_{n-2}x^{n-2}+\cdots+a_1x+a_0\)</span> 並滿足</li>
<li><span class="math inline">\(\begin{aligned} p(x_1)&amp;=a_0+a_1x_1+\cdots+a_{n-1}x_1^{n-1}=y_1\\ p(x_2)&amp;=a_0+a_1x_2+\cdots+a_{n-1}x_2^{n-1}=y_2\\ &amp;\vdots \\ p(x_n)&amp;=a_0+a_1x_n+\cdots+a_{n-1}x_n^{n-1}=y_n \end{aligned}\)</span></li>
</ul></li>
<li>將上面的線性方程組寫為矩陣形式 <span class="math inline">\(A\mathbf{a}=\mathbf{y}\)</span>
<ul>
<li>A 為 n×n 階 Vandermonde 矩陣</li>
<li>內插問題就是要解出係數向量 <span class="math inline">\(\mathbf{a}=\begin{bmatrix} a_0&amp;a_1&amp;\cdots&amp;a_{n-1}\end{bmatrix}^T\)</span></li>
<li>如果 n 個參數 <span class="math inline">\(x_1,x_2,\ldots,x_n\)</span> 彼此相異，推知 <span class="math inline">\(\mathrm{det}A_n\neq 0\)</span>， A 是可逆的，方程式必定存在<strong>唯一解</strong></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>Vandermonde matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Discrete mathematics - 泰勒級數</title>
    <url>/willywangkaa/2018/03/16/Discrete-mathematics-%E6%B3%B0%E5%8B%92%E7%B4%9A%E6%95%B8/</url>
    <content><![CDATA[<h1 id="泰勒級數taylor-series">泰勒級數（Taylor series）</h1>
<p>英國數學家布魯克·泰勒（Sir Brook Taylor）於1715年發表泰勒公式</p>
<p>以<strong>無限項連加式（級數）</strong>來表示一個函數，其中「每一項」皆由函數在「某一點之導數」求得</p>
<ul>
<li>英國數學家布魯克·泰勒（Sir Brook Taylor）於1715年發表泰勒公式
<ul>
<li>通過函數在自變量零點的導數求得的泰勒級數
<ul>
<li>又叫做<strong>麥克勞林級數</strong></li>
</ul></li>
</ul></li>
</ul>
<p>拉格朗日在1797年之前，最先提出帶有餘項的現在形式的泰勒定理。實際應用中，泰勒級數需要截斷，只取有限項，可以用泰勒定理估算這種近似的誤差。一個函數的有限項的泰勒級數叫做<strong>泰勒多項式</strong>。一個函數的泰勒級數是其泰勒多項式的極限（如果存在極限）。即使泰勒級數在每點都收斂，函數與其泰勒級數也可能不相等。開區間（或複平面開片）上，與自身泰勒級數相等的函數稱為<strong>解析函數</strong>。</p>
<h1 id="定義">定義</h1>
<p>在數學上，一個在實數或複數 <span class="math inline">\(a\)</span> 在 <strong>鄰域</strong>上的<strong>無窮</strong>可微實變函數或複變函數 <span class="math inline">\(f(x)\)</span> 的泰勒級數是如下的冪級數 (若與原函式相等時為<strong>解析函數</strong>)：</p>
<p><span class="math display">\[
f(x) \simeq \sum_{n=0}^{\infty }{\frac {f^{(n)}(a)}{n!}}(x-a)^{n}
\]</span></p>
<p>而 <span class="math inline">\(f^{(n)}(a)\)</span>表示函數 <span class="math inline">\(f\)</span> 在點 $ a$ 處的 $ n$ 階<strong>導數</strong>。如果 <span class="math inline">\(a=0\)</span> ，那麼這個級數也可以被稱為麥克勞林級數。</p>
<p>而多項式函數 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x = a\)</span> 時，<span class="math inline">\(n\)</span> 階的泰勒展開式 <span class="math inline">\(P_{n}(x)\)</span> 是：</p>
<p><span class="math display">\[
P_{n}(x) = \sum_{i = 0}^{n} \frac{ f^{(i)}(a) }{ i! }\cdot \left(x-a \right)^{i}
\]</span></p>
<h1 id="解析函數">解析函數</h1>
<p><a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0#%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B8">Read more-1 (wiki)</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0">Read more-2 (wiki)</a></p>
<hr />
<p>如果泰勒級數對於區間 <span class="math inline">\((a-r,a+r)\)</span>中的所有 <span class="math inline">\(x\)</span> 都收斂並且級數的和等於 <span class="math inline">\(f(x)\)</span> ，那麼我們就稱函數 <span class="math inline">\(f(x)\)</span> 為解析的（analytic）。若且唯若一個函數可以表示成為冪級數的形式時，它才是解析的。為了檢查級數是否<strong>收斂於</strong> <span class="math inline">\(f(x)\)</span>，通常採用<strong>泰勒定理</strong>估計級數的餘項 (數值方法)。上面給出的<strong>冪級數展開式</strong>中的係數正好是<strong>泰勒級數</strong>中的<strong>係數</strong>。</p>
<p><strong>泰勒級數的重要性體現在以下三個方面：</strong></p>
<ol type="1">
<li>冪級數的求<strong>導和積分</strong>可以逐項進行，因此求<strong>和函數</strong>相對比較容易。</li>
<li>一個解析函數可被延伸為一個定義在<strong>複平面</strong>上的一個開片上的解析函數，並使得複分析這種手法可行。</li>
<li>泰勒級數可以用來<strong><em>近似計算函數的值</em></strong>。</li>
</ol>
<p><strong>對定值 x 而言，函數的精準度會隨著多項式的次數 n 的增加而增加。</strong> <strong>對一個固定次數的多項式而言， 確度隨著 x 離開 x=0 處而遞減。</strong></p>
<h1 id="泰勒級數列表常用"><a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0#%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0%E5%88%97%E8%A1%A8">泰勒級數</a>列表(常用)</h1>
<p><strong>注意：</strong>核函數 $ x$ 為 <em>複數</em> 時它們依然成立！</p>
<ul>
<li>幾何級數(<a href="https://zh.wikipedia.org/wiki/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97">等比數列</a>)</li>
</ul>
<p><span class="math display">\[
\frac {1}{1-x} = \sum_{n=0}^{\infty }x^{n}\quad \forall x:\left|x\right|&lt;1
\]</span></p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86">二項式定理</a></li>
</ul>
<p><span class="math display">\[
(1+x)^{\alpha }=\sum_{n=0}^{\infty }C^\alpha_n \cdot x^{n}\quad \forall x:\left|x\right|&lt;1,\forall \alpha \in \mathbb{C}
\]</span></p>
<ul>
<li>指數函數</li>
</ul>
<p><span class="math display">\[
e^{x}=\sum_{n=0}^{\infty }{\frac {x^{n}}{n!}}\quad \forall x
\]</span></p>
<ul>
<li><p><span class="math inline">\(f(x) = e^x\)</span> 在 <span class="math inline">\(x = 0\)</span> 的泰勒展開式。 當<span class="math inline">\(n = 1\)</span>時，<span class="math inline">\(P_{1}(x) = 1+ \frac{\left( e^0\right)&#39;}{1!}\cdot\left( x - 0 \right)^1\)</span> 當<span class="math inline">\(n = 2\)</span>時，<span class="math inline">\(P_{2}(x) = 1+ \frac{\left( e^0\right)&#39;}{1!}\cdot\left( x - 0 \right)^1 + \frac{\left( e^0\right)&#39;&#39;}{2!}\cdot\left( x - 0 \right)^2\)</span> 當<span class="math inline">\(n = 3\)</span>時，<span class="math inline">\(P_{3}(x) = 1+ \frac{\left( e^0\right)&#39;}{1!}\cdot\left( x - 0 \right)^1 + \frac{\left( e^0\right)&#39;&#39;}{2!}\cdot\left( x - 0 \right)^2 + \frac{\left( e^0\right)^{(3)}}{3!}\cdot\left( x - 0 \right)^3\)</span><br> <span class="math inline">\(...\)</span></p></li>
<li><p>自然對數</p></li>
</ul>
<p><span class="math display">\[
\ln(1+x)=\sum_{n=1}^{\infty }{\frac {(-1)^{n+1}}{n}}x^{n}\quad \forall x\in (-1,1]
\]</span></p>
<h1 id="牛頓插值公式的淵源">牛頓插值公式的淵源</h1>
<p><a href="https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E5%A4%9A%E9%A1%B9%E5%BC%8F">Read more-1(wiki)</a>，<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0#%E8%88%87%E7%89%9B%E9%A0%93%E6%8F%92%E5%80%BC%E5%85%AC%E5%BC%8F%E7%9A%84%E6%B7%B5%E6%BA%90">Read more-2(wiki)</a></p>
<p><strong>牛頓插值公式</strong>也叫做<strong>牛頓級數</strong>，由「牛頓 <em>前向</em> 差分方程」的項組成，得名於伊薩克·牛頓爵士。一般稱其為連續「泰勒展開」的<strong>離散對應</strong>。</p>
<h2 id="差分">差分</h2>
<p>差分，又名差分函數或差分運算，是數學中的一個概念。它將原函數 <span class="math inline">\(f(x)\)</span> 映射到 <span class="math inline">\(f(x+a)-f(x+b)\)</span> 。差分運算，相應於微分運算，是<strong>微積分</strong>中重要的一個概念。</p>
<h3 id="定義-1">定義</h3>
<p><strong>前向差分</strong>的定義為：</p>
<p><span class="math display">\[
\Delta_{h}^{1}[f](x) = f(x + h) - f(x)
\]</span></p>
<p><span class="math display">\[
\Delta_{h}^{n}[f](x) = \Delta_{h}^{n-1}[f](x + h) - \Delta_{h}^{n-1}[f](x)
\]</span></p>
<p>$, where $ $ h =$ $ "x"$ <span class="math inline">\(一步的間距，若無下標h，那間距h = 1。\)</span></p>
<h4 id="前向差分">前向差分</h4>
<p>函數的前向差分通常簡稱為<strong>函數的差分</strong>。對於函數 <span class="math inline">\(f(x)\)</span> ，如果在等距節點：</p>
<p><span class="math display">\[
x_{k}=x_{0}+kh,(k=0,1,...,n)
\]</span></p>
<p><span class="math display">\[
\Delta f(x_{k})=f(x_{k+1})-f(x_{k})
\]</span></p>
<p>則稱 <span class="math inline">\(\Delta f(x)\)</span>，函數在每個小區間上的增量 <span class="math inline">\(y_{k+1}-y_{k}\)</span> 為 <span class="math inline">\(f(x)\)</span> 一階差分。</p>
<h4 id="後向差分">後向差分</h4>
<p>對於函數 <span class="math inline">\(f(x_{k})\)</span>，如果：</p>
<p><span class="math display">\[
\nabla f(x_{k})=f(x_{k})-f(x_{k-1})
\]</span></p>
<p>則稱 <span class="math inline">\(\nabla f(x_{k})\)</span> 為 <span class="math inline">\(f(x)\)</span> 的<strong>一階逆向差分</strong>。</p>
]]></content>
      <categories>
        <category>Discrete Mathematics</category>
      </categories>
      <tags>
        <tag>Taylor Series</tag>
      </tags>
  </entry>
  <entry>
    <title>Discrete Mathematics - Principle of inclusion and exclusion（排容原理）</title>
    <url>/willywangkaa/2018/09/11/Discrete%20Mathematics-Principle-of-inclusion-and-exclusion/</url>
    <content><![CDATA[<h1 id="principle-of-inclusion-and-exclusion排容原理">Principle of inclusion and exclusion（排容原理）</h1>
<p>假設 <span class="math inline">\(U\)</span> 為與集合，其中 <span class="math inline">\(|U| = N\)</span>，令 <span class="math inline">\(a_1, a_2, ..., a_n\)</span> 為 n 個性質，其中這些性質直接定義在 <span class="math inline">\(U\)</span> 上且 <span class="math inline">\(N(a_i)\)</span> 表示 <span class="math inline">\(U\)</span> 中滿足性質 <span class="math inline">\(a_i\)</span> 的元素個數。</p>
<ul>
<li>定義
<ul>
<li><span class="math inline">\(N(\bar{a_i})\)</span> 表示 <span class="math inline">\(U\)</span> 中不滿族性質 <span class="math inline">\(a_i\)</span> 的元素個數。</li>
<li><span class="math inline">\(N(a_ia_j)\)</span> 表示 <span class="math inline">\(U\)</span> 中同時滿足性質 <span class="math inline">\(a_i\)</span> 與 <span class="math inline">\(a_j\)</span> 的元素個數。</li>
<li><span class="math inline">\(N(\bar{a_i}\bar{a_j})\)</span> 表示 <span class="math inline">\(U\)</span> 中同時滿足性質 <span class="math inline">\(a_i\)</span> 與 <span class="math inline">\(a_j\)</span> 的元素個數。</li>
</ul></li>
</ul>
<h2 id="lemma-1">Lemma 1</h2>
<p>若有一數 <span class="math inline">\(n\)</span> 有正因數解，該組解必有一正因數「小於等於」<span class="math inline">\(\sqrt{n}\)</span>。</p>
<h3 id="proof">Proof</h3>
<p>若兩正因數都大於 <span class="math inline">\(\sqrt{n}\)</span> ，相乘後不可能為 <span class="math inline">\(n\)</span></p>
<h2 id="ex-97-清大">Ex ( 97 清大 )</h2>
<p>1 ~ 100 中質數有幾個？</p>
<h3 id="sol">Sol</h3>
<p><span class="math display">\[
\because \sqrt{100} = 10 \therefore Consider: 2, 3, 5, 7\\
\begin{matrix}
令 &amp; \; U \; 表示 2 到 100 的所有數所成集合，則 \; N = |U| = 99 \\
 &amp; a_1 表示 U 中大於 2 且為 2 的倍數的性質 \\
 &amp; a_2 表示 U 中大於 3 且為 3 的倍數的性質 \\
 &amp; a_3 表示 U 中大於 5 且為 5 的倍數的性質 \\
 &amp; a_4 表示 U 中大於 7 且為 7 的倍數的性質
\end{matrix} \\
欲求: N(\bar{a_1}\bar{a_2}\bar{a_3}\bar{a_4})\\
\Rightarrow 100 - (\lfloor\frac{100}{2}\rfloor + \lfloor\frac{100}{3}\rfloor+ \lfloor\frac{100}{5}\rfloor+ \lfloor\frac{100}{7}\rfloor) + \\
(\lfloor\frac{100}{6}\rfloor + \lfloor\frac{100}{15}\rfloor+ \lfloor\frac{100}{35}\rfloor+ \lfloor\frac{100}{10}\rfloor + \lfloor\frac{100}{14}\rfloor + \lfloor\frac{100}{21}\rfloor) - \\
(\lfloor\frac{100}{30}\rfloor + \lfloor\frac{100}{70}\rfloor+\lfloor\frac{100}{105}\rfloor + \lfloor\frac{100}{42}\rfloor) + \lfloor\frac{100}{350}\rfloor\\
= 22 -1 + 4  = 25
\]</span></p>
<h2 id="ex-97-台大-尤拉公式說明">Ex ( 97 台大 ) 尤拉公式說明</h2>
<p><span class="math inline">\(n = P_1^{e_1}\times P_2^{e_2}\times P_3^{e_3}, P_i \;is \;prime , e_i &gt; 0\quad Prove: \Phi(n) = n\times(1 - \frac1{P_1}) \times (1 - \frac1{P_2}) \times (1 - \frac1{P_3})\)</span></p>
<h3 id="proof-1">Proof</h3>
<p><span class="math display">\[
U = ｛1, ..., n｝, a_1 = ｛1 &lt; x &lt; n \;\vert\; P_1|x ｝, a_2 = ｛1 &lt; x &lt; n \;\vert\; P_2|x ｝, a_3 = ｛1 &lt; x &lt; n \;\vert\; P_3|x ｝\\
求 \; N(\bar{a_1}\bar{a_2}\bar{a_3}) \\
\Rightarrow n - (\frac{n}{P_1}+\frac{n}{P_2}+\frac{n}{P_3}) + (\frac{n}{P_1P_2} + \frac{n}{P_2P_3} + \frac{n}{P_1P_3}) - \frac{n}{P_1P_2P_3} \\
 = n \times (1-(\frac{1}{P_1}+\frac{1}{P_2}+\frac{1}{P_3}) + (\frac{1}{P_1P_2} + \frac{1}{P_2P_3} + \frac{1}{P_1P_3}) - \frac{1}{P_1P_2P_3}) \\
  = n\times(1 - \frac1{P_1}) \times (1 - \frac1{P_2}) \times (1 - \frac1{P_3})
\]</span></p>
<h2 id="theorem">Theorem</h2>
<blockquote>
<p>m 個<strong>相異物</strong>放置 n 個<strong>相異箱子「不允許」</strong>空箱的方法數。</p>
</blockquote>
<p><span class="math inline">\(|A| = m, |B| = n, m\geq n \Rightarrow onto(m, n) = \sum_{i = 0}^n(-1)^i\binom{n}{i}(n-i)^m\)</span> ( 由 A 集合至 B 集合的<strong>映成函數</strong>個數 )</p>
<blockquote>
<p>箱子不得為「空」，採用<strong>排容原理</strong>。</p>
</blockquote>
<h3 id="proof-2">Proof</h3>
<p><span class="math display">\[
onto(m, n) = n^m - \binom{n}{1}(n-1)^m + \binom{n}{2}(n-2)^m - ... + (-1)^{n-1}\binom{n}{n-1}(1)^m + (-1)^{n}\binom{n}{n}(0)^m\\
 = \sum_{i = 0}^n(-1)^i\binom{n}{i}(n-i)^m
\]</span></p>
<h2 id="stirling-number-of-the-second-kind">Stirling number of the second kind</h2>
<blockquote>
<p>＜Note＞ 分堆</p>
<p>m 個<strong>相異物</strong>放置於 n 個<strong>相同箱子「不允許空箱」</strong>的方法數，也就是將「映成函數個數」扣除重複計算到相同箱子的個數</p>
</blockquote>
<ul>
<li>假設 <span class="math inline">\(m, n\)</span> 為兩個整數，其中 <span class="math inline">\(m \geq n \geq 1\)</span>，定義</li>
</ul>
<p><span class="math display">\[
S(m, n) = \frac{onto(m, n)}{n!} = \frac{\sum_{i = 0}^n(-1)^i\binom{n}{i}(n-i)^m}{n!}
\]</span></p>
<p>稱為第二種 Stirling 數，有時記作 <span class="math inline">\(\begin{Bmatrix} m \\ n \end{Bmatrix}\)</span> ，另外為了方便起見，當 <span class="math inline">\(m &lt; n\)</span> 時，定義 <span class="math inline">\(S(m, n) = 0\)</span></p>
<blockquote>
<p>＜Note＞</p>
<p>m 個<strong>相異物</strong>放置於 n 個<strong>相同箱子「允許空箱」</strong>的方法數 <span class="math display">\[
= S(m, n) + S(m, n-1)+S(m, n-2)+\ldots+S(m, 2)+S(m, 1)
\]</span></p>
</blockquote>
<h2 id="theorem---第二種-stirling-數的遞迴結構">Theorem - 第二種 Stirling 數的遞迴結構</h2>
<blockquote>
<p>可用在演算法的使用上，通常以「Dynamic programming」的方式撰寫。</p>
</blockquote>
<p><span class="math display">\[
S(m+1, n) = S(m, n-1)+S(m, n)
\]</span></p>
<blockquote>
<ul>
<li>Dynamic programming ( 直向軸為 m，橫向軸為 n )</li>
</ul>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td style="text-align: center;">S(1, 1) = 1</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="even">
<td>2</td>
<td style="text-align: center;">S(2, 1) = 1</td>
<td style="text-align: center;">S(2, 2) = 1</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td>3</td>
<td style="text-align: center;">S(3, 1) = 1</td>
<td style="text-align: center;">S(3, 2) = 3</td>
<td style="text-align: center;">S(3, 3) = 1</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="even">
<td>4</td>
<td style="text-align: center;">S(4, 1) = 1</td>
<td style="text-align: center;">S(4, 2) = 7</td>
<td style="text-align: center;">S(4, 3) = 6</td>
<td style="text-align: center;">S(4, 4) = 1</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="odd">
<td>5</td>
<td style="text-align: center;">S(5, 1) = 1</td>
<td style="text-align: center;">S(5, 2) = 15</td>
<td style="text-align: center;">S(5, 3) = 25</td>
<td style="text-align: center;">S(5, 4) = 10</td>
<td style="text-align: center;">S(5, 5) = 1</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="even">
<td>6</td>
<td style="text-align: center;">S(6, 1) = 1</td>
<td style="text-align: center;">S(6, 2) = 31</td>
<td style="text-align: center;">S(6, 3) = 90</td>
<td style="text-align: center;">S(6, 4) = 65</td>
<td style="text-align: center;">S(6, 5) = 15</td>
<td style="text-align: center;">S(6, 6) = 1</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<ul>
<li>使用方法
<ul>
<li>欲求 <span class="math inline">\(onto(6, 3) + onto(6, 4)\)</span></li>
<li>查表加上轉換後：<span class="math inline">\(90\times 3! +65\times 4!\)</span></li>
</ul></li>
</ul>
</blockquote>
<h3 id="proof-組合證法">Proof ( 組合證法 )</h3>
<ul>
<li>S(m+1, n)：m+1 個相異物<strong>分成 n 堆</strong>，固定一物 A
<ul>
<li>A 為邊緣人<span class="math inline">\(\Rightarrow S(m, n-1)\)</span></li>
<li>A 有孤單病，所以在 n 堆中挑一堆進入 <span class="math inline">\(\Rightarrow S(m, n)\times n\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Discrete Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>排容原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine learning - Artificial Neural Networks 類神經網路學習</title>
    <url>/willywangkaa/2018/04/25/Machine%20learning-Artificial-Neural-Networks-%E9%A1%9E%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%E5%AD%B8%E7%BF%92/</url>
    <content><![CDATA[<h1 id="artificial-neural-networks-類神經網路概論-未完成">Artificial Neural Networks 類神經網路概論( 未完成 )</h1>
<hr />
<h2 id="簡介">簡介</h2>
<p>類神經網絡是一種受生物學啟發而產生的一種模擬人腦的學習系統。 <a href="https://youtu.be/gcK_5x2KsLA">Youtube - 介紹神經元與類神經的關係</a></p>
<figure>
<img src="\willywangkaa\images\neuralgraph.png" alt="neuralgraph" /><figcaption aria-hidden="true">neuralgraph</figcaption>
</figure>
<p>↑ 神經元示意圖( *synapse：比重 )</p>
<p>對於神經(neuron)我們有一個簡單的抽象：每個神經元是與其他神經元連結在一起的，一個神經元會受到多個其他神經元狀態的衝擊，並由此決定自身是否激發。</p>
<p>神經細胞透過輸入神經樹由其它神經細胞輸入脈波訊號後，經過神經細胞核的處理，其處理大約是：</p>
<ol type="1">
<li>將收集到的訊號作<strong>加總</strong></li>
<li><strong>非線性轉換</strong></li>
<li>產生一個新的脈波信號</li>
</ol>
<p>如果這個訊號夠強，則新的脈波信號會由神經軸傳送到輸出神經樹，再透過神經節將此訊號傳給其它神經細胞。值得注意的是：當訊號經過神經節後，由於<strong>神經節加權值</strong>的影響，其訊號大小值會改變。</p>
<p>神經網絡裡的結點相互連結決定了輸入的數據在裡面經過怎樣的計算。我們可以通過大量的輸入，讓神經網絡調整它自身的連接情況從而總是能夠得到我們預期的輸出。</p>
<figure>
<img src="\willywangkaa\images\neuralgraph2.png" alt="neuralgraph2" /><figcaption aria-hidden="true">neuralgraph2</figcaption>
</figure>
<p><strong>＜比較＞</strong>電腦裡的模擬神經網路的架構需具備：</p>
<ul>
<li>模擬頭腦神經的連結( 包含模擬突觸、細胞本體( 隱藏層 )、軸突 )</li>
<li>每個神經節點</li>
<li>實數的輸入與輸出</li>
<li>極大量的資訊</li>
<li>遷移學習( Transfer learning )
<ul>
<li><a href="https://www.youtube.com/watch?v=fCEHdyLkjNE">基礎概念 - 周莫烦 - 站在巨人的肩膀上, 迁移学习 Transfer Learning</a></li>
<li><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/5-16-transfer-learning/">實際應用( Python ) - 周莫烦 - 迁移学习 Transfer Learning</a></li>
<li><a href="https://www.zhihu.com/question/41979241">什么是迁移学习 (Transfer Learning)？这个领域历史发展前景如何？</a></li>
</ul></li>
</ul>
<h2 id="感知器-perceptron">感知器 ( Perceptron )</h2>
<p>設有 <span class="math inline">\(n\)</span> 維輸入的單個感知機( 從其他類神經元接收到的資訊 )，<span class="math inline">\(a_1\)</span> 至 <span class="math inline">\(a_n\)</span> 為 <span class="math inline">\(n\)</span> 維輸入向量的各個分量，<span class="math inline">\(w_1\)</span> 至 <span class="math inline">\(w_n\)</span> 為各個輸入分量連接到感知機的權值( 比重 )，<span class="math inline">\(w_0\)</span> 為偏置( 常數 )，一個神經元( Cell Body )分成兩個步驟，第一個 <span class="math inline">\(\sum\)</span> 為<strong>彙總</strong>資料，後面那個 <span class="math inline">\(f(.)\)</span> 為<strong>傳遞函數</strong>( 圖上的函數是"Sign function" )，判斷最後輸出的值， 最後以<strong>純量輸出( 1 or -1 )</strong>。</p>
<p><span class="math display">\[
Input: x_1, x_2, …,x_n
\]</span></p>
<p><span class="math display">\[
Output: 1 or  -1
\]</span></p>
<figure>
<img src="\willywangkaa\images\perceptrongraph.png" alt="perceptrongraph" /><figcaption aria-hidden="true">perceptrongraph</figcaption>
</figure>
<ul>
<li><strong>類神經元</strong>示意圖
<ul>
<li><strong>＜注意＞</strong><span class="math inline">\(w_0\)</span>不是伴隨其他的資訊傳進神經元的，而是因為某些演算法的需求，而另外多加的一個<strong>閾值</strong>( 正負常數值 )。</li>
<li>$ _{i = 0}^n W_i X_i$又稱為<strong>淨輸入( Net Input )</strong>，可處理線性組合的假說空間( Hypotheses )。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\sgn_triggerfunction.png" alt="sgn_triggerfunction" /><figcaption aria-hidden="true">sgn_triggerfunction</figcaption>
</figure>
<p>上圖為此神經元判斷的觸發函數( 每個神經元的判斷都不盡相同，此為其中一種 )，帶入剛剛所算的淨輸入，計算輸出( -1就是判斷為無反應的狀況 )。</p>
<ul>
<li><p><strong>權值(</strong><span class="math inline">\(w\)</span><strong>)</strong>：如果當前神經元的某個輸入值權值為零，則當前神經元激發與否與這個輸入值無關；如果某個輸入值的<em>權重為正</em>，它對於當前神經元的激發值產生<em>正影響</em>。反之，如果<em>權重為負</em>，則它對激發值產生<em>負影響</em>。</p></li>
<li><p><strong>偏移量(</strong><span class="math inline">\(w_0\)</span><strong>)</strong>：它定義了神經元的激發臨界值在空間上，它對決策邊界(decision boundary) 有<em>平移作用</em>，<em>就像常數作用在一次或二次函數上的效果</em>。感知器表示為<strong>輸入向量與權向量內積</strong>時，偏置被引申為<strong>權量</strong>，而對應的輸入值為 1。</p></li>
<li><p><strong>決策邊界(decision boundary)</strong>：設輸入向量與權向量的<strong>內積為零</strong>，可得出 n+1 維的<strong>超平面</strong>。平面的法向量為 w，並經過 n+1 維輸入空間的原點。法向量指向的<strong>輸入空間</strong>，其輸出值為<strong>+1</strong>，而與法向量<strong>反向的輸入空間</strong>，其輸出值則為<strong>−1</strong>。故可知這個超平面<strong>定義了決策邊界</strong>，並把輸入空間劃分為二。</p></li>
</ul>
<figure>
<img src="\willywangkaa\images\decisionboundery.png" alt="decisionboundery" /><figcaption aria-hidden="true">decisionboundery</figcaption>
</figure>
<ul>
<li><strong>激勵函數(activation function)</strong>：激勵函數代表神經元在什麼輸入情況下，才觸發動作。</li>
</ul>
<figure>
<img src="\willywangkaa\images\activationfunction.png" alt="activationfunction" /><figcaption aria-hidden="true">activationfunction</figcaption>
</figure>
<h3 id="感知器可以學習的函數">感知器可以「學習」的函數</h3>
<figure>
<img src="\willywangkaa\images\singlelayertwoinputperceptron.png" alt="singlelayertwoinputperceptron" /><figcaption aria-hidden="true">singlelayertwoinputperceptron</figcaption>
</figure>
<p>Consider a 2-input perceptron ( 感知器 ) : It outputs 1 iff</p>
<p><span class="math display">\[
o( x_1, x_2 ) = ( w_0+w_1 \cdot x_1+w2 \cdot x2 &gt; 0 )?
\]</span></p>
<div style="text-align: center">
equivalent to
</div>
<p><span class="math display">\[
o( x_1, x_2 ) = sgn( w_0+w_1 \cdot x_1+w2 \cdot x2 )
\]</span></p>
<h4 id="what-weights-represent-and-x1-x2">What weights represent <span class="math inline">\(AND (x1, x2)\)</span>?</h4>
<p><span class="math inline">\(w_0 = -0.8, w_1 = w_2 = 0.5\)</span><br><span class="math inline">\(o( x_1, x_2 ) \Rightarrow sgn(-0.8 + 0.5 \cdot x_1 + 0.5 \cdot x_2 )\)</span></p>
<figure>
<img src="\willywangkaa\images\weighttorepresentAND.png" alt="weighttorepresentAND" /><figcaption aria-hidden="true">weighttorepresentAND</figcaption>
</figure>
<h4 id="what-weights-represent-or-x1-x2">What weights represent <span class="math inline">\(OR (x1, x2)\)</span>?</h4>
<p><span class="math inline">\(w_0 = 0.3, w_1 = w_2 = 0.5\)</span><br><br><span class="math inline">\(o( x_1, x_2 ) = sgn(0.3 + 0.5 \cdot x1 + 0.5 \cdot x2 )\)</span></p>
<figure>
<img src="\willywangkaa\images\weighttorepresentOR.png" alt="weighttorepresentOR" /><figcaption aria-hidden="true">weighttorepresentOR</figcaption>
</figure>
<h4 id="what-weights-represent-not-x1-x2">What weights represent <span class="math inline">\(NOT (x1, x2)\)</span>?</h4>
<p><span class="math inline">\(w_0 =0.0, w_1 = -1.0, w_2 = 0\)</span><br><br><span class="math inline">\(o(x_1) = sgn( 0.0 –1.0x_1)\)</span></p>
<figure>
<img src="\willywangkaa\images\weighttorepresentNOT.png" alt="weighttorepresentNOT" /><figcaption aria-hidden="true">weighttorepresentNOT</figcaption>
</figure>
<h4 id="what-weights-represent-xor-x1-x2">What weights represent <span class="math inline">\(XOR (x1, x2)\)</span>?</h4>
<p>Not possible.</p>
<figure>
<img src="\willywangkaa\images\possibletorepresentXOR.png" alt="possibletorepresentXOR" /><figcaption aria-hidden="true">possibletorepresentXOR</figcaption>
</figure>
<p><strong>＜NOTE＞</strong>Not linearly separable <span class="math inline">\(\rightarrow\)</span> Can not be represented by a <strong>single percepton</strong>.<br><br> <strong>Solution: use multilayer networks.</strong></p>
<figure>
<img src="\willywangkaa\images\multilayertorepresentXOR.png" alt="multilayertorepresentXOR" /><figcaption aria-hidden="true">multilayertorepresentXOR</figcaption>
</figure>
<h2 id="how-to-determine-a-weight-vector-如何決定權重向量">How to Determine a Weight Vector? <br>如何決定權重向量？</h2>
<hr />
<p>在類神經網路學習的過程中，最重要的就是權重向量( Weight Vector )，因為這就是決定到時候感知器( Perceptrons )能不能做出正確預測( correct <span class="math inline">\(\pm 1\)</span> output )的關鍵依據。</p>
<p>通常來說，都會給定一組訓練範例( Trainning example )，而且，每個元素裡必定會含有輸入( Input )與輸出( Output )。</p>
<ul>
<li><span class="math inline">\(( x_1, x_2, x_3, \ldots , x_{n-1}, x_n )\)</span> 是訓練範例中會給的資訊。</li>
<li><span class="math inline">\(+1 \; or \; -1\)</span> 為 <span class="math inline">\(( x_1, x_2, x_3, \ldots , x_{n-1}, x_n )\)</span> 的已知輸出( Target value )。</li>
</ul>
<p>而我們的目標就是將 <span class="math inline">\(( w_1, w_2, w_3, \ldots , w_{n-1}, w_n )\)</span> 訓練出來。</p>
<p>解決的演算法有很多，在這邊只討論其中兩個：</p>
<ul>
<li>The perception trainnin rule</li>
<li>Gradient decent ( or call the delta rule )</li>
</ul>
<h3 id="perceptron-training-rule">Perceptron Training Rule</h3>
<ul>
<li><p><span class="math inline">\(t = c(x_1, x_2, x_3, ..., x_n )\)</span> 是我們<strong>已知道</strong>的結果( 1 or -1 )。</p></li>
<li><p><span class="math inline">\(o：\)</span>對於訓練資料$ (x_1, x_2, x_3, ..., x_n ) $以感知器( Perceptron )測試後出來的結果( 1 or -1 )。 <strong>＜Note＞：</strong>Here o is the output of Perceptron, not the target value.</p></li>
<li><p>所以 $ ( t - o ) $ 為此時感知器( Perceptron )的誤差，然後藉由我們設定的 <span class="math inline">\(\eta\)</span> 函式判斷要對目前的 <span class="math inline">\(w\)</span> 修正多少值。</p></li>
</ul>
<h4 id="演算法">演算法</h4>
<ul>
<li><p>Initialize weights (w0, w1, w2, x3, ...,wn ) to random values</p></li>
<li><p>Loop through training examples： <span class="math inline">\(w_i \leftarrow w_i + \Delta w_i\)</span> Where <span class="math inline">\(\Delta w_i = \eta (t-o) \cdot x_i\)</span> and <span class="math inline">\(\eta\)</span> is a learning rate (small positive value, e.g., 0.1)<br><br></p></li>
<li><p>Given training data set</p></li>
</ul>
<p><span class="math display">\[
D = \{ ( \vec{x}, t ) \}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Initialize all weights w_i to random values</span></span><br><span class="line">w[] &lt;- random values</span><br><span class="line">WHILE <span class="keyword">not</span> all examples correctly predicted DO</span><br><span class="line">	FOR each training example </span><br><span class="line">	x = (x_1, x_2, x_3, ..., x_n ) in D</span><br><span class="line">		Compute current output <span class="built_in">o</span> ( x_1, x_2, x_3, ..., x_n ) </span><br><span class="line">		FOR i = <span class="number">0</span> to n</span><br><span class="line">		    <span class="comment">// always let x_0=1</span></span><br><span class="line">			w_i  w_i + <span class="built_in">eta</span>(t - o) * x_i   </span><br></pre></td></tr></table></figure>
<p><strong>＜Note＞</strong> If (t-o) = 0, no change in weight.</p>
<p>輪過一遍所有訓練資料，稱之為一個時代( Epoch )，若一個時代過後還有 <span class="math inline">\(w_i\)</span> 是錯誤的就繼續修改 <span class="math inline">\(w_i\)</span> ，直到某個時代所有的 $ w_i $ 可以讓 $ x_i $ 輸出正確。 <strong>＜注意＞：</strong>如果訓練資料是<strong>線性可分離</strong>( XOR就不可線性分離 )，且<span class="math inline">\(\eta\)</span>是小於1的很小的值，那麼一定最後可以在<strong>有限的世代</strong>找到最後的感知器( Perceptron )。<br><br></p>
<p>倘若今天的資料是無法被線性分離的改如何處理？ - <strong>Approach 1:</strong> 建立一個演算法可以努力找到逼近值。 E.g. gradient descent method ( 梯度下降法 ) - <strong>Approach 2:</strong> 建立不同架構或多層( Multilayer networks )結構的神經網路以突破限制。</p>
<h3 id="gradient-descent">Gradient Descent</h3>
<p><a href="https://www.youtube.com/watch?v=_-02ze7tf08">Youtube - Gradient Decent 介紹</a></p>
<p>我們需要在 <span class="math inline">\((n+1)\)</span> 維的假說向量空間( Hypotheses Space )中搜索最合適( Best fit )的權值向量，我們需要有一定的規則指導我們的搜索，採用沿著梯度<strong>反方向</strong>往下走的方法，就稱為「梯度下降法」(Gradient Descent)。這種方法可以說是一種「貪婪演算法」(Greedy Algorithm)，因為它每次都朝著最陡的方向走去，企圖得到最大的下降幅度。即使訓練資料是不可線性分離的( Not lineary separable )，最後這個演算法還是會收斂在極趨近於目標想法的銓重向量停止。</p>
<p><strong>＜注意＞：</strong> <em>Least square</em>為最常用來檢測誤差的方法。</p>
<p>為了要計算梯度，我們不能採用不可微分的 sign() 步階函數，因為這樣就不能用<strong>微積分</strong>的方式計算出<strong>梯度</strong>了，而必須改用可以微分的連續函數 sigmoid()，這樣才能夠透過微分計算出梯度。</p>
<p><span class="math display">\[
E(w) = \frac{1}{2} \sum_{d \in D} ( t_d - o_d )
\]</span></p>
<p>上面公式中<span class="math inline">\(D\)</span>代表了所有的輸入案例( 或者說是樣本 )，<span class="math inline">\(d\)</span>代表了一個樣本實例，<span class="math inline">\(o_d\)</span>表示感知器的輸出，<span class="math inline">\(t_d\)</span>代表我們預想的輸出。</p>
<p>首先，我們先看看權重( Weight vector )向量 <span class="math inline">\(w\)</span> 的梯度( Gradient )為何：</p>
<p><span class="math display">\[
\bigtriangledown E( w ) = \frac{\partial E}{\partial w} = ( \frac{\partial E}{\partial w_0}, \frac{\partial E}{\partial w_1}, \ldots, \frac{\partial E}{\partial w_n} )
\]</span></p>
<p><strong>＜注意＞：</strong> <em>梯度</em> 是一個裡面所有元素為對 <span class="math inline">\(E\)</span> 以對每個 <span class="math inline">\(w_i\)</span> 偏微分的<strong>向量</strong>。且這個向量指向的地方為最上坡之處。( 如下圖紅色處顯示，而下方黑色箭頭則表示該梯度投影下來所對應的方向 )</p>
<figure>
<img src="\willywangkaa\images\gradient.png" alt="gradient" /><figcaption aria-hidden="true">gradient</figcaption>
</figure>
<p>所以 <strong>Gradient Descent</strong> 就是該點梯度的 <em>反方向</em> ，也就是最下坡的方向，<span class="math inline">\(i.e. \; -\bigtriangledown E(w)\)</span>。</p>
<p>這樣目標就明確了，欲在假說空間找到一組權值 <span class="math inline">\(w\)</span> 讓這個誤差的值最小，顯然我們用<strong>誤差對權值</strong>求導將是一個很好的選擇，導數的意義是提供了一個方向，沿著這個方向改變權值，將會讓總的<strong>誤差變大</strong>，更形象的叫它為梯度。</p>
<p>既然梯度確定了E最陡峭的上升的方向，那麼梯度下降的訓練法則是：</p>
<p><span class="math display">\[
\vec{w_i} \leftarrow \vec{w_i} + \Delta \vec{w_i}, \quad where \; \Delta \vec{w_i} = \eta \frac{\partial E}{\partial w_i}
\]</span></p>
<figure>
<img src="\willywangkaa\images\gradientgraph.png" alt="gradientgraph" /><figcaption aria-hidden="true">gradientgraph</figcaption>
</figure>
<h4 id="e.x."><span class="math inline">\(E.x.\)</span></h4>
<ul>
<li><p>Example: two weights: <span class="math inline">\(w = (w_0, w_1)\)</span></p>
<ul>
<li>Error surface <span class="math inline">\(E\)</span> is parabolic (by definition)</li>
<li>Single global minimum</li>
<li>Arrow: negated gradient at one point</li>
<li>Steepest descent along the surface</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\examplegradient.png" alt="examplegradient" /><figcaption aria-hidden="true">examplegradient</figcaption>
</figure>
<p>For the least square error function, gradient is easy to calculate:</p>
<p><span class="math display">\[
\bigtriangledown E( w ) = \frac{\partial E}{\partial w} = \frac{1}{2} \cdot \frac{\partial \sum_{d \in D} (t_d - o_d)^2}{\partial w_i} = \frac{1}{2} \sum_{d \in D}\frac{\partial (t_d - o_d)^2}{\partial w_i}
\]</span></p>
<p><span class="math display">\[
\Rightarrow \frac{1}{2} \cdot \sum_{d \in D} (2 \cdot (t_d - o_d)\frac{\partial( t_d - o_d )}{\partial w_i}) = \sum_{d\in D}((t_d - o_d)\frac{\partial(t_d - w\cdot x_d)}{\partial w_i})
\]</span></p>
<p><span class="math display">\[
\Rightarrow \sum_{d\in D} ((t_d - o_d)(-x_{id}))
\]</span></p>
<p>依上述，公式就可以簡化成：</p>
<p><span class="math display">\[
\Delta w_i = -\eta \frac{\partial E}{\partial w_i}
\]</span></p>
<p><span class="math display">\[
and
\]</span></p>
<p><span class="math display">\[
\frac{\partial E}{\partial w_i} = \sum_{d \in D}((t_d - o_d)(-x_{id}))
\]</span></p>
<p>最後公式變成：</p>
<figure>
<img src="\willywangkaa\images\gradientdecentfinalformula.png" alt="gradientdecentfinalformula" /><figcaption aria-hidden="true">gradientdecentfinalformula</figcaption>
</figure>
<h1 id="參考">參考</h1>
<hr />
<p><a href="http://mropengate.blogspot.tw/2015/06/ch15-4-neural-network.html">Mr' opengate - AI - Ch16 機器學習(4), 類神經網路 Neural network</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">Wikipedia - 人工神經網路</a></p>
<p><a href="https://www.youtube.com/watch?v=fCEHdyLkjNE">基礎概念 - 周莫烦 - 站在巨人的肩膀上, 迁移学习 Transfer Learning</a></p>
<p><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/5-16-transfer-learning/">實際應用( Python ) - 周莫烦 - 迁移学习 Transfer Learning</a></p>
<p><a href="https://www.zhihu.com/question/41979241">什么是迁移学习 (Transfer Learning)？这个领域历史发展前景如何？</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Artificial Neural Networks</tag>
        <tag>Gradient Decent</tag>
        <tag>Perceptron trainning rule</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine learning - Supervised learning</title>
    <url>/willywangkaa/2018/04/20/Machine-learning-Supervised-learning/</url>
    <content><![CDATA[<h1 id="supervised-learning-監督式學習">Supervised learning 監督式學習</h1>
<p>Concept Learning 概念式學習</p>
<figure>
<img src="\willywangkaa\images\machinelearningconcept.png" alt="machinelearningconcept" /><figcaption aria-hidden="true">machinelearningconcept</figcaption>
</figure>
<h2 id="機器學習簡介-節錄自-mr-opengate">機器學習簡介<br>( 節錄自 <a href="http://mropengate.blogspot.tw/2015/05/ai-supervised-learning.html">Mr' OpenGate</a> )</h2>
<p>機器學習是近20多年興起的一門多領域交叉學科，涉及<strong>機率論</strong>、<strong>統計學</strong>、<strong>逼近論</strong>、<strong>凸分析</strong>、<strong>計算複雜性理論</strong>等多門學科。機器學習理論主要是設計和分析一些讓計算機可以自動「學習」的演算法。機器學習算法是一類從資料中<strong>自動分析獲得規律</strong>，並利用規律對<strong>未知資料進行預測</strong>的算法。</p>
<p>機器學習已廣泛應用於<strong>數據挖掘</strong>、<strong>計算機視覺</strong>、<strong>自然語言處理</strong>、<strong>生物特徵識別</strong>、<strong>搜尋引擎</strong>、<strong>醫學診斷</strong>、<strong>檢測信用卡欺詐</strong>、<strong>證券市場分析</strong>、<strong>DNA序列測序</strong>、<strong>語音和手寫識別</strong>、<strong>戰略遊戲</strong>和<strong>機器人</strong>等領域。</p>
<p><strong>＜定義＞</strong> 機器學習定義如下</p>
<p><code>A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.</code></p>
<h3 id="ex."><span class="math inline">\(Ex.\)</span></h3>
<ul>
<li>T(任務)：將郵件分類為垃圾或非垃圾。</li>
<li>E(經驗)：觀察目前信箱的信是把哪些種類的郵件標記為垃圾，而哪些是非垃圾。</li>
<li>P(效能)：被正確分類成垃圾或非垃圾的郵件的數量。</li>
</ul>
<figure>
<img src="\willywangkaa\images\supervisedlearningworkflow.png" alt="supervisedlearningworkflow" /><figcaption aria-hidden="true">supervisedlearningworkflow</figcaption>
</figure>
<h2 id="一種歸納的方式">一種歸納的方式</h2>
<ul>
<li>從已知的現象訓練機器判斷常態的結果，而已知的現象只有<strong>是非</strong>之結論。(所以用這個方法訓練出來的智能只能判斷<strong>對錯</strong>)</li>
<li>所以以這種方法訓練的<strong>智能</strong>我們可以看待它是一個布林函數(Boolean-valued Funciotn)。</li>
<li>輸入 - 欲判斷的狀態 (Attributes)。</li>
<li>輸出 - 對(TURE)、錯(FALSE)。</li>
</ul>
<figure>
<img src="\willywangkaa\images\learningfunction.png" alt="learningfunction" /><figcaption aria-hidden="true">learningfunction</figcaption>
</figure>
<h2 id="環境狀態-attribute-學習目標-target-concept">環境狀態( Attribute )、<br>學習目標( Target Concept )</h2>
<h3 id="example-from-bookenjoy-sport">Example from book：Enjoy sport</h3>
<figure>
<img src="\willywangkaa\images\conceptlearningenjoysportdata.png" alt="conceptlearningenjoysportdata" /><figcaption aria-hidden="true">conceptlearningenjoysportdata</figcaption>
</figure>
<ul>
<li>六個會影響的<strong>環境狀態 ( Attribute )</strong></li>
<li>四個<strong>案例 ( Instance )</strong></li>
<li>學習目標：<strong>判斷</strong>當時是否很享受運動。<span class="math inline">\(EnjoySport = \{Yes, No\}\)</span></li>
</ul>
<h4 id="環境狀態-attribute">環境狀態( Attribute )</h4>
<ul>
<li>每個事件(instance)發生時會引響結果的<em>基本元素</em>。</li>
<li>倘若現在有一事件會被影響的環境狀態為 <span class="math inline">\(N\)</span> 個。</li>
<li>每個環境狀態可能出現的狀態個數為 <span class="math inline">\(n_i\)</span> 。(第 <span class="math inline">\(i\)</span> 個環境狀態)</li>
<li><strong>(Nominal values; symbolic values; Discretized values)</strong>(? 待了解)</li>
</ul>
<h4 id="案例-instance---已知結果的一群環境狀態">案例( Instance ) - 已知結果的一群環境狀態</h4>
<ul>
<li>令 <span class="math inline">\(x\)</span> 為已知結果的一群環境狀態。</li>
<li>那我們稱所有可能產生的案例為一個空間(Space)並稱它 <span class="math inline">\(X\)</span>。</li>
<li>若 <span class="math inline">\(M\)</span> 等於此空間 <span class="math inline">\(X\)</span> 的大小，則 $ M = n_1 n_2 n_{N-1} n_N$。</li>
<li>我們其實可以將 <span class="math inline">\(M\)</span> 視為此環境狀態所有組合的方法數。</li>
</ul>
<h4 id="學習目標-target-concept">學習目標( Target Concept )</h4>
<ul>
<li>要學到的想法(在這裡我們給機器訓練的想法也可視為一個函式)。
<ul>
<li><span class="math inline">\(c(x)=1 \qquad if \; EnjoySport=Yes\)</span></li>
<li><span class="math inline">\(c(x)=0 \qquad if \; EnjoySport=No\)</span></li>
</ul></li>
<li><span class="math inline">\(c\)</span> 是一個定義再<strong>案例空間(Instance Space)</strong>的布林函數。
<ul>
<li><span class="math inline">\(c:X \rightarrow \left\{ 0, 1 \right\}\)</span></li>
</ul></li>
<li>訓練集合 "<span class="math inline">\(D\)</span>"
<ul>
<li>所有已知想法的案例集合</li>
<li><span class="math inline">\(Ex.\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
 &lt;x_1, c(x_1)&gt;, &lt;x_2, c(x_2)&gt; \ldots &lt;x_m, c(x_m)&gt;
 \]</span></p>
<h4 id="假說-hypotheses---在這裡我們標記為-h">假說( Hypotheses ) - 在這裡我們標記為 <span class="math inline">\(H\)</span></h4>
<ul>
<li>定義：所有<strong>環境狀態( Attributes )</strong>之<strong>限制( Constraints )</strong> 的<strong>交集( Conjunction )</strong>。</li>
<li>限制( Constraints )的種類
<ul>
<li>Specific value ( <strong>針對</strong>值 ) <span class="math inline">\(\qquad e.g. \; ( sky = sunny )\)</span></li>
<li>Don't care value ( <strong>不在意</strong>值 ) <span class="math inline">\(\qquad e.g. \; ( sky = &quot;？&quot; )\)</span></li>
<li>No value allow ( <strong>無</strong>值 ) <span class="math inline">\(\qquad e.g. \; ( sky = &quot;\phi&quot; )\)</span></li>
</ul></li>
<li>若今天有一<strong>案例( Instance )</strong>符合了我們的假說，也就是說它每個<strong>環境狀態( Attributes )</strong>全部都不逾越我們假說中的所有<strong>限制( Constraints )</strong>。</li>
<li><span class="math inline">\(Ex.\)</span></li>
</ul>
<p><span class="math display">\[
h \leftarrow &lt; Sunny, Warm, ?, Strong, ?, ? &gt;
\]</span></p>
<ul>
<li>假說空間( Hypotheses Space )的大小
<ul>
<li>語意上來說( Syntactically distinct number )</li>
</ul></li>
</ul>
<p><span class="math display">\[
M_H = ( n_1 + 2 ) \cdot ( n_2 + 2 ) \cdot \ldots \cdot ( n_{N-1} + 2 ) \cdot ( n_{N} + 2 )
\]</span></p>
<p><span class="math display">\[
( Two \; more \; &quot;values&quot; \; have \; been \; added, &quot;?&quot; and &quot;\phi&quot; )
\]</span></p>
<ul>
<li>實際上來說( Semantically distinct number )</li>
</ul>
<p><span class="math display">\[
M_H = 1+ ( n_1 + 1 ) \cdot ( n_2 + 1 ) \cdot \ldots \cdot ( n_{N-1} + 1 ) \cdot ( n_{N} + 1 )
\]</span></p>
<p>因為如果該假說的限制交集裡，有一個以上的""存在於集合中，代表所有的案例( Instances )絕對都不可能不逾越我們的假說，全部的案例都會判定為錯誤(False)。</p>
<h4 id="小節論">小節論</h4>
<ul>
<li><p><span class="math inline">\(c:EnjoySport : X \rightarrow \{ 0, 1 \}\)</span> 是我們的<strong>學習目標( Target Concept )</strong>。</p></li>
<li><p>六個<strong>環境狀態( Attributes )</strong>：</p>
<ul>
<li>Sky ( 可能的變數有三種 )</li>
</ul>
<p><span class="math display">\[\{ Sunny, Cloudy, Rainy \}\]</span></p>
<ul>
<li>Airtamp ( 可能的變數有兩種 )</li>
</ul>
<p><span class="math display">\[\{ Warm, Cold \}\]</span></p>
<ul>
<li>Humidity ( 可能的變數有兩種 )</li>
</ul>
<p><span class="math display">\[\{ Normal, High \}\]</span></p>
<ul>
<li>Wind ( 可能的變數有兩種 )</li>
</ul>
<p><span class="math display">\[\{ Strong, Light \}\]</span></p>
<ul>
<li>Water ( 可能的變數有兩種 )</li>
</ul>
<p><span class="math display">\[\{ Cold, Warm \}\]</span></p>
<ul>
<li>Forecast ( 可能的變數有兩種 )</li>
</ul>
<p><span class="math display">\[\{ Same, Change\}\]</span></p></li>
<li><p>案例空間的大小 <span class="math inline">\(= 3 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 = 96\)</span></p></li>
<li><p>假說空間的大小 <span class="math inline">\(= 1 + ( 4 \cdot 3 \cdot 3 \cdot 3 \cdot 3 \cdot 3 ) = 973\)</span> ( 實際上 )</p></li>
</ul>
<p>現在知道目前的假說空間大小後，就要開始找到符合我們期望( Target )的假說( Hypotheses )，那要從何先下手呢？首先，我們可以先從現有的訓練資料使用，其中，我們還可以了解一個概念－－－<strong>Inductive learning hypothesis</strong>，意思是說，我們今天使用訓練的資訊來找到一個最靠近的假說時，我們也可以找到一些潛在的的規則包含在我們找到的假說之中，其中會有我們從為訓練過的<strong>案例( Instance )</strong>在內。</p>
<p><strong>＜注意＞：</strong>在實務上來說，有可能訓練的難度會急遽上升，有可能我們的假說空間會超級大，甚至於無限大也有可能，所以要一個個要從所有的假說找到我們需要的是不太可能的，<strong>那怎麼辦呢？</strong>我們可以利用假說空間的一個特性－－－Partial Ordering，也就是說，這個空間裡的元素，是可以依照一個順序大小排列的。</p>
<h2 id="假說空間的廣至收斂-general-to-specific-ordering-over-hypotheses">假說空間的廣至收斂<br>General-to-Specific Ordering over Hypotheses</h2>
<p>首先定義幾個名詞，我們有： - 案例( Instance )：<span class="math inline">\(x\)</span> - 假說( Hypothesis )：<span class="math inline">\(h\)</span> - 若今天 <span class="math inline">\(h(x) = 1\)</span> ，稱之 Positive ( True ) Outcome。</p>
<p>由廣至收斂，定義若 <span class="math inline">\(H_1 \geq_g H_2\)</span>，則可以說 <span class="math inline">\(H_1\)</span> 比 <span class="math inline">\(H_2\)</span>還要更廣( General )，舉例：</p>
<p><span class="math display">\[
\{ Sunny, ?, ?, ?, ?, ? \} \geq_g \{ Sunny, ?, ?, Strong, ?, ? \}
\]</span></p>
<figure>
<img src="\willywangkaa\images\GtoSpraph.png" alt="GtoSprap" /><figcaption aria-hidden="true">GtoSprap</figcaption>
</figure>
<h2 id="find-s-algorithm">Find S Algorithm</h2>
<ol type="1">
<li>將假說 <span class="math inline">\(h\)</span> 初始化為假說空間 <span class="math inline">\(H\)</span> 中的最特殊假說 ${ , , , , , } $</li>
<li>對每個<strong>正例</strong> <span class="math inline">\(x\)</span> ( <strong>＜注意＞</strong>我們只使用正例( Positive Outcome )，不用反例！ )<br></li>
</ol>
<ul>
<li>對 <span class="math inline">\(h\)</span> 的每個環境狀態( Attribute )進行約束 如果 <span class="math inline">\(x\)</span> 的該環境狀態滿足 <span class="math inline">\(h\)</span> 對應的環境狀態，那麼不做任何處理。 否則將 <span class="math inline">\(h\)</span> 中該環境狀態一般化( Generalize ) 以滿足 <span class="math inline">\(x\)</span> 的環境狀態。</li>
</ul>
<ol start="3" type="1">
<li>重複直到所有正例都被尋遍。</li>
<li>輸出最後唯一的假說 <span class="math inline">\(h\)</span> ，而這個假說正是我們使用訓練資料中的正例所能訓練出最收斂的假說。</li>
</ol>
<figure>
<img src="\willywangkaa\images\findsalgorithm.png" alt="findsalgorithm" /><figcaption aria-hidden="true">findsalgorithm</figcaption>
</figure>
<h2 id="version-space">Version Space</h2>
<h3 id="definition-consistent-hypotheses-認同假說">Definition: Consistent Hypotheses( 認同假說 )</h3>
<p>若有假說 <span class="math inline">\(h\)</span> 以訓練集合所有的案例進行測試，輸出結果和我們的想法一致，就可以聲明假說 <span class="math inline">\(h\)</span> 為認同假說( Consistent Hypotheses )。( 下方為原始定義 )</p>
<p>A hypothesis <span class="math inline">\(h\)</span> is consistent with a set of training examples <span class="math inline">\(D\)</span> of <strong>target concept</strong> <span class="math inline">\(c\)</span> if and only if <span class="math inline">\(h(x) = c(x)\)</span> for each training example <span class="math inline">\(&lt;x, c(x)&gt;\)</span> in <span class="math inline">\(D\)</span>.</p>
<p><span class="math display">\[
Consistent (h, D) \equiv ( \; \forall &lt;x, c(x ) \in D \;)  h(x) = c(x))
\]</span></p>
<h3 id="definition-version-space-候選空間">Definition: Version Space ( 候選空間 )</h3>
<p>候選空間就是對於該測試的資料集，所有的認同假說所組合的空間，因為每個假說都可以符合目前的訓練資料的期望，所以每個假說都等待我們再進一步驗證。( 下方為原始定義 ) The version space <span class="math inline">\(VS_{H,D}\)</span> , with respect to hypothesis space <span class="math inline">\(H\)</span> and training examples <span class="math inline">\(D\)</span>, is the subset of hypotheses from <span class="math inline">\(H\)</span> consistent with all training examples in <span class="math inline">\(D\)</span>.</p>
<p><span class="math display">\[
VS_{H,D} \equiv \{ h \in H \; | \; Consistent (h, D) \}
\]</span></p>
<figure>
<img src="\willywangkaa\images\versionspacegraph.png" alt="versionspacegraph" /><figcaption aria-hidden="true">versionspacegraph</figcaption>
</figure>
<ul>
<li>Version space for a "rectangle" hypothesis language in two dimensions. Green pluses are positive examples, and red circles are negative examples. GB is the maximally general positive hypothesis boundary, and SB is the maximally specific positive hypothesis boundary. The intermediate (thin) rectangles represent the hypotheses in the version space.</li>
</ul>
<p>Definition: General Boundary General boundary <span class="math inline">\(G\)</span> of version space <span class="math inline">\(VS_{H,D}\)</span> : set of most general members</p>
<p>Definition: Specific Boundary Specific boundary <span class="math inline">\(S\)</span> of version space <span class="math inline">\(VS_{H,D}\)</span> : set of most specific members</p>
<p>Version Space Every member of the version space lies between <span class="math inline">\(S\)</span> and <span class="math inline">\(G\)</span></p>
<p><span class="math display">\[
VS_{H,D} \equiv \{ h \in H \; | \; (\exists s \in  S ) (\exists g \in  G ) (g \geq_g h \; \geq_g s) \}
\]</span></p>
<p><span class="math display">\[
where \geq_g \equiv more \; general \; than \; or \; equal \; to
\]</span></p>
<h2 id="the-list-then-elimination-algorithm-列表消除演算法">The <em>List-Then-Elimination</em> Algorithm<br>列表消除演算法</h2>
<ol type="1">
<li><p>起始化： 候選空間( Version Space ) <span class="math inline">\(\leftarrow(assign)\)</span> 所有在假說空間的假說。</p></li>
<li><p>對每個訓練案例<span class="math inline">\(&lt;x, c(x)&gt;\)</span> 從候選空間消除所有 <span class="math inline">\(h(x) \neq c(x)\)</span> 的假說 <span class="math inline">\(h\)</span>。</p></li>
<li><p>對所有的訓練案例檢驗過，最後輸出候選空見剩下的<strong>假說列表</strong>。</p></li>
</ol>
<h3 id="優點">優點</h3>
<p><strong>保證</strong>最後的假說列表裡的所有假說必定和訓練案例的期望相符( Consistent )。</p>
<h3 id="缺點">缺點</h3>
<ul>
<li>若今天假說空間是<strong>無窮大</strong>，那這個方法就不能使用。</li>
<li>要將該假說空間的所有假說窮舉於列表之中。</li>
</ul>
<h2 id="candidate-elimination-algorithm-候選消除演算法">Candidate-Elimination Algorithm<br>候選消除演算法</h2>
<p><strong>＜前情提要＞：</strong>候選空間( Version Space )可以由 Most specific boundaries 與 Most general boundaries 界定出來。 - 正例可以將 Specific boundary 變的更一般化( General )。 Positive examples force specific boundary to become more general. - 反例可以將 General boundary 變的更收斂( Specific )。 Negative examples force general boundary to become more specific.</p>
<p>最後，這個界定出來的假說集合可以符合所有的訓練資料。 In the end, all hypotheses which satisfy training data remain.</p>
<ol type="1">
<li><p>起始化 G <span class="math inline">\(\leftarrow\)</span> 一組在假說空間 <span class="math inline">\(H\)</span> 最一般化的環境因素。標記為：<span class="math inline">\(&lt;?, \ldots, ?&gt;\)</span> S <span class="math inline">\(\leftarrow\)</span> 一組在假說空間 <span class="math inline">\(H\)</span> 最嚴苛的環境因素。標記為：<span class="math inline">\(&lt;\phi, \ldots, \phi&gt;\)</span></p></li>
<li><p>對於每個訓練案例 <span class="math inline">\(d\)</span>，進行以下操作：</p></li>
</ol>
<ul>
<li>若 <span class="math inline">\(d\)</span> 為一正例： 從 <span class="math inline">\(G\)</span> 中移除所有與 <span class="math inline">\(d\)</span> 不一致的假說。 對 <span class="math inline">\(S\)</span> 中每個對 <span class="math inline">\(s\)</span> 不一致的假說<span class="math inline">\(s\)</span>：</li>
</ul>
<ol type="1">
<li>將 <span class="math inline">\(s\)</span> 從 <span class="math inline">\(S\)</span> 之中移去。</li>
<li>把 <span class="math inline">\(s\)</span> 的所有的極小泛化假說 <span class="math inline">\(h\)</span> 加入到S中，其中 <span class="math inline">\(h\)</span> 滿足 <span class="math inline">\(h\)</span>與<span class="math inline">\(d\)</span>一致，且<span class="math inline">\(G\)</span>的其中一個元素必比起 <span class="math inline">\(h\)</span> 更泛化。</li>
<li>從<span class="math inline">\(S\)</span>中移去所有符合這樣的假說：它比S中另一假設更泛化。</li>
</ol>
<ul>
<li>若 <span class="math inline">\(d\)</span> 為一反例： 從 <span class="math inline">\(S\)</span> 中移去所有 <span class="math inline">\(d\)</span> 不一致的假說。 對 <span class="math inline">\(G\)</span> 中每個與 <span class="math inline">\(d\)</span> 不一致的假設 <span class="math inline">\(g\)</span>：</li>
</ul>
<ol type="1">
<li>從 <span class="math inline">\(G\)</span> 中移去 <span class="math inline">\(g\)</span> 。</li>
<li>把 <span class="math inline">\(g\)</span> 的所有的極小特化式 <span class="math inline">\(h\)</span> 加入到 <span class="math inline">\(G\)</span> 中，其中 <span class="math inline">\(h\)</span> 滿足 <span class="math inline">\(h\)</span> 與 <span class="math inline">\(d\)</span> 一致，而且 <span class="math inline">\(S\)</span> 的某個成員比 <span class="math inline">\(h\)</span> 更收斂。</li>
<li>從 <span class="math inline">\(G\)</span> 中移去所有符合這樣的假說：它比 <span class="math inline">\(G\)</span> 中另一假說更特殊。</li>
</ol>
<h3 id="範例---enjoysport">範例 - <span class="math inline">\(EnjoySport\)</span></h3>
<h4 id="起始化">起始化</h4>
<p>Specific boundary to: <span class="math inline">\(S_0 = \{(Ø,Ø,Ø,Ø,Ø,Ø)\}\)</span> General boundary to: <span class="math inline">\(G_0 = \{(?,?,?,?,?,?)\}\)</span></p>
<h4 id="st-instance-sunnywarmnormalstrongwarmsame-yes">1’st instance: (Sunny,Warm,Normal,Strong,Warm,Same) = Yes</h4>
<p><strong>Positive</strong> example <em>generalizes</em> Specific boundary</p>
<p><span class="math inline">\(S_1 = \{ (Sunny,Warm,Normal,Strong,Warm,Same)\}\)</span></p>
<p><span class="math inline">\(G_1 = \{ (?,?,?,?,?,?)\}\)</span></p>
<h4 id="nd-instance-sunnywarmhighstrongwarmsame-yes">2’nd instance: (Sunny,Warm,High,Strong,Warm,Same) = Yes</h4>
<p><strong>Positive</strong> example <em>generalizes</em> Specific boundary</p>
<p><span class="math inline">\(S_2 = \{(Sunny,Warm,?,Strong,Warm,Same)\}\)</span></p>
<p><span class="math inline">\(G_2 = \{ (?,?,?,?,?,?)\}\)</span></p>
<h4 id="rd-instance-rainycoldhighstrongwarmchange-no">3’rd instance: (Rainy,Cold,High,Strong,Warm,Change) = No</h4>
<p><strong>Negative</strong> example <em>specializes</em> General boundary</p>
<p><span class="math inline">\(S_3 = \{ (Sunny,Warm,?,Strong,Warm,Same) \}\)</span></p>
<p><span class="math inline">\(G_3 = \{(Sunny,?,?,?,?,?), \quad O.K.\)</span> <br></p>
<p><span class="math inline">\((Cloudy,?,?,?,?,?), \quad Not \; more \; general \; than \; S_3\)</span><br></p>
<p><span class="math inline">\((?,Warm,?,?,?,?), \quad O.K.\)</span><br></p>
<p><span class="math inline">\((?,?,Normal,?,?,?), \quad Not \; more \; general \; than \; S_3\)</span><br></p>
<p><span class="math inline">\((?,?,?,Light,?,?), \quad Not \; more \; general \; than \; S_3\)</span><br></p>
<p><span class="math inline">\((?,?,?,?,Cool,?), \quad Not \; more \; general \; than \; S_3\)</span><br></p>
<p><span class="math inline">\((?,?,?,?,?,Same)\} \quad O.K.\)</span><br></p>
<p><span class="math inline">\(\Rightarrow G_3 = \{ (Sunny,?,?,?,?,?), (?,Warm,?,?,?,?), (?,?,?,?,?,Same)\}\)</span><br></p>
<h4 id="th-instance-sunnywarmhighstrongcoolchange-yes">4’th instance: (Sunny,Warm,High,Strong,Cool,Change) = Yes</h4>
<p><strong>Positive</strong> example <em>generalizes</em> Specific boundary <span class="math inline">\(S_4 = \{ (Sunny,Warm,?,Strong,?,?) \}\)</span> <span class="math inline">\(G_4 = \{ (Sunny,?,?,?,?,?), (?,Warm,?,?,?,?) \}\)</span></p>
<p>Final version space is all hypotheses, h such that:</p>
<p><span class="math display">\[
g \geq_ g h \; \geq_g s
\]</span></p>
<figure>
<img src="\willywangkaa\images\candidate-eliminationalgorithm.png" alt="candidate-eliminationalgorithm" /><figcaption aria-hidden="true">candidate-eliminationalgorithm</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\candidate-eliminationalgorithm2.png" alt="candidate-eliminationalgorithm2" /><figcaption aria-hidden="true">candidate-eliminationalgorithm2</figcaption>
</figure>
<p>What query should the learner make next? How should these be classified?</p>
<p><span class="math display">\[
&lt;Sunny, Warm, Normal, Strong, Cool, Change&gt;
\]</span></p>
<p><span class="math display">\[
&lt;Rainy, Cold, Normal, Light, Warm, Same&gt;
\]</span></p>
<p><span class="math display">\[
&lt;Sunny, Warm, Normal, Light, Warm, Same&gt;
\]</span></p>
<h3 id="inductive-bias-歸納偏置-未完待補">Inductive Bias 歸納偏置 ( 未完待補 )</h3>
<p>需要某些的預先設定( 偏見 )。</p>
<h1 id="參考">參考</h1>
<hr />
<p><a href="http://mropengate.blogspot.tw/2015/05/ai-supervised-learning.html">Mr' OpenGate - AI - Ch13 機器學習(1), 機器學習簡介與監督式學習 Introduction to Machine Learning, Supervised Learning</a></p>
<p><a href="https://willywangkaa.csdn.net/minvacai/article/details/20202687">《机器学习》第2章中find-s算法的python实现</a></p>
<p><a href="https://en.wikipedia.org/wiki/Version_space_learning">WEKIPEDIA - Version space learning</a></p>
<p><a href="http://www.cnblogs.com/robert-dlut/p/3977184.html">robert_ai - ML一（概念学习和一般到特殊序）</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Concept Learning</tag>
        <tag>Supervised Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine learning - 機器學習地圖</title>
    <url>/willywangkaa/2018/04/20/Machine-learning-%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E5%9C%B0%E5%9C%96/</url>
    <content><![CDATA[<h1 id="機器學習地圖">機器學習地圖</h1>
<hr />
<h2 id="類別">類別</h2>
<ul>
<li><p><strong>監督學習 (Supervised learning)</strong>：從<strong>給定的訓練數據集</strong>中學習出一個模式（函數 / learning model），當新的數據到來時，可以<strong>根據這個模式預測</strong>結果。監督學習的訓練集<strong>要求</strong>是包括<strong>輸入</strong>和<strong>輸出</strong>，也可以說是<strong>特徵和目標</strong>。訓練集中的目標是由<strong>「人」</strong>標註的。常見的監督學習算法包括<strong>回歸分析</strong>和<strong>統計分類( Classify )</strong>。</p></li>
<li><p><strong>無監督學習 (unsupervised learning)</strong>：與監督學習相比，訓練集<strong>沒有人為標註的結果</strong>。常見的無監督學習算法有<strong>聚類( Cluster )</strong>。</p></li>
<li><p><strong>半監督學習 (Semi-supervised learning)</strong>：介於監督學習與無監督學習之間。</p></li>
<li><p><strong>增強學習 (reinforcement learning)</strong>：通過<strong>觀察</strong>來學習做成如何的動作。每個動作都會對環境有所影響，學習對象根據<strong>觀察到的周圍環境</strong>的<strong>反饋( 獎勵 )</strong>來做出判斷。</p></li>
</ul>
<h2 id="機器學習演算法種類">機器學習演算法種類</h2>
<ul>
<li>構造條件機率：回歸分析和統計分類
<ul>
<li>人工神經網絡</li>
<li>決策樹</li>
<li>高斯過程回歸</li>
<li>線性判別分析</li>
<li>最近鄰居法</li>
<li>感知器</li>
<li>徑向基函數核</li>
<li>支持向量機</li>
</ul></li>
<li>通過再生模型構造機率密度函數：
<ul>
<li>最大期望算法</li>
<li>graphical model：包括貝葉斯網和Markov隨機場</li>
<li>Generative Topographic Mapping</li>
</ul></li>
<li>近似推斷技術：
<ul>
<li>馬爾可夫鏈</li>
<li>蒙特卡羅方法</li>
<li>變分法</li>
</ul></li>
<li>最優化：大多數以上方法，直接或者間接使用最優化算法。</li>
</ul>
<figure>
<img src="\willywangkaa\images\machinelearningmap.png" alt="machinelearningmap" /><figcaption aria-hidden="true">machinelearningmap</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\kindofmachinelearning.png" alt="kindofmachinelearning" /><figcaption aria-hidden="true">kindofmachinelearning</figcaption>
</figure>
<h1 id="參考">參考</h1>
<hr />
<p><a href="http://mropengate.blogspot.tw/2015/05/ai-supervised-learning.html">Mr' OpenGate - AI - Ch13 機器學習(1), 機器學習簡介與監督式學習 Introduction to Machine Learning, Supervised Learning</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System - Basic Concept 2</title>
    <url>/willywangkaa/2018/07/10/Operating-System-Basic-Concept-2/</url>
    <content><![CDATA[<h1 id="基礎觀念---basic-concept-貳">基礎觀念 - Basic Concept (貳)</h1>
<hr />
<h2 id="機器指令-stage-階段">機器指令 Stage (階段)</h2>
<figure>
<img src="\willywangkaa\images\1526805202151.png" alt="1526805202151" /><figcaption aria-hidden="true">1526805202151</figcaption>
</figure>
<ol type="1">
<li>IF：Instruction Fetch</li>
<li>ID：Instruction Decode</li>
<li>FO：Fetch Operands</li>
<li>EXE：Execution</li>
<li>WM：Write Result to Memory</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th>CPU 會 Memory Access</th>
<th>DMA 要用 Memory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">IF</td>
<td>必用</td>
<td>Conflict</td>
</tr>
<tr class="even">
<td style="text-align: center;">ID</td>
<td>不使用</td>
<td>OK</td>
</tr>
<tr class="odd">
<td style="text-align: center;">FO</td>
<td>可能使用</td>
<td>OK or conflict</td>
</tr>
<tr class="even">
<td style="text-align: center;">EXE</td>
<td>不使用</td>
<td>OK</td>
</tr>
<tr class="odd">
<td style="text-align: center;">WM</td>
<td>可能使用</td>
<td>OK or conflict</td>
</tr>
</tbody>
</table>
<p>(P.3 - 66) (原文書 I/O Subsystem P. 596)</p>
<ul>
<li>DMA 之六個步驟：</li>
</ul>
<figure>
<img src="\willywangkaa\images\1526805611478.png" alt="1526805611478" /><figcaption aria-hidden="true">1526805611478</figcaption>
</figure>
<ol type="1">
<li><strong>驅動程序（CPU）</strong>
<ol type="1">
<li>作業系統中的「裝置驅動程序」<strong>提出要求</strong>，欲將存於硬碟的資料傳輸至 RAM，並指定地址位在 x 的「Buffer」</li>
<li>「裝置驅動程序」接著<strong>命令「硬碟控制器」（Disk controller）</strong>傳輸 C Byte 到指定的位置</li>
</ol></li>
<li><strong>硬碟控制器（Disk）</strong>
<ol type="1">
<li><strong>對「DMA 控制器」作初始化設定</strong></li>
<li>「硬碟控制器」使用「PCI bus」將每個位元組資料傳輸給「DMA 控制器」
<ul>
<li><strong>原先不使用「DMA 控制器」的情況下，要將資料交給 CPU 再傳輸到 RAM 中</strong></li>
</ul></li>
</ol></li>
<li><strong>DMA 控制器</strong>
<ol type="1">
<li>在接受自「硬碟控制器」傳來的資料後，將資料<strong>以「CPU memory bus」傳送到指定 RAM 中的位置 x</strong>；接著將 x 值遞增，C 值遞減直到成為 0</li>
<li>傳輸完成後，<strong>「DMA 控制器」觸發「Interrupt」以通知 CPU 中的驅動程序</strong></li>
</ol></li>
</ol>
<ul>
<li>Life cycle of I/O request (via Interrupted I/O) (P.3-65) (原文書P.612)</li>
</ul>
<figure>
<img src="\willywangkaa\images\1526806092878.png" alt="1526806092878" /><figcaption aria-hidden="true">1526806092878</figcaption>
</figure>
<blockquote>
<p>提升 I/O 效率</p>
<ol type="1">
<li><strong>減少執行 I/O 時所觸發的「Context switch」</strong>（<span class="math inline">\(B^+—tree\)</span>）</li>
<li>當程序（Process）要與裝置溝通時，減少資料對 RAM 存取的次數</li>
<li>在大量資料轉移、智慧控制器的運作、「Polling」執行時，盡量使用「Busy waiting」的方式解決短小的「I/O 等待」，減少觸發「Interrupt」的次數</li>
<li>增加 DMA 使用率，盡可能<strong>避免使用 CPU 來完成簡單資料的複製工作</strong></li>
<li>讓某些簡單程序可以藉由裝置裡的處理器來執行，使得這些<strong>運算能與 CPU 並行</strong></li>
<li>使 CPU、RAM控制子系統、I/O 裝置效能平衡，因為任何一個步驟發生錯誤很可能會<strong>導致系統的「停滯」（Idle）</strong></li>
</ol>
</blockquote>
<h2 id="blocking-io-and-nonblocking-io">Blocking I/O and Nonblocking I/O</h2>
<ul>
<li><strong>Blocking I/O</strong>：Process <strong>suspended</strong> until I/O completed.
<ul>
<li>Pros
<ul>
<li>Easy to use and understand.
<ul>
<li>撰寫維護簡單，明確的知道什麼user program 需求</li>
</ul></li>
</ul></li>
<li>Cons
<ul>
<li>Insufficient for some needs.
<ul>
<li>欲載入一個大型影片，如要等所有資料載完才反饋給使用者，將導致使用者體驗不好</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1526806717525.png" alt="Synchronous-I/O 也就是 Blocking I/O" /><figcaption aria-hidden="true">Synchronous-I/O 也就是 Blocking I/O</figcaption>
</figure>
<ul>
<li><p><strong>Nonblocking I/O</strong>：I/O return controll as much as available.（<strong>得以在提出 I/O 的需求</strong>後馬上交付控制權回來，所以<strong>該 Process 不用轉換至「Waiting state」</strong>）</p>
<ul>
<li>應用
<ul>
<li>User interface、Data copy（Buffered I/O）</li>
</ul></li>
<li>以<strong>多線程系統來實現</strong>技術
<ul>
<li>見 <a href="wangwilly.github.io/willywangkaa/2018/07/10/Operating-System-Process-Management-and-Thread-Management/#thread-management">Thread-management</a> ，若為「One to one」、「Many to many」系統，則某一個線程發出「I/O 請求」時，CPU 會移轉控制權給該程序的其他可執行的線程</li>
</ul></li>
<li>快速的<strong>回傳些許目前 I/O 裝置保存於緩存器的資料</strong></li>
</ul></li>
<li><p><strong>Asynchronous I/O</strong>：Process runs while I/O executes.</p>
<ul>
<li>屬於「Nonblocking I/O」的一種</li>
<li>難以駕馭其功能</li>
<li><strong>I/O 裝置完成需求後才將資料完整回傳並以「I/O subsystem」通知CPU</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1526807435082.png" alt="1526807435082" /><figcaption aria-hidden="true">1526807435082</figcaption>
</figure>
<h2 id="intruupt-機制與種類">Intruupt 機制與種類</h2>
<ul>
<li><p>「Interrupt」觸發時</p>
<ol type="1">
<li><p>作業系統收到後，<strong>若該處理為必要時</strong>，則作業系統會暫停目前 Process 執行，且保存其 「Status」、「Register」（Context switch）</p></li>
<li><p>作業系統會<strong>依據「Interrupt ID」（Interrupt number）查詢「Interrupt Vector」以確認何種中斷被觸發</strong>，且找出其「Interrupt service routine」（ISR）在記憶體的位置</p></li>
<li><p>在處理器中的指令會跳至該服務程序位置，執行「Interrupt service routine」</p></li>
<li><p>完成「Interrupt service routine」後，將控制權返回給 Kernel</p></li>
<li><p>作業系統恢復（Resume）中斷之前 Process 的進行。</p></li>
</ol></li>
</ul>
<figure>
<img src="\willywangkaa\images\1526808564478.png" alt="1526808564478" /><figcaption aria-hidden="true">1526808564478</figcaption>
</figure>
<ul>
<li><p>不同分類的「Interrupt」</p>
<ul>
<li><p>分類一</p>
<ol type="1">
<li>「External interrupt」：CPU 以外的周邊設備、控制卡… 所觸發
<ul>
<li><strong>I/O completed</strong>、<strong>I/O error</strong>、Machine-check…</li>
</ul></li>
<li>「Internal interrupt」：CPU 在執行程式過程中，<strong>遭遇重大錯誤而觸發並且通常優先權最高</strong>
<ul>
<li><strong>Divide-by-zero</strong>、<strong>執行非法的特權指令（Privileged instruction）</strong>…</li>
</ul></li>
<li>「Software interrupt」：User process 在執行之中，若<strong>需要作業系統提供的服務</strong>，必須觸發此中斷以<strong>通知作業系統執行對應的服務</strong>
<ul>
<li><strong>I/O request</strong>…</li>
</ul></li>
</ol></li>
<li><p>分類二</p>
<ol type="1">
<li>「Interrupt」：硬體裝置為了某些目的<strong>，需轉換目前處裡器裡執行的 Process</strong> 而產生的「通知信號」
<ul>
<li>「I/O 設備」為了告知 CPU 目前的狀態所以會觸發「I/O-completed」、「I/O-error」與「Machine-check」…</li>
<li><strong>「Timer」為一種硬體</strong>，在協助「Round robin」排程、<strong>防止單一 Process 霸佔而保護 CPU </strong>時，<strong>會觸發「Time out」</strong></li>
</ul></li>
<li>Trap：程序在執行時為了某些目的<strong>需要作業系統的協助</strong>而產生的「通知信號」
<ul>
<li>Arithmetic error
<ul>
<li>Divide-by-zero、執行非法指令、非法記憶體存取…</li>
</ul></li>
<li>User process 需要作業系統提供服務，產生「Trap」以通知作業系統
<ul>
<li>I/O-request</li>
</ul></li>
</ul></li>
</ol></li>
<li><p>分類三：以<strong>中斷的優先權高低分類</strong></p>
<ol type="1">
<li>Maskable interrupt（遮蔽式中斷）：觸發後<strong>可被忽略或延後處理</strong>
<ul>
<li>Software interrupt （優先權低）</li>
</ul></li>
<li>Non-maskable interrupt（無蔽式中斷）：觸發後必須及刻處理
<ul>
<li><strong>Internal interrupt（重大錯誤）、I/O error…</strong></li>
</ul></li>
</ol></li>
</ul></li>
</ul>
<h2 id="hardware-resource-protection">Hardware Resource Protection</h2>
<figure>
<img src="\willywangkaa\images\1526808604540.png" alt="1526808604540" /><figcaption aria-hidden="true">1526808604540</figcaption>
</figure>
<h3 id="dual-mode-operation---雙重模式">Dual mode operation - 雙重模式</h3>
<ul>
<li><strong>作業系統的運作模式只少要可被區分為兩種模式</strong>
<ul>
<li><strong>Kernel mode</strong>
<ul>
<li>又稱為「supervisor mode」、「System mode」、「Privileged mode」、「Monitor mode」</li>
<li>以此模式取得系統控制權（CPU）後，<strong>即可使用特權指令（Privileged instruction）</strong></li>
</ul></li>
<li><strong>User mode</strong>
<ul>
<li>「User process」通常在此模式之下，<strong>取得系統控制權且不允許執行特權指令</strong></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>「Duel mode」必須要有硬體的支持才可以實現</strong>，CPU 內有「Mode bit」以區分現在狀態為何</p>
</blockquote>
<h4 id="privileged-instruction特權指令">Privileged instruction（特權指令）</h4>
<p>任何可能會造成系統重大危害的指令，則通常為特權指令</p>
<p>唯獨在「Kernel mode」下才能執行，<strong>一旦在「User mode」之下執行會觸發「Trap」以通知作業系統</strong>，而應對處理通常會終止（Terminate）該 Process 的運行</p>
<ul>
<li>包含
<ul>
<li><strong>I/O instruction</strong>
<ul>
<li>為了保護 I/O 不被 User Process 濫用</li>
</ul></li>
<li>記憶體清除指令</li>
<li><strong>暫存器狀態修改指令</strong>
<ul>
<li>有關記憶體管理、保護而用的暫存器</li>
<li>如：「Base register」、「limit register」</li>
</ul></li>
<li><strong>「Timer」設定指令</strong>
<ul>
<li>為了保護 CPU 不被濫用</li>
<li>如：「Set」、「Change」</li>
</ul></li>
<li><strong>「Enable interrupt」</strong>、<strong>「Disable interrupt」</strong></li>
<li>「Halt」
<ul>
<li>當系統無及時的工作需要完成時作業系統會利用此指令以切換至「Idle state」</li>
</ul></li>
<li><strong>自「User mode」轉換到「Kernel mode」之指令</strong></li>
</ul></li>
</ul>
<p>Ex 33​ (Ref P.3-42)</p>
<ul>
<li>以下哪些是特權指令？
<ol type="1">
<li>Set the value of Timer</li>
<li>Read the clock</li>
<li>Clear Memory</li>
<li>Turn-off interrupt</li>
<li>Switch from user to kernel mode</li>
</ol></li>
</ul>
<p><strong>(1)(3)(4)(5)</strong></p>
<p>Ex 34</p>
<ul>
<li><p>以下哪些是必要的特權指令，且讓使用者程序（User process）能更方便與兼顧安全？ (2)<strong>(3)</strong>(4)<strong>(5)</strong>(7)</p>
<ol type="1">
<li><p>Change to user mode</p>
<ul>
<li><strong>若下放給「User mode」使用也無關緊要，不會使得「User process」得以進入「Kernel mode」</strong></li>
</ul></li>
<li><p>Change to monitor mode</p></li>
<li><p>Read from monitor memory ☆</p></li>
<li><p>Write to monitor memory</p></li>
<li><p>Fetch an instruction from monitor memory ☆</p></li>
<li><p>Turn on timer interrupt</p>
<ul>
<li><strong>「Timer」本來就保持啟動的狀態，所以此指令並不重要</strong></li>
</ul></li>
<li><p>Turn off timer interrupt</p></li>
</ol></li>
</ul>
<p>(2)<strong>(3)</strong>(4)<strong>(5)</strong>(7)</p>
<h3 id="io-protection">I/O Protection</h3>
<p><strong>將所有「I/O指令」設為特權指令</strong>，「User process」一律委託「Kernel」執行「I/O 運作」</p>
<ol type="1">
<li><p>I/O 運作繁瑣複雜，<strong>降低「User process」操控 I/O之複雜度</strong></p></li>
<li><p><strong>避免「User process」對「I/O 裝置」之不當操作</strong></p></li>
</ol>
<h3 id="memory-protection">Memory Protection</h3>
<p><strong>防止「User process」存取其他「User process」之記憶體空間以及「Kernel」的記憶體空間</strong></p>
<ul>
<li>以「Contiguous memory allocation」為例，針對每個 Process
<ul>
<li>「Kernel」會提供一套「Base registers」與「Limit registers」</li>
<li>「Base registers」紀錄 Process 在記憶體中的<strong>起始位址</strong></li>
<li>「Limit registers」紀錄 Process 在記憶體中的<strong>大小</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1526809058649.png" alt="1526809058649" /><figcaption aria-hidden="true">1526809058649</figcaption>
</figure>
<blockquote>
<p>Memory management unit（<strong>MMU</strong>；硬體）檢查是否逾越記憶體位置</p>
<p>（因為記憶體讀取很頻繁，若<strong>交由軟體檢查是否逾越則會導致中斷太多而讓效能低落</strong>）</p>
</blockquote>
<h3 id="cpu-protection">CPU Protection</h3>
<p>防止「User process」無限期/長期佔用 CPU 而不釋放</p>
<ul>
<li><p>以「Timer」實施保護</p></li>
<li><p>作業系統規定 Process 使用 CPU 之最大時限（Max time quantum）</p>
<ol type="1">
<li><p>當 Process 取得 CPU 之後，一開始會設定「Timer」裡的計時器為「Max time quantum」</p></li>
<li><p>隨著 Process 執行時間增加，計時器會逐漸遞減</p></li>
<li><p>當計時器結束時會一同觸發「Time-out interrupt」以通知作業系統強迫結束（Preemptive）該 Process 對 CPU 的使用權</p></li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Basic Concept</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System - Basic Concept 3</title>
    <url>/willywangkaa/2018/07/10/Operating-System-Basic-Concept-3/</url>
    <content><![CDATA[<h1 id="system-call">System Call</h1>
<hr />
<p>It's a programming interface to the services provides by the OS.</p>
<ul>
<li>定義：幫助執行中的 user process 與 kernel 之間溝通，當 user peocess 需要OS提供某種服務時，會先以 Trap 通知 OS (由 User mode 轉為 Kernel mode) 並傳入System call ID (no.) 及所需參數，接著 OS 執行對應的 System call，完成後將服務結果回傳至 User process。</li>
</ul>
<figure>
<img src="\willywangkaa\images\1526605131439.png" alt="1526605131439" /><figcaption aria-hidden="true">1526605131439</figcaption>
</figure>
<ul>
<li>種類 (Ref P.3-8 ~ 3-9)
<ul>
<li><strong>Process Control</strong>：建立、終止、暫停、恢復執行 process，設定/讀取 process attribute。</li>
<li><strong>File Management</strong>：建立、讀、寫、開啟、關閉、刪除檔案。</li>
<li><strong>Device Management</strong>：讀、寫 Device。</li>
<li><strong>Information of Maintenance：</strong>取得系統日期、時間，取得process屬性。</li>
<li><strong>Communications：</strong>process之間的通訊，且只針對<strong>Massage Passing</strong>方式提供服務。</li>
<li>Protection：硬體資源的保護，檔案讀取控制。</li>
</ul></li>
<li>System call 的參數(Parameter) 傳遞方式
<ul>
<li><strong>暫存器( Register )</strong>：保存參數於暫存器之中傳遞給作業系統。<br>Pros：簡單、存取速度快( 無記憶體存取 )。<br>Cons：不適用於存取大量參數的情況。</li>
<li><strong>記憶體( Memory )</strong>：以一個區塊( Block, Table )儲存這些參數並將此區塊的起始位址存於一個暫存器之中傳遞給作業系統。<br>Pros：適用於大量參數。<br>Cons：存取速度較慢，且操作較為麻煩。</li>
<li><strong>系統堆疊( Stack )</strong>：將參數 Push 堆疊之中，作業系統再從堆疊 Pop 取得參數。<br>Pros：也適用大量參數的傳遞，操作也很簡單。<br>Cons：目前無( 可用暫存器或是記憶體實現堆疊 )。</li>
</ul></li>
<li><span class="math inline">\(Ex. 20\)</span> (Ref P.3-36)</li>
</ul>
<h1 id="作業系統的架構-structure">作業系統的架構( Structure )</h1>
<hr />
<ul>
<li>分類
<ul>
<li>Simple</li>
<li>More complex than simple</li>
<li><strong>Layered approach</strong></li>
<li><strong>Microkernel</strong></li>
<li><strong>Module</strong></li>
<li>Hybrid</li>
</ul></li>
</ul>
<h2 id="simple">Simple</h2>
<ul>
<li>無雙重模式( Duel-mode )</li>
<li>單工</li>
<li>無模組化( Module )的設計</li>
<li>例如：MS-DOS</li>
</ul>
<h2 id="more-complex-than-simple">More complex than simple</h2>
<ul>
<li>Limited by hard functionality.( 因為當時硬體技術不夠成熟，作業系統受到硬體很大的限制 )</li>
<li>The original UNIX had limited structuring.</li>
<li>例如：UNIX</li>
<li>UNIX 包含兩個分開的部分
<ul>
<li>System Programs</li>
<li>Kernel</li>
</ul></li>
<li>Beyond simple but not fully layered.</li>
</ul>
<figure>
<img src="\willywangkaa\images\1526608163203.png" alt="1526608163203" /><figcaption aria-hidden="true">1526608163203</figcaption>
</figure>
<h2 id="layered-approach">Layered approach</h2>
<figure>
<img src="\willywangkaa\images\1526609224214.png" alt="1526609224214" /><figcaption aria-hidden="true">1526609224214</figcaption>
</figure>
<ul>
<li>定義：
<ul>
<li>採取 Top-down 的方式<strong>切割系統功能/元件</strong>以降低複雜度。</li>
<li>元件/模組之間呼叫關係<em>分層</em>，即：<strong>上層可以呼叫下層的功能，但下層不得呼叫上層的功能。</strong></li>
<li>使用由 Button-up 的測試、除錯( 防止下層可以呼叫上層 )。</li>
<li>層次( Layer )的劃分沒有明確的規定。</li>
</ul></li>
<li>Pros
<ul>
<li>降低複雜度。</li>
<li>有助於分工。</li>
<li>測試、除錯、維護容易。</li>
</ul></li>
<li>Cons
<ul>
<li>很難精準的劃分層次。例如：<span class="math inline">\(A \rightarrow_{call} B \rightarrow_{call} C\)</span> 但又因為某些原因必須要設計 <span class="math inline">\(C \rightarrow_{call} A\)</span>，最後變成 <span class="math inline">\(A, B, C\)</span> 都在同一層次；解決：將 <span class="math inline">\(C\)</span> 再拆開分成不同層次(難)。</li>
<li><strong>若層次太多，可能會導致作業系統的效能變差。</strong></li>
</ul></li>
</ul>
<h2 id="microkernel---微核心">＊Microkernel - 微核心</h2>
<ul>
<li>由卡內基-美隆大學( CMU )率先提出。
<ul>
<li>代表產品：Mach OS</li>
</ul></li>
<li>定義：將 Kernel 中一些<strong>不必要的服務移至 User mode 提供服務，以 System program 方式存在</strong>，如次一來可以得到一個比較小的 Kernel 。</li>
<li>一般而言，微核心提供下列三個最必要的服務：
<ul>
<li>Process control</li>
<li>Memory Management (不包含Virtual memory)</li>
<li>Process communications (只提供 massage passing 的服務)</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1526610608669.png" alt="1526610608669" /><figcaption aria-hidden="true">1526610608669</figcaption>
</figure>
<ul>
<li>Pros
<ul>
<li>Easier to extend a microkernal. ( 因為服務是在User mode，服務的新增或刪除可以不會改到 Kernel 的架構，相對來說更簡單 )</li>
<li>Easer to port the OS to new archutectures.( 作業系統移植到新的服務平台-cpu不用改太多 )</li>
<li>More reliable. ( 若有一個服務失效時，對 Kernel 的傷害較小 )</li>
<li>More secure.</li>
</ul></li>
<li>Cons
<ul>
<li>效能差，因為存在大量的 User mode 與 Kernel mode 的訊息傳遞。</li>
</ul></li>
</ul>
<p><strong>＜Note＞：</strong>相對於微核心的相反<span class="math inline">\(\rightarrow\)</span><strong>Monolitic kernel</strong>。<br>定義：所有的系統服務皆須在 Kernel 執行。( 商用如：Windows <span class="math inline">\(\Leftrightarrow\)</span> 使用者無法輕易的更改功能 )<br>Pros and Cons 皆與微核心相反。</p>
<h2 id="module---模組化">Module - 模組化</h2>
<ul>
<li>Many OS implement loadable kernel modules. ()</li>
<li>Use <strong>object-oriented approach</strong>.</li>
<li>Each core component is <strong>separate</strong>.</li>
<li>Each talks to the others over known interface.</li>
<li><strong>Each is loadable as needed within the kernel.</strong> ( 需要該服務的時候再載入到記憶體執行，不需要時就從記憶體移除 )</li>
<li><strong>Similar to "Layers" but with more flexible.</strong>( 效能更好 )</li>
<li>例如：Linux, Solaris ...</li>
<li>Pros
<ul>
<li>因為與 Kernel 傳輸的距離不長，效能比較好。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1526611810996.png" alt="1526611810996" /><figcaption aria-hidden="true">1526611810996</figcaption>
</figure>
<h2 id="hybrid---混和型">Hybrid - 混和型</h2>
<ul>
<li>現在的 OS 很難純粹關屬於某一型。</li>
<li><span class="math inline">\(Ex.\)</span> Linux and Solaris 是 <strong>Monolitic</strong> 且也是<strong>Moduler for dynamic loading.</strong></li>
<li><span class="math inline">\(Ex.\)</span> <strong>Windows</strong>大致上是 <strong>Monolitic</strong>，有時真針對不同客戶的需求才會對一些子系統再加入<em>Microkernel</em>。</li>
<li><span class="math inline">\(Ex.\)</span> <strong>Apple Mac OS Kernel</strong>
<ul>
<li><strong>Mach microkernal</strong></li>
<li>Some of BSD UNIX</li>
<li>I/O kit</li>
<li><strong>Dynamic loadable module( kernel extension )</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1526613108853.png" alt="1526613108853" /><figcaption aria-hidden="true">1526613108853</figcaption>
</figure>
<p>Aqua：負責 GUI 的顯示。</p>
<h1 id="vritual-machine">Vritual Machine</h1>
<hr />
<figure>
<img src="\willywangkaa\images\1530162737868.png" alt="1530162737868" /><figcaption aria-hidden="true">1530162737868</figcaption>
</figure>
<ul>
<li>定義：利用<strong>軟體技術</strong>模擬出一份與底層硬體一模一樣的功能介面之<strong>抽象化機器( abstract machine )。</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\1526613748648.png" alt="1526613748648" /><figcaption aria-hidden="true">1526613748648</figcaption>
</figure>
<ul>
<li>名詞解釋
<ul>
<li>Host：underlying hardware system, OS. ( 原生的硬體與 VMM 都可稱之為 Host )</li>
<li><strong>VMM ( Virtual Macihine Management or Hypervisor )</strong>：<em>Creates</em> and <em>managing/runs</em> Virtual machine. ( <strong>可以用硬體或是軟體實現</strong> )</li>
<li>Guest：Process provided with virtual copy of the host.</li>
</ul></li>
<li>Abstract hardware of a single computer into several different execution environments.</li>
<li>Similar to layered approach, but layer creates virtual machine(VM).</li>
<li>Pros
<ul>
<li>為測試<strong>開發中的作業系統之良好的負載平台</strong>，具有：<span class="math inline">\(\;^{[1]}\)</span>其他 user, user process 工作時仍可持續運作不須暫停；<span class="math inline">\(\;^{[2]}\)</span>萬一測試中的作業系統不穩定，就算當機了也不會影響 Host hardware, OS, user procrss 的工作，因為只是相當於一個 user process 失效而已，<strong>不會對 system 有重大危害。</strong></li>
<li>同一部 Host hardware 上可以在虛擬機中執行多個作業系統，<strong>可節省成本</strong>。</li>
<li>Consolidation( 資源的彙整、調度 )：在雲端運算環境時，通常會用有限的機器建立為數眾多的虛擬機，可以依虛擬機上的應用程式( Applications )之執行的負擔輕重<strong>調動 Host Machine 資源作為因應的支援。</strong></li>
<li>較為安全，若被病毒入侵不至於擴散。( 虛擬機之間是獨立的個體 )</li>
<li>可以 Freeze, Suspend, Running 及 Clone 虛擬機。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1526615255622.png" alt="1526615255622" /><figcaption aria-hidden="true">1526615255622</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1526615230230.png" alt="1526615230230" /><figcaption aria-hidden="true">1526615230230</figcaption>
</figure>
<h3 id="vmm的實現">VMM的實現</h3>
<h4 id="主流">主流</h4>
<p>主要以模擬與底層一模一樣的環境(如 cpu)給作業系統使用，有分成下列三種模擬方式。</p>
<ul>
<li><strong>Type 0 Hypervisor</strong> ( Hardware )
<ul>
<li><strong>Hardware</strong> - based solutions via firmware. Ex. IBM LPARS and Oracle LDOMs.</li>
</ul></li>
<li><strong>Type 1 Hypervisor</strong> ( Kernel mode )
<ul>
<li><strong>OS-like software.</strong> Ex. VMware ESX, Joyent SmartOS, <strong>Citrix XenServer</strong>.</li>
<li>General purpose OS that provide VMM functions( Serveices ). Ex. MicroSoft Window Server with <strong>HyperV</strong>, Redhat Linux with <strong>KVM</strong>.</li>
</ul></li>
<li><strong>Type 2 Hypervisor</strong> ( User mode )
<ul>
<li><strong>Applications level provides VMM functionally.</strong> Ex. Parallel Desktop, Oracle VirtualBox.</li>
</ul></li>
</ul>
<h4 id="非主流">非主流</h4>
<p>所實現出來的 VM 不等同於 host 的硬體環境。</p>
<ul>
<li><strong>Paravirtualization</strong>
<ul>
<li>The <strong>guest OS</strong> need <strong>modify</strong> to work in cooperator with VMM to optimize performance</li>
<li><strong>Preseents guest with similars but not identical to host hardware.</strong> <br>(指模擬出常用的機器指令，將少用的指令移除以達到 VM最佳化)</li>
<li><strong>Guest must be modified</strong> to run on paravirtualization hardware.</li>
</ul></li>
<li><strong>Application containment</strong> ( 創造一個執行環境 )
<ul>
<li><strong>Oralcle Soaris Zones, BSD Jails IBM AIX WPARs.</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1526804733939.png" alt="1526804733939" /><figcaption aria-hidden="true">1526804733939</figcaption>
</figure>
<ul>
<li>Programming - environment virtualization
<ul>
<li><strong>VMMs do not virtualize real hardware</strong> but instand create an optimized virtual system.</li>
<li>Ex. <strong>Java </strong> Virtual Machine (JVM) Microsoft.Net</li>
<li><strong>＜Note＞：</strong>JVM is a specification (規格) , not a implementation. 其中規範有：<span class="math inline">\(^{[1]}\)</span>Class Loader, <span class="math inline">\(^{[2]}\)</span> Class Verifier, <span class="math inline">\(^{[3]}\)</span> Java Interpreter.</li>
</ul></li>
<li>Emulator - 模擬器 ( 不同架構的cpu使用模擬器做轉換 )
<ul>
<li>Allow application writtem for one hardware to run on a very different hardware such as <strong>different type of cpu</strong>.</li>
</ul></li>
</ul>
<h1 id="policy-and-mechanism">Policy and Mechanism</h1>
<hr />
<ul>
<li>Policy
<ul>
<li>定義：<strong>"What" to be provided"</strong></li>
<li>Policy 會經常改變。</li>
</ul></li>
<li>Mechanism
<ul>
<li>定義：<strong>"How" to do that</strong></li>
<li>「The underlying mechanism」甚少改變或不變。</li>
</ul></li>
<li><strong>設計原則</strong>
<ul>
<li>Policy and mechanism 最好分開設計，以增進系統的彈性( Flexibility )。</li>
</ul></li>
<li>$Ex1. $
<ul>
<li>Mechanism：運用 Timer 幫助 cpu protection。</li>
<li>Policy：Max time Quantum 的大小制定。</li>
</ul></li>
<li>$Ex2. $
<ul>
<li>Mechanism：cpu 排班採<strong>優先權高低</strong>。</li>
<li>Policy：<strong>優先權高低的定義</strong>。</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
  </entry>
  <entry>
    <title>Operating System - File Management</title>
    <url>/willywangkaa/2018/09/10/Operating-System-File-Management/</url>
    <content><![CDATA[<h1 id="file-management">File management</h1>
<h2 id="file-openfile-close">File open、File close</h2>
<p>作業系統對檔案進行任何運作之前，皆必須到磁碟的「Physical directory」找出檔案的配置資訊。</p>
<ul>
<li>問題
<ul>
<li>因為檔案數目太龐大，<strong>所以搜尋的時間長</strong></li>
<li><strong>磁碟 I/O time(次數)很多，非常耗時</strong></li>
</ul></li>
</ul>
<h3 id="file-open">File open</h3>
<p>當檔案第一次被使用時，作業系統必須到磁碟的「Physical directory」找出檔案的配置資訊，<strong>接著將此資訊複製到作業系統的記憶體空間之中的一個表格稱為「Open file table」。</strong>將來對這個檔案進行任何操作之前，<strong>作業系統只需要到此表格搜尋取得檔案的配置資訊即可。</strong>由於「Open file table」中的檔案很少 ( E.g., 20 個)，<strong>搜尋的時間可以大幅降低，</strong>此表格位於<strong>記憶體中，所以可以節省可觀的 I/O time (次數)。</strong></p>
<figure>
<img src="\willywangkaa\images\fileopen.png" alt="fileopen" /><figcaption aria-hidden="true">fileopen</figcaption>
</figure>
<ul>
<li>因為檔案可以被多個 Process 共用，「Open file table 」分為：
<ul>
<li><strong>System-open file table</strong>
<ul>
<li>保存檔案共通配置的資訊
<ul>
<li>檔案名稱</li>
<li>配置區塊</li>
<li>檔案大小</li>
</ul></li>
</ul></li>
<li><strong>Process-open file table</strong>
<ul>
<li><strong>Process 存取檔案時，會有不同的資訊要保存</strong><br><strong>( E.g. 檔案目前讀取的指標位置、對檔案的存取權利 )</strong></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\openfiletable.png" alt="openfiletable" /><figcaption aria-hidden="true">openfiletable</figcaption>
</figure>
<h3 id="file-close">File close</h3>
<p>當檔案不再使用時，<strong>作業系統會將「Open file table」中此檔案的配置資訊更新回磁碟的「Physical directory」，且自表格中刪除此檔案的配置資訊。</strong></p>
<h2 id="consistency-semantic---一致性語意">Consistency semantic - 一致性語意</h2>
<blockquote>
<p>檔案可以被多個 Process / User 共享，而共享的模式 ( Model ) 有那幾種？</p>
</blockquote>
<h3 id="unix-semantic">UNIX semantic</h3>
<ul>
<li>Ex
<ul>
<li><strong>訂票系統的「座次表」檔案</strong>
<ul>
<li><strong>需要具備「互斥存取」</strong></li>
<li><strong>全部單位讀取檔案必須是「一致的」</strong></li>
<li><strong>某個 Process 對檔案作的任何改變其它 Process 會知道</strong></li>
</ul></li>
</ul></li>
</ul>
<h3 id="session-semantic">Session semantic</h3>
<ul>
<li>Ex
<ul>
<li><strong>「空白報名表」檔案供人下載填寫</strong>
<ul>
<li><strong>不需具備「互斥存取」</strong>：大家是在各自的「副本」上進行讀寫，讀寫不受限制。</li>
<li><strong>全部單位看到的內容「不一定一致」</strong></li>
</ul></li>
</ul></li>
</ul>
<h3 id="immutable-不可改變-semantic">Immutable (不可改變) semantic</h3>
<ul>
<li>Ex
<ul>
<li><strong>「總經理公告文件」檔案</strong>
<ul>
<li><strong>唯讀；不可更改</strong></li>
<li><strong>檔名不得重複</strong></li>
</ul></li>
</ul></li>
</ul>
<h2 id="file-protection">File protection</h2>
<h3 id="physical-protection">Physical protection</h3>
<p>防止因為「磁碟毀壞」，所造成的「資料遺失」。</p>
<ul>
<li><strong>Backup only</strong></li>
</ul>
<h3 id="logical-protection">Logical protection</h3>
<p><strong>防止非法使用者對檔案之不當存取</strong>。</p>
<ul>
<li>Name protection</li>
<li>Password protection</li>
<li>Access list</li>
<li>Access group</li>
</ul>
<h4 id="access-group">Access group</h4>
<figure>
<img src="\willywangkaa\images\accessgroup.png" alt="accessgroup" /><figcaption aria-hidden="true">accessgroup</figcaption>
</figure>
<ul>
<li><strong>User</strong>
<ul>
<li><strong>Owner</strong></li>
<li><strong>Group ( member )</strong></li>
<li><strong>Others ( universal )</strong></li>
</ul></li>
<li><strong>Access right</strong>
<ul>
<li><strong>R：Read</strong></li>
<li><strong>W：Write</strong></li>
<li><strong>X：Execute</strong></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>File Management</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System - System security</title>
    <url>/willywangkaa/2019/02/02/Operating-System-System-security/</url>
    <content><![CDATA[<h1 id="system-security">System security</h1>
<ul>
<li>提供「安全功能」與「安全服務」</li>
<li>針對各種常用作業系統，進行相關配置，以正確對付、防禦各種入侵</li>
<li>保證網路作業系統提供的網路服務得到安全配置</li>
</ul>
<h2 id="病毒virus">病毒（Virus）</h2>
<p>藉由用存取控制（Access control）的機制來保護資訊的安全，防止非法使用者的入侵與蓄意破壞</p>
<ul>
<li>特徵
<ul>
<li>A fragment of code embedded in a legitimate program</li>
<li>依附在別的程式上</li>
<li>會自行複製、感染、傳播、發作</li>
<li>「UNIX」與「Multiuser」作業系統不易受到病毒影響，因為「可執行檔」的寫入被系統保護</li>
</ul></li>
</ul>
<ol type="1">
<li><p>啟動磁區病毒</p>
<ul>
<li>早期的病毒類型，感染開機磁片中「Boot」程式或硬碟分割表以取得控制權限</li>
</ul></li>
<li><p>檔案型病毒</p>
<ul>
<li>寄生於執行檔後，會再自主感染其他執行檔
<ul>
<li>「常駐型」：會常駐在記憶體中，當其他程式執行時會進一步執行感染動作</li>
<li>「非常駐型」：感染磁碟機中找出尚未被感染的程式加以感染</li>
</ul></li>
</ul></li>
<li><p>巨集病毒</p>
<ul>
<li>裡用軟體本身提供的巨集功能設計出的病毒
<ul>
<li>Microsoft word 的 VBA 巨集</li>
</ul></li>
</ul></li>
<li><p>電腦蠕蟲</p>
<ul>
<li><p>A process that use spawn mechanism（孕育機制） to duplicate itself</p></li>
<li><p>不須依附在別的程式內</p></li>
<li><p>可能不用使用者操作也會自我複製執行</p></li>
<li><p>未必破壞被感染的系統</p></li>
<li><p>執行垃圾程式碼以發動「分散式阻斷服務攻擊」（DDos）</p>
<ul>
<li>採用垃圾郵件、漏洞傳播，如：<strong>莫里斯蠕蟲</strong></li>
</ul></li>
</ul></li>
<li><p>特洛伊木馬</p>
<ul>
<li><p>A code segment that misuses its environment</p></li>
<li><p>病毒依附在一般程式碼</p></li>
<li><p>滿足特定條件後便將使用者資料傳出，未達條件不進行任何動作</p></li>
<li><p>「Spyware」：常伴隨著商業軟體，施行網頁綁架與廣告騷擾</p></li>
</ul></li>
<li><p>Autorun病毒</p>
<ul>
<li>利用 USB 當作媒介，會自動執行程式侵入電腦</li>
</ul></li>
<li><p>千面人病毒</p>
<ul>
<li>每繁殖一次會以不同病毒碼傳染到別處，每一個中毒的檔案所含的病毒程式碼皆不同</li>
</ul></li>
</ol>
<h2 id="攻擊手段">攻擊手段</h2>
<ol type="1">
<li>Dumpster diving
<ul>
<li>攻擊者翻找目標系統文件、檔案、垃圾資料與殘存資訊，試圖找到密碼與其他有用的資訊</li>
</ul></li>
<li>Trap door
<ul>
<li>The designer of a program or system might leave a hole in the software that only is capable of use</li>
<li>隱藏在程式中的秘密功能</li>
</ul></li>
<li>Logic bomb
<ul>
<li>A program that initiates a security incident only under certain circumstances</li>
<li>難以查出問題所在</li>
<li>正常情況不發生，當發生特定條件時會發生錯誤</li>
</ul></li>
<li>Stack overflow / Buffer overflow
<ul>
<li>Attacker sends more data than the program expected</li>
<li>溢位（Overflow）後將原本「Stack」中的「Return address」改成惡意程式的位置</li>
<li>避免方法
<ul>
<li>Use static code analysis to look for memory writes that go beyond array boundaries</li>
<li>Randomize the base address of program libraries/stack in the memory</li>
<li>使用安全的函數（strcpy()→strncpy()）</li>
<li>使用高階程式語言
<ul>
<li>Java、Python</li>
</ul></li>
</ul></li>
</ul></li>
<li>Port scanning
<ul>
<li>Is not a attacker but rather a means for a cracker to detect a system's vulnerabilities to attacker</li>
<li>首先搜尋<strong>目標網路</strong>上所有可以接觸到的主機，然後查出主機上開啟了哪些通訊埠，並且進一步偵測出目標主機上所執行的作業系統類型及版本（OS fingerprinting），最後刺探出目標主機上正在執行或待命的網路服務與目標主機的 IP 位址之間的關係</li>
<li>Port scanning （通訊埠端口掃描）
<ul>
<li>駭客<strong>會傳送一連串的特殊訊息去測試此主機上有執行哪些網路服務</strong>，如 HTTP 使用 Port 80，透過「Port Scanning」<strong>得知哪些通訊埠是開啟的</strong>，讓駭客知道主機上目前所執行的網路服務類型</li>
</ul></li>
<li>Network Scanning（網路架構掃描）
<ul>
<li>若能得知目標網路內有哪些主機是可以接觸到、啟動（active）的，<strong>能夠縮小攻擊範圍並知道哪些主機可以成為被攻擊目標</strong></li>
</ul></li>
<li>Vulnerability Scanning（弱點掃描）
<ul>
<li>偵測及發現目標網路內被掃描的<strong>主機上所存在的弱點與漏洞</strong>，以便未來進行入侵攻擊</li>
</ul></li>
</ul></li>
<li>Denial of service（Dos）
<ul>
<li>Dos attacks are aimed not at gaining information or stealing resources but rather at disrupting legitimate use of a system or facility</li>
<li>DDos
<ul>
<li>利用多台殭屍系統（Zombies）<strong>同時對目標伺服器發出大量請求以癱瘓服務</strong></li>
</ul></li>
</ul></li>
</ol>
<h1 id="symmetric-encryption-and-asymmetric-encryption">Symmetric encryption and asymmetric encryption</h1>
<h2 id="symmetric-encryption">Symmetric encryption</h2>
<p>Same key is used to encrypt and to decrypt</p>
<h3 id="data-encrypt-standarddes">Data encrypt standard（DES）</h3>
<ul>
<li><strong>64 bit block cypher</strong>
<ul>
<li>每次加密操作只處理 64-bit 資料，稱為「Block」</li>
</ul></li>
<li><strong>56 bit key length</strong></li>
</ul>
<p><strong>Triple DES</strong></p>
<ul>
<li>C：Cypher；密文</li>
<li>M：Plaintext；明文</li>
<li>使用「金鑰包」包含三個 DES 金鑰 <span class="math inline">\(K_1、K_2、K_3\)</span> 均為 56-bits
<ul>
<li>加密：使用 <span class="math inline">\(K_1\)</span> 的金鑰進行 DES 加密，在用 <span class="math inline">\(K_2\)</span> 的金鑰<strong>進行 DES「解密」</strong>，最後使用 <span class="math inline">\(K_3\)</span> 進行 DES 加密，『<span class="math inline">\(C = E_{K_3}(D_{K_2}(E_{K_1}(M)))\)</span>』</li>
<li>解密：使用 <span class="math inline">\(K_3\)</span> 的金鑰進行 DES 解密，在用 <span class="math inline">\(K_2\)</span> 的金鑰<strong>進行 DES「加密」</strong>，最後使用 <span class="math inline">\(K_1\)</span> 進行 DES 解密，『<span class="math inline">\(M = D_{K_1}(E_{K_2}(D_{K_1}(C)))\)</span>』</li>
</ul></li>
<li>金鑰選項（<span class="math inline">\(K_1、K_2、K_3\)</span>）
<ul>
<li>金鑰選項1：三個金鑰獨立
<ul>
<li>強度最高，擁有 3×56 = 168 個獨立金鑰位元（Bit）</li>
</ul></li>
<li><strong>金鑰選項2</strong>：<span class="math inline">\(K_1、K_2\)</span> 獨立、<span class="math inline">\(K_3 = K_1\)</span>
<ul>
<li>安全性稍低，<strong>擁有 2×56 = 112 個獨立金鑰位元（Bit），但可以防禦「<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%80%94%E7%9B%B8%E9%81%87%E6%94%BB%E6%93%8A">中途相遇攻擊</a>」</strong></li>
</ul></li>
<li>金鑰選項3：<span class="math inline">\(K_1 = K_2 = K_3\)</span>
<ul>
<li>等同於普通 DES（因為會互相抵銷），擁有 56 個獨立金鑰位元（Bit）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="advanced-encryption-standardaes">Advanced encryption standard（AES）</h3>
<p>在<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6">密碼學</a>中又稱「Rijndael加密法」，是<a href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD%E8%81%94%E9%82%A6%E6%94%BF%E5%BA%9C">美國聯邦政府</a>採用的一種<a href="https://zh.wikipedia.org/wiki/%E5%8D%80%E5%A1%8A%E5%8A%A0%E5%AF%86">區段加密</a>標準，用來替代原先的<a href="https://zh.wikipedia.org/wiki/DES">DES</a></p>
<blockquote>
<p>嚴格地說，AES 和 Rijndael 加密法並不完全一樣（雖然在實際應用中兩者可以互換），因為Rijndael加密法可以支援更大範圍的區段和金鑰長度</p>
<ul>
<li><strong>AES 的區段（Block cypher）長度固定為128-bit</strong></li>
<li><strong>金鑰長度（Key length）則可以是 128、192、256-bit</strong></li>
</ul>
<p>而Rijndael使用的金鑰和區段長度均可以是128、192、256-bit</p>
<p>加密過程中使用的金鑰是由「<a href="https://zh.wikipedia.org/wiki/Rijndael%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88">Rijndael金鑰生成法</a>」產生</p>
</blockquote>
<p><strong>RSA 比 DES 和其它對稱演算法要慢得多</strong>；實際上「傳送方」會使用<strong>一種對稱演算法來加密他的資訊</strong>，然後用 RSA 來加密他的比較短的對稱密碼，然後將用 RSA 加密的對稱密碼和用對稱演算法加密的訊息送給「接收方」</p>
<ul>
<li><p>C：Cypher；密文</p></li>
<li><p>M：Plaintext；明文</p></li>
<li><p><span class="math inline">\(K_{as}\)</span>：AES 金鑰</p></li>
<li><p><span class="math inline">\(K_{bs}、K_{bp}\)</span>：RSA 私鑰與公鑰（<strong>接收方</strong>）</p></li>
<li><p>加密</p>
<ul>
<li>利用「AES 金鑰」對明文（M）加密</li>
<li>再使用「RSA 公鑰」對「AES 金鑰」加密</li>
<li>將上述兩者一併傳給接收方</li>
<li><span class="math inline">\(\Rightarrow E_{K_{as}}(M)｜E_{K_{bp}}(K_{as})\)</span></li>
</ul></li>
<li><p>解密</p>
<ul>
<li>用「RSA 私鑰」解密出「AES 金鑰」</li>
<li>再使用「AES 金鑰」解密出明文</li>
<li>爾後雙方傳遞資料只需使用「AES 金鑰」加密明文即可</li>
<li><span class="math inline">\(\Rightarrow D_{K_{bs}}(E_{K_{bp}}(K_{as})) = K_{as} \\ D_{K_{as}}(E_{K_{as}}(M)) = M\)</span></li>
</ul></li>
</ul>
<h3 id="rivest-cypher-4rc4">Rivest cypher 4（RC4）</h3>
<p>是密鑰長度可變的一種「<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8A%A0%E5%AF%86">串流流加密</a>算法」，也屬於<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">對稱加密算法</a>，RC4 是<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E7%B7%9A%E7%AD%89%E6%95%88%E5%8A%A0%E5%AF%86">有線等效加密</a>（WEP）中採用的加密算法，也曾經是「<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE">Transport layer security（TLS）</a>」可採用的算法之一</p>
<ul>
<li><p>RC4 由<a href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0">偽隨機數</a>生成器（Pseudo-random bit generator）和異或運算（XOR）組成</p></li>
<li><p>RC4的密鑰長度可變</p>
<ul>
<li>40 ~ 2048 bit</li>
</ul></li>
<li><p>RC4一個字節一個字節（Byte）地加解密</p></li>
<li><p>給定一個密鑰，偽隨機數生成器接受密鑰並產生一個「<a href="https://zh.wikipedia.org/wiki/S%E7%9B%92">S盒</a>」</p>
<ul>
<li>S盒用來加密數據，而且在加密過程中S盒會變化</li>
</ul></li>
<li><p>快速但是安全性低</p></li>
</ul>
<h2 id="asymmetric-encryption">Asymmetric encryption</h2>
<h3 id="rivestshamiradlemanrsa">Rivest–Shamir–Adleman（RSA）</h3>
<ol type="1">
<li>「接收方」生成一對公鑰、私鑰
<ol type="1">
<li>找出兩個極大質數 p、q
<ul>
<li><strong>計算 N = p×q</strong></li>
<li>同時算得 <span class="math inline">\(r = \phi (N) = (p-1)\times(q-1)\)</span></li>
</ul></li>
<li><strong>求出整數 e</strong>其滿足 <code>gcd(e,r) = 1</code> 且 e &lt; r</li>
<li><strong>求出整數 d</strong>其滿足 <code>e﹡d ≡ 1 (mod r)</code>
<ul>
<li><span class="math inline">\(e\cdot d-1 = k\cdot r, k \in Z\)</span></li>
</ul></li>
<li>最後得到公鑰：(N, e)、私鑰：(N, d)</li>
</ol></li>
<li>「接收方」公開其公鑰給欲傳遞訊息的「傳遞方」</li>
<li>「傳遞方」使用公鑰將明文加密
<ol type="1">
<li>將明文（M）轉換成一整數（m）
<ul>
<li>f：M→m</li>
</ul></li>
<li><span class="math inline">\(C \equiv m^e (\mod N)\)</span>，C 為密文</li>
</ol></li>
<li>「傳遞方」將密文傳送給「接收方」使用<strong>私鑰將其密文解密</strong>
<ol type="1">
<li><span class="math inline">\(m \equiv C^d (\mod N)\)</span></li>
<li>將整數（m）轉換明文（M）
<ul>
<li>f'：m→M</li>
</ul></li>
</ol></li>
</ol>
<blockquote>
<ul>
<li>由尤拉公式可以得知
<ul>
<li>模反元素必存在
<ul>
<li><span class="math inline">\(a\times?\equiv1(\mod n)\\ \Rightarrow a\times a^{\phi(n)-1} = a^{\phi(n)} \equiv 1(\mod n)\)</span></li>
</ul></li>
</ul></li>
<li>私鑰解密證明（<span class="math inline">\(C^d \equiv M(\mod n)\)</span>）
<ul>
<li>根據加密原則 <span class="math inline">\(M^e \equiv C (\mod n)\)</span>
<ul>
<li>則 $C = M^e - kn, k Z $</li>
</ul></li>
<li>將 C 帶入解密規則
<ul>
<li><span class="math inline">\((M^e - kn)^d \equiv M(\mod n), k \in Z \\ \Rightarrow (M^e)^d \equiv M(\mod n)\)</span></li>
<li>因為 <span class="math inline">\(e \cdot d \equiv 1(\mod \phi(n))\)</span> ，則 <span class="math inline">\(e\cdot d = h\phi(n)+1, h\in Z\)</span></li>
<li>則 <span class="math inline">\(M^{h\phi(n)+1} \equiv M (\mod n)\)</span></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<blockquote>
<p><strong>Authentication</strong></p>
<p>Constraining the set of potential sender of a message and is also useful for proving that a message has not been modified</p>
<p><strong>Message authentication code（MAC）</strong></p>
<p>特定演算法後產生的一小段資訊附加在原始訊息後傳送，以確認「某段訊息的完整性」與「傳送者的身分驗證」</p>
<figure>
<img src="\willywangkaa\images\MAC.png" alt="MAC" /><figcaption aria-hidden="true">MAC</figcaption>
</figure>
<ul>
<li>資訊鑑別碼（MAC）不能提供對資訊的保密，若要同時實現保密認證，同時需要對資訊進行加密</li>
</ul>
<p><strong>以 RSA 為一個訊息署名</strong></p>
<ol type="1">
<li>「傳送者」為<strong>原始訊息計算一個雜湊值（Message digest）</strong>
<ul>
<li>用<strong>「傳送者」的私鑰「加密」這個雜湊值即為一個「署名文」</strong></li>
<li>將原始訊息與「署名文」一併傳給「接收方」</li>
<li>這個訊息只有用「傳送者」的公鑰才能解密</li>
</ul></li>
<li>「接收者」獲得「署名文」後使用「傳送者」的公鑰「解密」得到雜湊值
<ul>
<li><strong>將雜湊值與「接受者」自己為這個訊息計算的雜湊值比較</strong>
<ul>
<li>假如兩者相符，則此訊息在傳播路徑上沒有被篡改過</li>
</ul></li>
</ul></li>
</ol>
</blockquote>
<h4 id="第三方攻擊">第三方攻擊</h4>
<p>和其它加密過程一樣，對RSA來說分配公鑰的過程是非常重要的，分配公鑰的過程必須能夠抵擋中間人攻擊</p>
<ol type="1">
<li>「竊聽者」交給 A 一個公鑰使 A 相信這是 B 的公鑰，則「竊聽者」可以截下 A 傳遞給 B 的資訊</li>
<li>「竊聽者」亦將自己的公鑰傳給 B 使 B 以為這是 A 的公鑰，則「竊聽者」可以將所有 B 遞移給 A 的訊息截下來，將這個訊息用自己的私鑰解密，然後將這個訊息再用 A 的公鑰加密後傳給 A</li>
</ol>
<blockquote>
<p>理論上 A 和 B 都不會發現訊息被竊聽，所以今天一般用<a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD">可靠的第三方機構簽發憑證</a>來防止這樣的攻擊</p>
</blockquote>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Technical Patent Study - Content of Patent</title>
    <url>/willywangkaa/2018/05/05/Technical%20Patent-Study-Content-of-Patent/</url>
    <content><![CDATA[<h1 id="專利看討">專利看討</h1>
<hr />
<p>不是攻擊對手，而是保護自己(和公司)的權力。</p>
<h2 id="專利制度">專利制度</h2>
<ul>
<li><p>中華民國專利法</p>
<ul>
<li>分為3章共156條</li>
</ul></li>
<li><p><strong>＜專利法(1)＞：</strong>為鼓勵、保護、利用發明、新型及設計之創作，以<strong>促進產業發展</strong>，特制定本法。</p></li>
<li><p><strong>＜專利法(2)＞：</strong>本法所稱專利，分為</p>
<ol type="1">
<li><p>發明專利。 (新發明)</p></li>
<li><p>新型專利。 (新型)</p></li>
<li><p>設計專利。 (新式樣)</p></li>
</ol></li>
</ul>
<figure>
<img src="\willywangkaa\images\formoftypeofpatent.png" alt="formoftypeofpatent" /><figcaption aria-hidden="true">formoftypeofpatent</figcaption>
</figure>
<h2 id="什麼可以成為專利">什麼可以成為專利？</h2>
<p>若認為<strong>能賺錢的發明</strong>才是發明，會非常難達成。<br>專利保護的概念，往往比大部分人想的都要廣，就算看起來不像是可受專利保護的概念，換個角度想也常能受專利保護。</p>
<figure>
<img src="\willywangkaa\images\thepatentofconcept.png" alt="thepatentofconcept" /><figcaption aria-hidden="true">thepatentofconcept</figcaption>
</figure>
<h3 id="改良也算是發明">「改良」也算是發明</h3>
<ul>
<li>發明電燈泡的只有一個人？
<ul>
<li>事實上，愛迪生的電燈泡出現之前70年，已經知道用白金當燈絲，但非真空。</li>
</ul></li>
<li>只要有發明的<strong>概念</strong>
<ul>
<li>並有<strong>具體</strong>的<strong>作法</strong>。</li>
</ul></li>
</ul>
<h3 id="不能成為專利的概念">不能成為專利的「概念」</h3>
<ul>
<li><p>動植物的<strong>新品種</strong>。</p>
<ul>
<li>如基因改造過的玉米、新品種的老鼠。</li>
</ul></li>
<li><p>人體或動物疾病之<strong>診斷</strong>、<strong>治療</strong>或<strong>治療方法</strong>。</p>
<ul>
<li>心臟移植手術的方法。</li>
<li><strong>＜Note＞：</strong> <strong>藥物</strong>、<strong>製藥方法</strong>、<strong>醫療器材</strong>等這些不包含在此。</li>
</ul></li>
<li><p><strong>科學原理</strong>或<strong>數學方法本身</strong></p>
<ul>
<li><span class="math inline">\(E = M\cdot C^2\)</span></li>
<li><strong>＜Note＞：</strong> <strong>利用</strong>科學原理或是數學方法是可以成為專利的。<br><span class="math inline">\(Ex.\)</span> MP3 壓縮技術、加解密技術。</li>
<li>純為人類智力的規則或方法。<br><span class="math inline">\(Ex.\)</span>：如何節稅、如何開連鎖店。</li>
<li>屬著作權保護的美術、文學與音樂創作。</li>
</ul></li>
</ul>
<h4 id="負面表列">負面表列</h4>
<p>一般是否屬於專利會保護的概念，只要看當地專立法所列的『負面表列』即可。</p>
<ul>
<li><strong>＜專利法(24)＞：</strong>下列各款，不予發明專利：</li>
</ul>
<ol type="1">
<li>動植物及生產動、植物之主要生物學方法。但微生物學之生產方法 ，不在此限。</li>
<li>人類或動物之診斷、治療或外科手術方法。</li>
<li>妨害公共秩序或善良風俗者。</li>
</ol>
<h2 id="專利在國際的考慮">專利在國際的考慮</h2>
<p>各國<strong>價值觀不同</strong>，所核准的專利範圍也不盡然相同。慎選區域，因為所費不斐，最好以<strong>市場大小</strong>及<strong>競爭對手</strong>的區域為基準考量。</p>
]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
        <tag>Concept</tag>
        <tag>專利看討</tag>
      </tags>
  </entry>
  <entry>
    <title>Technical Patent Study - Patent Claim</title>
    <url>/willywangkaa/2018/05/05/Technical%20Patent-Study-Patent-Claim-%E5%B0%88%E5%88%A9%E8%81%B2%E6%98%8E/</url>
    <content><![CDATA[<h1 id="patent-claim---聲明專利">Patent Claim - 聲明專利</h1>
<hr />
<h2 id="專利的異議與舉發">專利的「異議」與「舉發」</h2>
<ul>
<li>異議
<ul>
<li>對於<strong>審定公告之專利原則</strong>上，任何人得自審定公告之次日起<strong>3個月</strong>內提起異議。</li>
<li>用於<strong>撤銷該專利之審定</strong>。</li>
</ul></li>
<li>舉發
<ul>
<li>對於<strong>以取得之專利</strong>，得對之提起舉發。</li>
<li>用於<strong>撤銷「專利權」</strong>，使專利自使部存在。</li>
</ul></li>
</ul>
<p><strong>＜Note＞：</strong>有無仿冒？以專利角度看待，抄襲仿冒不是重點，重點是有無落入對方的專利申請範圍內。</p>
<h2 id="專利範圍之記載要件">專利範圍之記載要件</h2>
<ul>
<li>包含必要的<strong>技術特徵</strong>。</li>
<li>明確，使相關領域<strong>具通常知識者</strong>，<strong>可以明確瞭解其意義</strong>，不生疑義。</li>
<li>所載的發明符合產業<strong>利用性</strong>、<strong>新穎性</strong>與<strong>進步性</strong>。</li>
<li>為發明說明所支持。</li>
</ul>
<h3 id="結構-p-t-b">結構 ( P + T + B )</h3>
<ul>
<li>前言 ( <strong>P</strong>reamble )</li>
<li>連接詞 ( <strong>T</strong>ransition )</li>
<li>主體 ( <strong>B</strong>ody )</li>
</ul>
<h4 id="獨立項與附屬項">獨立項與附屬項</h4>
<p>★★★★★ 獨立項：載明申請專利之<strong>標的</strong>及其<strong>實施之必要技術</strong>特徵。</p>
<p>☆☆☆☆★ 附屬項：包含所<strong>依附項目</strong>之<em>全部技術內容</em>，並說明依附<em>請求項以外之技術特徵</em>。</p>
<p><strong>＜Note＞：</strong>獨立項<strong>遠重要於</strong>附屬項。</p>
<ul>
<li><span class="math inline">\(Ex.\)</span>
<ul>
<li><strong>一種杯子，其包含方形杯體及連接其上之把手。</strong><br>如請求項1之杯子，其中該杯體高度為10公分。<br>如請求項2之杯子，其中該把手是透明的。</li>
</ul></li>
</ul>
<h2 id="請求項-claim">請求項 ( Claim )</h2>
<ul>
<li>一般建議涵蓋不同範圍的請求項
<ul>
<li>最廣</li>
<li>中等  - 最小：最終銷售產品。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\thedifferentsetofclaim.png" alt="thedifferentsetofclaim" /><figcaption aria-hidden="true">thedifferentsetofclaim</figcaption>
</figure>
<h3 id="選擇一個女友">選擇一個「女友」？</h3>
<ul>
<li>請根據以下條件以請求項( Claim )的方式要求。
<ul>
<li>覺得她長的漂亮</li>
<li>身高165公分以上，必須比我矮5公分，所以要在175公分以下</li>
<li>瘦瘦的</li>
<li>懂得化妝</li>
<li>最好長髮飄逸</li>
<li>即使是生氣時，也要很溫柔</li>
<li>要當太太不一樣，要會做家事，會煮飯，喜歡小孩</li>
<li>年輕的未婚女性</li>
</ul></li>
</ul>
<h3 id="ex."><span class="math inline">\(Ex.\)</span></h3>
<ul>
<li>獨立項( 範圍 )
<ul>
<li>一名女性人類( P )，包含( T )下述之特性( B )：
<ul>
<li>覺得她長的漂亮<span class="math inline">\(\rightarrow\)</span>五官特徵與松島菜菜子差異0%~20%之間。</li>
<li>身高165公分以上，必須比我矮5公分，所以要在175公分以下<span class="math inline">\(\rightarrow\)</span>身高165公分至175公分之間。</li>
<li>瘦瘦的<span class="math inline">\(\rightarrow\)</span>以身高推算後之標準體重再減10%~20%之間。</li>
<li>懂得化妝<span class="math inline">\(\rightarrow\)</span>修過認證化妝課程20小時以上。</li>
<li>即使是生氣時，也要很溫柔<span class="math inline">\(\rightarrow\)</span>喜歡不聽話的0歲到16歲人類。</li>
<li>要當太太不一樣，要會做家事，會煮飯，喜歡小孩<span class="math inline">\(\rightarrow\)</span>喜歡也愛做被分配到的工作，但不要求薪水。</li>
<li>年輕的未婚女性<span class="math inline">\(\rightarrow\)</span>年齡16歲到20歲的未婚人類。</li>
</ul></li>
</ul></li>
<li>附屬項( 範圍 )
<ul>
<li>如專利範圍第1項所述之女性人類，更包括下述特性：
<ul>
<li>最好長髮飄逸<span class="math inline">\(\rightarrow\)</span>長髮過肩30公分以上。</li>
</ul></li>
</ul></li>
</ul>
<p><strong>＜Note＞：</strong>申請專利範圍用字要<strong>具體</strong>。<br>越<strong>抽象的形容詞</strong><span class="math inline">\(\rightarrow\)</span>越難寫<br><br>長得漂亮<br><span class="math inline">\(\rightarrow\)</span>五官特徵與松島菜菜子差異0%<sub>20%之間<span class="math inline">\(&lt;br&gt;\rightarrow\)</span>五官特徵與20歲松島菜菜子，經微軟發行的臉部辨識軟體，辨識之後差異0%</sub>20%之間</p>
<p>申請專利範圍所列的條件，<strong>『都』</strong>必須符合，才算是在專利範圍所主張的範圍之內。</p>
<ul>
<li>來了1個大美女、但少了一隻耳朵、指甲長且銳利、手常過膝
<ul>
<li>解決：</li>
<li>加入 Claim 3</li>
<li>一名女性人類( P )，包含( T )下述之特性( B )：</li>
<li>除了剛剛所述另外加入
<ul>
<li>有<strong>兩隻健全耳朵</strong>、且可辨識聲波。</li>
<li>四肢健全、雙手自然下垂、長度介於腰繫之間。</li>
<li>每根手指指甲長度在1.2~2公分之間。</li>
</ul></li>
</ul></li>
<li>來了個日本女生，但是個六指琴魔
<ul>
<li>修正 Claim：</li>
<li>有<strong>兩隻健全耳朵</strong>、且可辨識聲波。</li>
<li>四肢健全、雙手自然下垂、長度介於腰繫之間。</li>
<li>每隻手<strong>有五根手指頭</strong>、每根手指指甲長度在1.2~2公分之間。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\thedifferentsetofclaim2.png" alt="thedifferentsetofclaim2" /><figcaption aria-hidden="true">thedifferentsetofclaim2</figcaption>
</figure>
<ul>
<li>外加一個Claim 4涵蓋Claim 1～3
<ul>
<li>一名女性人類，包含以下特性。  - 一名女性人類，<strong>目前未婚</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\thedifferentsetofclaim3.png" alt="thedifferentsetofclaim3" /><figcaption aria-hidden="true">thedifferentsetofclaim3</figcaption>
</figure>
<h2 id="申請專利範圍之結構">申請專利範圍之結構</h2>
<ul>
<li>前言 ( Preamable )</li>
<li>連接詞 ( Trainsition )
<ul>
<li><strong>開放式：</strong>包含、包括、其特徵在於。(Comprise, contain, characterized by)</li>
<li><strong>封閉式：</strong>由...組成。( Consisting of )</li>
<li><strong>半開放式：</strong>基本上由...組成。( Consisting essentially of )</li>
</ul></li>
<li>主體 ( Body )</li>
</ul>
<h3 id="前言">前言</h3>
<ul>
<li>描述所請發明之標的型態：</li>
</ul>
<ol type="1">
<li>一種組合物…</li>
<li>一種裝置…</li>
<li>一種方法…</li>
</ol>
<ul>
<li>限制條件?</li>
</ul>
<ol type="1">
<li>一種<strong>用於載裝飲料( 用途限定 )</strong>的杯子…</li>
<li>一種<strong>具有兩分裝空間( 結構限定 )</strong>的杯子…</li>
<li>一種杯子…</li>
</ol>
<h3 id="連接詞">連接詞</h3>
<ul>
<li>開放式：包括、包含(comprise, contain)
<ul>
<li>表示所申請範圍包含主體中<strong>未記載</strong>之元件、成分、或步驟。</li>
<li>例如：一種組合物，包括成分A及B。</li>
</ul></li>
</ul>
<p><strong>＜Note＞：</strong>專利範圍涵蓋度最廣。</p>
<ul>
<li>半開放式：基本上由…組成(consisting essentially of)
<ul>
<li>不排除<strong>實質上無影響力之成分</strong>。</li>
<li>例如：一種組合物，基本上由成分A及B組成。</li>
</ul></li>
</ul>
<p><strong>＜Note＞：</strong>專利範圍涵蓋度中度。</p>
<ul>
<li>封閉式：由…組成(consisting of)
<ul>
<li>僅包含<strong>主體中記載之元件</strong>、成分、或步驟。</li>
<li>例如：一種組合物X，由成分A及B組成。</li>
</ul></li>
</ul>
<p><strong>＜Note＞：</strong>專利範圍涵蓋度最低。</p>
<h3 id="主體">主體</h3>
<ul>
<li>記載所請發明的<strong>主要特徵</strong>
<ul>
<li>標的請求項：物品或物質的結構特徵。</li>
<li>方法請求項：步驟。</li>
</ul></li>
</ul>
<h3 id="ex.-1"><span class="math inline">\(Ex.\)</span></h3>
<figure>
<img src="\willywangkaa\images\claimpractice1.png" alt="claimpractice1" /><figcaption aria-hidden="true">claimpractice1</figcaption>
</figure>
<ul>
<li>Claim A</li>
</ul>
<figure>
<img src="\willywangkaa\images\claimpractice2.png" alt="claimpractice2" /><figcaption aria-hidden="true">claimpractice2</figcaption>
</figure>
<ul>
<li>Claim B</li>
</ul>
<figure>
<img src="\willywangkaa\images\claimpractice3.png" alt="claimpractice3" /><figcaption aria-hidden="true">claimpractice3</figcaption>
</figure>
<ul>
<li>Claim C</li>
</ul>
<figure>
<img src="\willywangkaa\images\claimpractice4.png" alt="claimpractice4" /><figcaption aria-hidden="true">claimpractice4</figcaption>
</figure>
<ul>
<li>Claim D</li>
</ul>
<figure>
<img src="\willywangkaa\images\claimpractice5.png" alt="claimpractice5" /><figcaption aria-hidden="true">claimpractice5</figcaption>
</figure>
<ul>
<li>Claim E</li>
</ul>
<figure>
<img src="\willywangkaa\images\claimpractice6.png" alt="claimpractice6" /><figcaption aria-hidden="true">claimpractice6</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\claimpractice7.png" alt="upload successful" /><figcaption aria-hidden="true">upload successful</figcaption>
</figure>
<p><strong>＜Note＞：</strong>限制條件越多，權力範圍越小。專利說明書的所有部分，都是為『申請專利範圍』而活。</p>
<figure>
<img src="\willywangkaa\images\theeffectofthesizeofclaim.png" alt="theeffectofthesizeofclaim" /><figcaption aria-hidden="true">theeffectofthesizeofclaim</figcaption>
</figure>
<h2 id="範圍可以無限擴大嗎">範圍可以無限擴大嗎？</h2>
<ul>
<li>專利範圍當然是越大越好。</li>
<li>『發明之必要條件』與『既有技術』，專利說明書的具體實例也會影響專利範圍的大小。</li>
<li>最後，範圍無限擴大的專利的<strong>問題在能否通過</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
        <tag>Claim</tag>
        <tag>專利聲明</tag>
      </tags>
  </entry>
  <entry>
    <title>Technical Patent Study - Patent Specification</title>
    <url>/willywangkaa/2018/05/05/Technical-Patent-Study-Patent-Specification/</url>
    <content><![CDATA[<h1 id="patent-specification---專利說明書"><a href="http://terms.naer.edu.tw/detail/1678921/">Patent Specification</a> - 專利說明書</h1>
<hr />
<p>不能只提出要解之問題，要寫出<strong>『如何辦到』</strong>。專利說明書要說明『如何辦到』。</p>
<ul>
<li>想法：趁聖誕老公公發禮物時抓住他。
<ul>
<li>作法：需要具體機制。</li>
</ul></li>
<li>狗應該要有專門的馬桶。
<ul>
<li>作法：如何設計一個狗狗專用的馬桶。</li>
</ul></li>
</ul>
<h2 id="說明書的內容">說明書的內容</h2>
<figure>
<img src="\willywangkaa\images\patentspecificationcontent.png" alt="patentspecificationcontent" /><figcaption aria-hidden="true">patentspecificationcontent</figcaption>
</figure>
<h2 id="inid專利書目識別碼">INID專利書目識別碼</h2>
<ul>
<li><p><strong>I</strong>nternationally agreed <strong>N</strong>umbers for the <strong>I</strong>dentification of bibliographic <strong>D</strong>ata</p></li>
<li><p>二位阿拉伯數字組成的數字，作為辨識專利公報之書目資料項目的重要指標</p></li>
</ul>
<h3 id="國際專利分類號">國際專利分類號</h3>
<p>1971年由Strasburg國際專利協定所制定，並由<strong>世界智慧財產權組織(WIPO)</strong>每五年修訂一次並出版，其分類目的在便於專利資料的整理、查索及管理等運用。</p>
<p>目前<strong>最新版本為第八版</strong>，已於2006.01公佈並使用，並區分為核心版與進階版。</p>
<p>IPC從第一版的<strong>47,263個分類</strong>增加到第七版的<strong>67,634個分類</strong>，第八版的分類總數增加至約<strong>70,000個分類</strong>(進階版)，且分類架構已有大幅度的變動。</p>
<p>第七版以前約每五年更新一次，從第八版起，核心版將縮短為三年一次，進階版則隨時更新。</p>
<p>IPC分類之編排大致以</p>
<ol type="1">
<li>部(Section)</li>
<li>類(Class)</li>
<li>次類(Subclass)</li>
<li>主目(Group)</li>
<li>次目(Subgroup)</li>
</ol>
<p>五大階層編排中，每一階層彼此之間具有<strong>從屬關係</strong>。</p>
<h4 id="section---部">Section - 部</h4>
<figure>
<img src="\willywangkaa\images\theclassficationofIPC_section.png" alt="theclassficationofIPC_section" /><figcaption aria-hidden="true">theclassficationofIPC_section</figcaption>
</figure>
<h4 id="class---類">Class - 類</h4>
<figure>
<img src="\willywangkaa\images\theclassficationofIPC_class.png" alt="upload successful" /><figcaption aria-hidden="true">upload successful</figcaption>
</figure>
<h4 id="santa-calus-detector-patent-5523741">Santa Calus Detector Patent 5523741</h4>
<figure>
<img src="\willywangkaa\images\thesantacalusdetector1.png" alt="thesantacalusdetector1" /><figcaption aria-hidden="true">thesantacalusdetector1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\thesantacalusdetector2.png" alt="thesantacalusdetector2" /><figcaption aria-hidden="true">thesantacalusdetector2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\thesantacalusdetector3.png" alt="thesantacalusdetector3" /><figcaption aria-hidden="true">thesantacalusdetector3</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\thesantacalusdetector4.png" alt="upload successful" /><figcaption aria-hidden="true">upload successful</figcaption>
</figure>
<h4 id="小結論">小結論</h4>
<figure>
<img src="\willywangkaa\images\subsummary1.png" alt="subsummary1" /><figcaption aria-hidden="true">subsummary1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\subsummary2.png" alt="subsummary2" /><figcaption aria-hidden="true">subsummary2</figcaption>
</figure>
<h3 id="代號意義">代號意義</h3>
<p><strong>[10] 文件識別</strong></p>
<p>Identification of the patent, SPC, or patent document</p>
<p><strong>[11] 文件號碼</strong></p>
<p>Number of the patent , SPC, or patent document</p>
<p>[12] 文件種類</p>
<p>Plain language designation of the kind of document</p>
<p>[13] 文件種類代碼</p>
<p>Kind-of-document code according to WIPO Standard ST. 16</p>
<p>[15] 專利修正資訊</p>
<p>Patent correction information</p>
<p><strong>[19] 文件發行單位</strong></p>
<p>WIPO Standard ST. 3 Code, or other identification, of the office or organization publishing the document</p>
<ul>
<li>Santa Claus Detactor Patent 5523741</li>
</ul>
<figure>
<img src="\willywangkaa\images\santacalusdetector5.png" alt="santacalusdetector5" /><figcaption aria-hidden="true">santacalusdetector5</figcaption>
</figure>
<p>[20] 專利申請登記項目</p>
<p>Data concerning the application for a patent or SPC</p>
<p><strong>[21] 申請號</strong></p>
<p>Number(s) assigned to the application(s)</p>
<p><strong>[22] 申請日</strong></p>
<p>Date(s) of filing the application(s)</p>
<p>[23] 其他日期</p>
<p>Other Date(s), including date of filing complete specification following provisional specification and date of exhibition</p>
<p>[24] 工業產權生效日</p>
<p>Date from which industrial property rights may have effect</p>
<p>[25] 申請案最初提出時使用語文</p>
<p>Language in which the published application was originally filed</p>
<p>[26] 最初申請案之語文</p>
<p>Language in which the application is published</p>
<ul>
<li>Santa Claus Detactor Patent 5523741</li>
</ul>
<figure>
<img src="\willywangkaa\images\santacalusdetector6.png" alt="santacalusdetector6" /><figcaption aria-hidden="true">santacalusdetector6</figcaption>
</figure>
<p>[30] 國際優先權</p>
<p>Data relating to priority under the Paris Convention</p>
<p>[31] 優先權申請號</p>
<p>Number(s) assigned to priority application(s)</p>
<p>[32] 優先權申請日</p>
<p>Date(s) of filing of priority application(s)</p>
<p>[33] 優先權申請國家</p>
<p>WIPO Standard ST. 3 code identifying the national industrial property office allotting the priority application number or the organization allotting the regional priority application number ; for the international applications filed under the PCT, the code “WO” is to be used</p>
<p>[35] 優先權申請日期</p>
<p>For priority filings under regional or international arrangements, the WIPO Standard ST. 3 code identifying at least one country party to the Paris Convention for which the regional orinternational application was made</p>
<p>[40] 公開日期</p>
<p>Date(s) of making available of the public</p>
<p>[41] 未經審查尚未獲准專利的說明書提供公眾閱覽或複印的日期</p>
<p>[42] 經審查但尚未獲准專利的說明書提供公眾閱覽或複印的日期</p>
<p>[43] 未經審查之出版日期(公開日)</p>
<p>Date of making available to the public by printing or similar process of an unexamined patent document, on which no grant has taken place on or before the said date</p>
<p>[44] 經審查未獲權之出版日期</p>
<p><strong>[45] 經審查已獲權之公告日(公告日) </strong></p>
<p>Date of making available to the public by printing or similar process of an examined patent document on which grant has taken place on or</p>
<p>before the said date</p>
<p>[46] 僅有申請專利範圍的出版日期</p>
<p>[47] 獲准專利說明書提供公眾用覽或複製的日期</p>
<p>Date of making available to the public by viewing, copying on request, a patent document on which grant has taken place on or before the said date</p>
<ul>
<li>Santa Claus Detactor Patent 5523741</li>
</ul>
<figure>
<img src="\willywangkaa\images\santacalusdetector7.png" alt="upload successful" /><figcaption aria-hidden="true">upload successful</figcaption>
</figure>
<p>[50] 技術資料</p>
<p>Technical Information</p>
<p><strong>[51] 國際專利分類</strong></p>
<p>International Patent Classification or, in the case of a design patent, as referred to in subparagraph 4(c) of this Recommendation, International Classification for Industrial Designs</p>
<p><strong>[52] 本國專利分類</strong></p>
<p>Domestic or national Classification</p>
<p><strong>[54] 發明名稱</strong></p>
<p>Title of the invention</p>
<p><strong>[56] 先前技術文件明細</strong></p>
<p>List of prior art document, if separate from descriptive text</p>
<p><strong>[57] 摘要或申請專利範圍</strong></p>
<p>Abstract or claim</p>
<p><strong>[58] 檢索範圍</strong></p>
<p>Field of search</p>
<ul>
<li>Santa Claus Detactor Patent 5523741</li>
</ul>
<figure>
<img src="\willywangkaa\images\santacalusdetector8.png" alt="santacalusdetector8" /><figcaption aria-hidden="true">santacalusdetector8</figcaption>
</figure>
<p>[60] 與申請有關之法律文件</p>
<p>References to other legally or procedurally related domestic or previously domestic patent documents including unpublished applications therefore</p>
<p>[61] 追加關係</p>
<p>Earlier document to which this is an addition</p>
<p>[62] 分割關係</p>
<p>Earlier application form which the present document has been divided out</p>
<p>[63] 延續關係</p>
<p>Continuations</p>
<p>[64] 再發行關係</p>
<p>Document being reissued</p>
<p>[65] 同申請案, 先前公開於其他國家之文件</p>
<p>Previously published document concerning same application</p>
<p>[66] 取代關係</p>
<p>Document for which this is a substitute</p>
<p>[70] 人事項目</p>
<p>Identification of parties concerned with the patent ot SPC.</p>
<p>[71] 專利權人/申請人</p>
<p>Name(s) of applicant(s)</p>
<p>[72] 發明人</p>
<p>Name(s) of inventor(s) if known to be such</p>
<p>[73] 受讓人</p>
<p>Name(s) of grantee(s), holder(s),assignee(s), or owner(s)</p>
<p>[74] 代理人</p>
<p>Name(s) of attorney(s) agent(s)</p>
<p>[75] 發明人兼申請人</p>
<p>Name(s) of inventors who is (are) also applicant(s)</p>
<p><strong>[76] 發明人兼申請人及受讓人</strong></p>
<p>Name(s) of inventors who is (are) also applicant(s) and grantee(s).</p>
<ul>
<li>Santa Claus Detactor Patent 5523741</li>
</ul>
<figure>
<img src="\willywangkaa\images\santacalusdetector9.png" alt="santacalusdetector9" /><figcaption aria-hidden="true">santacalusdetector9</figcaption>
</figure>
<p>[80] 有關國際條約之資料識別</p>
<p>Identification of data related to International Conventions other than the Paris Convention, and to legislation with respect to SPCs.</p>
<p>[81] PCT國際申請指定國</p>
<p>[82] PCT選擇國</p>
<p>Elected State(s) according to the PCT</p>
<p><strong>[83] 微生物寄存資料</strong></p>
<p>Information concerning the deposit of microorganisms</p>
<p>[84] 專利指定國</p>
<p>Designed Contracting States under regional patent conventions</p>
<p>[85] 符合PCT第23條第1款或第40條第1款之規定而開始國內程序之日期</p>
<p>[86] PCT申請案相關資料</p>
<p>[87] PCT公開資料(公開號、公開語言、公開日)</p>
<p>[88] 檢索報告延遲公佈日期</p>
<p>[89] 發明人證書，或基於CMEA協定對於發明之保護文件號碼及原始國</p>
<ul>
<li>Santa Claus Detactor Patent 5523741</li>
</ul>
<figure>
<img src="\willywangkaa\images\santacalusdetector10.png" alt="santacalusdetector10" /><figcaption aria-hidden="true">santacalusdetector10</figcaption>
</figure>
]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
        <tag>Specification</tag>
        <tag>專利說明書</tag>
      </tags>
  </entry>
  <entry>
    <title>Technical Patent Study - Patent Applying</title>
    <url>/willywangkaa/2018/05/05/Technical%20Patent-Study-Patent-Applying-%E5%B0%88%E5%88%A9%E7%94%B3%E8%AB%8B/</url>
    <content><![CDATA[<h1 id="申請專利">申請專利</h1>
<hr />
<ul>
<li>申請流程
<ul>
<li>申請→18個月後公開→3年內請求實體審查→實體審查→<br>審定公告3個月→審查確定(無異議或異議不成立)→領證→( 舉發 )。</li>
</ul></li>
</ul>
<h2 id="申請日">申請日</h2>
<p>決定誰可以獲得勝利！</p>
<h3 id="申請日之取得">申請日之取得</h3>
<ul>
<li>專利法(25)：申請發明專利，由專利申請權人備具<strong>申請書</strong>、<strong>說明書</strong>、<strong>申請專利範圍</strong>、<strong>摘要及必要之圖式</strong>，向專利 <em>專責機關</em> 申請之。</li>
<li>專利法(25)：申請發明專利，以<strong>申請書</strong>、<strong>說明書</strong>、<strong>申請專利</strong>範圍及必要之圖式齊備之日為『<em>申請日</em>』。</li>
</ul>
<h2 id="申請文件">申請文件</h2>
<h3 id="需求">需求</h3>
<ul>
<li>申請書</li>
<li>說明書
<ul>
<li>發明名稱</li>
<li>發明說明<br>應<strong>明確且充分</strong>揭露發明之內容。</li>
<li><strong>申請專利範圍</strong><br>各請求向以<strong>簡潔</strong>之方式記載。</li>
<li>圖示</li>
</ul></li>
</ul>
<p><strong>＜Note＞：</strong>若申請有『生物材料專利』，申請人應將該生物材料<strong>寄存於指定機構</strong>。</p>
<h2 id="專利生效時間線">專利生效時間線</h2>
<figure>
<img src="\willywangkaa\images\timelineofpatentapplying.png" alt="timelineofpatentapplying" /><figcaption aria-hidden="true">timelineofpatentapplying</figcaption>
</figure>
<h2 id="專利權人">專利權人</h2>
<ul>
<li>發明人
<ul>
<li>對於這個發明有貢獻的人。</li>
</ul></li>
<li>專利申請人
<ul>
<li>提出專利申請的人，可以是公司、組織( 法人 )或是個人( 自然人 )。</li>
</ul></li>
</ul>
<p><strong>＜Note＞：</strong> <strong>一定要填寫發明人</strong>，用來表彰發明人的貢獻，若發明人的填寫有<strong>捏造的事實</strong>，即便取得專利權也可能被<strong>撤銷專利</strong>。</p>
<h3 id="誰是專利權人">誰是專利權人？</h3>
<p>真正擁有該專利權的人是<strong>「專利申請人」</strong>。</p>
<h2 id="審查">審查</h2>
<ul>
<li>專利提出申請 <strong>(繳費)</strong></li>
<li>請求審查 <strong>(再繳費)</strong>
<ul>
<li>申請後必須要在 2~5年( 大部分是<strong>3年</strong> )提出，否則專利視同<strong>撤回</strong>。<br>＜用意＞： 考慮專利是否具備價值。'</li>
</ul></li>
</ul>
<p><strong>＜Note＞：</strong>美國的專利申請，一律自動審查，<strong>無請求審查</strong>制度，所有費用都包含在提出專利申請時的繳費。</p>
<h2 id="始得權力日">始得權力日</h2>
<ul>
<li>專利權<strong>有效</strong>自<strong>申請日起算</strong>。</li>
<li><strong>侵權日</strong>自<em>專利審查</em>完成後起算。</li>
</ul>
<figure>
<img src="\willywangkaa\images\timelineofpatentapplying2.png" alt="timelineofpatentapplying2" /><figcaption aria-hidden="true">timelineofpatentapplying2</figcaption>
</figure>
<h3 id="早期公開制度-limited-early-publication-system">早期公開制度( Limited Early Publication System )</h3>
<p>『早期公開，請求審查』</p>
<ul>
<li>為大部分國家所採用。</li>
<li>在申請日後，18個月會在<strong>『公開公報』</strong>上刊登申請專利的內容。<br><strong>＜目的＞：</strong>使同產業<strong>提早新技術內容</strong>，以及避免<strong>重複研發相同技術</strong>。</li>
</ul>
<h3 id="暫准專利權-provisional-right">暫准專利權( Provisional right )</h3>
<p>如果在早期公開至專利核准期間，發生侵權行為，日後專利核准之後，專利權人可以<strong>要求暫准專利權其間的損失</strong>。</p>
<h3 id="公眾審查制度-public-review-system">公眾審查制度( Public review system )</h3>
<p>有些國家規定，在核准專利過後的3～6個月，會公開讓民眾確認這項專利的合格性，待時間過後繳交<strong>「專利領證費」</strong>並領證，接著，每年還需繳交「專利維持費」。</p>
<ul>
<li>歐盟
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
公眾審查制 ( 3～6個月 )</li>
</ul></li>
<li>美國
<ul>
<li><input type="checkbox" disabled="" />
公眾審查制</li>
<li>核准後直接領證。</li>
</ul></li>
</ul>
<h2 id="撤銷專利">撤銷專利</h2>
<p>在領到證書之後，<strong>任何人都可以主張撤銷你的專利</strong>。</p>
<ul>
<li>可能的原因
<ul>
<li>沒有符合「專利要件」。</li>
<li>不同意審查委員的看法。</li>
<li>提出當初審查委員沒有看討的<strong>先前技術( 習之技術 )</strong>。</li>
</ul></li>
</ul>
<h2 id="先申請主義-double-patenting">先申請主義( Double Patenting )</h2>
<ul>
<li>誰將獲得<strong>台灣專利</strong>？</li>
</ul>
<figure>
<img src="\willywangkaa\images\doublepatenting.png" alt="doublepatenting" /><figcaption aria-hidden="true">doublepatenting</figcaption>
</figure>
<p>( 乙君 ) <strong>＜先申請主義＞</strong></p>
<p>現在沒有所謂的＜先發明主義＞；依我國<strong>專利法(31)</strong>：相同發明有二以上之專利申請案時，僅得就其最先申請者准予發明專利。</p>
<p><strong>＜Note＞：</strong>先申請先贏。</p>
<h2 id="屬地主義">屬地主義</h2>
<p>只有在該國的專利核准過的專利，才能在該國享有專利權，其餘國家的專利權皆無法在該國產生任何作用。</p>
<h3 id="國際國內優先權">國際、國內優先權</h3>
<h4 id="right-of-priority---國際優先權">Right of Priority - 國際優先權</h4>
<ul>
<li>誰將獲得<strong>台灣專利</strong>？</li>
</ul>
<figure>
<img src="\willywangkaa\images\rightofpriority.png" alt="rightofpriority" /><figcaption aria-hidden="true">rightofpriority</figcaption>
</figure>
<p>( 乙君 ) 甲君<strong>未聲明＜國際優先權＞！</strong></p>
<p>專利申請人就<strong>相同發明</strong>，在他國提出第一次申請案後，<br>於<strong>特定期間</strong>內向我國提出之專利申請案得以主張「優先權』，換句話說<br>，以<strong>國外第一次申請案之申請日</strong>為『優先權日』，並據以作為審查是否符合專利之基準日。</p>
<p><strong>＜專利法(28)＞：</strong>申請人就相同發明在與<strong>中華民國相互承認優先權之國家或世界貿易組織會員(WTO)</strong>第一次依法申請專利，並於第一次申請專利之日後十二個月內，向中華民國申請專利者，得主張優先權。</p>
<p><strong>＜專利法(29)＞：</strong>依前條規定主張優先權者，應於申請專利同時聲明下列事項：</p>
<ol type="1">
<li>第一次申請之申請日。</li>
<li>受理該申請之國家或世界貿易組織會員。</li>
<li>第一次申請之申請案號數。<strong>申請人應於最早之優先權日後十六個月內</strong>，檢送經前項國家或世界貿易組織會員證明受理之申請文件。</li>
</ol>
<figure>
<img src="\willywangkaa\images\rightofpriority2.png" alt="rightofpriority2" /><figcaption aria-hidden="true">rightofpriority2</figcaption>
</figure>
<h4 id="right-of-domestic-priority---國內優先權">Right of Domestic Priority - 國內優先權</h4>
<ul>
<li>誰將獲得台灣專利？</li>
</ul>
<figure>
<img src="\willywangkaa\images\rightofdomesticpriority.png" alt="rightofdomesticpriority" /><figcaption aria-hidden="true">rightofdomesticpriority</figcaption>
</figure>
<p><strong>＜專利法(30)＞：</strong>申請人基於<strong>其在中華民國先申請</strong>之發明或新型專利案再提出專利之申請者 ，得就先申請案申請時說明書、申請專利範圍或圖式所載之發明或新型，主張優先權。</p>
<p><strong>＜Note＞：</strong>但有下列情事之一，不得主張之</p>
<ul>
<li>自先申請案申請日後<strong>已逾十二個月</strong>者。</li>
</ul>
<figure>
<img src="\willywangkaa\images\rightofdomesticpriority2.png" alt="upload successful" /><figcaption aria-hidden="true">upload successful</figcaption>
</figure>
<h2 id="曝光條款">曝光條款</h2>
<p><strong>＜專利法(22)＞：</strong>可供產業上利用之發明，無下列情事之一，得依本法申請取得發明專利。</p>
<ul>
<li>申請前已<strong>見於刊物</strong>者。</li>
<li>申請前已<strong>公開實施</strong>者。</li>
<li>申請前已<strong>為公眾所知悉</strong>者。</li>
</ul>
<p><strong>＜Note＞：</strong>發明雖無前項各款所列情事，但為其所屬技術領域中具有<strong>通常知識者</strong>依申請前之<strong>先前技術所能輕易完成</strong>時，仍不得取得發明。</p>
<p><strong>＜專利法(22)＞：</strong>申請人有下列情事之一，並於其事實發生後<strong>六個月內申請</strong>，該事實 <em>非</em> 屬第一項各款或前項不得取得發明專利之情事。</p>
<ol type="1">
<li>因<strong>實驗而公開</strong>者。</li>
<li>因於<strong>刊物發表</strong>者。</li>
<li>因<strong>陳列於政府主辦或認可之展覽會</strong>者。</li>
<li><strong>非出於其本意</strong>而洩漏者。</li>
</ol>
<h3 id="情境題">情境題</h3>
<h4 id="甲君獲得專利"><em>甲君</em>獲得專利</h4>
<figure>
<img src="\willywangkaa\images\situationquestion1.png" alt="situationquestion1" /><figcaption aria-hidden="true">situationquestion1</figcaption>
</figure>
<h4 id="乙君無法獲得專利"><em>乙君</em>無法獲得專利</h4>
<figure>
<img src="\willywangkaa\images\situationquestion2.png" alt="upload successful" /><figcaption aria-hidden="true">upload successful</figcaption>
</figure>
<h4 id="甲君獲得專利-1"><em>甲君</em>獲得專利</h4>
<figure>
<img src="\willywangkaa\images\situationquestion3.png" alt="upload successful" /><figcaption aria-hidden="true">upload successful</figcaption>
</figure>
<h4 id="沒有人可獲得專利-超過六個月的申請期"><em>沒有人</em>可獲得專利 ( 超過六個月的申請期 )</h4>
<figure>
<img src="\willywangkaa\images\situationquestion4.png" alt="upload successful" /><figcaption aria-hidden="true">upload successful</figcaption>
</figure>
<h2 id="審查-1">審查</h2>
<p>中華民國由智慧財產局依該申請是否具<strong>備專利要件</strong>決定。</p>
<ul>
<li><strong>符合</strong>專利要件→授予專利(<strong>核准</strong>)</li>
<li><strong>不符合</strong>專利要件→應予駁回(<strong>核駁</strong>)</li>
</ul>
<h3 id="核駁">核駁</h3>
<p>申請人對於『不給專利之審定』，不服者可以申請<strong>再審查</strong>。</p>
<p><strong>＜專利法(48)＞：</strong>發明專利申請人對於不予專利之審定有<em>不服者</em>，得於<strong>審定書送達後二個月內(60天內)</strong>備具<em>理由書</em>，<strong>申請再審查</strong>。但因<strong>申請程序不合法</strong>或<strong>申請人不適格</strong>而<em>不受理或駁回者</em>，得逕依法提起<strong>行政救濟</strong>。</p>
<h3 id="行政救濟">行政救濟</h3>
<ul>
<li>對於『再審查』不服之一方：應提起<strong>訴願</strong>。( 向<em>經濟部</em>為之 )</li>
<li>對於『訴願』不服之一方：應提起<strong>行政訴訟</strong>。( 向<em>行政院</em>為之 )
<ul>
<li>起訴：高等行政法院</li>
<li>上訴：最高行政法院</li>
</ul></li>
</ul>
<h2 id="專利權人-1">專利權人</h2>
<ul>
<li>專利權人是誰？</li>
</ul>
<figure>
<img src="\willywangkaa\images\situationquestion5.png" alt="situationquestion5" /><figcaption aria-hidden="true">situationquestion5</figcaption>
</figure>
<p><strong>＜專利法(7)＞：</strong> <strong>受雇人</strong>於<em>職務</em>上所完成之發明、新型或設計</p>
<ol type="1">
<li>其專利申請權及專利權屬於<strong>雇用人</strong>，雇用人應支付受雇人適當之報酬。</li>
<li>但契約<strong>另有約定者( 合約 )</strong>，從其約定。</li>
</ol>
<p><strong>＜Note＞：</strong>發明人具有『姓名表示權』。</p>
<p><strong>＜專利法(8)＞：</strong>受雇人於<strong>非職務</strong>上所完成之發明、新型或設計，其專利申請權及專利權<strong>屬於受雇人</strong>。</p>
<p><strong>＜專利法(7)＞：</strong>一方<strong>出資聘請</strong>他人從事研究開發者，其專利申請權及專利權之歸屬</p>
<ol type="1">
<li>依雙方契約約定</li>
<li>契約未約定者，屬於發明人、新型創作人或設計人。</li>
</ol>
<p><strong>＜Note＞：</strong> <strong>出資人</strong>得實施其發明、新型或設計之權力。</p>
<p><strong>＜Note＞：</strong> 美國專利的<strong>專利申請人一定是發明人</strong>，因此當職務上之發明，則在申請的同時，送交一份『讓與書』，以便權力由個人轉到公司。</p>
<h3 id="contract-of-employment-聘用合約書">Contract of Employment 聘用合約書</h3>
<figure>
<img src="\willywangkaa\images\contractofemplement.png" alt="contractofemplement" /><figcaption aria-hidden="true">contractofemplement</figcaption>
</figure>
<h1 id="補充">補充</h1>
<hr />
<h2 id="專利費用預估參考---以新台幣計工研院資料">專利費用預估參考 - 以新台幣計(工研院資料)</h2>
<figure>
<img src="\willywangkaa\images\feeofpatent.png" alt="feeofpatent" /><figcaption aria-hidden="true">feeofpatent</figcaption>
</figure>
<h2 id="輔大專利申請">輔大專利申請</h2>
<figure>
<img src="\willywangkaa\images\patentapplyingofFJU.png" alt="patentapplyingofFJU" /><figcaption aria-hidden="true">patentapplyingofFJU</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\patentofapplyingofFJU2.png" alt="patentofapplyingofFJU2" /><figcaption aria-hidden="true">patentofapplyingofFJU2</figcaption>
</figure>
<h1 id="參考">參考</h1>
<hr />
<p><a href="http://myweb.fcu.edu.tw/~mhsung/Patent/Patent_Searching/TIPO/TIPO_01.htm">中華民國專利公報檢所解析</a></p>
<p><a href="https://ejje.weblio.jp/content/%E6%97%A9%E6%9C%9F%E5%85%AC%E9%96%8B">早期公開を英語で・英訳 - 英和辞典・和英辞典 Weblio辞書</a></p>
<p><a href="https://www.tipo.gov.tw/np.asp?ctNode=7187&amp;mp=1">雙語詞彙</a></p>
]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
        <tag>Apply</tag>
        <tag>專利</tag>
        <tag>申請</tag>
      </tags>
  </entry>
  <entry>
    <title>Test - MathJax 文法測試</title>
    <url>/willywangkaa/2018/03/06/Test-MathJax-%E6%96%87%E6%B3%95%E6%B8%AC%E8%A9%A6/</url>
    <content><![CDATA[<h1 id="admin-mathjax-pandoc-測試">Admin + MathJax + Pandoc 測試</h1>
<hr />
<p><span class="math display">\[
\lim_{n \to \infty}\left ( 1 + \frac{1}{n} \right )^{n}
\]</span></p>
<p><span class="math display">\[
\left\{\begin{matrix}a \equiv b (\mod m)\\ c \equiv d (\mod m)\end{matrix}\right. \Rightarrow \left\{\begin{matrix}a \pm c \equiv b \pm d (\mod m)\\ a \cdot c \equiv b \cdot d (\mod m)\end{matrix}\right.
\]</span></p>
]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title>Technical Patent Study - 科技專利專題</title>
    <url>/willywangkaa/2018/05/04/Technical-Patent-Study-%E7%A7%91%E6%8A%80%E5%B0%88%E5%88%A9%E5%B0%88%E9%A1%8C/</url>
    <content><![CDATA[<h1 id="科技專利專題-technical-patent-study---概觀">科技專利專題 Technical Patent Study - 概觀</h1>
<hr />
<p>首先，要了解專利就必須先思考到底是甚麼東西、有什麼用？</p>
<ol type="1">
<li>瞭解專利對於<strong>企業發展</strong>及<strong>生存</strong>的<em>重要性</em>。</li>
<li>知道自己或團隊<strong>研發成果</strong>，<em>哪些可以申請專利</em>。</li>
<li>透過<strong>專利檢索</strong>快速<em>學習他人技術</em>。</li>
<li>避免侵害他人的專利。</li>
<li>撰寫優質的專利說明書(申請專利的技術文件)。</li>
</ol>
<h1 id="智慧財產權-intellectual-property-right">智慧財產權 Intellectual Property Right</h1>
<hr />
<p>智慧財產權，是一種<strong>無體財產權</strong>，係指人類精神活動之成果而能產生財產上之價值者，由法律所創設的一種<strong>權利</strong>，包括：</p>
<ol type="1">
<li><strong>著作權</strong></li>
<li><strong>商標權</strong></li>
<li><strong>專利權</strong></li>
<li>工業設計</li>
<li>積體電路布局 (IC)</li>
<li>鄰接權</li>
<li>植物種苗</li>
<li>商業秘密</li>
<li>不公平競爭</li>
</ol>
<figure>
<img src="\willywangkaa\images\intalletualpropertyform.png" alt="intalletualpropertyform" /><figcaption aria-hidden="true">intalletualpropertyform</figcaption>
</figure>
<h2 id="創作保護主義">創作保護主義</h2>
<hr />
<p>創作保護主義，僅有<strong>創作之事實</strong>，即取得<strong>著作權</strong>。但為期權利明確及有完整之著作權記錄，得兼採登記主義，而登記機關改歸中央圖書館。但著作物登記並非著作權之取得要件，僅推定其權利為真實。至於著作權之移轉或處分之限制，以及以著作權為標的之質權的設定、移轉、變更或消滅或處分之限制，則非經登記，不得對抗第三人。</p>
<p>其保護僅及於該著作之<strong>表達(Expression)</strong>，而不及於其所表達之思想(Idea)、程序、製程、系統、操作方法、概念、原理、發現。</p>
<p><strong>＜小見解＞：</strong>上述的「表達(Experssion)」就是已經動手做出的有形實體(書畫)，或無形創作(音樂、文章、程式碼)。</p>
<h3 id="著作權">著作權</h3>
<h4 id="著作權法之沿革">著作權法之沿革</h4>
<p>前清宣統 2年（ 1910 年）頒布之著作權律，係我國第一部之成文著作權法，其採註冊保護主義，著作物經註冊給照者，受著作權保護（著作權律第 4 條）。民國建立後，著作權律仍然沿用。北洋政府嗣於 1915 年頒布一部著作權法。國民政府亦於 1928年頒布著作權法，期間於 1944年、1949年、1964年、1985年、1990年、1992年、1993年、1998年、2001年、2003年及2004年均有修正。1985年修法前，作者必須申請註冊登記，始取得著作權，1985年修法後，改為著作人於著作完成時，享有著作權，係<strong>創作保護主義</strong>或稱<strong>自然發生主義</strong>。<em>註冊或登記均僅具存證之性質，並非取得著作權之要件</em>，倘當事人對於權利有爭執時，應由當事人自行<strong>提出證據證</strong>明之，並由司法機關依具體個案調查事實認定之，不應以著作權登記簿謄本之核發，作為認定著作權有無之唯一證據。而智慧財產局自<strong>1998年1月23日起</strong>，已<em>不再受理著作權登記業務</em>，倘原登記或註冊事項如有變更亦無從辦理更新。</p>
<h4 id="著作權侵害">著作權侵害</h4>
<p>判斷是否受侵害時須考慮的因素有二：</p>
<ol type="1">
<li>被侵害的<strong>標的必須是表達</strong>而<em>非思想</em>。</li>
<li>被告須有<strong>接觸(Access)</strong>或<strong>實質相似(Substantial Similarity)</strong>的<em>抄襲(Copying)行為</em>。</li>
</ol>
<p><strong>＜小見解＞：</strong>接觸(Access)就是該<strong>被告</strong>有可能接處到原創作者的<em>任何途徑</em>，所以有些創作者會在<strong>淨室(Clean Room)</strong>創作，防止任何的接觸可能性。</p>
<h4 id="如何保護著作權">如何保護著作權</h4>
<p>「<em>舉證之所在、敗訴之所在</em>」，如何<strong>舉證</strong>該著作是自己的原創是件很重要的事，用白話文來說，就是在創作時要無時無刻保留自己的手稿，來證明創作的靈感。法律是講求證據的，如果研發過程中<strong>未</strong>留下任何紀錄，則明明是贏的官司也可能會打輸。</p>
<ul>
<li>有些科技公司會有<strong>研發紀錄簿</strong>，證明創作的理念。</li>
<li>建立<strong>淨室(Clean Room)</strong>，意旨個隔離所有可能的接觸。</li>
</ul>
<h3 id="小結論">小結論</h3>
<ul>
<li>『專利保護<strong>概念</strong>，著作權不保護<strong>概念</strong>』</li>
</ul>
<h3 id="舉例">舉例</h3>
<h4 id="ex1."><span class="math inline">\(Ex1.\)</span></h4>
<p>微積分或力學原理，教師製作磨課師課程可以參考原文教科書，另行自編教材並解說，但在作業或測驗方面，就必須使用原文書的例題及習題內容了，這部分可以自由利用嗎？如果台灣書商無法授權，又該如何？</p>
<p>原文教科書的例題及習題，仍是受著作權法保護，教師必須自行製作題目，否則就只能取得授權。</p>
<p>台灣書商無法給予課本內容之授權，通常是因為他只有賣書的權利，沒有內容授權的權利，必須與出版社連繫。若出版社無權授權，就要與著作人聯絡。真的找不到，就只能自己創作，才是安全的。</p>
<p>這就說明了，編一本書是很辛苦的，內容及例題和解答，都是智慧成果，所以書才會賣得很貴。磨課師課程的內容製作也很辛苦，若想少辛苦一點，就是付錢取得他人既有成果來使用，這無法單是以標明出處，就可取代授權的。</p>
<h4 id="ex2."><span class="math inline">\(Ex2.\)</span></h4>
<figure>
<img src="\willywangkaa\images\patentexample1.png" alt="patentexample1" /><figcaption aria-hidden="true">patentexample1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\patentexample2.png" alt="patentexample2" /><figcaption aria-hidden="true">patentexample2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\patentexample3.png" alt="patentexample3" /><figcaption aria-hidden="true">patentexample3</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\patentexample4.png" alt="patentexample4" /><figcaption aria-hidden="true">patentexample4</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\patentexample5.png" alt="patentexample5" /><figcaption aria-hidden="true">patentexample5</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\patentexample6.png" alt="patentexample6" /><figcaption aria-hidden="true">patentexample6</figcaption>
</figure>
<h2 id="審查主義">審查主義</h2>
<p>指創作<em>完成後</em>，須向 <em>主管機關</em> 提出申請、並經主管機關<strong>審查通過</strong>後，始能取得權利者。</p>
<ul>
<li>中華民國的主管機關為『經濟部智慧財產局』</li>
<li>美國的主管機關為『專利商標局』</li>
<li>日本的主管機關為『特許廳』</li>
<li>大陸的主管機關為『知識產權局』</li>
</ul>
<h3 id="商標">商標</h3>
<p><strong>商標</strong>（英語：Trademark）是識別某<a href="https://zh.wikipedia.org/wiki/%E5%95%86%E5%93%81">商品</a>、<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1">服務</a>或與其相關具體個人或<a href="https://zh.wikipedia.org/wiki/%E4%BC%81%E4%B8%9A">企業</a>的顯著<a href="https://zh.wikipedia.org/wiki/%E6%A8%99%E8%AA%8C">標誌</a>，可以是<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%BD%A2">圖形</a>或<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97">文字</a>，也可以<a href="https://zh.wikipedia.org/wiki/%E8%81%B2%E9%9F%B3">聲音</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B0%A3%E5%91%B3">氣味</a>或<a href="https://zh.wikipedia.org/wiki/%E7%AB%8B%E9%AB%94%E5%9C%96">立體圖</a>來表示。</p>
<h4 id="標記">標記</h4>
<p>在採商標註冊標示國家，如美國，圖形「®」表示某個商標經過註冊，並受法律保護，稱作「主要註冊」（Principal Register）。圖形「™」常用來指某個標誌未經註冊通過而作為商標使用，僅具描述（merely descriptive）性質，可申請「輔助註冊」（supplemental register）避免日後其他類似商標註冊混淆，但標示使用上不限商標是否註冊通過。另外，尚有「℠」的<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8B%99%E5%95%86%E6%A8%99">服務商標</a>。</p>
<p>目前<a href="https://zh.wikipedia.org/wiki/%E5%85%A9%E5%B2%B8%E4%B8%89%E5%9C%B0">兩岸三地</a>商標法規中，中國大陸有明確規範「®」及圈內中文化的「注」，香港和台灣則無。</p>
<h3 id="專利">專利</h3>
<h4 id="專利流程-3-階段">專利流程 3 階段</h4>
<figure>
<img src="\willywangkaa\images\patentflowchart.png" alt="upload successful" /><figcaption aria-hidden="true">upload successful</figcaption>
</figure>
<h4 id="專利申請">專利申請</h4>
<p><a href="\willywangkaa\2018\05\05\Patent-Applying-專利申請#more">繼續閱讀</a></p>
<h1 id="參考">參考</h1>
<hr />
<p><a href="http://www.wunan.com.tw/www2/download/preview/1S24.PDF">五南文化 - 著作法參考書</a></p>
<p><a href="http://willywangkaa.udn.com/2010hsiao/16979891">著作權之侵害與救濟：第六章 著作權侵害之救濟的基本問題</a></p>
<p><a href="http://speech.nccu.edu.tw/sys/read_attach.php?id=29">認識智慧財產權 - 國立政治大學</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%95%86%E6%A0%87">Wiki - 商標</a></p>
]]></content>
      <categories>
        <category>Technical Patent Study</category>
      </categories>
      <tags>
        <tag>Patent</tag>
      </tags>
  </entry>
  <entry>
    <title>Test - 第一篇測試發文</title>
    <url>/willywangkaa/2018/03/06/Test-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%B8%AC%E8%A9%A6%E7%99%BC%E6%96%87/</url>
    <content><![CDATA[<h1 id="h1">H1</h1>
<h2 id="h2">H2</h2>
<h3 id="h3">H3</h3>
<h4 id="h4">H4</h4>
<h5 id="h5">H5</h5>
<h6 id="h6">H6</h6>
]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Mark Down</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - Graph algorithm</title>
    <url>/willywangkaa/2018/10/15/Algorithm-Graph-algorithm/</url>
    <content><![CDATA[<h1 id="graph-algorithm">Graph algorithm</h1>
<h2 id="depth-first-search">Depth first search</h2>
<ul>
<li>考慮圖中一點 u
<ul>
<li>color(u)：目前 u 節點的狀態
<ul>
<li>White
<ul>
<li>初始值，<strong>尚未訪查過</strong></li>
</ul></li>
<li>Gray
<ul>
<li><strong>已被訪查過</strong>，但未訪查完其子節點</li>
</ul></li>
<li>Black
<ul>
<li><strong>已經訪查完其子節點</strong></li>
</ul></li>
</ul></li>
<li>d(u)
<ul>
<li>發現時間點（Discover time）</li>
<li>第一次被訪查的時間點</li>
</ul></li>
<li>f(u)
<ul>
<li>完結時間點（Finish time）</li>
<li>訪查完其子節點的時間點</li>
</ul></li>
</ul></li>
<li>演算法（P.4-6）
<ul>
<li><strong>DFS(G)</strong>：自 G 中任一點開始做 DFS
<ul>
<li>dfs_visit(u)：訪查 u 節點</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    foreach u ∈ G.V           <span class="comment">// G 的點集合</span></span><br><span class="line">        <span class="built_in">color</span>(u) = white;</span><br><span class="line">    time = <span class="number">0</span>;                 <span class="comment">// 紀錄目前的時間</span></span><br><span class="line"></span><br><span class="line">    foreach u ∈ G.<span class="function">V</span></span><br><span class="line"><span class="function">        <span class="title">if</span><span class="params">(color(u) == white)</span> <span class="comment">// 找到一個尚未被訪查過的節點</span></span></span><br><span class="line"><span class="function">            <span class="title">dfs_visit</span><span class="params">(u)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_visit</span><span class="params">(Graph G, node u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">color</span>(u) = gray;</span><br><span class="line">    <span class="built_in">d</span>(u)     = ++time;</span><br><span class="line"></span><br><span class="line">    foreach v ∈ G.<span class="built_in">adj</span>(u)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">color</span>(v) == white)</span><br><span class="line">            <span class="built_in">dfs_visit</span>(G,v);</span><br><span class="line">    </span><br><span class="line">    time++;</span><br><span class="line">    <span class="built_in">f</span>(u)     = time;</span><br><span class="line">    <span class="built_in">color</span>(u) = black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li><span class="math inline">\(\Theta(\vert V\vert+\vert E\vert)\)</span> ：點數加上邊數</li>
</ul></li>
</ul>
<blockquote>
<p><strong>將整個圖的所有點與邊訪查一次</strong></p>
</blockquote>
<h3 id="應用">應用</h3>
<h4 id="dfs-tree---edge">DFS tree - Edge</h4>
<p>深度優先搜尋時，可以將圖中的邊分成四類：</p>
<ol type="1">
<li><strong>Tree edge</strong>
<ul>
<li>u 透過 (u,v) 邊以訪查 v 節點</li>
</ul></li>
</ol>
<blockquote>
<ul>
<li>可在訪查的過程表示為一個「DFS tree」</li>
</ul>
</blockquote>
<ol start="2" type="1">
<li><strong>Back edge</strong>
<ul>
<li>不為「Tree edge」，而在「DFS tree」上由<strong>子孫節點至祖先節點</strong>的邊</li>
</ul></li>
</ol>
<blockquote>
<ul>
<li><strong>自旋邊（Self loop）亦為「Back edge」</strong></li>
</ul>
</blockquote>
<ol start="3" type="1">
<li><strong>Forward edge</strong>
<ul>
<li>不為「Tree edge」，而在「DFS tree」上由<strong>祖先節點至子孫節點</strong>的邊</li>
</ul></li>
<li><strong>Cross edge</strong>
<ul>
<li>無祖孫關係的邊</li>
</ul></li>
</ol>
<p>在實現中，通常在執行 DFS 時就會直接以<strong>節點的狀態</strong>判斷邊的種類</p>
<ol type="1">
<li><strong>Tree edge</strong></li>
</ol>
<p><span class="math display">\[
u_{灰} \rightarrow_{Tree–edge} v_{白}
\]</span></p>
<ol start="2" type="1">
<li><strong>Back edge</strong></li>
</ol>
<p><span class="math display">\[
u_{灰} \rightarrow_{Back–edge} v_{灰}
\]</span></p>
<ol start="3" type="1">
<li><strong>Forward edge</strong></li>
</ol>
<p><span class="math display">\[
u_{灰} \rightarrow_{Forward–edge} ｛v_{黑} \;＆＆ \; d(u)&lt;d(v) ｝
\]</span></p>
<figure>
<img src="\willywangkaa\images\forwardedge.png" alt="forwardedge" /><figcaption aria-hidden="true">forwardedge</figcaption>
</figure>
<ol start="4" type="1">
<li><strong>Cross edge</strong></li>
</ol>
<p><span class="math display">\[
u_{灰} \rightarrow_{Cross–edge} ｛v_{黑} \;＆＆ \; d(v)&lt;d(u) ｝
\]</span></p>
<figure>
<img src="\willywangkaa\images\crossedge.png" alt="crossedge" /><figcaption aria-hidden="true">crossedge</figcaption>
</figure>
<ul>
<li>Ex （96 年台大資工）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    foreach u ∈ G.V &#123;          <span class="comment">// G 的點集合</span></span><br><span class="line">        <span class="built_in">color</span>(u) = white;</span><br><span class="line">        <span class="built_in">edge</span>(u)  = <span class="literal">NULL</span>;       <span class="comment">// DFS tree 初始化邊(雙向邊)</span></span><br><span class="line">    &#125;</span><br><span class="line">    time = <span class="number">0</span>;                  <span class="comment">// 紀錄目前的時間</span></span><br><span class="line"></span><br><span class="line">    foreach u ∈ G.<span class="function">V</span></span><br><span class="line"><span class="function">        <span class="title">if</span><span class="params">(color(u) == white)</span> <span class="comment">// 找到一個尚未被訪查過的節點</span></span></span><br><span class="line"><span class="function">            <span class="title">dfs_visit</span><span class="params">(G,u)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_visit</span><span class="params">(Graph G,node u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">color</span>(u) = gray;</span><br><span class="line">    <span class="built_in">d</span>(u)     = ++time;</span><br><span class="line"></span><br><span class="line">    foreach v ∈ G.<span class="built_in">adj</span>(u) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">color</span>(v) == white) &#123;</span><br><span class="line">            <span class="built_in">edge</span>(v)               = u;       <span class="comment">// 相連節點設為 u</span></span><br><span class="line">            <span class="built_in">edge</span>(v).attribute     = tree;</span><br><span class="line">            <span class="built_in">dfs_visit</span>(G,v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">color</span>(v) == gray) &#123;</span><br><span class="line">            <span class="built_in">edge</span>(v)               = u;       <span class="comment">// 相連節點設為 u</span></span><br><span class="line">            <span class="built_in">parent</span>(v).attribute   = back;</span><br><span class="line">			<span class="built_in">dfs_visit</span>(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 黑節點</span></span><br><span class="line">            <span class="built_in">edge</span>(v)               = u;       <span class="comment">// 相連節點設為 u</span></span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">d</span>(u) &gt; <span class="built_in">d</span>(v))                  <span class="comment">// 無祖孫關係</span></span><br><span class="line">				<span class="built_in">edge</span>(v).attribute = cross;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">d</span>(u) &lt; <span class="built_in">d</span>(v))             <span class="comment">// 有祖孫關係</span></span><br><span class="line">				<span class="built_in">edge</span>(v).attribute = forward;</span><br><span class="line">            </span><br><span class="line">			<span class="built_in">dfs_visit</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	time++</span><br><span class="line">	<span class="built_in">f</span>(u)     = time;</span><br><span class="line">    <span class="built_in">color</span>(u) = black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dfs-tree---acyclic">DFS tree - Acyclic</h4>
<blockquote>
<p><strong>存在「Back edge」時，代表有迴圈產生</strong></p>
</blockquote>
<ul>
<li>演算法（94 台大資工）（99 台大資工）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Acyclic</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    foreach u ∈ G.V                      <span class="comment">// G 的點集合</span></span><br><span class="line">        <span class="built_in">color</span>(u) = white;</span><br><span class="line">    time = <span class="number">0</span>;                            <span class="comment">// 紀錄目前的時間</span></span><br><span class="line"></span><br><span class="line">    foreach u ∈ G.<span class="function">V</span></span><br><span class="line"><span class="function">        <span class="title">if</span><span class="params">(color(u) == white)</span>            <span class="comment">// 找到一個尚未被訪查過的節點</span></span></span><br><span class="line"><span class="function">            <span class="title">if</span><span class="params">(dfs_visit(G,u) == CYCLIC)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">return</span> CYCLIC</span>;</span><br><span class="line">    <span class="keyword">return</span> ACYCLIC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CYCLIC = true, ACYCLIC = false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs_visit</span><span class="params">(Graph G, node u)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">color</span>(u) = gray;</span><br><span class="line">    <span class="built_in">d</span>(u)     = ++time;</span><br><span class="line"></span><br><span class="line">    foreach v ∈ G.<span class="built_in">adj</span>(u) &#123;</span><br><span class="line">        f = ACYCLIC;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">color</span>(v) == white)</span><br><span class="line">            f = f || <span class="built_in">dfs_visit</span>(G,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">color</span>(v) == gray)        <span class="comment">// 找到 Back-edge</span></span><br><span class="line">            f = f || CYCLIC;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    time++;</span><br><span class="line">    <span class="built_in">f</span>(u)     = time;</span><br><span class="line">    <span class="built_in">color</span>(u) = black;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Time complexity</strong>
<ul>
<li><strong>有向圖</strong>（94 台大資工）
<ul>
<li><span class="math inline">\(\Theta(∣V∣+∣E∣)\)</span></li>
</ul></li>
<li><strong>無向圖</strong>（99 台大資工）
<ul>
<li><span class="math inline">\(\Theta(∣V∣)\)</span></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>無向圖</strong></p>
<ul>
<li>根據鴿籠原理，最多只要檢查 V 個邊即可知道此圖是否為「Cyclic」
<ul>
<li><span class="math inline">\(\Theta(∣V∣+∣V∣) = \Theta(∣V∣)\)</span></li>
</ul></li>
<li><strong>在無向圖中只含有</strong>
<ul>
<li><strong>Tree edge</strong></li>
<li><strong>Back edge</strong></li>
</ul></li>
</ul>
</blockquote>
<blockquote>
<p><strong>有向圖</strong>不能以上述判斷</p>
<p>Example - 兩節點 A、B - 五條邊皆從 A 節點至 B 節點 - <strong>此圖不包含「Cycle」</strong></p>
</blockquote>
<h2 id="minimum-spainning-tree">Minimum spainning tree</h2>
<h3 id="問題探討">問題探討</h3>
<ul>
<li><strong>假設 (u,v) 為 G 權重最小的邊，則 (u,v) 必在 G 的某一個「最小生成樹」中</strong></li>
</ul>
<p>（<strong>反證法</strong>）</p>
<figure>
<img src="\willywangkaa\images\minimumspainingtree_1.png" alt="minimumspainingtree_1" /><figcaption aria-hidden="true">minimumspainingtree_1</figcaption>
</figure>
<ul>
<li>假設 T 為 G 的一個最小生成樹
<ul>
<li>(u,v)∉T</li>
<li>則 T ∪ {(u,v)} 會產生一個環路 C
<ul>
<li>C 存在一邊 e≠(u,v)，其 Weight(e) ≧ Weight(u,v)</li>
</ul></li>
</ul></li>
<li>令 T' = T ∪ {(u,v)} - {e}
<ul>
<li>則 Weight(T') ≦ Weight(T)</li>
<li><strong>T 不為 G 的最小生成樹</strong></li>
</ul></li>
</ul>
<blockquote>
<p>有兩種矛盾的現象產生</p>
<ul>
<li>當 <span class="math inline">\(Weight(T&#39;)&lt;Weight(T)\)</span> 時
<ul>
<li>代表原本的生成樹不為最小生成樹</li>
</ul></li>
<li>當 <span class="math inline">\(Weight(T&#39;) = Weight(T)\)</span> 時
<ul>
<li>代表該最小生成樹的集合中，必有一個樹包含 (u,v) 邊</li>
</ul></li>
</ul>
</blockquote>
<blockquote>
<p>「Cycle」：<strong>由三條邊組成的環路</strong></p>
</blockquote>
<ul>
<li>☆ 假設 (u,v) 為 G 中「權重」（Weight）<strong>第二小</strong>的邊
<ul>
<li>則 (u,v) 必在 G 的某一個「最小生成樹」中</li>
</ul></li>
</ul>
<p>（<strong>反證法</strong>）</p>
<blockquote>
<p>前提為該圖 G 各個權重不相等，否則反例如下：</p>
<figure>
<img src="\willywangkaa\images\minimumspainingtree_2.png" alt="minimumspainingtree_2" /><figcaption aria-hidden="true">minimumspainingtree_2</figcaption>
</figure>
</blockquote>
<ul>
<li>假設 T 為 G 的一個最小生成樹
<ul>
<li>(u,v)∉T</li>
<li>則 T ∪ {(u,v)} 會產生一個環路 C
<ul>
<li>因為環路必由三個邊組成
<ul>
<li>C 存在一邊 e≠(u,v)，其 Weight(e) ≧ Weight(u,v)</li>
</ul></li>
</ul></li>
</ul></li>
<li>令 T' = T ∪ {(u,v)} - {e}
<ul>
<li>則 Weight(T') ≦ Weight(T)</li>
<li><strong>T 不為 G 的最小生成樹</strong></li>
</ul></li>
</ul>
<blockquote>
<p>G 中<strong>權重第三小</strong>的邊不一定存在於 G 的某一個「最小生成樹」中</p>
<ul>
<li>Counter example</li>
</ul>
<figure>
<img src="\willywangkaa\images\minimumspainingtree_3.png" alt="minimumspainingtree_3" /><figcaption aria-hidden="true">minimumspainingtree_3</figcaption>
</figure>
</blockquote>
<h4 id="kruskals-algorithm-的正確性">Kruskal's algorithm 的正確性</h4>
<ul>
<li>T=(V,E)
<ul>
<li>使用「Kruskal's algorithm」找出的生成樹</li>
</ul></li>
<li>T'=(V,E')
<ul>
<li>真正的最小生成樹</li>
</ul></li>
</ul>
<ol type="1">
<li>若 T = T'​
<ul>
<li>得證</li>
</ul></li>
<li>若 T ≠ T'
<ul>
<li>T 必有邊不包含在 T' 之中
<ul>
<li>則挑一權重最小的邊 e ∈ E - E'</li>
<li>T' ∪ {e} 形成一環路 C</li>
<li>T' ∪ {e} 存在 e' ≠ e 且 w(e') ≧ w(e)
<ul>
<li>若 w(e') &lt; w(e)，「Kruskal's algorithm」執行時必優先選擇 e'（矛盾）</li>
</ul></li>
</ul></li>
<li>可造一個生成樹 T'' = (V, <strong>(E' - {e'})</strong> ∪ {e})
<ul>
<li>Weight(T'') ≦ Weight(T')</li>
</ul></li>
<li>重複上述步驟
<ul>
<li><span class="math inline">\(T&#39; \xrightarrow{用\;T\;有而\;T&#39;\;沒有的邊做替換} T&#39;&#39; \xrightarrow{用\;T\;有而\;T&#39;&#39;\;沒有的邊做替換} \dots \rightarrow T\)</span></li>
<li>其過程中生成樹的權重不會增加
<ul>
<li>則可以證明 Weight(T') = Weight(T)</li>
<li>T 為最小生成樹</li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h2 id="flow-network">Flow network</h2>
<p>「流量網路圖論模型」為一<strong>有向圖</strong> G=(V,E) 滿足：</p>
<ul>
<li><p>含有唯一「<strong>in-degree = 0</strong>」的點 S（Source；源點）</p></li>
<li><p>含有唯一「<strong>out-degree = 0</strong>」的點 T（Sink；匯點）</p></li>
<li><p>對於 (u,v) ∈ E</p>
<ul>
<li>定義<strong>容量 c：</strong><span class="math inline">\(E→R^+\)</span>
<ul>
<li>通常其加權有向邊 (u,v) 代表其<strong>容量</strong></li>
</ul></li>
<li>定義<strong>流量 f：</strong><span class="math inline">\(E → R\)</span>
<ul>
<li><strong>每個點流入水量等於流出水量</strong></li>
</ul></li>
<li>容量限制（Capacity constraints）
<ul>
<li><span class="math inline">\(\forall(u,v )\in E \Rightarrow f(u,v)\leq c(u,v)\)</span></li>
</ul></li>
</ul></li>
</ul>
<p>假設一流量網路 G=(V,E)，其「殘餘網路」（Residual network）為</p>
<ul>
<li>有向圖 <span class="math inline">\(G_f = (V, E_f)\)</span>
<ul>
<li><span class="math inline">\(E_f = ｛(u,v)︱^{（1）}0&lt;f(u,v)&lt;c(u,v) \;或\; ^{（2）}f(u,v)&lt;0｝\)</span></li>
<li>上述意旨 <span class="math inline">\((u,v)\in E_f\)</span> 代表<strong>其邊「尚有容量可以自 u 至 v」</strong>
<ul>
<li>假設 <span class="math inline">\(f(u,v)&gt;0\)</span> 代表有流量自 u 至 v，則其邊有容量的可能有二
<ul>
<li><strong>（1）其流量尚未達到容量（</strong><span class="math inline">\(f(u,v) &lt; c(u,v)\)</span><strong>）</strong>
<ul>
<li>殘餘容量：<span class="math inline">\(c_f(u,v) = c(u,v)-f(u,v)\)</span></li>
</ul></li>
<li><strong>（2）流量可以使其產生「回推容量」</strong>
<ul>
<li>因為 <span class="math inline">\(f(u,v)\)</span> 代表<strong>「u 至 v 有流量通過」</strong>
<ul>
<li>則<strong>「v 至 u」</strong>可將通過的流量<strong>回推</strong>，進而產生<strong>容量</strong></li>
</ul></li>
<li>殘餘容量：<span class="math inline">\(c_f(v,u) = f(u,v) = -f(v,u)\)</span></li>
</ul></li>
</ul></li>
</ul></li>
<li>「流量網路」的邊在「殘餘網路」中<strong>至多會被拆成兩條邊</strong>
<ul>
<li><span class="math inline">\(∣E_f∣ \leq 2∣E∣\)</span></li>
</ul></li>
</ul></li>
<li>假設在 <span class="math inline">\(G_f\)</span> 中，<strong>從「源點」至「匯點」存在一條路徑</strong>
<ul>
<li><strong>代表「源點」至「匯點」尚有容量</strong></li>
<li>假設其路徑中可以產生最小流量 <span class="math inline">\(f&#39;\)</span>
<ul>
<li>原流量網路的流量可增加為 <span class="math inline">\(f+f&#39;\)</span></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>增廣路徑定裡</strong></p>
<ul>
<li><strong>「一個網路達到最大流」</strong><span class="math inline">\(\Leftrightarrow\)</span> <strong>「其殘餘網路中『源點』至『匯點』沒有路徑」</strong></li>
</ul>
</blockquote>
<h3 id="max-flow-problem">Max flow problem</h3>
<ul>
<li>Input
<ul>
<li>一個「Flow network」 G = (V,E)</li>
</ul></li>
<li>Output
<ul>
<li>此網路的最大流量（源點最大流至匯點的水量）</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\flownetwork.png" alt="flownetwork" /><figcaption aria-hidden="true">flownetwork</figcaption>
</figure>
<h4 id="ford-fulkerson-algorithm">Ford-Fulkerson algorithm</h4>
<p>步驟</p>
<ol type="1">
<li>先將「流量網路」G 轉換為「殘餘網路」<span class="math inline">\(G_f\)</span></li>
<li>在 <span class="math inline">\(G_f\)</span> 中自 s → t 找一條增廣路徑 p（隨便的方法找一條路徑，如：DFS）
<ul>
<li>令 f 為 p 上最小的權重
<ul>
<li><span class="math inline">\(\overrightarrow{P}\)</span> 上每一邊的容量減少 f</li>
<li><span class="math inline">\(\overleftarrow{P}\)</span>上的每一邊容量增加 f<strong>（回推容量）</strong></li>
</ul></li>
</ul></li>
<li>重複第二步直到找不到增廣路徑 p</li>
<li>指向頂點 s 邊，其容量總和即為「最大流量」</li>
</ol>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Graph <span class="title">fordfulkerson</span><span class="params">(Graph G, node s, node t)</span> </span>&#123;</span><br><span class="line">    G_f = <span class="built_in">residualnetwork</span>(G);</span><br><span class="line">    path = <span class="built_in">exist_path</span>(G_f,s,t);</span><br><span class="line">    <span class="keyword">while</span>(path) &#123;</span><br><span class="line">        G_f = <span class="built_in">add_argumenting_path</span>(G_f, path);</span><br><span class="line">        path = <span class="built_in">exist_path</span>(G_f,s,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G_f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li><span class="math inline">\(O(∣f^＊∣\cdot E)\)</span>
<ul>
<li><span class="math inline">\(∣f^＊∣\)</span> 為最大流量</li>
<li><strong>效能差</strong></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<ul>
<li><strong>每次在第二個步找到的最小流量 f 為 1</strong>
<ul>
<li>每次找增廣路徑的時間複雜度為 O(∣V∣+∣E∣)</li>
<li><strong>必重複</strong> <span class="math inline">\(∣f^＊∣\)</span> <strong>回合找到最後總流量</strong>
<ul>
<li><span class="math inline">\(O(∣f^＊∣\cdot(∣V∣+∣E∣)) = O(∣f^＊∣\cdot E)\)</span></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1549795349837.png" alt="1549795349837" /><figcaption aria-hidden="true">1549795349837</figcaption>
</figure>
</blockquote>
<blockquote>
<p><strong>利用「已經求取完最大流量」的 Residual network 可得到「原本流量網路」的 Minimum cut</strong></p>
<ul>
<li>Minimum cut：有 (S,T) 兩個子圖，滿足
<ul>
<li>S <span class="math inline">\(\cup\)</span> T = V 且 S <span class="math inline">\(\cap\)</span> T = <span class="math inline">\(\phi\)</span></li>
<li>從子圖 S 連至子圖 T 之所有邊的權重和為所有「Cut」中最小</li>
</ul></li>
</ul>
<p>在求完最大流量的「Residual network」中，令</p>
<ul>
<li>S：｛自 S 可以到達的節點｝</li>
<li>T：｛自 T 可以到達的節點｝</li>
</ul>
<p>則 (S, T) 是原本「Flow network」的「Minimum cut」</p>
</blockquote>
<h4 id="edmond-karp-algorithm">Edmond-Karp algorithm</h4>
<p>步驟</p>
<ol type="1">
<li>先將「流量網路」G 轉換為「殘餘網路」<span class="math inline">\(G_f\)</span></li>
<li>自 s 作「<strong>Breadth first search</strong>」至 t 找到路徑 p
<ul>
<li>令 f 為 p 上最小的權重
<ul>
<li><span class="math inline">\(\overrightarrow{P}\)</span> 上每一邊的容量減少 f</li>
<li><span class="math inline">\(\overleftarrow{P}\)</span>上的每一邊容量增加 f<strong>（回推容量）</strong></li>
</ul></li>
</ul></li>
<li>重複第二步直到找不到增廣路徑 p</li>
<li>指向頂點 s 邊，其容量總和即為「最大流量」</li>
</ol>
<ul>
<li>Time complexity
<ul>
<li>以「Breadth first search」找最多 O(∣V∣∣E∣) 條「增廣路徑」
<ul>
<li>「鄰接矩陣」：<span class="math inline">\(O(∣V∣^2∣V∣∣E∣) = O(∣V∣^3∣E∣)\)</span></li>
<li>「鄰接串列」：<span class="math inline">\(O((∣V∣+∣E∣)(∣V∣∣E∣)) = O(∣V∣∣E∣^2)\)</span></li>
</ul></li>
</ul></li>
</ul>
<h5 id="時間複雜度證明">時間複雜度證明</h5>
<p><strong>證明最短增廣路徑（Argument path）的長度「非遞減」（反證法）</strong></p>
<blockquote>
<p><span class="math inline">\(G_f = (V, E_f)\)</span>：<strong>某次增廣前的「殘餘網路圖」</strong></p>
<p><span class="math inline">\(G_{f&#39;} = (V, E_{f&#39;})\)</span>：<strong>某次增廣後的「殘餘網路圖」</strong></p>
<ul>
<li><span class="math inline">\(\forall x \in V\)</span>
<ul>
<li><span class="math inline">\(\delta_f (s, x)\)</span> 為源點 s 到 x 頂點在 <span class="math inline">\(G_f\)</span> <strong>最短路徑</strong></li>
<li><span class="math inline">\(\delta_{f&#39;} (s, x)\)</span> 為源點 s 到 x 頂點在 <span class="math inline">\(G_f\)</span> <strong>最短路徑</strong></li>
</ul></li>
</ul>
</blockquote>
<ol type="1">
<li>假設 v 頂點是「在某次增廣後 <span class="math inline">\(\delta_{f} (s, v)\)</span> 長度變小的頂點」
<ul>
<li><span class="math inline">\(\Rightarrow \delta_f(s,v) &gt; \delta_{f&#39;}(s,v)\)</span></li>
</ul></li>
<li>假設 u 頂點為最短路徑 <span class="math inline">\(\delta_{f&#39;}(s,v)\)</span> 裡 v 的前一個頂點（<strong>在該次增廣後其最短路徑有可能變長或不變</strong>）
<ul>
<li><span class="math inline">\(\Rightarrow \delta_{f&#39;}(s,v) = \delta_{f&#39;}(s,u)+1\)</span></li>
<li>因為「增廣前 s 至 u 的最短路徑」≦「增廣後 s 至 u 的最短路徑」
<ul>
<li>$<em>f(s,u) </em>{f'}(s,u) $
<ul>
<li>則 <span class="math inline">\(\Rightarrow \delta_f(s,u)+1 \leq \delta_{f&#39;}(s,u)+1 = \delta_{f&#39;}(s,v) &lt; \delta_f(s,v)\\ \Rightarrow \delta_f(s,v)&gt; \delta_f(s,u)+1 \;......（1）\)</span></li>
</ul></li>
<li>如果 <span class="math inline">\((u,v) \in E_f\)</span>
<ul>
<li>由於三角定裡則「s 至 v 的最短路徑」必小於等於「s 至 u 的最短路徑」加上 (u,v) 邊
<ul>
<li><span class="math inline">\(\Rightarrow \delta_f(s,v) \leq \delta(s,u)+1\)</span></li>
</ul></li>
</ul></li>
<li>因為（1）則 <span class="math inline">\((u,v)\notin E_f\)</span></li>
</ul></li>
</ul></li>
<li>因為 <span class="math inline">\((u,v) \in E_{f&#39;}\)</span> 且 <span class="math inline">\((u,v) \notin E_f\)</span>
<ul>
<li>所以可以知道<strong>「此次增廣必經過 (v, u)」</strong>
<ul>
<li>則「s 至 u 的最短路徑」等於「s 至 v 的最短路徑」+ 1
<ul>
<li><span class="math inline">\(\Rightarrow \delta_f(s,u) = \delta_f(s,v)+1 \;.....（2）\)</span></li>
</ul></li>
</ul></li>
<li>將（2）帶入（1）中
<ul>
<li>$_f(s,v) &gt; (_f(s,v) + 1)+1 $（矛盾）</li>
</ul></li>
</ul></li>
<li>所以 v 頂點不存在，證明<strong>「最短增廣路徑」長度非遞減</strong></li>
</ol>
<p><strong>證明增廣次數為 O(∣V∣∣E∣)</strong></p>
<blockquote>
<ul>
<li>在一次增廣中
<ul>
<li><strong>定義「Critical edge」為該增廣路徑中容量最小的邊（</strong>若有多條取其一即可）</li>
</ul></li>
</ul>
</blockquote>
<ol type="1">
<li>假設 (u,v) 為 k-th 增廣中的「Critical edge」
<ul>
<li>則 k-th 增廣後 <span class="math inline">\((u,v) \notin E_{f&#39;}\)</span></li>
<li>若在 k-th 增廣之後的 i-th 增廣後 (u,v) 再度出現（i &gt; k）
<ul>
<li>則 i-th 增廣必定沿著 (u,v) 進行增廣</li>
</ul></li>
</ul></li>
<li>對 k-th 與 i-th 進行討論
<ul>
<li>在 k-th 增廣前，存在 <span class="math inline">\(\delta_{f^{作 \;k–th \; 之前}}(s,v)+1 = \delta_{f^{作 \;k–th \; 之前}}(s,u)\)</span></li>
<li>在 i-th 增廣前，存在 <span class="math inline">\(\delta_{f^{作 \;i–th \; 之前}}(s,u)+1 = \delta_{f^{作 \;i–th \; 之前}}(s,v)\)</span></li>
<li>然而已知「最短增廣路徑長度非遞減」
<ul>
<li>故 <span class="math inline">\(\delta_{f^{作 \;k–th \; 之前}}(s,v)+2 \leq \delta_{f^{作 \;i–th \; 之前}}(s,u)\)</span></li>
</ul></li>
</ul></li>
<li>最短增廣路的長度不超過 ∣V∣-1
<ul>
<li>因為一條邊為「Critical edge」時，其增廣路徑會不斷累加 2
<ul>
<li>故一條邊成為「Critical edge」的次數不超過 <span class="math inline">\(\frac{∣V∣-1}{2}\)</span></li>
</ul></li>
<li>每次增廣最少有一條「Critical edge」
<ul>
<li>由定義可以知道 <span class="math inline">\(∣E_f∣ \leq 2∣E∣\)</span></li>
</ul></li>
<li>所以最差的情況就是每條邊都被選成為增廣路徑
<ul>
<li>$O(∣E∣) =O(∣V∣∣E∣) $</li>
</ul></li>
</ul></li>
</ol>
<h4 id="dinic-algorithm">Dinic algorithm</h4>
<p>「Shortest augmenting path algorithm」改良版，作一次可以找到所有「一樣長的最短擴充路徑」</p>
<p>步驟</p>
<ol type="1">
<li>計算「剩餘網路」各點到源點（匯點）的最短距離</li>
<li>建立「容許網路」（Admissible network）
<ul>
<li>尋找「阻塞流」（Blocking flow），並擴充其流量</li>
</ul></li>
<li>重覆步驟 1、2 最多 V-1 次，直到無法擴充流量</li>
</ol>
<blockquote>
<ul>
<li>在「剩餘網路」中
<ul>
<li>以阻塞流擴充流量，就斷絕了所有「一樣長的最短擴充路徑」</li>
</ul></li>
<li>在「容許網路」中
<ul>
<li>所有「由源點到匯點的最短路徑」都被阻塞
<ul>
<li>在「剩餘網路」中，在「Edmond-Karp algorithm」中已證明源點到匯點的最短距離會增加</li>
</ul></li>
</ul></li>
<li>「擴充路徑」的長度範圍是 1 到 V-1 （Simple path）
<ul>
<li>故最多找 V-1 次阻塞流</li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>時間複雜度
<ul>
<li>O(∣V∣²∣E∣)
<ul>
<li>找一個阻塞流：O(∣V∣∣E∣)</li>
<li>最多找：O(∣V∣)</li>
</ul></li>
</ul></li>
</ul>
<h5 id="容許網路">容許網路</h5>
<p>在「剩餘網路」上以源點（匯點）作為起點，計算源點（匯點）到每一點的<strong>最短距離</strong></p>
<ul>
<li>在剩餘網路中
<ul>
<li>一條由<strong>源點往匯點方向</strong>的邊
<ul>
<li>若兩其端點最短距離相差一
<ul>
<li>稱作「容許邊」（Admissible edge）</li>
</ul></li>
</ul></li>
</ul></li>
<li>所有容許邊，整體視作一張圖
<ul>
<li>稱作「容許網路」（Admissible Network）</li>
</ul></li>
</ul>
<p>「流量網路」G = (V,E)</p>
<figure>
<img src="\willywangkaa\images\1549793031130.png" alt="1549793031130" /><figcaption aria-hidden="true">1549793031130</figcaption>
</figure>
<p>其「剩餘網路」<span class="math inline">\(G_f = (V, E_f)\)</span></p>
<figure>
<img src="\willywangkaa\images\1549793298592.png" alt="1549793298592" /><figcaption aria-hidden="true">1549793298592</figcaption>
</figure>
<p>一種由源點開始的「容許網路」</p>
<figure>
<img src="\willywangkaa\images\1549793355647.png" alt="1549793355647" /><figcaption aria-hidden="true">1549793355647</figcaption>
</figure>
<p>一種由匯點開始的「容許網路」</p>
<figure>
<img src="\willywangkaa\images\1549793388148.png" alt="1549793388148" /><figcaption aria-hidden="true">1549793388148</figcaption>
</figure>
<blockquote>
<ul>
<li>容許網路
<ul>
<li>為有向無環圖（DAG）或稱作分層圖（Level graph）
<ul>
<li>容許網路可以畫成一層一層的模樣，只有相鄰的層有邊</li>
</ul></li>
<li>任意一條由源點到匯點的路徑
<ul>
<li>為最短擴充路徑</li>
</ul></li>
<li>藉由容許網路，可以迅速找到所有「一樣長的最短擴充路徑」</li>
</ul></li>
</ul>
<p>容許網路就是剩餘網路的「最短路徑圖」</p>
<figure>
<img src="\willywangkaa\images\1549793497499.png" alt="1549793497499" /><figcaption aria-hidden="true">1549793497499</figcaption>
</figure>
<p>（左圖為源點開始的「容許網路」分層圖；右圖為匯點開始的「容許網路」分層圖）</p>
</blockquote>
<h5 id="阻塞流">阻塞流</h5>
<p>在容許網路中一個源點到匯點的流，無法再擴充流量稱作「阻塞流」（通常會出現許多種選擇，不必選其最大流）</p>
<ol type="1">
<li>逐次建立的「容許網路」中
<ul>
<li><strong>會找到所有「一樣長的最短擴充路徑」</strong></li>
</ul></li>
<li>在該「容許網路」中<strong>讓擴充的流量到達瓶頸</strong>
<ul>
<li>整體形成「阻塞流」</li>
</ul></li>
</ol>
<figure>
<img src="\willywangkaa\images\1549794137394.png" alt="1549794137394" /><figcaption aria-hidden="true">1549794137394</figcaption>
</figure>
<blockquote>
<ul>
<li>容許網路上尋找最短擴充路徑
<ul>
<li>不必作溯洄沖減（溯洄沖減會增加路徑長度，最後得到的不是最短擴充路徑）</li>
</ul></li>
<li>源點隨意往匯點走，若遇到死胡同，就重頭開始走，下次避免再走到死胡同
<ul>
<li><strong>改由匯點隨意往源點走，就不會遇到死胡同</strong></li>
</ul></li>
<li>若順利走到匯點，就形成一條最短擴充路徑，並且擴充流量
<ul>
<li><strong>一條最短擴充路徑</strong>
<ul>
<li>至少有<strong>一條邊</strong>是瓶頸</li>
</ul></li>
</ul></li>
<li>容許網路最多只有 E 條邊能作為瓶頸
<ul>
<li>所以一個阻塞流最多只有 E 條最短擴充路徑</li>
<li>從源點走到匯點並擴充流量需時 O(∣V∣)
<ul>
<li>最多有 O(∣E∣) 條最短擴充路徑，所以找出一個阻塞流的時間複雜度為 O(∣V∣∣E∣)</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h4 id="補充例題">補充例題</h4>
<p><strong>Example</strong>（P.4-80 ex.20；<strong>Escape problem</strong>）</p>
<figure>
<img src="\willywangkaa\images\escapeproblem.png" alt="escapeproblem" /><figcaption aria-hidden="true">escapeproblem</figcaption>
</figure>
<blockquote>
<p>將問題轉換成「邊與點均有 <strong>Capacity</strong> 的最大流量問題」</p>
<p><strong>（將問題「Reduce」至「Flow network」中解決）</strong></p>
</blockquote>
<figure>
<img src="\willywangkaa\images\escapeproblem_sol.png" alt="escapeproblem_sol" /><figcaption aria-hidden="true">escapeproblem_sol</figcaption>
</figure>
<p>給定一個「Escape problem」的格子圖 ( Grid；有 m 個<strong>起點</strong>與 4n-4 個<strong>出口</strong> )</p>
<p>建立「Flow network」G=(V,E)：</p>
<ol type="1">
<li>建立一個「Source」節點 S 並與逃生問題中的<strong>起點</strong>（藍色節點）相接</li>
<li>建立一個「Sink」節點 T 並與逃生問題中的<strong>邊界點</strong>（黃色區塊）的點相接</li>
<li>「Grid」上的每一條無向邊 (u,v) ，在 G 中建立相對應的有向邊 (u,v) 與 (v,u)</li>
<li>將每一個節點與邊的流量接設定為 1</li>
</ol>
<p>若在 G 中能找到最大流量為 m，則亦可以在「Grid」中找到一個逃生的方法。</p>
<blockquote>
<p><strong>點與邊均有「Capacity」 的流量網路可以用傳統的流量網路實現</strong></p>
<figure>
<img src="\willywangkaa\images\escapeproblem_solconti.png" alt="escapeproblem_solconti" /><figcaption aria-hidden="true">escapeproblem_solconti</figcaption>
</figure>
</blockquote>
<p><strong>Example（2）（101交通大學資料結構與演算法）</strong></p>
<p>This question is about the max flow problem</p>
<ul>
<li><strong>Which of the following statements is wrong?</strong>
<ul>
<li>（A）By the Ford-Fulkerson algorithm we can find the maximum flow.</li>
<li>（B）Given a flow network G=(V,E), Edmond-Karp algorithm has time complexity <span class="math inline">\(O(∣V∣∣E∣^2)\)</span>.</li>
<li>（C）The time complexity of Ford-Fulkerson algorithm depend on the capacity.</li>
<li><strong>（D）If each edge has a different capacity, then there exists a unique minimum cut.</strong></li>
<li>（E）The maximum flow is equal to the capacity of a minimum cut.</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1549709412486.png" alt="1549709412486" /><figcaption aria-hidden="true">1549709412486</figcaption>
</figure>
<ul>
<li><strong>Which statement is wrong for a flow network G=(V,E)?</strong>
<ul>
<li>（A）If f is a maximum flow in G, <strong>then the corresponding residual network contains no augmenting path.</strong></li>
<li>（B）For any cut (S,T), the capacity of the cut is not smaller than the value of the flow crossing this cut.</li>
<li>（C）The value of any flow f in G is bounded above by the capacity of any cut of G.</li>
<li><strong>（D）If all edges of G have different capacities, then there exists a unique flow f that gives the maximum flow.</strong></li>
<li>（E）The capacity of each edge of G can be any non-negative number.</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1549708938056.png" alt="1549708938056" /><figcaption aria-hidden="true">1549708938056</figcaption>
</figure>
<ul>
<li><strong>Let G=(V,E) be a bipartite graph, where V = L ∪ R. Which statement is wrong about finding a maximum bipartite matching?</strong>
<ul>
<li>（A）It can be solved by constructing a corresponding flow network and finding the maximum flow.</li>
<li>（B）The corresponding flow network can be obtained by adding two vertices s, t and edges from s to vertices in L, and edges from vertices in R to t.</li>
<li>（C）The capacity of each edge in the corresponding flow network is set to 1.</li>
<li><strong>（D）The maximum flow of the corresponding flow network is always integral and the flow value of each edge is integral as well.</strong></li>
<li>（E）The cardinality of a maximum matching of G is equal to the maximum flow of the corresponding flow network.</li>
</ul></li>
</ul>
<p><strong>「Maximum flow」必為整數，但是 Edge 上的「Flow」未必</strong></p>
<figure>
<img src="\willywangkaa\images\1549709744238.png" alt="1549709744238" /><figcaption aria-hidden="true">1549709744238</figcaption>
</figure>
<h2 id="其它問題">其它問題</h2>
<ul>
<li><strong>問題的要求即使有小變化，可能使其難度改變很大</strong>
<ul>
<li>Shortest path problem（Polynomial）與 <strong>Longest path problem（Non-deterministic polynomial）</strong></li>
<li>Minimum cut（Polynomial）與 <strong>Maximum cut（Non-deterministic polynomial）</strong></li>
<li><strong>Euler circuit（Polynomial）</strong>與 Hamilton cycle（NP-Complete）</li>
</ul></li>
<li><strong>同一個問題，若給的環境不同，難度亦可能相差很多</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th></th>
<th>Graph</th>
<th>Tree</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Longest path problem</strong></td>
<td>NPC</td>
<td>Linear time（4-66 ex.6）</td>
</tr>
<tr class="even">
<td><strong>Minimum vertex cover</strong></td>
<td>NPC</td>
<td>Linear time（Polynomial）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Vertex cover：會和圖上所有邊相連的一個<strong>點集合</strong></p>
<p>下圖的「Vertex cover」為｛b, d, f｝</p>
<figure>
<img src="\willywangkaa\images\vertexcover.png" alt="vertexcover" /><figcaption aria-hidden="true">vertexcover</figcaption>
</figure>
</blockquote>
<h1 id="補充例題-1">補充例題</h1>
<p>Example（100 交通大學資料結構與演算法）</p>
<ul>
<li>Suppose there are several cities along a highway (from the left to the right on the map), which has no forks</li>
<li>Given the distances between the neighboring cities, we can compute the distance between any two cities
<ul>
<li>For example, given 4 cities, in order, (A,B,C,D) and the distances between neighboring cities are: distance(A,B)=1, distance(B, C)=2, distance(C,D)=4</li>
<li>Then we can compute the distance matrix</li>
</ul></li>
<li>In this problem, we consider the reverse problem
<ul>
<li>Given the distance between all pair of the cities, we want to recover the order of the cities along the highway</li>
<li>Suppose there are N cities and we only know the distances between all pairs of cities, that is, there are <span class="math inline">\(\frac{N(N-1)}{2}\)</span> number in arbitrary order</li>
<li>For convenience, let the leftmost city be the first city and the rightmost city be the last one and order cities accordingly</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th></th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>1</td>
<td>3</td>
<td>7</td>
</tr>
<tr class="even">
<td>B</td>
<td></td>
<td>2</td>
<td>6</td>
</tr>
<tr class="odd">
<td>C</td>
<td></td>
<td></td>
<td>4</td>
</tr>
</tbody>
</table>
<blockquote>
<p>（中譯）</p>
<ul>
<li>假設有數個在「無岔路高速公路」旁的城市（在地圖上為由左至右）</li>
<li>當每個相鄰城市的距離得知時，我們可以計算出任兩個城市之間的距離
<ul>
<li>舉例來說，依序給定四個城市（A、B、C、D）與每個相鄰城市的距離：
<ul>
<li>A 與 B 距離 = 1</li>
<li>B 與 C 距離 = 2</li>
<li>C 與 D 距離 = 4</li>
</ul></li>
<li>則我們可以計算出其距離矩陣</li>
</ul></li>
<li>在此問題中要考慮的是「逆向工程問題」
<ul>
<li>給定任兩個城市之間的距離（未給出是哪兩個城市，只知道距離資訊），欲將原始相鄰城市的距離求出</li>
<li>假設知道 N 個城市與城市的距離，也就是說會給定一串大小為 <span class="math inline">\(\frac{N(N-1)}{2}\)</span> 且無序的數字數列</li>
<li>為了方便計算，讓最左邊的城市當作第一個城市最右邊的城市為最後一個城市</li>
</ul></li>
</ul>
</blockquote>
<p><strong>Which of the following is false?</strong></p>
<ol type="1">
<li>The largest value must be the distance of <strong>the first city and last city along the highway</strong></li>
<li>It can be solved by <strong>searching</strong></li>
<li>If the input has an answer, <strong>then it is unique</strong></li>
<li>The second largest value can be the distance of the first city and second to the last city along the highway</li>
<li>The second largest value can be the distance of <strong>the second city and the last city along the highway</strong></li>
</ol>
<p><strong>Ans: (3)</strong></p>
<p><strong>Suppose there are 6 cities and the distance between each pair of the cities are: 9, 8, 8, 7, 6, 6, 5, 5, 3, 3, 3, 2, 2, 1, 1. Which of the following is correct ?</strong></p>
<ol type="1">
<li>There is no solution for this input</li>
<li>The distance of the second city and the third city is 3</li>
<li>The distance of the fourth city and the fifth city is 1</li>
<li>The distance of the third city and the fourth city is 3</li>
<li>The distance of the second city and the third city is 8</li>
</ol>
<table>
<thead>
<tr class="header">
<th></th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>3</td>
<td>6</td>
<td>8</td>
<td>9</td>
</tr>
<tr class="even">
<td>2</td>
<td></td>
<td>2</td>
<td>5</td>
<td>7</td>
<td>8</td>
</tr>
<tr class="odd">
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td>5</td>
<td>6</td>
</tr>
<tr class="even">
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>2</td>
<td>3</td>
</tr>
<tr class="odd">
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table>
<p><strong>Ans: (4)</strong></p>
<p>Example（105 成功大學資料結構與演算法）</p>
<p>（參考：<a href="http://cs.jhu.edu/~cs363/fall2013/assign8_sln.pdf">600.363/463 Algorithms - Fall 2013 Solution to Assignment 8 - JHU CS</a>、<a href="https://www.ptt.cc/bbs/Grad-ProbAsk/M.1550727264.A.BB0.html">105成大資演第7題</a>）</p>
<ul>
<li>We are given a direct graph G=(V,E) on which each edge (u,v)∈E has an associated value <strong>r(u,v), which is a read number in the range 0≦r(u,v)≦1 that represents the reliability of a communication channel from u to v</strong></li>
<li>We interpret r(u,v) as <strong>the probabilities that the channel from u to v will not fail</strong>, and we assume that these probabilities are independent</li>
<li>Given an efficient algorithm to find the most reliability path between two given vertices</li>
</ul>
<blockquote>
<p>欲找到自 u 至 v 最可靠的路徑，最大化其路徑上的成功傳送機率乘積</p>
<ul>
<li>令 s 為起點、 t 為終點
<ul>
<li>p=(<span class="math inline">\(v_0, v_1, \ldots, v_k\)</span>)
<ul>
<li><span class="math inline">\(v_0 = s, v_k = t\)</span></li>
</ul></li>
<li>p=argument path, <span class="math inline">\(max(\prod_{i = 0}^k r(v_{i-1},v_i))\)</span></li>
</ul></li>
<li>將其問題轉換成「Single source shortest path problem」
<ul>
<li><strong>轉換權重</strong>
<ul>
<li>用對數含函數轉換
<ul>
<li><span class="math inline">\(\Rightarrow \log r(u,v)\)</span></li>
<li>連乘轉換為連加
<ul>
<li><span class="math inline">\(max(\sum_{i = 0}^k r(v_{i-1},v_i))​\)</span></li>
</ul></li>
<li><strong>對數函數不改變權重單調性</strong>
<ul>
<li><a href="\willywangkaa\2018\12\02\Data-structure-graph#johnsons-algorithm">單調性改變範例 - Johnson's algorithm</a></li>
</ul></li>
</ul></li>
<li>轉換為「最短路徑問題」
<ul>
<li><strong>取其負值將最大路徑問題轉換為最小路徑問題</strong></li>
<li><span class="math inline">\(\Rightarrow w(u,v) = -\log r(u,v)\)</span>
<ul>
<li><span class="math inline">\(min(\sum_{i = 0}^k w(v_{i-1},v_i))\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>以「Dijkstra's algorithm」解決轉換後的問題</strong>
<ul>
<li>p=argument path, <span class="math inline">\(min(\sum_{i = 0}^k w(v_{i-1},v_i))\)</span></li>
<li>時間複雜度：O(∣V∣log∣V∣+∣E∣)</li>
</ul></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm - Recurrence</title>
    <url>/willywangkaa/2018/09/01/Algorithm-Recurrence/</url>
    <content><![CDATA[<h1 id="recurrence">Recurrence</h1>
<blockquote>
<p><strong>＜外傳＞</strong></p>
<ul>
<li>某些問題隨輸入資料大小成指數成長是無法避免的
<ul>
<li>雖然「Divide-and-conquer」無法獲致良好的執行效率但仍可採用</li>
</ul></li>
<li>河內塔問題
<ul>
<li>每呼叫一次就需搬動圓盤一次
<ul>
<li>當圓盤的個數 n 為 64</li>
<li>總共需要搬動圓盤 <span class="math inline">\(2^{64}-1\)</span> 次</li>
<li>演算法的複雜度等級是 <span class="math inline">\(O(2^n)\)</span></li>
</ul></li>
<li>河內塔問題<strong>圓盤搬動次序與 n 成指數關係</strong></li>
<li>經過証明，上述河內塔問題的演算法
<ul>
<li>為該問題的限制下<strong>最佳的演算法</strong></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h2 id="substitution-method">Substitution method</h2>
<ul>
<li><p>Concept</p>
<ol type="1">
<li><p><strong>以經驗猜測一個邊界(bound)</strong>。</p></li>
<li><p>假設<strong>子</strong>問題符合此邊界，證明<strong>母</strong>問題也符合此邊界。</p></li>
</ol></li>
<li><p><strong>適用時機</strong></p>
<ul>
<li>題目比分重。</li>
<li>單向；單邊：只需要證明 <span class="math inline">\(O, \Omega\)</span> 單向，不必證明 <span class="math inline">\(\Theta\)</span> 。</li>
<li>題目要求。</li>
</ul></li>
</ul>
<h3 id="經典範例">經典範例</h3>
<p>Example - <span class="math inline">\(T(n) = 2 T(\lfloor\frac n2\rfloor)+n\)</span>，<span class="math inline">\(T(n) = O(？)\)</span></p>
<p>（Substitution method）猜：<span class="math inline">\(T(n) = O(n \lg n)\)</span></p>
<blockquote>
<p>已知 <span class="math inline">\(g(n) = 2 g(\frac n2)+n = O(n\lg n)\)</span></p>
</blockquote>
<p>欲證 <span class="math inline">\(T(n) = O(n \lg n)\)</span>，即證明 <span class="math inline">\(\exists C, n_0&gt;0 \ni n \geq n_0, T(n) \leq C \cdot n\lg n\)</span></p>
<p>假設<strong>子問題</strong> <span class="math inline">\(T(n) \leq C \cdot \lfloor\frac n2\rfloor\lg \lfloor\frac n 2\rfloor\)</span> 成立</p>
<p>考慮 <span class="math inline">\(T(n) = 2\cdot T(\lfloor\frac n2\rfloor)+n \leq 2 \cdot C \cdot \lfloor\frac n2\rfloor\lg \lfloor\frac n2\rfloor+n\)</span></p>
<p><span class="math inline">\(\Rightarrow T(n) = 2\cdot T(\lfloor\frac n2\rfloor)+n \leq 2 \cdot C \cdot \frac n2\lg \frac n2+n\)</span></p>
<p><span class="math inline">\(\Rightarrow T(n) = 2\cdot T(\lfloor\frac n2\rfloor)+n \leq C \cdot n(\lg n - \lg2)+n = C \cdot n\lg n + (1 - C)n\)</span></p>
<p>取 <span class="math inline">\(C \geq 2, T(n) = 2\cdot T(\lfloor\frac n2\rfloor)+n \leq C \cdot n \lg n\)</span></p>
<p><span class="math inline">\(\therefore T(n) = O(n\lg n)\)</span></p>
<p>Example（97成大資工） - 解 <span class="math inline">\(T(n) = 2T(\lfloor \sqrt n \rfloor)+\lg n\)</span>, 用 O 表示 - （比分重、單邊、<span class="math inline">\(\lfloor\rfloor\)</span>） - 考慮使用「Substitution method」而不使用疊代法</p>
<p><span class="math inline">\(\lg n \lg \lg n\)</span></p>
<h2 id="recurrence-tree">Recurrence tree</h2>
<ul>
<li>名詞解釋
<ul>
<li><span class="math inline">\(T(n) = T(\frac n3)+T(\frac 23 n) + n\)</span>
<ul>
<li><span class="math inline">\(r = \frac 13+\frac 23 = 1\)</span><strong>：子問題的 n 係數的相加。</strong></li>
</ul></li>
<li><span class="math inline">\(T(n)\)</span>：母問題。</li>
<li><span class="math inline">\(T(\frac n3), T(\frac 23n)\)</span>：子問題。</li>
<li><span class="math inline">\(n\)</span>：Cost，將子問題合併的代價。</li>
</ul></li>
<li><strong>適用時機</strong>
<ul>
<li>子問題個數大於二</li>
<li>子問題型態為<span class="math inline">\(T(\frac n a)\)</span></li>
</ul></li>
</ul>
<h3 id="經典範例-1">經典範例</h3>
<figure>
<img src="\willywangkaa\images\tree_1.png" alt="tree_1" /><figcaption aria-hidden="true">tree_1</figcaption>
</figure>
<ul>
<li><span class="math inline">\(r &lt; 1\)</span>
<ul>
<li><p>Ex ( 94 成大資工 )</p>
<ul>
<li><span class="math inline">\(T(n) = T(\frac n2) + T(\frac n4) + T(\frac n8) + n\)</span>，求 <span class="math inline">\(\Theta\)</span></li>
</ul></li>
<li><p>Sol</p>
<ul>
<li><p><span class="math inline">\(r = \frac n 2 + \frac n 4 + \frac n 8 = \frac 7 8 &lt; 1\)</span></p></li>
<li><p>建立遞迴樹 <span class="math inline">\(T(n) = n + \frac 78 n +\frac{49}{64}n + \ldots + C_l\)</span> (等比級數)</p></li>
<li><p><strong>求取其邊界 (夾擠法)</strong> 求上邊界：<span class="math inline">\(T(n) = n + \frac 78 n +\frac{49}{64}n + \ldots + C_l \leq n + \frac 78 n +\frac{49}{64}n + \ldots + (\frac 78)^h\)</span> <strong>(有限等比級數小於無限等比級數)</strong> <span class="math inline">\(\Rightarrow \frac{n}{1 - \frac 7 8} = 8 n \Rightarrow T(n) = O(n)\)</span></p>
<p>求下邊界：<span class="math inline">\(T(n) = n + \frac 78 n +\frac{49}{64}n + \ldots + C_l \geq n \Rightarrow T(n) = \Omega(n)\)</span></p></li>
<li><p><span class="math inline">\(\Rightarrow T(n) = \Theta(n)\)</span></p></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\tree_2.png" alt="tree_1" /><figcaption aria-hidden="true">tree_1</figcaption>
</figure>
<ul>
<li><span class="math inline">\(r = 1\)</span>
<ul>
<li>Ex (100 政大)(90 ,91 台大)
<ul>
<li><span class="math inline">\(T(n) = T(\frac n3) + T(\frac 23) + n\)</span></li>
</ul></li>
<li>Sol
<ul>
<li><span class="math inline">\(r = \frac 13+\frac{2}{3} = 1\)</span></li>
<li>建立遞迴樹 <span class="math inline">\(T(n) = n+n+n+\ldots+C_l\)</span></li>
<li>求取其邊界 求上邊界：因為<span class="math inline">\((\frac23)^k*n= 1 \Rightarrow k = \log_{\frac32}n \Rightarrow 高度 = k + 1\)</span> ，所以<span class="math inline">\(T(n) = n+n+n+\ldots+C_l \leq n \cdot \log_{\frac32}n+1\)</span> <span class="math inline">\(\Rightarrow T(n) = O(n\log n)\)</span> br&gt;求下邊界：<span class="math inline">\(T(n) = n+n+n+\ldots+C_l \geq n \cdot \log_3n + 1\)</span> <span class="math inline">\(\Rightarrow T(n) = \Omega(n\log n)\)</span></li>
<li><span class="math inline">\(\Rightarrow T(n) = \Theta(n\lg n)\)</span></li>
</ul></li>
</ul></li>
<li><span class="math inline">\(r &gt; 1\)</span>
<ul>
<li>無，因為子問題的數量比母問題大。</li>
</ul></li>
</ul>
<h2 id="master-theorem">Master theorem</h2>
<p>令 <span class="math inline">\(T(n) = aT(\frac{n}{b})+f(n), a \geq 1, b &gt; 1\)</span> 。</p>
<ul>
<li>若 <span class="math inline">\(\exists \epsilon &gt; 0 \ni f(n) = O(n^{\log_ba-\epsilon})\)</span> ，則 <span class="math inline">\(T(n) = \Theta(n^{\log_ba})\)</span>。</li>
<li>若 <span class="math inline">\(\exists \epsilon &gt; 0, 0 &lt; c &lt; 1 \ni f(n) = O(n^{\log_ba+\epsilon}) \;and\; af(\frac nb) &lt; cf(n)\)</span>，則 <span class="math inline">\(T(n) = \Theta(f(n))\)</span>。</li>
<li>☆<strong>若</strong> <span class="math inline">\(f(n) = \Theta(n^{\log_ba}\cdot \lg^kn), k \geq 0\)</span>，則 <span class="math inline">\(T(n) = \Theta(n^{\log_ba}\cdot\lg^{k+1}n)\)</span> (與 f(n) 相差 <span class="math inline">\(lg\)</span> 的次方)。</li>
</ul>
<h3 id="經典例題">經典例題</h3>
<ul>
<li>Ex ( 100 政大 )
<ul>
<li><span class="math inline">\(T(n) = 7T(\frac n2) + n^2\)</span></li>
<li>sol
<ul>
<li>By master theorem <span class="math inline">\(\Rightarrow \exists \epsilon = \lg 7 - 2 \ni n^2 = O(n^{\log_27-\epsilon})\)</span>，所以<span class="math inline">\(T(n) = \Theta(n^{\lg 7})\)</span>。</li>
</ul></li>
</ul></li>
<li>Ex ( 99 交大 )
<ul>
<li><span class="math inline">\(T(n) = 3T(\frac n4) + n\lg n\)</span></li>
<li>sol
<ul>
<li>By master theorem <span class="math inline">\(\Rightarrow n^{log_43} = n^{1-\epsilon}, where\; 0 &lt; \epsilon &lt; 1\)</span><br><span class="math inline">\(\Rightarrow n\log n = \omega(n) = \omega(n^{1-\epsilon})\)</span>，所以<span class="math inline">\(T(n) = \Theta(n\log n)\)</span>。</li>
</ul></li>
</ul></li>
<li>Ex ( 98 交大 )
<ul>
<li><span class="math inline">\(T(n) = 3T(\frac n2)+ n \lg n\)</span></li>
<li>sol
<ul>
<li>By master theorem <span class="math inline">\(\Rightarrow n^{log_23} = n^{1+\epsilon}, where\; 0 &lt; \epsilon &lt; 1\)</span><br><span class="math inline">\(\Rightarrow n\log n = o(n^{1+\epsilon})\)</span>，所以<span class="math inline">\(T(n) = \Theta(n^{\log_23})\)</span>。</li>
</ul></li>
<li><span class="math inline">\(T(n) = 4T(\frac n2) + n\lg n\)</span></li>
<li>sol
<ul>
<li>By master theorem <span class="math inline">\(\Rightarrow n^{log_24} = n^2\)</span><br><span class="math inline">\(\Rightarrow n^{2} = \omega(n\log n)\)</span>，所以<span class="math inline">\(T(n) = \Theta(n^2)\)</span>。</li>
</ul></li>
</ul></li>
<li><strong>＜Note＞</strong> ☆ 與 <span class="math inline">\(f(n)\)</span> 比較，<span class="math inline">\(f(n)\)</span> 多了<span class="math inline">\(\frac{1}{\lg n}\)</span>
<ul>
<li>$T(n) = 4 T(n2) +  $</li>
<li>sol
<ul>
<li>不可使用 Master Theorem。</li>
<li><span class="math inline">\(n^{\log_ba = n^2}, f(n) = \frac{n^2}{\lg n} \Rightarrow T(n) = n^2\lg \lg n\)</span></li>
</ul></li>
</ul></li>
<li><strong>＜Note＞</strong> ☆ 與 <span class="math inline">\(f(n)\)</span> 比較，<span class="math inline">\(f(n)\)</span> 多了<span class="math inline">\(\frac{1}{\lg^a n} , a &gt; 1\)</span>
<ul>
<li>直接為 <span class="math inline">\(O(n^{\log_ab})\)</span></li>
</ul></li>
</ul>
<h1 id="進階遞迴問題">進階遞迴問題</h1>
<h2 id="ackermanns-function">Ackermann's function</h2>
<p><span class="math display">\[
\left\{\begin{matrix}
A(0, n) &amp; = &amp; n+1 &amp; (1)\\
A(m , 0) &amp; = &amp; A(m-1, 1) &amp; (2)\\
A(m , n) &amp; = &amp; A(m-1, A(m, n-1)) &amp; (3) 
\end{matrix}\right.
\]</span></p>
<ul>
<li>求取 <span class="math inline">\(A(1, n)\)</span> 的通解</li>
</ul>
<p><span class="math display">\[
\begin{matrix}
令 \; a_n &amp;=&amp; A(1, n) &amp; \\ 
&amp; = &amp; A(0, A(1, n-1)) &amp; By\;(3) \\
&amp; = &amp; A(0, a_{n-1}) &amp; By\; 自定義的a_n\\
&amp; = &amp; a_{n-1} + 1 &amp; By \; (1) \\
\end{matrix}
\]</span></p>
<p>且</p>
<p><span class="math display">\[
a_0  =  A(1, 0) = A(0, 1) = 2
\]</span></p>
<p>所以</p>
<p><span class="math display">\[
\begin{matrix}
a_n &amp; = &amp; a_{n-1} + 1 \\
&amp; = &amp; (a_{n-2} + 1) + 1 \\
&amp; = &amp; ((a_{n-3} + 1) + 1) + 1 \\
&amp; \ldots &amp; \\
&amp; = &amp; a_0 + \sum_{i = 1}^{n-1} + 1 \\
&amp; = &amp; 2 + n &amp; \forall n \geq 0
\end{matrix}
\]</span></p>
<ul>
<li>求取 <span class="math inline">\(A(2, n)\)</span> 的通解</li>
</ul>
<p><span class="math display">\[
\begin{matrix}
令 \; b_n &amp;=&amp; A(2, n) &amp; \\ 
&amp; = &amp; A(1, A(2, n-1)) &amp; By\;(3) \\
&amp; = &amp; A(1, b_{n-1}) &amp; By\; 自定義的a_n\\
&amp; = &amp; a_{b_{n-1}} &amp; By \; 第一題結論 \\
&amp; = &amp; b_{n-1} + 2 \\ 
&amp; = &amp; (b_{n-2} + 2) + 2 \\
&amp; = &amp; ((b_{n-3}+2) + ) + 2 \\
&amp; \ldots &amp; \\
&amp; = &amp; b_0 + \sum_{i = 1}^{n-1}2 + 2 \\
&amp; = &amp; b_0 + 2n &amp; b_0 = A(2, 0) = A(1, 1) = a_1 = 3\\
&amp; = &amp; 2n + 3 &amp; \forall n \geq 0
\end{matrix}
\]</span></p>
<ul>
<li>求取 <span class="math inline">\(A(3, n)\)</span> 的通解</li>
</ul>
<p><span class="math display">\[
\begin{matrix}
令 \; c_n &amp;=&amp; A(3, n) &amp; \\ 
&amp; = &amp; A(2, A(3, n-1)) &amp; By\;(3) \\
&amp; = &amp; A(2, c_{n-1}) &amp; By\; 自定義的a_n\\
&amp; = &amp; b_{c_{n-1}} &amp; By \; 第一題結論 \\
&amp; = &amp; 2c_{n-1} + 3
\end{matrix}
\]</span> 先求出 <span class="math inline">\(c_0 = A(3, 0) = A(2, 1) = b_1 = 5\)</span> ，再來</p>
<p><span class="math inline">\(c_n\)</span> 特徵多項式為 <span class="math inline">\(\alpha - 2= 0 \Rightarrow \alpha = 2\)</span>，所以令齊次解為 <span class="math inline">\(c_n^{(h)} = C_0\times2^n\)</span>，接著 <span class="math inline">\(c_n\)</span> 的特解為 <span class="math inline">\(c_n^{(p)} = C_1\times (1)\)</span> 代回求 <span class="math inline">\(C_1\)</span></p>
<p><span class="math display">\[
\begin{matrix}
\Rightarrow C_1 = 2\times C_1 + 3 \\
\Rightarrow C_1 = -3 \\
\therefore c_n = c_n^{h} + c_n^{(p)} = C_0\times2^n - 3 \\
c_0 = 5 = C_0 - 3 \\
\Rightarrow C_0 = 8 \\
\therefore c_n = 2^{n+3} - 3, \forall n \geq 0
\end{matrix}
\]</span></p>
<h2 id="strassen-演算法分治矩陣乘法">Strassen 演算法（分治矩陣乘法）</h2>
<p>長久以來人們普遍認為矩陣乘法定義本身即為最佳的算法，這個迷思直到1969年才被施特拉森打破──他提出了一個更快捷的分治（Divide-and-conquer）矩陣乘法，為 Strassen 演算法</p>
<ul>
<li>給定兩個方陣 A、B
<ul>
<li>其大小均為 n×n
<ul>
<li>n = 2k</li>
</ul></li>
<li>若 n 非 2 的冪次方
<ul>
<li>可將 A 和 B 擴充為 <span class="math inline">\(\begin{bmatrix} A&amp;0\\ 0&amp;I \end{bmatrix}\)</span> 和 <span class="math inline">\(\begin{bmatrix} B&amp;0\\ 0&amp;I \end{bmatrix}\)</span></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>考慮 2×2 階<strong>分塊矩陣乘法</strong></p>
<p><span class="math inline">\(\begin{bmatrix} C_{11}&amp;C_{12}\\ C_{21}&amp;C_{22} \end{bmatrix}=\begin{bmatrix} A_{11}&amp;A_{12}\\ A_{21}&amp;A_{22} \end{bmatrix}\begin{bmatrix} B_{11}&amp;B_{12}\\ B_{21}&amp;B_{22} \end{bmatrix}\)</span></p>
<ul>
<li>傳統矩陣乘法
<ul>
<li><span class="math inline">\(C_{ij}=A_{i1}B_{1j}+A_{i2}B_{2j}\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1549349573405.png" alt="1549349573405" /><figcaption aria-hidden="true">1549349573405</figcaption>
</figure>
<p><span class="math inline">\(C_{11} = A_{11}B_{11} + A_{12}B_{21} \\ C_{12} = A_{11}B_{12} + A_{12}B_{22} \\ C_{21} = A_{21}B_{11} + A_{22}B_{21} \\ C_{22} = A_{21}B_{12} + A_{22}B_{22}\)</span></p>
<ul>
<li>遞迴式為：<span class="math inline">\(T(n) = 8T(\frac n2) + cn^2\)</span>
<ul>
<li>8 個分塊矩陣乘法</li>
<li>4 個分塊矩陣加法</li>
<li><span class="math inline">\(cn^2\Rightarrow 3\times2^2\)</span></li>
</ul></li>
<li>「Master theorem」
<ul>
<li><span class="math inline">\(T(n) = \Theta(n^3)\)</span></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>Strassen 演算法</li>
</ul>
<p><span class="math inline">\(\begin{aligned} P_1&amp;=(A_{11}+A_{22})(B_{11}+B_{22})\\ P_2&amp;=(A_{21}+A_{22})B_{11}\\ P_3&amp;=A_{11}(B_{12}-B_{22})\\ P_4&amp;=A_{22}(B_{21}-B_{11})\\ P_5&amp;=(A_{11}+A_{12})B_{22}\\ P_6&amp;=(A_{21}-A_{11})(B_{11}+B_{12})\\ P_7&amp;=(A_{12}-A_{22})(B_{21}+B_{22})\\ C_{11}&amp;=P_1+P_4-P_5+P_7\\ C_{12}&amp;=P_3+P_5\\ C_{21}&amp;=P_2+P_4\\ C_{22}&amp;=P_1+P_3-P_2+P_6 \end{aligned}\)</span></p>
<ul>
<li>遞迴式為：<span class="math inline">\(T(n) = 7T(\frac n2) + cn^2\)</span>
<ul>
<li>7 個分塊矩陣乘法</li>
<li>18 個分塊矩陣加法</li>
</ul></li>
<li>「Master theorem」
<ul>
<li><span class="math inline">\(T(n) = \Theta(n^{\log_27}) \approx \Theta(n^{2.807})\)</span></li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>根據 2000 年的硬體架構
<ul>
<li>矩陣尺寸必須超過1000，Strassen 演算法才可能擊敗經過高度優化的傳統算法</li>
<li>即便矩陣尺寸增大至 10000 相較於傳統算法
<ul>
<li>Strassen 演算法所能提昇的運算效率依然十分有限（約小於10%）</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h3 id="算法推導">算法推導</h3>
<ul>
<li>考慮 2×2 階矩陣 <span class="math inline">\(\begin{bmatrix} w&amp;x\\ y&amp;z \end{bmatrix}=\begin{bmatrix} a&amp;b\\ c&amp;d \end{bmatrix}\begin{bmatrix} p&amp;q\\ r&amp;s \end{bmatrix}\)</span>
<ul>
<li>乘開後 <span class="math inline">\(\begin{aligned} w&amp;=ap+br\\ y&amp;=cp+dr\\ x&amp;=aq+bs\\ z&amp;=cq+ds \end{aligned}\)</span></li>
<li>將四個式子合併成矩陣表達式 <span class="math inline">\(\begin{bmatrix} w\\ y\\ x\\ z \end{bmatrix}=\begin{bmatrix} a&amp;b&amp;0&amp;0\\ c&amp;d&amp;0&amp;0\\ 0&amp;0&amp;a&amp;b\\ 0&amp;0&amp;c&amp;d \end{bmatrix}\begin{bmatrix} p\\ r\\ q\\ s \end{bmatrix}\)</span></li>
</ul></li>
<li>欲將 4×4 階的矩陣分解成數個矩陣之和以減少乘法運算
<ul>
<li><strong>分解出來的矩陣至多僅含4個非零元，且所有非零元都位於一 2×2 階子陣</strong></li>
<li>如：<span class="math inline">\(\begin{bmatrix} \ast&amp;\ast&amp;0&amp;0\\ \ast&amp;\ast&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0 \end{bmatrix} 、\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ \ast&amp;0&amp;\ast&amp;0\\ 0&amp;0&amp;0&amp;0\\ \ast&amp;0&amp;\ast&amp;0 \end{bmatrix}、\begin{bmatrix} \ast&amp;0&amp;0&amp;\ast\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ \ast&amp;0&amp;0&amp;\ast \end{bmatrix}\)</span></li>
</ul></li>
</ul>
<blockquote>
<p>考慮三種分解型態</p>
<ul>
<li><strong>型態 I</strong>
<ul>
<li>子陣有相同的元</li>
<li>需要一個乘法運算</li>
<li><span class="math inline">\(\begin{bmatrix} a&amp;a\\ a&amp;a \end{bmatrix}\begin{bmatrix} u\\ v \end{bmatrix}=\begin{bmatrix} a(u+v)\\ a(u+v) \end{bmatrix}\)</span></li>
</ul></li>
<li><strong>型態 II</strong>
<ul>
<li>子陣的元有相同的絕對值</li>
<li><strong>兩行或兩列不同號</strong></li>
<li>需要1個乘法運算</li>
<li><span class="math inline">\(\begin{bmatrix} a&amp;-a\\ a&amp;-a \end{bmatrix}\begin{bmatrix} u\\ v \end{bmatrix}=\begin{bmatrix} a(u-v)\\ a(u-v) \end{bmatrix}\)</span></li>
</ul></li>
<li><strong>型態 III</strong>
<ul>
<li>子陣為上或下三角矩陣</li>
<li>（非零）非主對角元等於兩主對角元之差</li>
<li><strong>需要2個乘法運算</strong></li>
<li><span class="math inline">\(\begin{bmatrix} a&amp;0\\ a-b&amp;b \end{bmatrix}\begin{bmatrix} u\\ v \end{bmatrix}=\begin{bmatrix} au\\ au+b(v-u) \end{bmatrix}\)</span>
<ul>
<li>可分解為兩個退化的<strong>型態 I</strong>和<strong>型態 II</strong>（退化是指存在零行或零列）</li>
<li><span class="math inline">\(\begin{bmatrix} a&amp;0\\ a-b&amp;b \end{bmatrix}=\begin{bmatrix} a&amp;0\\ a&amp;0 \end{bmatrix}+\begin{bmatrix} 0&amp;0\\ -b&amp;-b \end{bmatrix}\)</span></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<p>分解矩陣製造<strong>型態 I</strong>和<strong>型態 II</strong></p>
<ol type="1">
<li><p><span class="math inline">\(\begin{bmatrix} a&amp;b&amp;0&amp;0\\ c&amp;d&amp;0&amp;0\\ 0&amp;0&amp;a&amp;b\\ 0&amp;0&amp;c&amp;d \end{bmatrix}=\begin{bmatrix} -d&amp;d&amp;0&amp;0\\ -d&amp;d&amp;0&amp;0\\ 0&amp;0&amp;a&amp;-a\\ 0&amp;0&amp;a&amp;-a \end{bmatrix}+\begin{bmatrix} a+d&amp;b-d&amp;0&amp;0\\ c+d&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;a+b\\ 0&amp;0&amp;c-a&amp;a+d \end{bmatrix}\)</span></p>
<ul>
<li>等號右邊的第一個矩陣
<ul>
<li><span class="math inline">\(\begin{bmatrix} -d&amp;d&amp;0&amp;0\\ -d&amp;d&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0 \end{bmatrix}+\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;a&amp;-a\\ 0&amp;0&amp;a&amp;-a \end{bmatrix}\)</span></li>
</ul></li>
</ul></li>
<li><p>令 <span class="math inline">\(M_1\)</span> 表示上式等號<strong>右邊的第二個矩陣</strong></p>
<ul>
<li>觀察發現 $(M_1)<em>{11}=(M_1)</em>{44}=a+d $</li>
<li><span class="math inline">\(M_1=\begin{bmatrix} a+d&amp;0&amp;0&amp;a+d\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ a+d&amp;0&amp;0&amp;a+d \end{bmatrix}+\begin{bmatrix} 0&amp;b-d&amp;0&amp;-(a+d)\\ c+d&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;a+b\\ -(a+d)&amp;0&amp;c-a&amp;0 \end{bmatrix}\)</span></li>
</ul></li>
<li><p>令 <span class="math inline">\(M_2\)</span> 表示上式等號<strong>右邊的第二個矩陣</strong></p>
<ul>
<li><p>觀察發現 <span class="math inline">\(M_2\)</span> 可分解成兩個<strong>型態 III</strong></p></li>
<li><p><span class="math inline">\(M_2=\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ c+d&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ (c-a)-(c+d)&amp;0&amp;c-a&amp;0 \end{bmatrix}+\begin{bmatrix} 0&amp;b-d&amp;0&amp;(b-d)-(a+b)\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;a+b\\ 0&amp;0&amp;0&amp;0 \end{bmatrix}\)</span></p></li>
<li><p>等號右邊的第一個矩陣</p>
<ul>
<li><span class="math inline">\(\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ c+d&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ -(c+d)&amp;0&amp;0&amp;0 \end{bmatrix}+\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ c-a&amp;0&amp;c-a&amp;0 \end{bmatrix}\)</span></li>
</ul></li>
<li><p>等號右邊的第二個矩陣</p>
<ul>
<li><span class="math inline">\(\begin{bmatrix} 0&amp;b-d&amp;0&amp;b-d\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0 \end{bmatrix}+\begin{bmatrix} 0&amp;0&amp;0&amp;0-(a+b)\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;a+b\\ 0&amp;0&amp;0&amp;0 \end{bmatrix}\)</span></li>
</ul></li>
</ul></li>
<li><p>整理所有的分解矩陣，<strong>按照「Strassen 演算法」給定的排序</strong></p>
<ul>
<li><span class="math inline">\(\begin{aligned} \begin{bmatrix} a&amp;b&amp;0&amp;0\\ c&amp;d&amp;0&amp;0\\ 0&amp;0&amp;a&amp;b\\ 0&amp;0&amp;c&amp;d \end{bmatrix}&amp;=\begin{bmatrix} a+d&amp;0&amp;0&amp;a+d\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ a+d&amp;0&amp;0&amp;a+d \end{bmatrix}+\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ c+d&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ -(c+d)&amp;0&amp;0&amp;0 \end{bmatrix}\\ &amp;+\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;a&amp;-a\\ 0&amp;0&amp;a&amp;-a \end{bmatrix}+\begin{bmatrix} -d&amp;d&amp;0&amp;0\\ -d&amp;d&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0 \end{bmatrix}\\ &amp;+\begin{bmatrix} 0&amp;0&amp;0&amp;-(a+b)\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;a+b\\ 0&amp;0&amp;0&amp;0 \end{bmatrix}+\begin{bmatrix} 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ c-a&amp;0&amp;c-a&amp;0 \end{bmatrix}\\ &amp;+\begin{bmatrix} 0&amp;b-d&amp;0&amp;b-d\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0 \end{bmatrix} \end{aligned}\)</span></li>
<li>可以表示為「行列展開」的矩陣乘法</li>
<li><span class="math inline">\(\displaystyle\begin{aligned} \begin{bmatrix} a&amp;b&amp;0&amp;0\\ c&amp;d&amp;0&amp;0\\ 0&amp;0&amp;a&amp;b\\ 0&amp;0&amp;c&amp;d \end{bmatrix}&amp;=\begin{bmatrix} 1\\ 0\\ 0\\ 1 \end{bmatrix}(a+d)\begin{bmatrix} 1&amp;0&amp;0&amp;1 \end{bmatrix}+\begin{bmatrix} 0\\ 1\\ 0\\ -1 \end{bmatrix}(c+d)\begin{bmatrix} 1&amp;0&amp;0&amp;0 \end{bmatrix}\\ &amp;+\begin{bmatrix} 0\\ 0\\ 1\\ 1 \end{bmatrix}(a)\begin{bmatrix} 0&amp;0&amp;1&amp;-1 \end{bmatrix}+\begin{bmatrix} 1\\ 1\\ 0\\ 0 \end{bmatrix}(d)\begin{bmatrix} -1&amp;1&amp;0&amp;0 \end{bmatrix}\\ &amp;+\begin{bmatrix} -1\\ 0\\ 1\\ 0 \end{bmatrix}(a+b)\begin{bmatrix} 0&amp;0&amp;0&amp;1 \end{bmatrix}+\begin{bmatrix} 0\\ 0\\ 0\\ 1 \end{bmatrix}(c-a)\begin{bmatrix} 1&amp;0&amp;1&amp;0 \end{bmatrix}\\ &amp;+\begin{bmatrix} 1\\ 0\\ 0\\ 0 \end{bmatrix}(b-d)\begin{bmatrix} 0&amp;1&amp;0&amp;1 \end{bmatrix} \end{aligned}\)</span></li>
</ul></li>
</ol>
<ul>
<li><span class="math inline">\(\begin{bmatrix} a&amp;b&amp;0&amp;0\\ c&amp;d&amp;0&amp;0\\ 0&amp;0&amp;a&amp;b\\ 0&amp;0&amp;c&amp;d \end{bmatrix}\)</span> 乘上<span class="math inline">\(\begin{bmatrix} p\\ r\\ q\\ s \end{bmatrix}\)</span>
<ul>
<li><span class="math inline">\(\begin{aligned} \begin{bmatrix} w\\ y\\ x\\ z \end{bmatrix}&amp;=\begin{bmatrix} 1\\ 0\\ 0\\ 1 \end{bmatrix}(a+d)(p+s)+\begin{bmatrix} 0\\ 1\\ 0\\ -1 \end{bmatrix}(c+d)(p)\\ &amp;+\begin{bmatrix} 0\\ 0\\ 1\\ 1 \end{bmatrix}(a)(q-s)+\begin{bmatrix} 1\\ 1\\ 0\\ 0 \end{bmatrix}(d)(-p+r)\\ &amp;+\begin{bmatrix} -1\\ 0\\ 1\\ 0 \end{bmatrix}(a+b)(s)+\begin{bmatrix} 0\\ 0\\ 0\\ 1 \end{bmatrix}(c-a)(p+q)\\ &amp;+\begin{bmatrix} 1\\ 0\\ 0\\ 0 \end{bmatrix}(b-d)(r+s) \end{aligned}\)</span></li>
<li><span class="math inline">\(\begin{bmatrix} a&amp; b&amp; c&amp; d \end{bmatrix}\)</span> 代 <span class="math inline">\(\begin{bmatrix} A_{11}&amp; A_{12}&amp; A_{21}&amp; A_{22} \end{bmatrix}\)</span></li>
<li><span class="math inline">\(\begin{bmatrix} p&amp; q&amp; r&amp; s \end{bmatrix}\)</span> 代 <span class="math inline">\(\begin{bmatrix} B_{11}&amp; B_{12}&amp; B_{21}&amp; B_{22} \end{bmatrix}\)</span></li>
<li><span class="math inline">\(\begin{bmatrix} w&amp; x&amp; y&amp; z \end{bmatrix}\)</span> 代 <span class="math inline">\(\begin{bmatrix} C_{11}&amp; C_{12}&amp; C_{21}&amp; C_{22} \end{bmatrix}\)</span></li>
<li>即為「Strassen 演算法」</li>
</ul></li>
</ul>
<h1 id="補充例題">補充例題</h1>
<p>Example（100 交通大學資料結構與演算法）</p>
<ul>
<li>Let d and k be two non-negative integers, where k &gt; d ≧ 0.</li>
<li>A dk-binary sequence is a binary sequence that satisfies the following two constraints：
<ul>
<li><ol type="a">
<li>d constraint：two 1's are separated by a run of consecutive 0 of length at least d</li>
</ol></li>
<li><ol start="2" type="a">
<li>k constraint：any run of consecutive 0's is of length at most k</li>
</ol></li>
</ul></li>
<li>For example, 010010001001 is a dk-binary sequence of length 12 width d=0 and k=3.</li>
<li>Let n indicate the length of dk-binary sequence</li>
</ul>
<ol start="47" type="1">
<li>Given n=6, d=0, k=6, then how many dk-binary sequences are there?</li>
</ol>
<ul>
<li>（A）8</li>
<li>（B）16</li>
<li><strong>（C）32</strong></li>
<li>（D）64</li>
<li>（E）128</li>
</ul>
<p>由 0、1 組成長度為六的字串個數 <span class="math inline">\(\Rightarrow 2^6\)</span></p>
<ol start="48" type="1">
<li>Given n=10, d=4, k=5, then how many dk-binary sequences are there?</li>
</ol>
<ul>
<li>（A）8</li>
<li>（B）6</li>
<li>（C）12</li>
<li>（D）10</li>
<li>（E）11</li>
</ul>
<p>（參考：<a href="www.ptt.cc/bbs/Grad-ProbAsk/M.1329321054.A.ECB.html">Re: [理工] [DS&amp;algo] 100交大</a>）</p>
<p><strong>在序列中有 0 個 1</strong></p>
<ul>
<li>不可能發生</li>
</ul>
<p><strong>在序列中有 1 個 1</strong></p>
<ul>
<li>0000010000</li>
<li>0000100000</li>
</ul>
<p><strong>在序列中有 2 個 1</strong>（兩個 1 <strong>最多</strong>只能將序列切成 3 段）</p>
<blockquote>
<p>轉換題目成整數分割</p>
<ul>
<li><p>字串長度為 10</p></li>
<li><p>兩個位子置 1</p></li>
<li><p>剩下 8 個位子置 0</p></li>
<li><p>必須有連續 4 個零或 5 個零出現</p></li>
</ul>
</blockquote>
<ul>
<li>在序列中有連續 4 個 0（必有連續 4 個 0 出現，則必有一個 4 在此整數分割）
<ul>
<li>8=4+<strong>4'</strong>
<ul>
<li>序列：0000100001</li>
</ul></li>
<li>8=4+3+1
<ul>
<li>序列：0001000010</li>
</ul></li>
<li>8=4+2+2
<ul>
<li>序列：0010000100</li>
</ul></li>
<li>8=4+1+3
<ul>
<li>序列：0100001000</li>
</ul></li>
<li>8=<strong>4'</strong>+4
<ul>
<li>序列：1000010000</li>
</ul></li>
</ul></li>
<li>有連續5個零的狀況
<ul>
<li>8=5+3
<ul>
<li>序列：0001000001</li>
</ul></li>
<li>8=5+2+1
<ul>
<li>序列：0010000010</li>
</ul></li>
<li>8=5+1+2
<ul>
<li>序列：0100000100</li>
</ul></li>
<li>8=3+5
<ul>
<li>序列：1000001000</li>
</ul></li>
</ul></li>
</ul>
<ol start="49" type="1">
<li>Given n=14, d=1, k=14, then how many dk-binary sequences are there?</li>
</ol>
<ul>
<li>（A）81</li>
<li>（B）160</li>
<li>（C）821</li>
<li><strong>（D）987</strong></li>
<li>（E）1024</li>
</ul>
<p>由 0、1 組成長度為十四且 1 不得連續出現的字串個數</p>
<ul>
<li><span class="math inline">\(a_n = a_{n-1}+a_{n-2}\)</span></li>
<li><span class="math inline">\(a_1 = 2、a_2 = 3\)</span></li>
<li><span class="math inline">\(a_{14} = 987\)</span></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recurrence</tag>
        <tag>Ackermann</tag>
      </tags>
  </entry>
  <entry>
    <title>Data structure - Advance binary search tree</title>
    <url>/willywangkaa/2018/10/28/Data-structure-Advance-binary-search-tree/</url>
    <content><![CDATA[<h1 id="avl-tree">AVL tree</h1>
<p>Height balance binary search tree</p>
<ul>
<li>性質
<ul>
<li><span class="math inline">\(|H_L - H_R| \leq 1\)</span>，其中 <span class="math inline">\(H_L、H_R\)</span> 為<strong>樹根節點</strong>左右子樹之高度</li>
<li>左右子樹亦為「AVL tree」</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example</strong> (True or False)</p>
<ul>
<li>若「Binary search tree」之樹根節點左右子樹皆為「AVL tree」則整棵樹為「AVL tree」(FALSE)</li>
<li><strong>在「AVL tree」，任何節點在左右子樹必為「AVL tree」(TRUE)</strong></li>
<li><strong>在「AVL tree」，任何兩個葉節點位於的高度 (Level) 差必 ≦ 1 (FALSE)</strong>；如下圖 s、t 葉節點</li>
</ul>
<figure>
<img src="\willywangkaa\images\AVLex_1.png" alt="AVLex_1" /><figcaption aria-hidden="true">AVLex_1</figcaption>
</figure>
<ul>
<li>在「AVL tree」，左子樹所有節點之數必 ≦ 右子樹所有節點之數值 (TRUE)</li>
<li>在「AVL tree」中使用「Inorder travesal」可以得到「小→大」的排序 (TRUE)</li>
</ul>
</blockquote>
<ul>
<li>調整原則
<ol type="1">
<li>中間鍵值往上拉，小的置左大的置右
<ul>
<li>此三個節點是被標上 LL、LR、RL、RR 兩條邊所連結的三個節點</li>
</ul></li>
<li>孤兒節點 (子樹) 依照「Binary serch tree」性質置入</li>
</ol></li>
<li>LR</li>
</ul>
<figure>
<img src="\willywangkaa\images\AVL_LR_1.png" alt="AVL_LR_1" /><figcaption aria-hidden="true">AVL_LR_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\AVL_LR_2.png" alt="AVL_LR_2" /><figcaption aria-hidden="true">AVL_LR_2</figcaption>
</figure>
<ul>
<li>RR</li>
</ul>
<figure>
<img src="\willywangkaa\images\AVL_RR_1.png" alt="AVL_RR_1" /><figcaption aria-hidden="true">AVL_RR_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\AVL_RR_2.png" alt="AVL_RR_2" /><figcaption aria-hidden="true">AVL_RR_2</figcaption>
</figure>
<blockquote>
<p>從「AVL tree」中任取兩個葉節點，該高度差取絕對值<del>小於等於一</del>。( 任何大於等於 0 的整數都有可能 )</p>
<p>從「AVL tree」中任取<strong>其根節點位於同層</strong>的兩子樹，其子樹的高度差取絕對值<del>小於等於一</del>。( 任何大於等於 0 的整數都有可能 )</p>
<figure>
<img src="\willywangkaa\images\AVLex_2.png" alt="AVLex_2" /><figcaption aria-hidden="true">AVLex_2</figcaption>
</figure>
</blockquote>
<p>形成高度為 h 的 AVL tree 所需之<strong>最多節點數</strong> = 「Full binary serach tree」數量 = <span class="math inline">\(2^h -1\)</span></p>
<p>形成高度為 h 的 AVL tree 所需之<strong>最少節點數</strong> = <span class="math inline">\(F_{h+2} - 1\)</span> ( F 為費氏數列 )</p>
<ul>
<li>證明</li>
</ul>
<p>高度為 0 時為一空樹最少 0 個節點即可，<span class="math inline">\(F_{0+2}-1 = 1-1 = 0\)</span> ，成立。</p>
<p>假設高度小於等於 h-1 時成立，考慮高度等於 h 時， <strong>最少節點數必定發生在「樹根」之左右子樹高度相差一時，</strong> 不失一般性，令左子樹高度為 h-1；右子樹高度為 h-2， 所以左子樹最少節點個數為 <span class="math inline">\(F_{(h-1)+2}-1 = F_{h+1}-1\)</span>； 右子樹最少節點個數為 <span class="math inline">\(F_{(h-2)+2}-1 = F_{h}-1\)</span>。</p>
<p><strong>整棵樹需要最少的節點數為</strong> <span class="math inline">\(F_{h+1} -1 +F_{h} -1 + 1 = F_{h+2} - 1\)</span> ，QED</p>
<p>Example</p>
<ul>
<li>形成高度為 5 的「AVL tree」最少需要的節點數？</li>
</ul>
<p><span class="math inline">\(F_{5+2}-1 = F_7 -1 = 12\)</span></p>
<p><strong>Example</strong></p>
<ul>
<li><strong>300 個節點的 AVL tree 之最大高度為</strong>？</li>
</ul>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>13</td>
<td>21</td>
<td>34</td>
<td>55</td>
<td>89</td>
<td>144</td>
<td>233</td>
<td>377</td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(F_{13} -1 = 232 \\ \Rightarrow F_{13} = F_{11+2} \\ \Rightarrow h = 11\)</span></p>
<blockquote>
<p><strong>最小高度為</strong>？</p>
<p><span class="math inline">\(2^h -1 = 300 \\ \Rightarrow h = \lceil \lg 301 \rceil = 9\)</span></p>
</blockquote>
<p><strong>Example</strong></p>
<ul>
<li>令 N(H) 代表形成高度 H 之「AVL tree」之最小節點數 N(0) = 0、N(1) = 1</li>
<li>（1）寫出 N(H) 之遞迴定義</li>
<li>（2）延續（1），求出 N(5) 與 N(10)</li>
</ul>
<p>（1）：<strong>N(H) = N(H-1) + N(H-2) + 1</strong>，H ≧ 2；</p>
<p>（2）：<strong>N(5) = 12，N(10) = 144</strong></p>
<h1 id="m-way-search-tree">M-way search tree</h1>
<p>主要應用在「External search (sort)」，資料量大於記憶體空間，必須藉由外部儲存體保存，再分批載入記憶體中搜尋欲求的資料</p>
<p>Example ( Height：h，m-way search tree )</p>
<ul>
<li>（1）最多節點個數</li>
<li>（2）最多儲存資料數量</li>
</ul>
<p>（1）：<span class="math inline">\(m^0 + m^1 + m^2 + \ldots + m^{h-2} + m^{h-1} = \frac{m^h-1}{m-1}\)</span></p>
<p>（2）：<span class="math inline">\(\frac{m^h-1}{m-1} \cdot (m-1) = m^h -1\)</span></p>
<h2 id="b-tree-of-order-m-balance">B-tree of order m (Balance)</h2>
<ul>
<li><strong>樹根節點至少有 ≧ 2 個子節點，即 m ≧ 根節點 Degree ≧ 2</strong></li>
<li>除了樹根節點與失敗節點( Failure node；External node ) 之外，<strong>其餘的節點</strong>
<ul>
<li><span class="math inline">\(\lceil \frac m2 \rceil \leq Degree \leq m\)</span> 或 <span class="math inline">\(\lceil \frac m2 -1 \rceil \leq 節點內的資料數量 \leq m-1\)</span></li>
</ul></li>
<li><strong>所有的失敗節點皆必須位於同一層 ( Level )</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\mwaybtree.png" alt="mwaybtree" /><figcaption aria-hidden="true">mwaybtree</figcaption>
</figure>
<p>從上一層讀取至下一層需要多一次 Block I/O</p>
<h3 id="b-tree-of-order-3"><strong>B</strong> tree of order 3</h3>
<ul>
<li>樹根節點：2 ≦ Degree ≦ 3</li>
<li>除失敗節點之其餘節點：<span class="math inline">\(\lceil \frac 32 \rceil = 2\)</span> ≦ Degree ≦ 3</li>
</ul>
<blockquote>
<p>此樹中樹根節點<strong>恰巧</strong>與其餘節點 Degree 的特性相同，所以只會出現兩種節點</p>
<ul>
<li>2 - node：Degree 為 2</li>
<li>3 - node：Degree 為 3</li>
</ul>
<p>所以又稱此樹為「2-3 tree」</p>
</blockquote>
<h3 id="b-tree-of-order-4">B tree of order 4</h3>
<ul>
<li>樹根節點：2 ≦ Degree ≦ 4</li>
<li>除失敗節點之其餘節點：<span class="math inline">\(\lceil \frac 42 \rceil = 2\)</span> ≦ Degree ≦ 4</li>
</ul>
<blockquote>
<p>此樹中樹根節點<strong>恰巧</strong>與其餘節點 Degree 的特性相同，所以只會出現三種節點</p>
<ul>
<li>2 - node：Degree 為 2</li>
<li>3 - node：Degree 為 3</li>
<li>4 - node：Degree 為 4</li>
</ul>
<p>所以又稱此樹為「2-3-4 tree」</p>
</blockquote>
<blockquote>
<p>B tree of order 5</p>
<ul>
<li>樹根節點：2 ≦ Degree ≦ 5</li>
<li>除失敗節點之其餘節點：<span class="math inline">\(\lceil \frac 52 \rceil = 3\)</span> ≦ Degree ≦ 5</li>
</ul>
<p><strong>此樹中樹根節點與其餘節點 Degree 的特性不同</strong></p>
</blockquote>
<p>在<strong>固定高度</strong>之下：</p>
<ul>
<li><p>最多節點數</p>
<ul>
<li><span class="math inline">\(m^0 + m^1 + \ldots + m^{h-1} = \frac{m^h-1}{m-1}\)</span></li>
</ul></li>
<li><p>最多資料儲存量</p>
<ul>
<li>因為每一節點都會有 m-1 筆資料，所以將最多節點數乘每節點最多 可儲存量 <span class="math inline">\(\frac{m^h-1}{m-1} \times (m-1) = m^h -1\)</span></li>
</ul></li>
<li><p><strong>最少節點數</strong></p>
<ul>
<li>樹根節點最少要有兩個子節點</li>
<li>其餘節點最少要有 <span class="math inline">\(\lceil \frac m2 \rceil\)</span> 個子節點</li>
<li>則 <span class="math inline">\(1 + 2 + 2\cdot \lceil \frac m2 \rceil + 2\cdot \lceil \frac m2 \rceil^2 + \ldots + 2\cdot \lceil \frac m2 \rceil^{h-2} \\ = 1 + 2\cdot[\lceil \frac m2 \rceil^0 + \lceil \frac m2 \rceil^1 + \ldots + \lceil \frac m2 \rceil^{h-2} ] \\ = 1 + 2\cdot [\frac {\lceil\frac m2 \rceil^{h-1}-1}{\lceil\frac m2\rceil -1}]\)</span></li>
</ul></li>
<li><p><strong>最少資料儲存量</strong></p>
<ul>
<li>根節點最少可以儲存 1 筆資料</li>
<li>每個節點最少可以儲存 $m2  $ 筆資料</li>
<li>則 <span class="math inline">\(1 + 2\cdot [\frac {\lceil\frac m2 \rceil^{h-1}-1}{\lceil\frac m2\rceil -1}] \times (\lceil \frac m2\rceil-1) \\ = 1 + 2\cdot(\lceil\frac m2\rceil^{h-1}-1) \\ = 2\cdot\lceil\frac m2\rceil^{h-1}-1\)</span></li>
</ul></li>
</ul>
<h2 id="insert-data-in-b-tree">Insert data in B-tree</h2>
<p>步驟：</p>
<ol type="1">
<li>先找尋資料 x 在樹中的置入位置</li>
<li><strong>檢查該置入節點是否「Overflow」( 即資料數量等於 m )</strong>
<ol type="1">
<li>如果無「Overflow」，結束</li>
<li>如果「Overflow」針對該點「Split」，再針對該父點做第二步的檢查</li>
</ol></li>
</ol>
<blockquote>
<p>Split</p>
<p>將節點內的第 <span class="math inline">\(\lceil \frac m2 \rceil\)</span> 個資料上拉至父節點，其餘資料分裂成兩個子節點</p>
<figure>
<img src="\willywangkaa\images\mwaybtree_split.png" alt="mwaybtree_split" /><figcaption aria-hidden="true">mwaybtree_split</figcaption>
</figure>
</blockquote>
<blockquote>
<p>註解：B tree 不直接新增節點，而是等到整個資料樹的樹根節點「Overflow」才會新增節點。</p>
</blockquote>
<h2 id="delete-data-in-b-tree">Delete data in B-tree</h2>
<p>步驟：</p>
<ol type="1">
<li>在樹中找尋 x 資料位於的節點</li>
<li>將節點分為「葉節點」與「非葉節點」
<ul>
<li>「葉節點」
<ol type="1">
<li>將資料 x 移除</li>
<li>檢查節點是否「Underflow」( 資料數量 <span class="math inline">\(\geq \lceil\frac m2\rceil-1\)</span> )； 若無「Underflow」結束； 若有「Underflow」檢查是否可以「Rotation」，可以則執行之並結束，<strong>若否則作「Combine」( Merge ) 並對父節點執行此步驟 ( 檢查節點是否「Underflow」 )</strong></li>
</ol></li>
<li><strong>「非葉節點」( 注意 )</strong>
<ol type="1">
<li><strong>找出 x 之左子樹中的最大值 y ( 或右子樹中的最小值 )</strong></li>
<li>y 必存在於某「葉節點」之中，以資料 y 取代資料 x 並移除 y <strong>( 相當於刪除「葉節點」的一筆資料 )</strong></li>
</ol></li>
</ul></li>
</ol>
<blockquote>
<p>Rotation</p>
<figure>
<img src="\willywangkaa\images\mwaybtree_ratation.png" alt="mwaybtree_ratation" /><figcaption aria-hidden="true">mwaybtree_ratation</figcaption>
</figure>
</blockquote>
<blockquote>
<p>Combine</p>
<figure>
<img src="\willywangkaa\images\mwaybtree_combine.png" alt="mwaybtree_combine" /><figcaption aria-hidden="true">mwaybtree_combine</figcaption>
</figure>
<p>若父節點因此發生「Underflow」，則兩代 ( 父、子 ) 所有鍊節全部斷開，再<strong>針對父節點的「Underflow」逐層往上處理</strong></p>
<figure>
<img src="\willywangkaa\images\mwaybtree_split_2.png" alt="mwaybtree_split_2" /><figcaption aria-hidden="true">mwaybtree_split_2</figcaption>
</figure>
</blockquote>
<p>Example ( 刪除 Leaf 之資料 )</p>
<p>2 - 3 Tree ( 2 ≦ Degree ≦ 3；1 ≦ 資料量 ≦ 2 )，刪除 5, 50, 8, 90</p>
<figure>
<img src="\willywangkaa\images\mwaybtree_deletion.png" alt="mwaybtree_deletion" /><figcaption aria-hidden="true">mwaybtree_deletion</figcaption>
</figure>
<p>刪除 5 後</p>
<figure>
<img src="\willywangkaa\images\mwaybtree_deletion_2.png" alt="mwaybtree_deletion_2" /><figcaption aria-hidden="true">mwaybtree_deletion_2</figcaption>
</figure>
<p>刪除 50 後</p>
<figure>
<img src="\willywangkaa\images\mwaybtree_deletion_3.png" alt="mwaybtree_deletion_3" /><figcaption aria-hidden="true">mwaybtree_deletion_3</figcaption>
</figure>
<p>刪除 8 後</p>
<figure>
<img src="\willywangkaa\images\mwaybtree_deletion_4.png" alt="mwaybtree_deletion_4" /><figcaption aria-hidden="true">mwaybtree_deletion_4</figcaption>
</figure>
<p>刪除 90 後</p>
<figure>
<img src="\willywangkaa\images\mwaybtree_deletion_5.png" alt="mwaybtree_deletion_5" /><figcaption aria-hidden="true">mwaybtree_deletion_5</figcaption>
</figure>
<h1 id="red-black-tree">Red black tree</h1>
<p>Balanced binary search tree</p>
<ol type="1">
<li>節點顏色非黑即紅</li>
<li>樹根節點必為黑節點</li>
<li>「Nil」節點也視為黑節點</li>
<li>紅節點其子節點必為黑節點 ( 任何路徑上不得出現連續紅節點 )</li>
<li>樹根至任意不同之「葉節點」路徑<strong>皆具有相同數量的黑色節點 ( Balance )</strong></li>
</ol>
<figure>
<img src="\willywangkaa\images\rbtree.png" alt="rbtree" /><figcaption aria-hidden="true">rbtree</figcaption>
</figure>
<blockquote>
<p>在紅黑樹中</p>
<ol type="1">
<li>最短路徑：全為黑色 ( 鏈結、節點 ) 之路徑</li>
<li>最長路徑：黑紅交錯 ( 鏈結、節點 ) 之路徑</li>
<li>「2-3-4 tree」高度 = <span class="math inline">\(\lceil \log(n+1)\rceil\)</span>
<ul>
<li>全為「2－節點」：<span class="math inline">\(\lceil \log_2(n+1)\rceil\)</span> ( 最小高度 )
<ul>
<li>因為當「2-3-4 tree」全為「2－節點」時，<strong>所建出之紅黑樹會一樣高 ( 全部皆為黑色路徑 )</strong></li>
</ul></li>
<li>全為「4－節點」：<span class="math inline">\(2 \cdot \lceil \log_2(n+1)\rceil\)</span> (最大高度)
<ul>
<li>因為當「2-3-4 tree」全為「4－節點」時，<strong>所建出之紅黑樹會是兩倍高 ( 黑紅路徑交錯出現 )</strong></li>
</ul></li>
</ul></li>
</ol>
</blockquote>
<h2 id="insert-x-in-rb-tree-top-down">Insert x in RB-tree (Top-down)</h2>
<p>步驟：</p>
<ol type="1">
<li>先找尋 x 的插入位置
<ul>
<li><strong>在找尋 x 的插入位置時，所經過得路徑上，若發現有節點具有兩個紅色子節點，使其「顏色交換 ( color change )」，再檢查有無違反「連續之紅色節點」，若有作「Rotation」侯進行下一步 (插入)，若無直接進行下一步</strong></li>
</ul></li>
<li>將插入之節點標為紅色後放置在該插入位置</li>
<li>檢查有無違反「連續之紅色節點」，若有作「Rotation」進行下一步，若無則直接進行下一步</li>
<li>如果需要，將樹根節點改為黑色節點</li>
</ol>
<blockquote>
<p><strong>注意</strong>：第一步與第三步只會有一者發生</p>
</blockquote>
<blockquote>
<p>Rotation</p>
<p>分為 LL、LR、RL、RR ，與 AVL tree 旋轉相似，只是加上顏色變化：中間鍵值往上拉標黑，兩子點標紅</p>
<figure>
<img src="\willywangkaa\images\Rbrotation.png" alt="Rbrotation" /><figcaption aria-hidden="true">Rbrotation</figcaption>
</figure>
</blockquote>
<h2 id="delete-x-in-rb-tree">Delete x in RB-tree</h2>
<p>目前不討論</p>
<h2 id="the-height-of-rb-tree">The height of RB-tree</h2>
<ul>
<li><p>假設原始紅黑樹為 T</p></li>
<li><p>假設對於每個<strong>頂點 x</strong></p>
<ul>
<li>其頂點至葉節點之每個路徑的黑色節點數量為 BH(x) （Black node height）</li>
<li>其樹高為 H(x)</li>
</ul></li>
</ul>
<blockquote>
<p>其中 H(x)、BH(x) 定義如下：</p>
<figure>
<img src="\willywangkaa\images\theheightofrbtree.png" alt="theheightofrbtree" /><figcaption aria-hidden="true">theheightofrbtree</figcaption>
</figure>
</blockquote>
<ul>
<li><strong>＜證明＞</strong>任何以 x 頂點為根的子樹 T'，其內部節點（在原本 T 的內部節點）至少有 <span class="math inline">\(2^{BH(x)}-1\)</span></li>
</ul>
<p>（對 H(x) 做數學歸納法推導）</p>
<ol type="1">
<li><p>當 H(x) 為 0 時，則可以知道其為 <strong>Nil 節點</strong>，則<strong>以該節點為子樹 T'</strong>必無存在<strong>內部節點</strong>（T 的內部節點）</p>
<ul>
<li>因為 BH(x) = 0，則 <span class="math inline">\(2^0-1 = 1-1 = 0\)</span>，無內部節點</li>
</ul></li>
<li><p>考慮一個節點 x<strong>（黑節點）</strong>，其樹高為 H(x) = k &gt; 0，則該點為 <strong>T 的一個內部節點</strong></p>
<ul>
<li>討論其節點的「兩個子節點」y
<ul>
<li>節點 y 至每個葉節點的黑色節點數量為<span class="math inline">\(\left\{\begin{matrix} BH(x),\;若\; y \;為紅色節點 \\ BH(x)-1,\;若\; y \;為黑色節點 \end{matrix}\right.\)</span></li>
</ul></li>
<li><strong>假設其「兩個子節點」 成立</strong>，則 y 到葉節點包含 T 的內部節點至少有 <span class="math inline">\(2^{BH(x)-1}-1\)</span></li>
<li>考慮以 x 節點為子樹 T' ，其包含 T 的內部節點至少有
<ul>
<li>（左子點包含 T 的內部節點）+（右子點包含 T 的內部節點）+（x 本身就為 T 的內部節點）</li>
<li><span class="math inline">\((2^{BH(x)-1}-1)+(2^{BH(x)-1}-1)+1 = 2^{BH(x)}-1\)</span>，<strong>命題得證</strong></li>
</ul></li>
</ul></li>
</ol>
<ul>
<li><strong>＜證明＞</strong>一棵含有 n 個<strong>內部節點</strong>的紅黑樹 T 其樹高最多只有 <span class="math inline">\(2\cdot\lg(n+1)\)</span>
<ul>
<li>假設 H 為 T 的樹高</li>
<li>根據紅黑樹的性質「紅色節點不能與另一個紅節點相連」
<ul>
<li>從根節點至葉節點（<strong>不包括根節點</strong>）的任何一條簡單路徑，至少有一半的節點為黑節點</li>
</ul></li>
<li>所以從根節點至葉節點的 <span class="math inline">\(BH \geq \frac{H}{2}\)</span></li>
<li>再根據上述定理，<span class="math inline">\(n \geq 2^{BH}-1 \geq 2^{\frac{H}{2}}-1\)</span></li>
<li>則 <span class="math inline">\(2^\frac{H}{2} \leq n+1 \Rightarrow \frac{H}{2} \leq \lg(n+1) \Rightarrow H \leq 2\lg(n+1)\)</span></li>
</ul></li>
</ul>
<h1 id="red-black-tree-不同定義">Red black tree ( 不同定義 )</h1>
<p>為一棵被「2-3-4 tree」所對應之「Binary search tree」</p>
<ol type="1">
<li>「鏈結」非黑即紅</li>
<li>若該「鏈結」在原本「2-3-4 tree」就已經存在則視為黑色鏈結，否則視為紅色鏈結</li>
<li>任何路徑上不可連續出現紅色鏈結</li>
<li>樹根節點到不同葉節點的路徑上皆具有相同數量之黑色鏈結</li>
</ol>
<ul>
<li>2－結點</li>
</ul>
<figure>
<img src="\willywangkaa\images\2-nodetorbtree.png" alt="2-nodetorbtree" /><figcaption aria-hidden="true">2-nodetorbtree</figcaption>
</figure>
<ul>
<li>3－結點</li>
</ul>
<figure>
<img src="\willywangkaa\images\3-nodetotbtree.png" alt="3-nodetotbtree" /><figcaption aria-hidden="true">3-nodetotbtree</figcaption>
</figure>
<blockquote>
<p>3－結點轉換時會有兩種可能，所以轉換不唯一</p>
</blockquote>
<figure>
<img src="\willywangkaa\images\4-nodetorbtree.png" alt="4-nodetorbtree" /><figcaption aria-hidden="true">4-nodetorbtree</figcaption>
</figure>
<h1 id="optimal-binary-search-tree-obst">Optimal binary search tree (OBST)</h1>
<p>給 n 個內部節點加權值：<span class="math inline">\(p_i\)</span>，<strong>1 ≦ i ≦ n</strong>，與 n+1 個外部節點加權值：<span class="math inline">\(q_i\)</span>，<strong>0 ≦ j ≦ n</strong></p>
<p>在所有 <span class="math inline">\(\frac {1}{n+1}\binom{2n}{n}\)</span> 不同種二元搜尋樹中，具有最小的搜尋總成本之二元搜尋樹 ( 不唯一 )</p>
<ul>
<li>Search total cost = 成功搜尋成本 + 失敗搜尋成本</li>
<li>成功搜尋成本 = <span class="math inline">\(\sum^n_{i = 1} (內部節點_i \;之「Level」值\times p_i)\)</span>
<ul>
<li>內部節點<span class="math inline">\(_i\)</span> 之「Level」值：<strong>比較次數</strong></li>
</ul></li>
<li>失敗搜尋成本 = <span class="math inline">\(\sum^n_{j = 0} ((外部節點_j \;之「Level」值-1)\times q_i)\)</span>
<ul>
<li><strong>外部節點</strong><span class="math inline">\(_j\)</span> <strong>之「Level」值 - 1：比較次數</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\orbtree.png" alt="orbtree" /><figcaption aria-hidden="true">orbtree</figcaption>
</figure>
<ul>
<li>圖（1）
<ul>
<li>成功搜尋成本 = 1 × 0.5 + 2 × 0.1 + 3 × 0.05 = 0.85</li>
<li>失敗搜尋成本 = 1 × 0.15 + 2 × 0.1 + 3 × 0.05 + 3 × 0.05 = 0.65</li>
<li>總成本 = 0.85 + 0.65 = 1.5</li>
</ul></li>
<li>圖（2）
<ul>
<li>成功搜尋成本 = 1 × 0.1 + 2 × 0.5 + 2 × 0.05 = 1.2</li>
<li>失敗搜尋成本 = 2 × ( 0.15 + 0.1 + 0.05 + 0.05 ) = 0.7</li>
<li>總成本 = 1.2 + 0.7 = 1.9</li>
</ul></li>
</ul>
<blockquote>
<p>在有加權值之影響下，不見得高度越小，成本越小</p>
</blockquote>
<h2 id="建立-obst">建立 OBST</h2>
<blockquote>
<p>Dynamic programming 三要件</p>
<ul>
<li>定出針對該問題之遞迴公式</li>
<li>建立表格</li>
<li>利用表格</li>
</ul>
</blockquote>
<p>假設 <span class="math inline">\(a_{i+1}, a_{i+2}, \ldots, a_{j}\)</span> 為內部節點，且 <span class="math inline">\(a_{i+1} &lt; a_{i+2} &lt; \ldots &lt; a_{j}\)</span></p>
<p>令內部節點加權值 = <span class="math inline">\(p_{i+1}, p_{i+2}, \ldots, p_{j}\)</span>；外部節點加權值 = <span class="math inline">\(q_{i}, q_{i+1}, \ldots, q_{j}\)</span></p>
<blockquote>
<p>定義</p>
<p><span class="math inline">\(T_{i, j}\)</span> 代表由 <span class="math inline">\(a_{i+1}, a_{i+2}, \ldots, a_{j}\)</span> 所組成之「OBST」，且令 <span class="math inline">\(T_{i, i}\)</span> 為空樹，而當 i &gt; j 時無定義</p>
</blockquote>
<p>Example</p>
<ul>
<li><span class="math inline">\(T_{2, 5}\)</span>：<span class="math inline">\(a_3, a_4, a_5\)</span> 所組成之 OBST</li>
<li><span class="math inline">\(T_{2, 3}\)</span>：<span class="math inline">\(a_3\)</span> 所組成之 OBST</li>
</ul>
<p>定義</p>
<ul>
<li><span class="math inline">\(C_{i, j}\)</span> 代表 <span class="math inline">\(T_{i, j}\)</span> 的成本</li>
<li><span class="math inline">\(r_{i, j}\)</span> 代表 <span class="math inline">\(T_{i, j}\)</span> 之樹根節點編號</li>
<li><span class="math inline">\(w_{i, j}\)</span> 代表 <span class="math inline">\(T_{i, j}\)</span> 之<strong>內外部節點加權值和</strong></li>
<li>若為空樹 <span class="math inline">\(C_{i, i} = 0 \\ r_{i, i} = nil \\ w_{i, i} = q_i\)</span></li>
</ul>
<h3 id="遞迴推導">遞迴推導</h3>
<ol type="1">
<li>在 <span class="math inline">\(a_{i+1}, a_{i+2}, \ldots, a_{j}\)</span> 中任挑一個作為樹根 ( <span class="math inline">\(a_k\)</span> )</li>
</ol>
<figure>
<img src="\willywangkaa\images\OBST_1.png" alt="OBST_1" /><figcaption aria-hidden="true">OBST_1</figcaption>
</figure>
<p>則 L 子樹以 <span class="math inline">\(T_{i, k-1}\)</span> 表示； R 子樹以 <span class="math inline">\(T_{k, j}\)</span> 表示</p>
<p><span class="math inline">\(C_{i, j} = 1\cdot p_k + c_{i, k-1} + c_{k, j} + w_{i, k-1} + w_{k, j} \\ = c_{i, k-1} + c_{k, j} + w_{i, j}\)</span></p>
<figure>
<img src="\willywangkaa\images\OBST_2.png" alt="OBST_2" /><figcaption aria-hidden="true">OBST_2</figcaption>
</figure>
<ol start="2" type="1">
<li>在所有可能中挑出一個能使當前子樹成本最低之樹根</li>
</ol>
<p><span class="math display">\[
C_{i, j} = w_{i, j} + min_{i+1 \leq k \leq j}｛C_{i, k-1}, C_{k, j}｝
\]</span></p>
<blockquote>
<p>在 Comman 之演算法教科書中</p>
<p>失敗搜尋成本 = <span class="math inline">\(\sum^n_{j = 0} (外部節點_j \;之「Level」值\times q_i)\)</span>，不用多扣除一次「搜尋次數」</p>
<p>所以，可以先依上述方式計算完後之總成本<strong>再加上多出來的成本</strong>，如下： <span class="math display">\[
［Comman］總成本 = ［上述算法］總成本 + \sum_{j = 0}^n q_j
\]</span></p>
</blockquote>
<h2 id="特殊題型">特殊題型</h2>
<p>若題目未給出外部節點之加權值，將外部節點加權值視為 0，再沿用原本作法計算</p>
<ul>
<li>重新定義 <span class="math inline">\(T_{i, j}\)</span>
<ul>
<li>為 <span class="math inline">\(a_{i} , a_{i+1} , \ldots , a_{j}\)</span> 所組成之 OBST</li>
<li>內部節點之加權值為 <span class="math inline">\(p_{i}, p_{i+1}, \ldots, p_{j}\)</span></li>
<li><span class="math inline">\(C_{i, j}\)</span> 為 <span class="math inline">\(T_{i, j}\)</span> 之總成本</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\OBST_3.png" alt="OBST_3" /><figcaption aria-hidden="true">OBST_3</figcaption>
</figure>
<p><span class="math display">\[
C_{i, j} = 1\cdot p_k + C_{i, k-1} + C_{k+1, j} + w_{i, k-1} + w_{k+1, j} \\
= w_{i, j} + C_{i, k-1} + C_{k+1, j} \\
\Rightarrow C_{i, j} = w_{i, j} + min_{i\leq k \leq j}｛C_{i, k-1} + C_{k+1, j}｝
\]</span></p>
<h1 id="splay-tree">Splay tree</h1>
<table>
<thead>
<tr class="header">
<th></th>
<th>AVL tree</th>
<th>Splay tree</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>調整過程</td>
<td>複雜</td>
<td>簡單</td>
</tr>
<tr class="even">
<td>實際最差行況</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr class="odd">
<td>分攤成本 (Amortize)</td>
<td>N/A</td>
<td>O(log n)</td>
</tr>
</tbody>
</table>
<p>正常的插入與刪除節點只是會需要加上「Splay」操作</p>
<blockquote>
<p>Splay：將該起點旋轉至整棵樹樹根節點</p>
<ul>
<li>Search (x)：x 為作「Splay」之起點</li>
<li>Insert (x)：x 為作「Splay」之起點</li>
<li>Delete (x)： x 之父節點為作「Splay」之起點 ( 若存在 )</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Binary search tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Data structure - Advance heap</title>
    <url>/willywangkaa/2018/10/31/Data-structure-Advance-heap/</url>
    <content><![CDATA[<h1 id="binary-heap">Binary heap</h1>
<h2 id="build-heap">Build heap</h2>
<h3 id="top-down">Top down</h3>
<p>依序插入所有資料逐步建立「Heap」</p>
<blockquote>
<p>Time complexity for heap insertion：log n</p>
</blockquote>
<ul>
<li>Time complexity 若要建立一個 n 筆資料之「Heap」
<ul>
<li><span class="math inline">\(\sum_{i = 1}^n \log i = \log(n!) = n\log n\)</span></li>
<li><span class="math inline">\(\Theta(n\log n)\)</span></li>
</ul></li>
</ul>
<h3 id="buttum-up">Buttum up</h3>
<ol type="1">
<li><strong>將 n 個輸入資料先以「Complete binary tree」( 陣列 ) 放置好</strong></li>
<li>從最後一個父節點 (A[i]) 開始，往回執行 ( A[i-1], A[i-2] ... ) 對各個父節點，調整子樹成為「Heap」，直到 A[1] 為止</li>
</ol>
<figure>
<img src="\willywangkaa\images\buildheap.png" alt="buildheap" /><figcaption aria-hidden="true">buildheap</figcaption>
</figure>
<h4 id="time-complexity">Time complexity</h4>
<blockquote>
<p>因為是一個「Complete binary tree」( 完全二元樹 )，所以樹高為 <span class="math inline">\(\lceil \log (n+1) \rceil\)</span></p>
</blockquote>
<p>討論</p>
<figure>
<img src="\willywangkaa\images\buildheap_2.png" alt="buildheap_2" /><figcaption aria-hidden="true">buildheap_2</figcaption>
</figure>
<p>若父節點位於「Level i」調整其子樹成為「Heap」之最大成本為 <strong>K-i</strong></p>
<p>而第 i 層最多有 <span class="math inline">\(2^{i-1}\)</span> 個子樹需要調整，則最大總成本為 <span class="math inline">\(\sum_{i=1}^k 2^{i-1}\times (K-i) = \sum_{i=1}^{k-1} 2^{i-1}\times (K-i)\)</span></p>
<p><span class="math display">\[
S = 2^0 \cdot (k-1) + 2^1 \cdot (k-2) + \ldots + 2^{k-2} \cdot (k-(k-1)) + 2^{k-1}\cdot (k-k) \\
= 2^0 \cdot (k-1) + 2^1 \cdot (k-2) + \ldots + 2^{k-2} \cdot 1 ...........(1)\\
\Rightarrow 2S = 2^1 \cdot (k-1) + 2^2 \cdot (k-2) + \ldots + 2^{k-1} \cdot 1.........(2) \\
2S-S = -2^0\cdot(k-1) + 2 + 2^2 + \ldots + 2^{k-2} + 2^{k-1} \\
\Rightarrow S = -(k-1) + 2\cdot(\frac{2^{k-1}-1}{2-1}) = -k+1+2^k - 2 = 2^k-k-1 \\ = 2^{\lg n} - \lg n -1 = n - \lg n-1 \\
\Rightarrow \Theta(n)
\]</span></p>
<ul>
<li>Algorithm ( Heapify )</li>
</ul>
<p>Max-heap</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tree: Array[1..n]</span></span><br><span class="line"><span class="comment">// n   : 元素個數</span></span><br><span class="line"><span class="comment">// i   : 節點編號 (調整以 i 為樹根之子樹)</span></span><br><span class="line"><span class="built_in">Heapify</span>(tree, i, n) &#123;</span><br><span class="line">    x = tree[i];</span><br><span class="line">    j = <span class="number">2</span> * i                     <span class="comment">//左子</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; n)                 <span class="comment">// 具有右子</span></span><br><span class="line">            <span class="keyword">if</span>(tree[j]&lt;tree[j+<span class="number">1</span>])</span><br><span class="line">                j = j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= tree[j])          <span class="comment">// 已經為 heap</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tree[j/<span class="number">2</span>] = tree[j];</span><br><span class="line">            j = <span class="number">2</span> * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[j/<span class="number">2</span>] = x;                <span class="comment">// 將資料 x 置於正確位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Build</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Build</span>(tree, n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(i = n/<span class="number">2</span>; i&gt;= <span class="number">1</span>; i--) &#123;     <span class="comment">// i = n/2 為最後一個父節點</span></span><br><span class="line">        <span class="built_in">Heapify</span>(tree, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example ( Delete max )</p>
<ul>
<li>Time complexity：O(log n)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">x = tree[<span class="number">1</span>];</span><br><span class="line">tree[<span class="number">1</span>] = tree[n];</span><br><span class="line">n--;</span><br><span class="line"><span class="built_in">heapify</span>(tree, <span class="number">1</span>, n);</span><br></pre></td></tr></table></figure>
<p>Example ( Merge heap )</p>
<ul>
<li>Time complexity：O(n)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// H1:[1..n]</span></span><br><span class="line"><span class="comment">// H2:[1..m]</span></span><br><span class="line"></span><br><span class="line">Heap H3[<span class="number">1.</span>.m+n];</span><br><span class="line"><span class="built_in">copy</span>(H3[<span class="number">1.</span>.n], H1);   <span class="comment">// O(n)</span></span><br><span class="line"><span class="built_in">copy</span>(H3[n+<span class="number">1.</span>.m], H2); <span class="comment">// O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Build</span>(H3, m+n);       <span class="comment">// O(n)</span></span><br></pre></td></tr></table></figure>
<h1 id="double-ended-priority-queue">Double ended priority queue</h1>
<ul>
<li>時間複雜度特性
<ul>
<li>Insert：O(log n)</li>
<li>Del_min：O(log n)</li>
<li>Del_max：O(log n)</li>
</ul></li>
</ul>
<h2 id="min-max-heap">Min-max heap</h2>
<p>Complete tree</p>
<ul>
<li>每層由「Min-level」與「Max-level」交互合併</li>
<li>樹根位於「Min-level」</li>
<li>Min-level
<ul>
<li>位於此層之節點在該子樹中有「最小值」</li>
</ul></li>
<li>Max-level
<ul>
<li>位於此層之節點在該子樹中有「最大值」</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\minmaxheap.png" alt="minmaxheap" /><figcaption aria-hidden="true">minmaxheap</figcaption>
</figure>
<blockquote>
<p>Minimum value = 樹根節點</p>
<p>Maximum value = max｛樹根節點之左右子節點｝</p>
</blockquote>
<h3 id="insert-node-in-min-max-heap">Insert node in min-max heap</h3>
<p>步驟：</p>
<ol type="1">
<li>x 先置於最後一個節點之下一個位置 ( n = Min-max heap.size + 1 )</li>
<li>令 p 為「 x 的父節點」</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case1 &quot;p&quot;: 位於「Min-level」</span></span><br><span class="line"><span class="keyword">if</span>(x &lt; H[p]) &#123;</span><br><span class="line">    H[n] = H[p];       <span class="comment">// 父節點下移</span></span><br><span class="line">    <span class="comment">// verifyMin( binary_heap, position, value )</span></span><br><span class="line">    <span class="built_in">verifyMin</span>(H, p, x);   <span class="comment">// 往祖父點測試有無違反「Min-level」性質</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">verifyMax</span>(H, n, x);   <span class="comment">// 往祖父點測試有無違反「Max-level」性質</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// case2 &quot;p&quot;: 位於「Max-level」</span></span><br><span class="line"><span class="keyword">if</span>(x &gt; H[p]) &#123;</span><br><span class="line">    H[n] = H[p];       <span class="comment">// 父節點下移</span></span><br><span class="line">    <span class="comment">// verifyMax( binary_heap, position, value )</span></span><br><span class="line">    <span class="built_in">verifyMax</span>(H, p, x);   <span class="comment">// 往祖父點測試有無違反「Max-level」性質</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">verifyMin</span>(H, n, x);   <span class="comment">// 往祖父點測試有無違反「Min-level」性質</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>Step 1：O(1)</li>
<li>Step 2：O(1) + O(<span class="math inline">\(\frac{\lg n}{2}\)</span>) (Verify) = O(lg n)</li>
</ul></li>
</ul>
<h3 id="delete-min-in-min-max-heap">Delete-min in min-max heap</h3>
<p>步驟：</p>
<ol type="1">
<li>移出樹根資料</li>
<li>將最後一節點先暫存於 x 後刪除</li>
<li><strong>x 插入樹根</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// H: Heap</span></span><br><span class="line"><span class="comment">// n: Heap 大小</span></span><br><span class="line"><span class="comment">// r: 目前子樹樹根編號</span></span><br><span class="line"><span class="comment">// x: 重新插入值</span></span><br><span class="line"><span class="built_in">Del_reinsert</span>(H, n, r, x) &#123;</span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    <span class="keyword">if</span>(r*<span class="number">2</span> &gt; n) &#123;                                   <span class="comment">// 檢查子樹樹根有無左子節點，若無則無子節點</span></span><br><span class="line">        H[r] = x;</span><br><span class="line">    <span class="comment">// case 2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n*<span class="number">4</span> &gt; n) &#123;                           <span class="comment">// 樹根無孫節點，所以此樹最小值可能落在樹根之子節點中</span></span><br><span class="line">        <span class="keyword">int</span> k = r*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(H[k] &gt; H[k+<span class="number">1</span>])</span><br><span class="line">            k++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x &lt; H[k]) &#123;                              <span class="comment">// 此樹最小值在子樹樹根子節點中</span></span><br><span class="line">            H[r] = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            H[r] = H[k];</span><br><span class="line">            H[k] = r;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">int</span> j = r*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> min = oo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = j; i &lt;= j+<span class="number">4</span> &amp;&amp; i&lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(H[i] &lt; min) &#123;</span><br><span class="line">                k = i;</span><br><span class="line">                min = H[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = k/<span class="number">2</span>;                                 <span class="comment">// p 為 k 之父節點</span></span><br><span class="line">        <span class="comment">// k 必位於「Min-level」</span></span><br><span class="line">        <span class="keyword">if</span>(H[k] &lt; x) &#123;                               <span class="comment">// 此樹最小值在子樹樹根孫節點中</span></span><br><span class="line">            H[r] = H[k];</span><br><span class="line">            <span class="keyword">if</span>(x &gt; H[p]) <span class="built_in">Swap</span>(x, H[p]);              <span class="comment">// !!</span></span><br><span class="line">            <span class="built_in">Del_reinsert</span>(H, n, k, x);                <span class="comment">// &quot;x&quot;插入原本 k 所在之位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            H[r] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Del_min</span> (H, n) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(H[<span class="number">1</span>], H[n]);</span><br><span class="line">    re = H[n];</span><br><span class="line">    n--;</span><br><span class="line">	<span class="built_in">Del_reinsert</span>(H, n, <span class="number">1</span>, H[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example (Delete 3 times)</p>
<figure>
<img src="\willywangkaa\images\delminmaxheap_1.png" alt="delminmaxheap_1" /><figcaption aria-hidden="true">delminmaxheap_1</figcaption>
</figure>
<ul>
<li>1 st deletion</li>
</ul>
<figure>
<img src="\willywangkaa\images\delminmaxheap_2.png" alt="delminmaxheap_2" /><figcaption aria-hidden="true">delminmaxheap_2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delminmaxheap_3.png" alt="delminmaxheap_3" /><figcaption aria-hidden="true">delminmaxheap_3</figcaption>
</figure>
<p><strong>Seep 3</strong> ↓</p>
<figure>
<img src="\willywangkaa\images\delminmaxheap_4.png" alt="delminmaxheap_4" /><figcaption aria-hidden="true">delminmaxheap_4</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delminmaxheap_5.png" alt="delminmaxheap_5" /><figcaption aria-hidden="true">delminmaxheap_5</figcaption>
</figure>
<ul>
<li>2nd delition</li>
</ul>
<figure>
<img src="\willywangkaa\images\delminmaxheap_6.png" alt="delminmaxheap_6" /><figcaption aria-hidden="true">delminmaxheap_6</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delminmaxheap_7.png" alt="delminmaxheap_7" /><figcaption aria-hidden="true">delminmaxheap_7</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delminmaxheap_8.png" alt="delminmaxheap_8" /><figcaption aria-hidden="true">delminmaxheap_8</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delminmaxheap_9.png" alt="delminmaxheap_9" /><figcaption aria-hidden="true">delminmaxheap_9</figcaption>
</figure>
<ul>
<li>3rd delietion</li>
</ul>
<figure>
<img src="\willywangkaa\images\delminmaxheap_10.png" alt="delminmaxheap_10" /><figcaption aria-hidden="true">delminmaxheap_10</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delminmaxheap_11.png" alt="delminmaxheap_11" /><figcaption aria-hidden="true">delminmaxheap_11</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delminmaxheap_12.png" alt="delminmaxheap_12" /><figcaption aria-hidden="true">delminmaxheap_12</figcaption>
</figure>
<h4 id="delete-max">Delete-max</h4>
<figure>
<img src="\willywangkaa\images\delminmaxheap_1.png" alt="delminmaxheap_1" /><figcaption aria-hidden="true">delminmaxheap_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delminmaxheap_13.png" alt="delminmaxheap_13" /><figcaption aria-hidden="true">delminmaxheap_13</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delminmaxheap_14.png" alt="delminmaxheap_14" /><figcaption aria-hidden="true">delminmaxheap_14</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delminmaxheap_15.png" alt="delminmaxheap_15" /><figcaption aria-hidden="true">delminmaxheap_15</figcaption>
</figure>
<h2 id="double-ended-heap-deap">Double-ended heap (DEAP)</h2>
<p>Complete binary tree</p>
<ul>
<li>樹根不賦值</li>
<li>樹根左子樹為「Min heap」</li>
<li>樹根右子樹為「Max heap」</li>
</ul>
<figure>
<img src="\willywangkaa\images\deapnodemap.png" alt="deapnodemap" /><figcaption aria-hidden="true">deapnodemap</figcaption>
</figure>
<ul>
<li><strong>「Min heap」與「Max heap」對應編號</strong>
<ul>
<li>令 i 為在「Min-heap」中某一節點之<strong>編號</strong>，則 j 為「i 在 Max-heap 中對應」之節點編號</li>
<li><span class="math inline">\(j = i + 上一層之最多節點數量 \\ = i + 2^{(目前節點之「Level」-1)-1} \\ = i + 2^{\lceil\lg (i+1)\rceil-2}\)</span></li>
<li>如果該節點 j 不存在 ( j &gt; n )，則 j = <span class="math inline">\([\frac i2 ]\)</span></li>
</ul></li>
</ul>
<h3 id="insert-data-in-deap">Insert data in deap</h3>
<p>步驟：</p>
<ol type="1">
<li>x 先置於最後一個節點之下一個位置 ( n = Deap.size + 1 )</li>
<li>檢查</li>
</ol>
<p>（1）若 x 目前位於「Min-heap」( 位置假設為 i )，則 j 為 x 在「Max-heap」對應之節點編號</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &gt; deap[j]) &#123;</span><br><span class="line">    deap[i] = deap[j];</span><br><span class="line">    <span class="comment">//max_heap_insert(陣列, 陣列位置, 資料);</span></span><br><span class="line">    <span class="built_in">max_heap_insert</span>(deap, j, x);          <span class="comment">// 將 x 與該父節點比較並調整</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//min_heap_insert(陣列, 陣列位置, 資料);</span></span><br><span class="line">    <span class="built_in">min_heap_insert</span>(deap, i, x);          <span class="comment">// 將 x 與該父節點比較並調整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）若 x 目前位於「Max-heap」( 位置假設為 j )，則 i 為 x 在「Min-heap」對應之節點編號</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &lt; deap[i]) &#123;</span><br><span class="line">    deap[i] = deap[j];</span><br><span class="line">    <span class="comment">//min_heap_insert(陣列, 陣列位置, 資料);</span></span><br><span class="line">    <span class="built_in">min_heap_insert</span>(deap, i, x);          <span class="comment">// 將 x 與該父節點比較並調整</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//max_heap_insert(陣列, 陣列位置, 資料);</span></span><br><span class="line">    <span class="built_in">max_heap_insert</span>(deap, j, x);          <span class="comment">// 將 x 與該父節點比較並調整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delete-data-in-deap">Delete data in deap</h3>
<p>步驟：</p>
<ol type="1">
<li>將左子樹樹根資料移出</li>
<li>將最後一節點刪除並該資料先由 x 暫存</li>
<li>左子樹樹根之空缺，由其左右子節點中最小遞補之，由上而下直到某「葉節點」產生空缺</li>
<li>對該空缺作「Insert data in deap」</li>
</ol>
<figure>
<img src="\willywangkaa\images\deap.png" alt="deap" /><figcaption aria-hidden="true">deap</figcaption>
</figure>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\deldeap_1.png" alt="deldeap_1" /><figcaption aria-hidden="true">deldeap_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\deldeap_2.png" alt="deldeap_2" /><figcaption aria-hidden="true">deldeap_2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\deldeap_3.png" alt="deldeap_3" /><figcaption aria-hidden="true">deldeap_3</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\deldeap_4.png" alt="deldeap_4" /><figcaption aria-hidden="true">deldeap_4</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\deldeap_5.png" alt="deldeap_5" /><figcaption aria-hidden="true">deldeap_5</figcaption>
</figure>
<h2 id="symmetric-min-max-heap-smmh">Symmetric min-max heap (SMMH)</h2>
<p>Complete binary tree</p>
<ul>
<li>樹根不賦值</li>
<li>條件一 ( <span class="math inline">\(P_1\)</span> )：左兄弟 ≦ 右兄弟</li>
<li><strong>條件二</strong> ( <span class="math inline">\(P_2\)</span> )<strong>：若該節點 x 有祖父節點則「祖父節點之左子節點鍵值」 ≦ x</strong></li>
<li><strong>條件三</strong> ( <span class="math inline">\(P_3\)</span> <strong>)：若該節點 x 有祖父節點則「祖父節點之右子節點鍵值」 ≧ x </strong></li>
</ul>
<p>針對下方全部綠色節點，全部鍵值都比 2 大，都比 80 小</p>
<figure>
<img src="\willywangkaa\images\SMMH.png" alt="SMMH" /><figcaption aria-hidden="true">SMMH</figcaption>
</figure>
<blockquote>
<p>由上方性質可以反映出</p>
<p>「以節點邊號 i 為樹根之子樹中，其子孫最小值為左子節點，其子孫最大值為右子節點」</p>
</blockquote>
<h3 id="insert-data-in-smmh">Insert data in SMMH</h3>
<p>步驟：</p>
<ol type="1">
<li>x 先置於最後一個節點之下一個位置 ( n = SMMH.size + 1 )</li>
<li><strong>檢查「條件一」是否滿足，若違反「左右兄弟節點互換」</strong></li>
<li><strong>檢查「條件二」、「條件三」是否滿足，若違反其中一者則調整之</strong></li>
</ol>
<h3 id="delete-min-in-smmh">Delete min in SMMH</h3>
<p>步驟：</p>
<ol type="1">
<li>移出左子樹根之資料</li>
<li><strong>刪除最後一個節點並將值暫存於 x</strong></li>
<li><strong>x 暫置於左子樹根之空缺</strong></li>
<li><strong>檢查「條件一」是否滿足，若違反「左右兄弟節點互換」</strong></li>
<li><strong>檢查「條件二」是否滿足，若違反則調整之</strong></li>
<li>重複步驟四、五直到完全符合條件</li>
</ol>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\SMMH_2.png" alt="SMMH_2" /><figcaption aria-hidden="true">SMMH_2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delSMMH_1.png" alt="delSMMH_1" /><figcaption aria-hidden="true">delSMMH_1</figcaption>
</figure>
<p>在藍色中選出一個最小值</p>
<figure>
<img src="\willywangkaa\images\delSMMH_2.png" alt="delSMMH_2" /><figcaption aria-hidden="true">delSMMH_2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delSMMH_3.png" alt="delSMMH_3" /><figcaption aria-hidden="true">delSMMH_3</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delSMMH_4.png" alt="delSMMH_4" /><figcaption aria-hidden="true">delSMMH_4</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delSMMH_5.png" alt="delSMMH_5" /><figcaption aria-hidden="true">delSMMH_5</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\delSMMH_6.png" alt="delSMMH_6" /><figcaption aria-hidden="true">delSMMH_6</figcaption>
</figure>
<h1 id="leftist-heap">Leftist heap</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Min-heap</th>
<th style="text-align: center;">Leftist heap</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Insert data</td>
<td style="text-align: center;">O(log n)</td>
<td style="text-align: center;">O(log n)</td>
</tr>
<tr class="even">
<td style="text-align: center;">Delete min</td>
<td style="text-align: center;">O(log n)</td>
<td style="text-align: center;">O(log n)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Merge heap</td>
<td style="text-align: center;">O(n)：build heap</td>
<td style="text-align: center;">O(log n)</td>
</tr>
</tbody>
</table>
<h2 id="leftist-tree-minimum-leftist-tree">Leftist tree (Minimum leftist tree)</h2>
<ul>
<li>Shortest：到任一個外部節點之最短路徑長</li>
</ul>
<p>令 x 為「Extended binary tree」中某個節點，則</p>
<p>Shortest(x) = <span class="math inline">\(\left\{\begin{matrix} 0 &amp;, x 為「外部節點」 \\ 1 + min｛Shortest(x\rightarrow Lchild), Shortest(x\rightarrow Rchild)｝ &amp; , 其他 \end{matrix}\right.\)</span></p>
<ul>
<li>Leftist tree
<ul>
<li>針對任何一個內部節點 x，其 Shortest(x→Lchild) ≧ Shortest(x→Rchild)</li>
</ul></li>
</ul>
<h2 id="leftist-heap-1">Leftist heap</h2>
<p>本身也為一棵「Leftist tree」且為一棵「Min-tree」( 父節點值 ≦ 子節點值 )</p>
<h3 id="merge-leftist-heap-h_1-h_2">Merge leftist heap (<span class="math inline">\(H_1, H_2\)</span>)</h3>
<p>步驟：</p>
<ol type="1">
<li>比較 <span class="math inline">\(H_1\)</span> 與 <span class="math inline">\(H_2\)</span> 之根節點值，找出最小值。( 假設 <span class="math inline">\(H_1\)</span> 之根節點比較小 )</li>
<li><strong>以</strong> <span class="math inline">\(H_1\)</span> <strong>之根節點作為新樹之根節點，該新樹保留</strong> <span class="math inline">\(H_1\)</span> <strong>之左子樹</strong></li>
<li>Merge( <span class="math inline">\(H_1\)</span> 之右子樹, <span class="math inline">\(H_2\)</span> ) <strong>成為新樹之右子樹</strong> (遞迴)</li>
<li>檢查所有節點是否符合「Leftist tree」之性質，若不滿足則作「Swap」</li>
</ol>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\leftisttreemerge_1.png" alt="leftisttreemerge_1" /><figcaption aria-hidden="true">leftisttreemerge_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\leftisttreemerge_2.png" alt="leftisttreemerge_2" /><figcaption aria-hidden="true">leftisttreemerge_2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\leftisttreemerge_3.png" alt="leftisttreemerge_3" /><figcaption aria-hidden="true">leftisttreemerge_3</figcaption>
</figure>
<h3 id="delete-min-in-leftist-heap">Delete-min in leftist heap</h3>
<p>步驟：</p>
<ol type="1">
<li>刪除根節點並輸出，斷開鏈結後得兩子樹 <span class="math inline">\(H_1, H_2\)</span></li>
<li>Merge(<span class="math inline">\(H_1, H_2\)</span>)</li>
</ol>
<h3 id="insert-data-in-leftist-heap">Insert data in leftist heap</h3>
<p>步驟：</p>
<ol type="1">
<li>插入節點自成為一個「Leftist heap」<span class="math inline">\(H_2\)</span>，令被插入之「Leftist heap」為 <span class="math inline">\(H_1\)</span></li>
<li>Merge(<span class="math inline">\(H_1, H_2\)</span>)</li>
</ol>
<h1 id="binominal-heap">Binominal heap</h1>
<h2 id="binominal-tree">Binominal tree</h2>
<blockquote>
<p><strong>令樹高從 0 開始</strong></p>
</blockquote>
<ul>
<li>高度為 0 的「Binominal tree」記為 <span class="math inline">\(B_0\)</span>，只有樹根一個節點</li>
<li>高度為 k 的「Binaminal tree」 記為 <span class="math inline">\(B_k\)</span>，由兩棵 <span class="math inline">\(B_{k-1}\)</span> 組成 (任挑其中一點作為樹根)</li>
</ul>
<blockquote>
<ol type="1">
<li><span class="math inline">\(B_k\)</span> 中「i-th level」之節點為 <span class="math inline">\(\binom{k}{i}\)</span></li>
<li><span class="math inline">\(B_k\)</span> 之節點總數為 <span class="math inline">\(2^k\)</span></li>
</ol>
</blockquote>
<h2 id="binominal-heap-1">Binominal heap</h2>
<p>是由 ≧ 0 棵「Binominal tree」所組成之集合 ( 森林 ) 且每棵樹也為「Min-tree」</p>
<blockquote>
<p>「Binominal heap」有 13 筆資料( 節點 )，則由 3 個「Binomal tree」組成</p>
<ul>
<li>若總結點數量 n = <span class="math inline">\(2^k\)</span>
<ul>
<li>「Binominal heap」只有一棵「Binominal tree」</li>
</ul></li>
<li>若總結點數量 n = <span class="math inline">\(2^k-1\)</span>
<ul>
<li>有 k 棵「Binominal tree」</li>
</ul></li>
<li>k = lg ( n+1 )</li>
</ul>
</blockquote>
<h3 id="merge-binominal-heap">Merge binominal heap</h3>
<p>步驟：</p>
<ol type="1">
<li>將具有相同高度之「Binominal tree」合併成一棵新的「Binominal tree」</li>
<li>合併直到此<strong>集合中無相同高度之「Binominal 」</strong></li>
</ol>
<figure>
<img src="\willywangkaa\images\leftistheapmerge_1.png" alt="leftistheapmerge_1" /><figcaption aria-hidden="true">leftistheapmerge_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\leftistheapmerge_2.png" alt="leftistheapmerge_2" /><figcaption aria-hidden="true">leftistheapmerge_2</figcaption>
</figure>
<blockquote>
<ol type="1">
<li>合併兩棵樹花費 O(1)，最多大約 lg n 棵樹合併 ( O(lg n) )</li>
<li>上述之合併方法稱為「勤勞合併」( Hard-working merge )</li>
<li><strong>另一種合併方法為「偷懶合併」( Lazy merge )</strong>
<ul>
<li><strong>相同高度不合併，純粹串接在同一集合中( O(1) )</strong></li>
</ul></li>
</ol>
</blockquote>
<h3 id="delete-min-in-binominal-heap">Delete-min in binominal heap</h3>
<p>步驟：</p>
<ol type="1">
<li>從各個樹根找出最小值，令存在最小值數根之樹為 T，其餘樹之集合稱為 <span class="math inline">\(H_1\)</span> （Binominal heap）</li>
<li>刪 T 的樹根會生成子樹，稱之為 <span class="math inline">\(H_2\)</span></li>
<li>Merge(<span class="math inline">\(H_1, H_2\)</span>)</li>
</ol>
<blockquote>
<ol type="1">
<li>在所有樹根找最小值，因為最多才 lg (n+1) 棵樹，所以尋找最小值只需 O( log n ) 即可</li>
<li>在作「Delete-min」時，必採取「勤勞合併」</li>
</ol>
</blockquote>
<h3 id="insert-data-in-binominal-heap-h_1">Insert data in binominal heap (<span class="math inline">\(H_1\)</span>)</h3>
<p>步驟：</p>
<ol type="1">
<li>插入之資料 x，自己成為一個「Binominal heap」( <span class="math inline">\(H_2\)</span> )</li>
<li>Merge( <span class="math inline">\(H_1, H_2\)</span> )</li>
</ol>
<p>Example (<strong>Amotize 計算</strong>) 給 1, 2, 3, 4, 5, 6, 7 以建立「Binominal heap」</p>
<figure>
<img src="\willywangkaa\images\insertbinominalheap_1.png" alt="insertbinominalheap_1" /><figcaption aria-hidden="true">insertbinominalheap_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\insertbinominalheap_2.png" alt="insertbinominalheap_2" /><figcaption aria-hidden="true">insertbinominalheap_2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\insertbinominalheap_3.png" alt="insertbinominalheap_3" /><figcaption aria-hidden="true">insertbinominalheap_3</figcaption>
</figure>
<blockquote>
<ul>
<li>大部分插入的時間為 O( 1 )</li>
<li>少部分插入的時間為 O( lg n )
<ul>
<li>當 n = <span class="math inline">\(2^k -1\)</span> 增加一個節點變成 <span class="math inline">\(2^k\)</span>，有 k 棵樹要合併成一棵</li>
</ul></li>
<li>Amotized cost：O( 1 )</li>
</ul>
</blockquote>
<h2 id="binominal-heap-不同版本">Binominal heap ( 不同版本 )</h2>
<figure>
<img src="\willywangkaa\images\datastructurebinominalheap.png" alt="datastructurebinominalheap" /><figcaption aria-hidden="true">datastructurebinominalheap</figcaption>
</figure>
<ul>
<li>著重於「Data structure」之表示</li>
</ul>
<h1 id="fibonacci-heap">Fibonacci heap</h1>
<blockquote>
<p>[Corman] Fibonacci heap 也是用上述相同的資料結構</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Fibonacci heap</th>
<th style="text-align: center;">Algorithm wiss版本</th>
<th style="text-align: center;">Data structure 版本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Insert data</td>
<td style="text-align: center;"><strong>O(1)：Amotized</strong></td>
<td style="text-align: center;"><strong>O(1)：Amotized</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">Delete min</td>
<td style="text-align: center;">O( log n )：採<strong>勤勞合併</strong></td>
<td style="text-align: center;">O( log n )：採<strong>勤勞合併</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Merge</td>
<td style="text-align: center;">O( log n )：採<strong>勤勞合併</strong></td>
<td style="text-align: center;">O( 1 )：<strong>採偷懶合併</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">Find-min</td>
<td style="text-align: center;">O( log n )：有 log n 個樹根</td>
<td style="text-align: center;">O( 1 )：採用「Min」指標</td>
</tr>
</tbody>
</table>
<h2 id="fibonacci-heap---data-structure">Fibonacci heap - Data structure</h2>
<p>為「Extended binominal heap」亦為「Binominal heap」之「Supperset」；除了「Binominal heap」之「Insert data」、「Merge」、「Delete min」，另外有：</p>
<ol type="1">
<li><strong>Delete x (任意刪除資料)：O( log n ) 考慮刪除資料恰為「Min-data」</strong></li>
<li><strong>Decrease key of a node (減少某點之鍵值)：O(1) 採用「Amotized cost」</strong>
<ul>
<li>應用於圖論中，<strong>如「Minimum spanning tree」之「Kruskal、Prim 演算法」</strong></li>
</ul></li>
</ol>
<h3 id="delete-x-in-fibonacci-heap">Delete x in fibonacci heap</h3>
<figure>
<img src="\willywangkaa\images\delfibonacciheap.png" alt="delfibonacciheap" /><figcaption aria-hidden="true">delfibonacciheap</figcaption>
</figure>
<p>Example 刪除節點 12</p>
<p>刪除該節點後，其兩棵子樹獨立，成為樹根之間之「Sibling」，<strong>並且遇到相同高度「Binominal tree」時不合併 ( 偷懶合併法 )</strong></p>
<figure>
<img src="\willywangkaa\images\delfibonacciheap_2.png" alt="delfibonacciheap_2" /><figcaption aria-hidden="true">delfibonacciheap_2</figcaption>
</figure>
<h3 id="decrease-key-in-fibonacci-heap">Decrease key in fibonacci heap</h3>
<figure>
<img src="\willywangkaa\images\delfibonacciheap.png" alt="delfibonacciheap" /><figcaption aria-hidden="true">delfibonacciheap</figcaption>
</figure>
<ul>
<li>針對節點（1）減少 1：<strong>（1）→（0），其餘不動</strong>
<ul>
<li>O( 1 )</li>
</ul></li>
<li>針對節點（3）減少 1：<strong>（3）→（2），其餘不動</strong>
<ul>
<li><strong>O( 1 )</strong></li>
</ul></li>
<li>針對節點（3）減少 3：<strong>（3）→（0），其餘不動</strong>
<ul>
<li><strong>需要改變「Min」指標 O( 2 )</strong></li>
</ul></li>
<li>針對節點（15）減少 1：（15）→（14）
<ul>
<li>（14）&gt; （12）：不用更動 O( 1 )</li>
</ul></li>
<li><strong>針對節點（15）減少 4：（15）→（11）</strong>
<ul>
<li>（11）&lt; （12）：<strong>該子樹獨立 O( 1 )</strong>，成為樹根之間之「Sibling」並檢查是否比「Min」還小</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\decreasekeyfibonacciheap_1.png" alt="decreasekeyfibonacciheap_1" /><figcaption aria-hidden="true">decreasekeyfibonacciheap_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\decreasekeyfibonacciheap_2.png" alt="decreasekeyfibonacciheap_2" /><figcaption aria-hidden="true">decreasekeyfibonacciheap_2</figcaption>
</figure>
<blockquote>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Operation</th>
<th style="text-align: center;">Binary heap (worst cast)</th>
<th style="text-align: center;">Fibonacci heap (amotized)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Make empty heap</td>
<td style="text-align: center;"><span class="math inline">\(\Theta(1)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Theta(1)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">Insert x</td>
<td style="text-align: center;"><span class="math inline">\(\Theta(\log n)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Theta(1)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Extract min</td>
<td style="text-align: center;"><span class="math inline">\(\Theta(\log n)\)</span></td>
<td style="text-align: center;"><strong>O( log n )</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">Union (Merge)</td>
<td style="text-align: center;"><span class="math inline">\(\Theta(n)\)</span>：Build heap</td>
<td style="text-align: center;"><span class="math inline">\(\Theta(1)\)</span>：<strong>偷懶合併</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Decrease key</td>
<td style="text-align: center;"><span class="math inline">\(\Theta(\log n)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Theta(1)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">Delete x</td>
<td style="text-align: center;"><span class="math inline">\(\Theta(\log n)\)</span>：視為子 heap 中 Del-min</td>
<td style="text-align: center;"><strong>O(log n)</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Find min</td>
<td style="text-align: center;"><span class="math inline">\(\Theta(1)\)</span>：樹根</td>
<td style="text-align: center;"><span class="math inline">\(\Theta(1)\)</span>：採「Min pointer」</td>
</tr>
</tbody>
</table>
<ul>
<li>Decrease key in binary heap ( <span class="math inline">\(\Theta(\log n)\)</span> )</li>
</ul>
<figure>
<img src="\willywangkaa\images\decreasekeyinbinaryheap.png" alt="decreasekeyinbinaryheap" /><figcaption aria-hidden="true">decreasekeyinbinaryheap</figcaption>
</figure>
</blockquote>
<blockquote>
<p>（參考：<a href="https://www.ptt.cc/bbs/Grad-ProbAsk/M.1549085126.A.609.html">Re: ［理工］ 106交大資演9 - 看板Grad-ProbAsk - 批踢踢實業坊</a>）</p>
<ul>
<li>「Fibonacci Heap」
<ul>
<li>DS 與 Algorithm 版實作一樣</li>
<li><strong>「Worst case time/amortized time」皆一致</strong></li>
</ul></li>
<li>「Binomial Heap」
<ul>
<li>DS 和 Algorithm 對於 Merge/Insert 的實作不一樣
<ul>
<li>DS 版本直接串接<strong>（Lazy Merge）</strong></li>
<li>Algorithm 版每次「Insert/Merge」要保證「Binomial Heap」中沒有同 Order 的 「Binomial Tree」<strong>（Hard-working merge）</strong></li>
</ul></li>
</ul></li>
</ul>
<p>時間複雜度整理</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 7%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Binomial (Algorithm)</th>
<th>Binomial (Algorithm)</th>
<th>Lazy-Binomial (DS)</th>
<th>Lazy-Binomial (DS)</th>
<th>Fibonacci</th>
<th>Fibonacci</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Operation</strong></td>
<td>Worst</td>
<td>Amortized</td>
<td>Worst</td>
<td>Amortized</td>
<td>Worst</td>
<td>Amortized</td>
</tr>
<tr class="even">
<td>Make <strong>empty heap</strong></td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
</tr>
<tr class="odd">
<td>Insert x</td>
<td>Θ(lg n)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
</tr>
<tr class="even">
<td>Minimum</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
</tr>
<tr class="odd">
<td>Extract-min</td>
<td>Θ(lg n)</td>
<td>Θ(lg n)</td>
<td>Θ(lg n)</td>
<td>Θ(lg n)</td>
<td>Θ(lg n)</td>
<td>Θ(lg n)</td>
</tr>
<tr class="even">
<td>Union (Merge)</td>
<td>Θ(lg n)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
<td>Θ(1)</td>
</tr>
<tr class="odd">
<td>Decrease key</td>
<td>Θ(lg n)</td>
<td><strong>O(lg n)</strong></td>
<td>Θ(lg n)</td>
<td><strong>O(lg n)</strong></td>
<td>Θ(n)</td>
<td>Θ(1)</td>
</tr>
<tr class="even">
<td>Find min</td>
<td>Θ(lg n)</td>
<td>Θ(lg n)</td>
<td>Θ(lg n)</td>
<td>Θ(lg n)</td>
<td>Θ(n)</td>
<td>Θ(lg n)</td>
</tr>
</tbody>
</table>
<ul>
<li>「Minimum」
<ul>
<li>假設一個指標指向「Minimum element」
<ul>
<li>進行其他操作時<strong>指標必須進行相對應的更新</strong>
<ul>
<li><strong>「Minimum」可以在 Θ(1) 完成</strong></li>
</ul></li>
</ul></li>
<li>「Fibonacci Heap」一般都會維護這個指標</li>
<li><strong>當「Binomial Heap」不維護這個指標時</strong>
<ul>
<li><strong>「Minimum」之「Worst/amortized」為 Θ(lg n)</strong></li>
</ul></li>
</ul></li>
<li>「Extract-min」
<ul>
<li>課本上一般證明為 O(lg n)
<ul>
<li>但是不可能為 O(lg n)，因為如此一來只要靠 Insert/Extract-min 就可得到 O(n lg n) 排序
<ul>
<li>無論「Worst」或是「Amortized」都必須是 Θ(lg n)</li>
</ul></li>
</ul></li>
</ul></li>
<li>「Delete」
<ul>
<li>依靠「Decrease-key」與「Extract-min」實作
<ul>
<li>時間複雜度為 Θ(「Decrease-key」+「Extract-min」)</li>
</ul></li>
</ul></li>
<li>「Fibonacci heap」的「Decrease-key」
<ul>
<li><strong>「Worst case」： Θ(n)</strong>
<ul>
<li>可藉由一連串 Insert/Decrease-key/Delete 建構出一個「Fibonacci <strong>tree</strong>」並退化成一個串列，<strong>其全部的節點都已被標記（標記節點；用來標示一個非根節點已失去一個子節點，則不得再奪其子節點，可能需要進行其他特別操作）</strong></li>
<li>對<strong>葉節點</strong>作 Decrease-key 時，必須要把所有串列上的點都「Cut」（分離成為一個獨立的「Fibonacci <strong>tree</strong>」），需要 Θ(n)</li>
</ul></li>
</ul></li>
<li>「Binomial heap」的「Insert/Union」
<ul>
<li>「Amortized time」：O(1)</li>
<li>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.420.43
<ul>
<li>第六小節的第一段最後提到參考文獻</li>
</ul></li>
<li>https://link.springer.com/chapter/10.1007%2F3-540-57568-5_242
<ul>
<li>Double-ended binomial queues, by C. M. Khoong and H. W. Leong</li>
</ul></li>
</ul></li>
<li>「Binomial heap」的「Decrease-key」
<ul>
<li><strong>「Amortized time」：O(lg n)</strong></li>
<li>找不到下限證明<strong>無法聲明其時間複雜度為 Θ(lg n)</strong>
<ul>
<li>（猜測應該很多人都研究過，沒有辦法證明「Amortized time」為 O(lg n)，所以設計「Fibonacci Heap」）</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Data structure - Tree</title>
    <url>/willywangkaa/2018/10/28/Data-structure-Tree/</url>
    <content><![CDATA[<h1 id="binary-tree">Binary tree</h1>
<h2 id="節點數量計算">節點數量計算</h2>
<ul>
<li><p>二元樹之<strong>第 i 階</strong>之節點個數為 <span class="math inline">\(2^{i-1}\)</span>，i ≧ 1</p></li>
<li><p>在高度為 k 的二元樹，全部節點之個數為 <span class="math inline">\(2^k-1\)</span>，k ≧ 1</p></li>
<li><p>對於任一非空二原樹 T ，如果令 Leaf 節點的個數為 <span class="math inline">\(n_0\)</span>， 而 Degree 為 2 的節點的個數為 <span class="math inline">\(n_2\)</span>，則 <span class="math inline">\(n_0 = n_2+1\)</span></p></li>
</ul>
<p><span class="math display">\[
令\; n_1 代表 \;Degree\;為\; 1 \; 的節點個數，n\; 表示節點總數 \\
\Rightarrow n = n_0 + n_1 + n_2 ......(1)\\
又因為只有\; Degree \; 為 \; 1、2 \;的節點才會有分支，令分支總數為 \;B \\
\Rightarrow B = n_1 + 2\cdot n_2 \\
樹的總節點個數又為分支總數加 \;1 \\
\Rightarrow n = n_1 + 2\cdot n_2 + 1 ......(2)\\
By \;(1)、(2)\Rightarrow n_0 = n_2 + 1
\]</span></p>
<blockquote>
<p><strong>Example</strong></p>
<p>有一樹的 Degree 為 4 ，Non-leaf 必有 4 個子節點，若 Leaf 節點個數為 <span class="math inline">\(n_0\)</span> ，求總結點數？ <span class="math display">\[
令\; n \;為樹的節點總數 \\
n = n_0 + (n_1 + n_2 + n_3) + n_4 \\
而非葉節點必有四個子節點，所以 \;n_1、n_2、n_3\; 個數皆為零 \\
\Rightarrow n = n_0 + n_4 ......(1)\\
令\; B \;為樹的總分支數量 \\
B = 4\cdot n_4 \\
樹的總節點個數又為分支總樹加 \;1 \\
n = 4\cdot n_4 + 1 ......(2)\\
By \;(1)、(2) \Rightarrow n_4 = \frac {n_0 -1}{3} \\
\Rightarrow n = n_0 + \frac {n_0 -1}{3} = \frac {4\cdot n_0 -1}{3}
\]</span></p>
</blockquote>
<blockquote>
<p>Example</p>
<p>Completed binary tree 有 1000 個節點 (邊號為 1 ~ 1000)</p>
<ul>
<li>節點編號 747 之 Grandparent 為</li>
</ul>
<p><span class="math inline">\(\frac{\frac{747}{2}}{2} = 186\)</span></p>
<ul>
<li>節點編號 i 之 Grandchilden 為</li>
</ul>
<p>4i +1、4i + 2、4i + 3、4i+4</p>
<ul>
<li>節點編號 512 之左子節點為</li>
</ul>
<p>512 × 2 = 1024 ≧ 1000 ，不存在</p>
<ul>
<li><strong>樹高為</strong></li>
</ul>
<p><span class="math inline">\(2^k-1 = 1000 \\ \Rightarrow k = \lceil \lg 1001 \rceil = 10\)</span></p>
<ul>
<li>節點編號 537 位於哪一層</li>
</ul>
<p><span class="math inline">\(2^k - 1 = 537 \\ \Rightarrow k = \lceil \lg 538 \rceil = 10\)</span></p>
<ul>
<li>第七層的第一個節點編號為</li>
</ul>
<p>前六層之節點總數 <span class="math inline">\(2^6 - 1 = 63 \\ \Rightarrow 64\)</span></p>
<ul>
<li><strong>最後一個父節點之編號</strong></li>
</ul>
<p><span class="math inline">\(1000 / 2\)</span> = 500</p>
<ul>
<li><strong>有幾個 Leaf 節點</strong></li>
</ul>
<p>1000 - 500 = 500</p>
<ul>
<li>Degree 為 1 之節點個數為；該節點編號為</li>
</ul>
<p><span class="math inline">\(n = n_0 + n_1 + n_2 \\ \Rightarrow n = 500 + n_1 + (n_0 -1 )\\ \Rightarrow n = 1\)</span></p>
<p>編號為 500</p>
<ul>
<li>(True or false) 在一個「Complete binary tree」，<span class="math inline">\(n_1\)</span>的數量 = 0 or 1？</li>
</ul>
<p>TRUE</p>
<ul>
<li>(True or false) 在一個「Complete binary tree」，任何節點之左右子樹必也為「Complete binary tree」？</li>
</ul>
<p><strong>TRUE</strong></p>
<ul>
<li>(True or false) 在「Binary tree」中，根節點之左右子樹若皆為「Complete binary tree」，則此樹為「Complete binary tree」？</li>
</ul>
<p>False</p>
</blockquote>
<h1 id="strict-binary-tree">Strict binary tree</h1>
<p>二元樹中，任何<strong>非葉節點</strong>必有兩個子節點 ( <span class="math inline">\(n_1\)</span> = 0 )</p>
<figure>
<img src="\willywangkaa\images\strictbinarytree.png" alt="strictbinarytree" /><figcaption aria-hidden="true">strictbinarytree</figcaption>
</figure>
<ul>
<li>Example
<ul>
<li>「Full binary tree」必為「Strict binary tree」？ <strong>True</strong></li>
<li>「Complete binary tree」必為「Strict binary tree」？ <strong>False</strong></li>
<li>「Strict binary tree」必為「Full binary tree」？ <strong>False</strong></li>
<li>「Strict binary tree」必為「Complete binary tree」？ <strong>False</strong></li>
</ul></li>
</ul>
<blockquote>
<p>Example</p>
<p>針對下列非空二元樹，選出正確敘述</p>
<ul>
<li>（1）<span class="math inline">\(n_0 = n_2 + 1\)</span></li>
<li>（2）<span class="math inline">\(n = 2\cdot n_0 - 1\)</span></li>
<li>（3）高 = <span class="math inline">\(\lceil \lg (n+1)\rceil\)</span></li>
<li>（4）<span class="math inline">\(n_0 + n_2 \leq n \leq n_0 + n_2 + 1\)</span></li>
</ul>
<p>任意「Binary tree」--- （1）</p>
<p>「Full binary tree」--- （1）（2）（3）<strong>（4）</strong></p>
<p>「Complete binary tree」 --- （1）（3）（4）</p>
<p><strong>「Strict bianry tree」</strong>--- （1）（2）</p>
</blockquote>
<blockquote>
<p><strong>Link list tree</strong></p>
<p>n 個節點之「Binary tree」總共有 2n 個鍊節，其中 n-1 條鍊節是有用的</p>
<p><strong>n - (n-1) = n + 1 為 Nil (浪費)</strong></p>
</blockquote>
<h1 id="tree-travesal">Tree travesal</h1>
<blockquote>
<p>若只有前序與後序的資訊時狀況如下：</p>
<ul>
<li>Preorder：abc</li>
<li>Postorder：cba</li>
</ul>
<figure>
<img src="\willywangkaa\images\treetra_1.png" alt="treetra_1" /><figcaption aria-hidden="true">treetra_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\treetra_2.png" alt="treetra_2" /><figcaption aria-hidden="true">treetra_2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\treetra_3.png" alt="treetra_3" /><figcaption aria-hidden="true">treetra_3</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\treetra_4.png" alt="treetra_4" /><figcaption aria-hidden="true">treetra_4</figcaption>
</figure>
</blockquote>
<p>Example</p>
<ul>
<li>Preorder：ABCDEFG</li>
<li>Postorder：DCBFGEA</li>
</ul>
<p><strong>A</strong>(BCD)(EFG)</p>
<p>(DCB)(FGE)<strong>A</strong></p>
<figure>
<img src="\willywangkaa\images\traex_1.png" alt="traex_1" /><figcaption aria-hidden="true">traex_1</figcaption>
</figure>
<p>討論 <strong>＜EFG＞</strong></p>
<figure>
<img src="\willywangkaa\images\traex_2.png" alt="traex_2" /><figcaption aria-hidden="true">traex_2</figcaption>
</figure>
<p>討論 <strong>＜BCD＞</strong></p>
<figure>
<img src="\willywangkaa\images\traex_3_1.png" alt="traex_3_1" /><figcaption aria-hidden="true">traex_3_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\traex_3_2.png" alt="traex_3_2" /><figcaption aria-hidden="true">traex_3_2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\traex_3_3.png" alt="traex_3_3" /><figcaption aria-hidden="true">traex_3_3</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\traex_3_4.png" alt="traex_3_4" /><figcaption aria-hidden="true">traex_3_4</figcaption>
</figure>
<p>Example</p>
<p>決定下列二元樹各為何？</p>
<ul>
<li>前序等於中序
<ul>
<li>Right skew tree、Empty、Single node tree</li>
</ul></li>
<li>後序等於中序
<ul>
<li>Left skew tree、Empty、Single node tree</li>
</ul></li>
<li>前序等於後續
<ul>
<li>Single node tree、Empty</li>
</ul></li>
</ul>
<p>Example</p>
<p>下列哪些可決定唯一的二元樹？</p>
<ul>
<li>（1）Levelorder + Preorder</li>
<li>（2）Levelorder + Postorder</li>
<li><strong>（3）Levelorder + Inorder</strong></li>
</ul>
<p>Levelorder：abc</p>
<p>Preorder：cba</p>
<figure>
<img src="\willywangkaa\images\traex_3_1.png" alt="traex_3_1" /><figcaption aria-hidden="true">traex_3_1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\traex_3_2.png" alt="traex_3_2" /><figcaption aria-hidden="true">traex_3_2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\traex_3_3.png" alt="traex_3_3" /><figcaption aria-hidden="true">traex_3_3</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\traex_3_4.png" alt="traex_3_4" /><figcaption aria-hidden="true">traex_3_4</figcaption>
</figure>
<p>Example</p>
<p>下列何者可以決定唯一的二元樹？</p>
<ul>
<li><strong>（1）Complete binary tree + 前序</strong></li>
<li><strong>（2）Complete binary tree + 中序</strong></li>
<li><strong>（3）Complete binary tree + 後序</strong></li>
<li><strong>（4）Complete binary tree + 中序</strong></li>
</ul>
<p><strong>皆可</strong>，因為「Complete binary tree」可以視為一個已經建好的樹狀表格，在依照各不同的「Order」填入即可</p>
<h2 id="應用">應用</h2>
<ul>
<li>葉節點個數計算</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Myst</span><span class="params">( T:pointer of root )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == nil) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n_L = <span class="built_in">Myst</span>( T-&gt;leftchild );</span><br><span class="line">        n_R = <span class="built_in">Myst</span>( T-&gt;rightchild );</span><br><span class="line">        <span class="keyword">if</span>( n_L + n_R == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> n_L + n_R</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Swap a binary tree</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span> <span class="params">( T:pointer of root )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != nil) &#123;</span><br><span class="line">        <span class="built_in">Swap</span>(T-&gt;leftchild);</span><br><span class="line">        <span class="built_in">Swap</span>(T-&gt;rightchild);</span><br><span class="line">        Tmp = T-&gt;leftchild;</span><br><span class="line">        T-&gt;leftchild = T-&gt;rightchild;</span><br><span class="line">        T-&gt;rightchild = R-&gt;leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="binary-search-tree">Binary search tree</h1>
<p>Example</p>
<p>n 個節點的<strong>「Full binary search tree」</strong>問平均比較次數？</p>
<blockquote>
<p>樹高 k = <span class="math inline">\(\lceil \lg (n+1) \rceil\)</span></p>
<p><span class="math inline">\(\Rightarrow n = 2^k -1\)</span></p>
</blockquote>
<p>令 S 為全部的比較次數，若比較到第一層需要比較一次比較次數，若到第二層需要兩次比較次數.... <span class="math display">\[
\begin{matrix}
 S = &amp; 2^0 \cdot 1 + &amp; 2^1 \cdot 2 + 2^2 \cdot 3 + \ldots + 2^{k-1}\cdot k..................(1)\\ 
 2S= &amp; &amp; 2^1 \cdot 1 + 2^2 \cdot 2 + \ldots + 2^{k-1}\cdot (k-1) + 2^k \cdot k .....(2)
\end{matrix} \\
By (2)-(1) \Rightarrow S = -2^0 -2^1 - 2^2 -\ldots - 2^{k-1} + 2^k \cdot k \\
\Rightarrow \frac{S}{n} = \frac{2^k\cdot k-\frac{2^k-1}{2-1}}{2^k-1} = \frac {2^k\cdot(k-1)+1}{2^k -1} \approx \frac {2^k\cdot(k-1)}{2^k} = (k-1) = \lg(n+1)-1
\]</span> 所以平均只要比較樹高的量即可</p>
<p><strong>Example</strong></p>
<p>下列何者可決定唯一的「Binary tree」？</p>
<ul>
<li><strong>（1）Binary search tree + Preorder</strong></li>
<li>（2）Binary search tree + Inorder</li>
<li><strong>（3）Binary search tree + Postorder</strong></li>
<li><strong>（4）Binary search tree + Levelorder</strong></li>
</ul>
<blockquote>
<p>「Binary search」本身就會有「Inorder」</p>
</blockquote>
<p><strong>Example (P.212 ex28)</strong></p>
<p>有一個「Binary search tree」，找資料 2006 時經過了</p>
<p>1000、5566、5203、k、1314、1510、2381、2006</p>
<p>雖然知道 K 是多少，但可以藉由 k 之後查詢的資料判斷一定是小於 5203，所以</p>
<figure>
<img src="\willywangkaa\images\treeex_1.png" alt="treeex_1" /><figcaption aria-hidden="true">treeex_1</figcaption>
</figure>
<p>還有兩種狀況需要討論</p>
<ul>
<li>若 1314、1510、2381、2006 比 k 還要小的情況</li>
</ul>
<figure>
<img src="\willywangkaa\images\treeex_2.png" alt="treeex_2" /><figcaption aria-hidden="true">treeex_2</figcaption>
</figure>
<p><strong>則 2381 &lt; k &lt; 5203</strong></p>
<ul>
<li>若 1314、1510、2381、2006 比 k 還要大的情況</li>
</ul>
<figure>
<img src="\willywangkaa\images\treeex_3.png" alt="treeex_3" /><figcaption aria-hidden="true">treeex_3</figcaption>
</figure>
<p><strong>則 1000 &lt; k &lt; 1314</strong></p>
<p>所以 2381 &lt; k &lt; 5203；1000 &lt; k &lt; 1314</p>
<h1 id="thread-binary-tree">Thread binary tree</h1>
<blockquote>
<p>一棵 n 個結點並以鏈結串列製作之二元樹中，會有 2n - (n-1) = n+1 條鏈結是「Nil」</p>
</blockquote>
<ul>
<li><p>若 x 的「Lchild」為「Nil」，則視為<strong>左引線指向中序順序中 x 的前一個節點</strong></p></li>
<li><p>若 x 的「Rchild」為「Nil」，則視為<strong>右引線指向中序順序中 x 的後一個節點</strong></p></li>
<li><p>節點結構</p></li>
</ul>
<figure>
<img src="\willywangkaa\images\threadbt.png" alt="threadbt" /><figcaption aria-hidden="true">threadbt</figcaption>
</figure>
<h2 id="head-node">Head node</h2>
<figure>
<img src="\willywangkaa\images\threadbthead.png" alt="threadbthead" /><figcaption aria-hidden="true">threadbthead</figcaption>
</figure>
<ul>
<li>Insuccess (x) 找出 x 的中序後繼者
<ul>
<li>若 x 的「Rthread」為 True，則 x 的「Rchild」即為後繼者</li>
<li>若 x 的「Rthread」為 False，則 x 的右子點開始往左下找，直到「Lthread」為 True，該節點即為後繼者</li>
</ul></li>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Insuccess</span>(x)&#123;</span><br><span class="line">    temp = x-&gt;Rchild;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;Rthread == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;Lthread != <span class="literal">false</span>) &#123;</span><br><span class="line">            temp = temp-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>簡化「Inorder travesel」</li>
</ul>
<p>從「Head」開始不斷詢問「Insuccessor」並列出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Inorder</span>(head) &#123;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        temp = <span class="built_in">Insuccess</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(temp != head) <span class="built_in">print</span>(temp-&gt;data);</span><br><span class="line">    &#125; <span class="keyword">while</span>(temp != head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Insert t node as the right child of s</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Insert</span>(t, S) &#123;</span><br><span class="line">    t-&gt;Rthread = s-&gt;Rthread;</span><br><span class="line">    t-&gt;Rchild  = s-&gt;Rchild;</span><br><span class="line">    t-&gt;Lthread = <span class="literal">true</span>;</span><br><span class="line">    t-&gt;Lchild  = s;</span><br><span class="line">    s-&gt;Rthread = <span class="literal">false</span>;</span><br><span class="line">    s-&gt;Rchild  = t;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;rthread == <span class="literal">false</span>) &#123;</span><br><span class="line">        temp         = <span class="built_in">Insuccess</span>(t);  <span class="comment">// 原本為 s 的中序後繼者，要將引線指向 t 節點</span></span><br><span class="line">        temp-&gt;Lchild = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="extended-binary-tree">Extended binary tree</h1>
<p>n 個節點之二元樹，如果以鏈結串列方式建立，則<strong>有 n+1 條空鏈結</strong>，在這些空鏈結上加上特殊結點，稱為「外部節點」( Extended node；Falure node )，其餘結點稱為「內部節點」( Internal node )</p>
<figure>
<img src="\willywangkaa\images\extendbinarytree.png" alt="extendbinarytree" /><figcaption aria-hidden="true">extendbinarytree</figcaption>
</figure>
<blockquote>
<p>有些版本 ( 如離散數學 )：</p>
<ul>
<li>外部節點等價於葉節點</li>
<li>內部節點等價於非葉節點</li>
</ul>
</blockquote>
<ul>
<li>I：Internal path length</li>
<li>E：External path length</li>
</ul>
<p>令 n 為內部節點數量，則有 n+1 個外部節點：</p>
<ul>
<li>I = <span class="math inline">\(\sum_{i = 1}^n\)</span>（樹根至 內部節點<span class="math inline">\(_i\)</span> 之路徑長）</li>
<li>E = <span class="math inline">\(\sum_{j = 1}^n\)</span>（樹根至 外部節點<span class="math inline">\(_j\)</span> 之路徑長）</li>
</ul>
<h2 id="theorem">Theorem</h2>
<p>令 n 為內部節點個數 <span class="math display">\[
E = I + 2n
\]</span> <strong>數學歸納法</strong></p>
<ol type="1">
<li>當內部節點數量為 0，E = I = 0，E = 0 + 2×0 = 0，成立</li>
<li>假設 內部節點數量 ≦ n-1 時成立</li>
<li>考慮內部節點數量 = n 時。令 <span class="math inline">\(n_L\)</span> 為樹根之左子樹具有的節點數量 ，<span class="math inline">\(I_L\)</span> 為「Internal path length」，<span class="math inline">\(E_L\)</span> 為「External path length」， 同理右子樹也假設 <span class="math inline">\(n_R、I_R、E_R\)</span>； 所以<span class="math inline">\(I = I_L + I_R + (n_L + n_R) \\ E = E_L+E_R +(n_L +1 +n_R+1)\\ \because E_L = I_L + 2n_L , E_R = I_R + 2n_R \\ \Rightarrow E = (I_L + 2n_L) + (I_R + 2n_R) + (n_L +1 +n_R+1) \\ = I + 2N\)</span></li>
</ol>
<blockquote>
<ul>
<li>E 與 I 成正比</li>
<li>樹高越小 E、I 值越小</li>
</ul>
</blockquote>
<p><strong>Example</strong></p>
<p><strong>Skewed extended binary tree 具有 n 個內部節點，求 I 與 E 之值</strong></p>
<p><span class="math inline">\(E = I + 2n = \sum_{i = 0}^{n-1} i + 2n \\ = \frac {n^2 + 3n}{2} \\ I = \frac{n^2-n}{2}\)</span></p>
<h2 id="weighted-external-path-length">Weighted external path length</h2>
<p>給 n 個外部節點加權值 <span class="math inline">\(q_i, 1 \leq i \leq n\)</span>，則 WEPL = <span class="math inline">\(\sum_{i = 1}^n [樹根到「外部節點_i」路徑長 \cdot q_i]\)</span></p>
<blockquote>
<p>因為加權值的影響，不見得樹高越小 WEPL 越小 (Fall 的機率)</p>
</blockquote>
<h3 id="minimum-wepl">Minimum WEPL</h3>
<p>給 n 個外部節點加權值，要在 <span class="math inline">\(\frac 1n \binom{2n-2}{n-1}\)</span> 棵不同的「Extended binary tree」中找出 WEPL 最小的樹</p>
<ul>
<li>Huffman algorithm
<ul>
<li>Greedy algorithm</li>
<li><strong>此樹亦稱為「Optimal 2-way merge tree」</strong></li>
</ul></li>
</ul>
<p>令 w = ｛n 個外部節點之加權值｝</p>
<p>步驟：</p>
<ol type="1">
<li>在 w 中取出兩個最小的加權值建立「Extended binary tree」</li>
<li>將該「Extended binary tree」之加權值再加回 w</li>
<li>重複上述，直到剩下一個值在 w 中 (執行 n-1 次)</li>
<li>此樹稱為「Huffman tree」，其 WEPL 即為「Minimum WEPL」</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// w: set｛n 個外部節點之加權值｝</span></span><br><span class="line"><span class="comment">// n: w.size</span></span><br><span class="line"><span class="built_in">Huffman</span>(w, n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        node t;</span><br><span class="line">        t-&gt;Lchild = <span class="built_in">Del_min</span>(w);</span><br><span class="line">        t-&gt;Rchild = <span class="built_in">Del_min</span>(w);</span><br><span class="line">        t-&gt;weight = t-&gt;Lchild-&gt;weight + t-&gt;Rchild-&gt;weight;</span><br><span class="line">        <span class="built_in">Insert</span>(w, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>Priority queue (Min-heap)</li>
<li>因為對「Min-heap」作了 n-1 次 Del_min 與 Insert(w, t) <span class="math inline">\(\Rightarrow O(n\log n)\)</span></li>
</ul></li>
</ul>
<h1 id="infixprefixpostfix-expression">Infix、Prefix、Postfix expression</h1>
<p><strong>Infix to postfix</strong></p>
<ul>
<li>優先權表</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Operator</th>
<th style="text-align: center;">優先權</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">在「Stack」<strong>外</strong>的 "("</td>
<td style="text-align: center;"><strong>高</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">負號</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">在「Stack」<strong>外</strong>的 "^" （左結合）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">在「Stack」<strong>內</strong>的 "^"（左結合）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">"*"、"/"</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">"+"、"-"</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">"＞"、"＜"、"=="、"≧"、"≦"</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">Not</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">AND、OR</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">在「Stack」<strong>外</strong>的 "="（Assign）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">在「Stack」<strong>內</strong>的 "="（Assign）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">在「Stack」<strong>內</strong>的 "("</td>
<td style="text-align: center;"><strong>低</strong></td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">infix_to_postfix</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    output = <span class="keyword">new</span> string;</span><br><span class="line">    s      = <span class="keyword">new</span> stack;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(x = <span class="built_in">Next_token</span>(input)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_operand</span>(x)) &#123;</span><br><span class="line">            output.<span class="built_in">append</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    tmp = <span class="built_in">pop</span>(s);</span><br><span class="line">                    <span class="keyword">if</span>(tmp!=<span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">                        output.<span class="built_in">append</span>(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span>(tmp!=<span class="string">&quot;(&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">switch</span></span>( <span class="built_in">compare_priority</span>(x,s.<span class="built_in">top</span>()) ) &#123;</span><br><span class="line">                    <span class="keyword">case</span> great:</span><br><span class="line">                        <span class="built_in">push</span>(x,s);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> lessandequal:</span><br><span class="line">                        <span class="keyword">do</span>&#123;</span><br><span class="line">                            tmp = <span class="built_in">pop</span>(s);</span><br><span class="line">                            output.<span class="built_in">append</span>(tmp);</span><br><span class="line">                        &#125; <span class="keyword">while</span>(<span class="built_in">comparepriority</span>(tmp,s.<span class="built_in">top</span>())==great)</span><br><span class="line">                        <span class="built_in">push</span>(x,s);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isempty</span>(s)) &#123;</span><br><span class="line">        output.<span class="built_in">append</span>(<span class="built_in">pop</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Infix to postfix</strong></p>
<ul>
<li>優先權表</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Operator</th>
<th style="text-align: center;">優先權</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">在「Stack」<strong>外</strong>的 ")"</td>
<td style="text-align: center;"><strong>高</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">負號</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">在「Stack」<strong>外</strong>的 "^" （左結合）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">在「Stack」<strong>內</strong>的 "^"（左結合）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">"*"、"/"</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">"+"、"-"</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">"＞"、"＜"、"=="、"≧"、"≦"</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">Not</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">AND、OR</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">在「Stack」<strong>外</strong>的 "="（Assign）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">在「Stack」<strong>內</strong>的 "="（Assign）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">在「Stack」<strong>內</strong>的 ")"</td>
<td style="text-align: center;"><strong>低</strong></td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">infix_to_prefix</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    output  = <span class="keyword">new</span> string;</span><br><span class="line">    a       = <span class="keyword">new</span> stack;</span><br><span class="line">    b       = <span class="keyword">new</span> stack;</span><br><span class="line">    outputs = <span class="keyword">new</span> stack;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(x = <span class="built_in">Next_token</span>(input)) &#123;</span><br><span class="line">        <span class="built_in">push</span>(x,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(x = <span class="built_in">pop</span>(a)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_operand</span>(x)) &#123;</span><br><span class="line">            <span class="built_in">push</span>(x,outputs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    tmp = <span class="built_in">pop</span>(b);</span><br><span class="line">                    <span class="keyword">if</span>(tmp!=<span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">                        <span class="built_in">push</span>(tmp,outputs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span>(tmp!=<span class="string">&quot;)&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">switch</span></span>( <span class="built_in">compare_priority</span>(x,b.<span class="built_in">top</span>()) ) &#123;</span><br><span class="line">                    <span class="keyword">case</span> great:</span><br><span class="line">                        <span class="built_in">push</span>(x,b);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> lessandequal:</span><br><span class="line">                        <span class="keyword">do</span>&#123;</span><br><span class="line">                            tmp = <span class="built_in">pop</span>(b);</span><br><span class="line">                            <span class="built_in">push</span>(tmp,outputs);</span><br><span class="line">                        &#125; <span class="keyword">while</span>(<span class="built_in">comparepriority</span>(tmp,b.<span class="built_in">top</span>())==great)</span><br><span class="line">                        <span class="built_in">push</span>(x,b);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isempty</span>(b)) &#123;</span><br><span class="line">        <span class="built_in">push</span>(<span class="built_in">pop</span>(b),outputs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isempty</span>(outputs)) &#123;</span><br><span class="line">        output.<span class="built_in">append</span>(<span class="built_in">pop</span>(outputs));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Postfix evaluation algorithm</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evaluation</span><span class="params">(string postfix)</span> </span>&#123;</span><br><span class="line">    output = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    s      = <span class="keyword">new</span> stack;</span><br><span class="line">    <span class="keyword">while</span>(x=<span class="built_in">next_token</span>(postfix)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isoperand</span>(x)) &#123;</span><br><span class="line">            <span class="built_in">push</span>(x,s);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">is_unary</span>(x)) &#123;</span><br><span class="line">                tmp = <span class="built_in">pop</span>(s);</span><br><span class="line">                <span class="built_in">push</span>(s, <span class="built_in"><span class="keyword">operator</span></span>(tmp,x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp1 = <span class="built_in">pop</span>(s);</span><br><span class="line">                tmp2 = <span class="built_in">pop</span>(s);</span><br><span class="line">                <span class="built_in">push</span>(s, <span class="built_in"><span class="keyword">operator</span></span>(tmp1,tmp2,x));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>求「Stack size」至少需要多少？</p>
<ol type="1">
<li>Infix to postfix：a × (b+c-d)/(e*f)</li>
<li>Postfix to value：ab+c*de-/f+</li>
</ol>
<p>（1）：4</p>
<p>（2）：3</p>
</blockquote>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep learning - Probability and Information theories I</title>
    <url>/willywangkaa/2019/04/19/Deep-learning-Probability-and-Information-theories-I/</url>
    <content><![CDATA[<h1 id="deep-learning---probability-and-information-theories-i">Deep learning - Probability and Information theories I</h1>
<h2 id="random-variables-and-probability-distribution">Random variables and probability distribution</h2>
<h3 id="random-variables隨機變數">Random variables（隨機變數）</h3>
<blockquote>
<p>在實驗的過程，所有可能的實驗結果 <span class="math inline">\(\omega\)</span> 組成之集合稱為「樣本空間」（Sample space）<span class="math inline">\(\Omega\)</span></p>
<ul>
<li>擲<strong>一次</strong>六面骰子
<ul>
<li>其樣本空間為｛1, 2, 3, 4, 5, 6｝</li>
</ul></li>
</ul>
<p>「事件」（Event）為樣本空間的<strong>子集合</strong></p>
<ul>
<li>擲<strong>一次</strong>六面骰子
<ul>
<li>其中一個事件「大於 4 點」的集合為｛5, 6｝</li>
<li>上述事件的機率為一分數（Fraction）
<ul>
<li>分母為樣本空間的元素個數 6</li>
<li>分子為其事件的元素個數 2</li>
<li><span class="math inline">\(機率(大於 \;4 \;點) = \frac 26 = \frac 13\)</span></li>
</ul></li>
</ul></li>
<li><strong>對於所有事件</strong>
<ul>
<li><strong>0 ≦ 事件對應的機率 ≦ 1</strong></li>
</ul></li>
</ul>
</blockquote>
<blockquote>
<p><strong>Definition</strong>（隨機變數 <span class="math inline">\(\mathrm x\)</span>）</p>
<p>為一個<strong>函數</strong>將樣本空間 <span class="math inline">\(\Omega\)</span> 的元素映射至實數空間，換言之 <span class="math inline">\(\mathrm X\)</span> 為一個自訂的法則，將每個實驗結果 <span class="math inline">\(\omega \in \Omega\)</span> 賦予其實數值 <span class="math inline">\(\mathrm X(\omega)\)</span></p>
<p>Example</p>
<ul>
<li>對應於樣本空間 <span class="math inline">\(\Omega = ｛(1,1),(1,2), \ldots,(6, 6)｝\)</span>，自訂一個隨機變數 <span class="math inline">\(\mathrm X\)</span> 其等於有序對（Order pair）的元素相加
<ul>
<li><span class="math inline">\(\mathrm X(1, 1) = 2, \mathrm X(1, 2) = 3\)</span></li>
<li>推廣：<span class="math inline">\(\mathrm X(i, j) = i+j\)</span></li>
</ul></li>
</ul>
<p><strong>Notation</strong></p>
<ul>
<li><span class="math inline">\(\mathrm X = x\)</span>
<ul>
<li>為事件集合 <span class="math inline">\(｛\omega\in\Omega:\mathrm X(\omega) = x｝\)</span></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>一個<strong>隨機變數</strong> <span class="math inline">\(\mathrm X\)</span> 可被隨機指定指定值的變數
<ul>
<li>（以正體標示，斜體標示為一個常數變數）</li>
<li>會對應一個機率值當指定 <span class="math inline">\(\mathrm x\)</span> 一個值時
<ul>
<li>如：<span class="math inline">\(\Pr(\mathrm X = x_1) = 0.1, \Pr(\mathrm X = x_2) = 0.3\ldots\)</span></li>
</ul></li>
<li>正規來說，<span class="math inline">\(\mathrm X\)</span> 為一個函數將一個「機率事件」映射至「實數域」</li>
</ul></li>
<li>必須伴隨一個可以說明當 <span class="math inline">\(\mathrm X\)</span> 為該實數值的<strong>機率分佈</strong> <span class="math inline">\(\mathrm P\)</span>
<ul>
<li><span class="math inline">\(\mathrm X～\mathrm P(\theta)\)</span> 意旨「<span class="math inline">\(\mathrm X\)</span> 擁有一個以 <span class="math inline">\(\theta\)</span> 為<strong>參數</strong>的機率分佈 <span class="math inline">\(\mathrm P\)</span>」</li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>若 <span class="math inline">\(\mathrm X\)</span> 為<strong>離散值</strong>，<span class="math inline">\(\mathrm P(\mathrm X = x)\)</span> 為一個<strong>「機率質量函數」（Probability mass function</strong>；<span class="math inline">\(P_{\mathrm X}(x) = \mathrm P(\mathrm X = x) = \Pr(\mathrm X =x )\)</span>）
<ul>
<li>如：「一個公正的骰子能擲出的點數」為「離散均勻分佈」並且 <span class="math inline">\(P_{\mathrm X}(x) = \frac 16\)</span></li>
</ul></li>
<li>若 <span class="math inline">\(\mathrm X\)</span> 為<strong>連續值</strong>，<span class="math inline">\(\mathrm P(\mathrm X = x)\)</span> 為一個<strong>「機率密度函數」（Probability density function</strong>；<span class="math inline">\(F_{\mathrm x}(x)\)</span>）
<ul>
<li><span class="math inline">\(F_{\mathrm X}(x)\)</span> 的輸出值不為<strong>機率</strong>而是<strong>機率密度</strong>（在 <span class="math inline">\(x\)</span> 點之<strong>累進機率成長的幅度</strong>）</li>
<li>為「累進分佈函數」（Cumulative distribution function）的<strong>導函數</strong>
<ul>
<li>機率求取：<span class="math inline">\(\Pr(a\leq\mathrm x\leq b) = \int_{[a,b]}p(x)\mathrm dx\)</span></li>
<li><span class="math inline">\(F_{\mathrm X}(x)\)</span> 的輸出可能大於 1
<ul>
<li>在 [a, b] <strong>平均分佈（Uniform distribution）</strong>的狀態下</li>
<li>其<strong>機率密度函數</strong> <span class="math inline">\(p(x) = \left\{\begin{matrix}\frac {1}{b-a} &amp;,if\; x\in [a, b] \\ 0 &amp;,otherwise \end{matrix}\right.\)</span></li>
<li>當 <span class="math inline">\(b-a\)</span> 小於 1 時，<span class="math inline">\(p(x)&gt;1\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h3 id="marginal-probability邊際機率">Marginal probability（邊際機率）</h3>
<ul>
<li>多個變數存在於一個機率分佈
<ul>
<li><span class="math inline">\(P_{\mathrm{X,Y}}(x, y)\)</span> （<strong>聯合機率分佈；Joint probability distribution</strong>）</li>
</ul></li>
<li><strong>邊際機率分佈</strong>
<ul>
<li>在一個聯合機率分佈之下，取其多個隨機變數中只對其子集所關心的機率分佈
<ul>
<li>離散型：<span class="math inline">\(\mathrm P(\mathrm X = x) = \sum_y P_{\mathrm{X,Y}}(x, y)\)</span></li>
<li>連續型：<span class="math inline">\(\int F_{\mathrm{X,Y}}(x,y)\mathrm dy\)</span></li>
</ul></li>
<li>亦稱作「Sum rule of probability」</li>
</ul></li>
</ul>
<h3 id="conditional-probability條件機率">Conditional probability（條件機率）</h3>
<ul>
<li>在機率質量函數或機率密度函數中，其條件機率函數為
<ul>
<li><span class="math inline">\(\mathrm P(\mathrm X = x\vert\mathrm X = y) = \frac {\mathrm P(\mathrm X = x,\mathrm Y = y)}{\mathrm P(\mathrm Y = y)}\)</span></li>
<li>必須符合 <span class="math inline">\(\mathrm P(\mathrm y = y) &gt; 0\)</span> 的情況下</li>
</ul></li>
<li><strong>Product rule of probability</strong>
<ul>
<li><span class="math inline">\(\mathrm P(\mathrm X^{(1)}, \ldots, \mathrm X^{(n)}) = \mathrm P(\mathrm X^{(1)})\prod_{i = 2}^n\mathrm P(\mathrm X^{(i)}｜\mathrm X^{(1)}, \ldots, \mathrm X^{(i-1)})\)</span></li>
<li>如：<span class="math inline">\(\mathrm P(\mathrm{a, b, c}) = \mathrm P(\mathrm{c｜a, b})\mathrm P(\mathrm{b｜a})\mathrm P(\mathrm{a})\)</span></li>
</ul></li>
</ul>
<h3 id="independence-and-conditional-independence獨立與條件獨立">Independence and conditional independence（獨立與條件獨立）</h3>
<ul>
<li>隨機變數 <span class="math inline">\(\mathrm X\)</span> <strong>獨立</strong>於（Independent）<span class="math inline">\(\mathrm Y\)</span>
<ul>
<li>若且唯若 <span class="math inline">\(\mathrm P(\mathrm X\vert\mathrm Y) = \mathrm {P(Y)}\)</span></li>
<li>可推論至 <span class="math inline">\(\mathrm {P(X,Y) = P(X)P(Y)}\)</span></li>
<li>標記為 <span class="math inline">\(\mathrm X \perp \mathrm Y\)</span></li>
</ul></li>
<li>隨機變數 <span class="math inline">\(\mathrm X\)</span> 在 <span class="math inline">\(\mathrm Z\)</span> 之下<strong>條件獨立</strong>於（Conditionally independent）<span class="math inline">\(\mathrm Y\)</span>
<ul>
<li>若且唯若 <span class="math inline">\(\mathrm {P(X\vert Y, Z) = P(X\vert Z)}\)</span></li>
<li>可推論至 <span class="math inline">\(\mathrm {P(X,Y\vert Z) = P(X\vert Z)P(Y\vert Z)}\)</span></li>
<li>標記為 <span class="math inline">\(\mathrm X \perp \mathrm{Y\vert Z}\)</span></li>
</ul></li>
</ul>
<h3 id="expectation期望值">Expectation（期望值）</h3>
<ul>
<li>可稱為「Expectation value」或「Mean」（平均值）</li>
<li>當一個"平均值"定義在對應於 <span class="math inline">\(\mathrm X\)</span> 的函數 <span class="math inline">\(f\)</span> 中
<ul>
<li>將 <span class="math inline">\(f\)</span> 視為一個事件模型（分佈模型），當輸入 <span class="math inline">\(\mathrm X\)</span> 值改變時，其輸出值的加權（其出現機率）平均</li>
<li>離散型：<span class="math inline">\(\mathrm E_{\mathrm {X～P}}[f(x)] = \sum_xP_{\mathrm X}(x)f(x)\)</span></li>
<li>連續型：<span class="math inline">\(\mathrm E_{\mathrm {X～P}}[f(x)] = \int F_{\mathrm X}(x)f(x) \mathrm dx = \mu_{f(x)}\)</span></li>
</ul></li>
<li>對於與 <span class="math inline">\(\mathrm X\)</span> 無關的變數 <span class="math inline">\(a, b\)</span>，<strong>期望值函數為線性函數</strong>
<ul>
<li><span class="math inline">\(\mathrm E[af(\mathrm X)+b] = a\mathrm E[f(\mathrm X)]+b\)</span></li>
</ul></li>
</ul>
<p><strong>證明</strong>（離散型）</p>
<p><span class="math inline">\(\mathrm E[af(\mathrm X)+b] = \sum_xP_{\mathrm X}(x)(af(x)+b) \\ = \sum_x aP_{\mathrm X}(x)f(x)+ bP_{\mathrm X}(x) = a\sum_x P_{\mathrm X}(x)f(x)+b\sum_xP_{\mathrm X}(x)= \\ =a\sum_x P_{\mathrm X}(x)f(x)+b\cdot1 = a\mathrm E[f(\mathrm x)]+b\)</span></p>
<ul>
<li>因為 <span class="math inline">\(\mathrm E[f(x)]\)</span> 為一個<strong>決定性的定值</strong>
<ul>
<li>則 <span class="math inline">\(\mathrm E[\mathrm E[f(x)]] = \mathrm E[f(x)]\)</span></li>
</ul></li>
<li>在<strong>聯合機率分佈之下定義期望值</strong>
<ul>
<li>離散型：<span class="math inline">\(\mathrm {E[f(X,Y)]} = \sum_{x,y}P_{\mathrm {X,Y}}(x,y)f(x,y)\)</span></li>
<li>連續型：<span class="math inline">\(\mathrm {E[f(X,Y)]} = \int_{x,y}F_{\mathrm {X,Y}}(x,y)f(x,y)\mathrm dx\mathrm dy\)</span></li>
</ul></li>
<li>條件期望值
<ul>
<li>離散型：<span class="math inline">\(\mathrm E[f(\mathrm X)｜\mathrm Y = y] = \sum_x P_{\mathrm{X,Y}}(x｜y)f(x)\)</span></li>
<li>連續型：<span class="math inline">\(\mathrm E[f(\mathrm X)｜\mathrm Y = y] = \int F_{\mathrm{X,Y}}(x｜y)f(x)\mathrm dx\)</span></li>
<li>若隨機變數 <span class="math inline">\(\mathrm {X,Y}\)</span> <strong>相互獨立</strong>
<ul>
<li><span class="math inline">\(\mathrm {E[f(X)g(Y)] = E[f(X)]E[g(Y)]}\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="variance變異數">Variance（變異數）</h3>
<ul>
<li>描述「一個對應於隨機變數 <span class="math inline">\(\mathrm X\)</span> 的事件函數 <span class="math inline">\(f\)</span>」其<strong>輸出之於該期望值的差異量</strong>
<ul>
<li><span class="math inline">\(\mathrm {Var[f(X)] = E[(f(X)-E[f(X)])^2] = \sigma_{f(X)}^2}\)</span>
<ul>
<li>= <span class="math inline">\((「每個 \;\mathrm {f(X)} \;的輸出」- 「\;\mathrm {f(X)} \;的平均數」)^2 的平均數\)</span></li>
<li>離散型：<span class="math inline">\(\sigma^2 = \frac 1n\sum_{i = 1}^n(x_i-\mu)^2\)</span></li>
</ul></li>
<li><span class="math inline">\(\sigma_{\mathrm f(x)}\)</span> 稱作「Standard deviation」（標準差）</li>
</ul></li>
<li>對於與 <span class="math inline">\(\mathrm x\)</span> 無關的變數 <span class="math inline">\(a, b\)</span> 時
<ul>
<li><span class="math inline">\(\mathrm {Var}[af(\mathrm X)+b] = a^2\mathrm{Var}[f(\mathrm X)]\)</span></li>
<li>因為取變異數其可視為一個<strong>二次式</strong></li>
<li>又因為取變異數是與其平均數的<strong>相對值</strong>，所以 <span class="math inline">\(b\)</span> 不影響其輸出</li>
</ul></li>
</ul>
<p><strong>證明</strong></p>
<p><span class="math inline">\(\mathrm {Var}[af(\mathrm X)+b] = \mathrm{E[(af(X)+b-E[af(X)+b])^2]} \\ = \mathrm{E[(af(X)+b-aE[f(X)]-b)^2]} = \mathrm{E[(af(X)-aE[f(X)])^2]}\\= \mathrm{a^2E[(f(X)-E[f(X)])^2]} = a^2\mathrm{Var}[f(\mathrm X)]\)</span></p>
<h3 id="covariance共變異數">Covariance（共變異數）</h3>
<blockquote>
<p>在給定兩個變量（兩個隨機變數 <span class="math inline">\(\mathrm {X, Y}\)</span>）之下</p>
<ol type="1">
<li>探討兩個變量之間是否有關聯，其關聯程度是多少，在統計學上稱為「<strong>相關</strong>」</li>
<li>藉由「共變異數」可以決定兩個變量的「線性相關程度」
<ul>
<li>正相關：當 <span class="math inline">\(\mathrm X\)</span> 值增加時 <span class="math inline">\(\mathrm Y\)</span> 值隨之增加，此時稱兩變數為<strong>線性正相關</strong></li>
<li>負相關：當 <span class="math inline">\(\mathrm X\)</span> 值增加時 <span class="math inline">\(\mathrm Y\)</span> 值隨之遞減，此時稱兩變數為<strong>線性負相關</strong></li>
<li>零相關：當 <span class="math inline">\(\mathrm X\)</span> 值增加時 <span class="math inline">\(\mathrm Y\)</span> 值不隨之增加遞減或是成<strong>非線性相關</strong>，此時稱兩變數為<strong>線性零相關</strong></li>
</ul></li>
<li>引申出「相關係數」<span class="math inline">\(r\)</span>，<span class="math inline">\(\mathrm {X, Y}\)</span> 有 <span class="math inline">\(n\)</span> 筆數據
<ul>
<li><span class="math inline">\(-1\leq\frac{\sum_{i = 1}^n(x_i-\mathrm E[f(\mathrm X)])(y_i-\mathrm E[g(\mathrm Y)])}{n\cdot\sigma_{\mathrm X}\cdot \sigma_{\mathrm Y}}\leq1\)</span></li>
</ul></li>
</ol>
</blockquote>
<ul>
<li>共變異數描述 <span class="math inline">\(f(\mathrm X)\)</span> 與 <span class="math inline">\(g(\mathrm Y)\)</span> 的變動的差異性
<ul>
<li><span class="math inline">\(\mathrm{Cov[f(X), g(Y)] = E[(f(X)-E[f(X)])(g(Y)-E[g(Y)])]}\)</span></li>
<li>此數為正時，當 <span class="math inline">\(\mathrm X\)</span> 值增加時 <span class="math inline">\(\mathrm Y\)</span> 值隨之增加</li>
<li>此數為負時，當 <span class="math inline">\(\mathrm X\)</span> 值增加時 <span class="math inline">\(\mathrm Y\)</span> 值隨之遞減，反之亦然</li>
</ul></li>
<li>若 <span class="math inline">\(\mathrm{X, Y}\)</span> 相互獨立，則 <span class="math inline">\(\mathrm{Cov(X,Y)} =0\)</span>
<ul>
<li><strong>反之不成立</strong>，當 <span class="math inline">\(\mathrm{X,Y}\)</span> 有可能相互有「非線性關係」（Nonlinear）</li>
<li>如：<span class="math inline">\(\mathrm Y = \sin(\mathrm X), \mathrm Y ～\mathrm{Uniform(-\pi, \pi)}\)</span> 如下圖</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1554273024744.png" alt="1554273024744" /><figcaption aria-hidden="true">1554273024744</figcaption>
</figure>
<ul>
<li><span class="math display">\[\mathrm{Var}(af(\mathrm X)+bg(\mathrm Y)) \equiv \mathrm{Var}(a\mathrm X+b\mathrm Y) \\ = a^2\mathrm{Var(X)}+b^2\mathrm{Var(Y)}+2ab\mathrm{Cov(X,Y)}\]</span>
<ul>
<li>如果 <span class="math inline">\(\mathrm{X,Y}\)</span> 相互獨立則 <span class="math inline">\(\mathrm{Var}(\mathrm X+\mathrm Y) = \mathrm{Var(X)}+\mathrm{Var(Y)}\)</span></li>
</ul></li>
</ul>
<p><strong>證明</strong></p>
<p><span class="math inline">\(\mathrm{Var}(a\mathrm X+b\mathrm Y) = \mathrm{E[(ax+by-E[ax+by])^2]} \\ = \mathrm{E[(ax+by- aE[x]-bE[y])^2]} = \mathrm{E[(a(x-E[x])+b(y-E[y]))^2]} \\ = \mathrm{E[a^2(x-E[x])^2+b^2(y-E[y])^2+ab(x-E[x])(y-E[y])]} \\ = \mathrm{a^2E[(x-E[x])^2]+b^2E[(y-E[y])^2]+abE[(x-E[x])(y-E[y])]} \\ = a^2\mathrm{Var(x)}+b^2\mathrm{Var(y)}+2ab\mathrm{Cov(x,y)}\)</span></p>
<ul>
<li><span class="math inline">\(\mathrm{Cov}(a\mathrm x+b, c\mathrm y+d) = ac\mathrm{Cov(x,y)}\)</span></li>
</ul>
<p><strong>證明</strong></p>
<p><span class="math inline">\(\mathrm{Cov}(a\mathrm x+b, c\mathrm y+d) = \mathrm E[(a\mathrm x+b-\mathrm E[a\mathrm x+b])(c\mathrm y+d-\mathrm E[c\mathrm y+d])] \\ = \mathrm E[(a\mathrm x+b-a\mathrm E[\mathrm x]-b)(c\mathrm y+d-c\mathrm E[\mathrm y]-d)] \\ = \mathrm E[ac(\mathrm x-\mathrm E[\mathrm x])(\mathrm y-\mathrm E[\mathrm y])] = ac\mathrm E[(\mathrm x-\mathrm E[\mathrm x])(\mathrm y-\mathrm E[\mathrm y])] = ac\mathrm{Cov(x,y)}\)</span></p>
<ul>
<li><span class="math inline">\(\mathrm{Cov}(a\mathrm x+b\mathrm y, c\mathrm w +d\mathrm v) = \\ ac\mathrm{Cov(x,w)}+ad\mathrm{Cov(x,v)}+bc\mathrm{Cov(y,w)}+bd\mathrm{Cov(y,v)}\)</span></li>
</ul>
<p><strong>證明</strong></p>
<p><span class="math inline">\(\mathrm{Cov}(a\mathrm x+b\mathrm y, c\mathrm w +d\mathrm v) \\= \mathrm E[(a\mathrm x+b\mathrm y-\mathrm E[a\mathrm x+b\mathrm y])(c\mathrm w+d\mathrm v-\mathrm E[c\mathrm w+d\mathrm v])] \\ = \mathrm E[(a\mathrm x+b\mathrm y-a\mathrm E[\mathrm x]-b\mathrm E[\mathrm y])(c\mathrm w+d\mathrm v-c\mathrm E[\mathrm w]-d\mathrm E[\mathrm v])] \\ = \mathrm E[(a(\mathrm x-\mathrm E[\mathrm x])+b(\mathrm y-\mathrm E[\mathrm y]))(c(\mathrm w-\mathrm E[\mathrm w])+d(\mathrm v-\mathrm E[\mathrm v]))] \\= \mathrm E[ac(\mathrm x-\mathrm E[\mathrm x])(\mathrm w-\mathrm E[\mathrm w])+ad(\mathrm x-\mathrm E[\mathrm x])(\mathrm v-\mathrm E[\mathrm v])\\+bc(\mathrm y-\mathrm E[\mathrm y])(\mathrm w-\mathrm E[\mathrm w])+bd(\mathrm y-\mathrm E[\mathrm y])(\mathrm v-\mathrm E[\mathrm v])] \\ = ac\mathrm{Cov(x,w)}+ad\mathrm{Cov(x,v)}+bc\mathrm{Cov(y,w)}+bd\mathrm{Cov(y,v)}\)</span></p>
<h2 id="multivariate-and-derived-variables">Multivariate and Derived variables</h2>
<h3 id="multivariate-random-variables多元隨機變數">Multivariate random variables（多元隨機變數）</h3>
<ul>
<li>多元隨機變數標記為 <span class="math inline">\(\mathrm x = \begin{bmatrix} \mathrm x_1\\ \vdots \\ \mathrm x_d \end{bmatrix}\)</span>
<ul>
<li>可視為一個向量（稱作「Random vector」隨機向量），裡面每一個分量則為一個特性（Attributes；Variables；Features），其彼此通常為相互依賴的（Dependent）否則拆開討論即可</li>
<li>多元隨機變數對應的機率分佈 <span class="math inline">\(\mathrm {P(x)}\)</span> 即為 <span class="math inline">\(\mathrm{x_1,\ldots,x_d}\)</span> 對應的<strong>聯合機率分佈</strong></li>
</ul></li>
<li><span class="math inline">\(\mathrm x\)</span> 的<strong>期望值</strong>定義為 <span class="math inline">\(\mu_{\mathrm x} = \mathrm{E(x) = \begin{bmatrix} \mathrm \mu_{x_1}\\ \vdots \\ \mathrm \mu_{x_d} \end{bmatrix}}\)</span></li>
<li><span class="math inline">\(\mathrm x\)</span> 的<strong>共變異數矩陣（Covariance matrix）</strong>
<ul>
<li><span class="math inline">\(\Sigma_x = \begin{bmatrix} \sigma^2_{\mathrm x_1} &amp; \sigma_{\mathrm {x_1,x_2}} &amp; \ldots &amp; \sigma_{\mathrm {x_1,x_d}}\\ \sigma_{\mathrm {x_2,x_1}} &amp; \sigma^2_{\mathrm x_2} &amp; \ldots &amp; \sigma_{\mathrm {x_2,x_d}} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ \sigma_{\mathrm {x_d,x_1}} &amp; \sigma_{\mathrm {x_d,x_2}} &amp; \ldots &amp;\sigma^2_{\mathrm x_d} \end{bmatrix}\)</span></li>
<li><span class="math inline">\(\sigma_{\mathrm {x_i,x_j}} = \mathrm{Cov(x_i,x_j) = E(x_i-\mu_{x_i})(x_j-\mu_{x_j})} \\ = \mathrm{E(x_ix_j)-\mu_{x_i}\mu_{x_j}}\)</span></li>
<li><span class="math inline">\(\Sigma_x = \mathrm{Cov(x) = E[(x-\mu_x)(x-\mu_x)^T] = E(xx^T)-\mu_x\mu_x^T}\)</span></li>
<li><strong>重要性質</strong>
<ul>
<li>必為<strong>對稱矩陣</strong></li>
<li>必為<strong>半正定</strong>
<ul>
<li>特徵向量必為<strong>實數</strong>且 ≧ 0</li>
</ul></li>
<li>此矩陣為<strong>非奇異</strong>若且唯若此舉陣為<strong>正定</strong></li>
<li>此矩陣為<strong>奇異</strong>代表隨機向量 <span class="math inline">\(\mathrm x\)</span> 可能
<ul>
<li>包含<strong>確定性（Deterministic）</strong>的隨機變數，此值與其他隨機變數的共變異數為 0（相互獨立）</li>
<li>包含一對以上隨機變數<strong>相互獨立</strong></li>
<li>包含一對以上隨機變數為<strong>非線性相依</strong></li>
<li>包含重複的隨機變數導致矩陣內兩列（Row）相依</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><strong>證明共變異數矩陣必為半正定</strong></p>
<ol type="1">
<li>令 <span class="math inline">\(C\)</span> 為一個共變異數矩陣
<ul>
<li>存在一個隨機向量 <span class="math inline">\(\mathrm x\)</span> 使得 <span class="math inline">\(C = E[(x-\mu_x)(x-\mu_x)^T]\)</span></li>
</ul></li>
<li><span class="math inline">\(\forall u, u^TCu = u^TE[(x-\mu_x)(x-\mu_x)^T]u \\ = E[u^T(x-\mu_x)(x-\mu_x)^Tu] \\ = E[＜(x-\mu_x), u＞^2] = ＜(x-\mu_x), u＞^2\)</span>
<ul>
<li>因為 <span class="math inline">\(＜(x-\mu_x), u＞^2\)</span> 必為<strong>實數</strong>，則對其求期望值不會改變其值</li>
</ul></li>
<li>因為 <span class="math inline">\(＜(x-\mu_x), u＞ \in \mathbf R\)</span>
<ul>
<li><span class="math inline">\(u^TCu = ＜(x-\mu_x), u＞^2 \geq 0\)</span></li>
<li>共變異數矩陣為半正定</li>
</ul></li>
</ol>
<h3 id="derived-random-variables衍隨機變數">Derived random variables（衍隨機變數）</h3>
<ul>
<li>由其他<strong>隨機向量</strong>（<span class="math inline">\(\mathrm x\)</span>）衍生定義出的<strong>隨機變數</strong>（<span class="math inline">\(\mathrm y\)</span>）
<ul>
<li>給定一個參數向量 <span class="math inline">\(w\)</span>，<span class="math inline">\(\mathrm x\)</span> 可衍生隨機變數 <span class="math inline">\(\mathrm y\)</span></li>
<li><span class="math inline">\(\mathrm y = f(\mathrm x;w) = w^Tx\)</span></li>
</ul></li>
<li>由 <span class="math inline">\(\mathrm x\)</span> 向量以描述向量 <span class="math inline">\(\mathrm y\)</span> 的性質
<ul>
<li>期望值向量：<span class="math inline">\(\mu_{\mathrm y} = \mathrm E(w^T\mathrm x) = w^T\mathrm{E(x)} = w^T\mu_x\)</span></li>
</ul></li>
<li><span class="math inline">\(\sigma^2_{\mathrm y} = w^T\Sigma_{\mathrm x}w\)</span>
<ul>
<li><span class="math inline">\(\sigma^2_{\mathrm y} = \mathrm E[(\mathrm y-\mu_{\mathrm y})^2] \\ = \mathrm E[(w^T\mathrm x-w^T\mu_{\mathrm x})^2] \\ = \mathrm E[(w^T(\mathrm x-\mu_{\mathrm x}))^2] \\ = \mathrm E[(w^T(\mathrm x-\mu_{\mathrm x}))((\mathrm x-\mu_{\mathrm x})^Tw)] \\ = w^T \mathrm E[((\mathrm x-\mu_{\mathrm x}))((\mathrm x-\mu_{\mathrm x})^T)] w = w^T\Sigma_{\mathrm x}w\)</span></li>
</ul></li>
</ul>
<h2 id="bayes-rule-and-statistics">Bayes' rule and statistics</h2>
<blockquote>
<p><span class="math inline">\(\Pr(\mathrm x = x)\)</span> <strong>的意義？</strong></p>
<ol type="1">
<li><strong>Bayesian probability（貝氏機率）</strong>
<ul>
<li>It's a degree of belief or qualitative levels of certainty</li>
<li>「相信 <span class="math inline">\(\mathrm x = x\)</span> 事件發生的程度（確定性）」</li>
</ul></li>
<li><strong>Frequentist probability（頻率）</strong>
<ul>
<li>If we can draw samples of <span class="math inline">\(\mathrm x\)</span>, them the proportion of frequency of samples having the value <span class="math inline">\(\mathrm x\)</span> is equal to <span class="math inline">\(\Pr(\mathrm x = x)\)</span></li>
<li>如果可以對隨機變數 <span class="math inline">\(\mathrm x\)</span> 進行抽樣，<span class="math inline">\(\Pr(\mathrm x = x)\)</span> 則為 <span class="math inline">\(x\)</span> 在抽樣中的出現比率</li>
</ul></li>
</ol>
<p><strong>上述兩個意義應為一致</strong></p>
</blockquote>
<h3 id="bayes-rule貝氏定理">Bayes' rule（貝氏定理）</h3>
<p><span class="math display">\[
\mathrm {P(y\vert x)} = \frac{\mathrm{P(x\vert y)P(y)}}{\mathrm{P(x)}} = \frac{\mathrm{P(x\vert y)P(y)}}{\mathrm{\sum_yP(x\vert y} = y)\mathrm{P(y}=y)}
\]</span></p>
<ul>
<li>貝氏定理在機器學習上是非常重要的概念，所以上述的每一項皆有各自的名稱
<ul>
<li><span class="math inline">\(\mathrm{posterior = \frac{likeihood \times prior}{evidence}} \\ \mathrm{後驗機率 = \frac{相似性\times 前驗機率}{事證}}\)</span></li>
</ul></li>
<li><strong>為何重要？</strong>
<ul>
<li>一個醫生在診斷病人的疾病時，內心中其實令看到的「病徵」（Symptom）為 <span class="math inline">\(\mathrm x\)</span>、令「病種」（Disease）為 <span class="math inline">\(\mathrm y\)</span>，而醫生的目標就是要經由「病徵」確診病人的「病種」（使 <span class="math inline">\(\mathrm{P(y\vert x)}\)</span> 最大化）</li>
<li>醫生藉由過往統計的 <span class="math inline">\(\mathrm{P(x \vert y), P(y)}\)</span> （在某個「病種」下其「病徵」發作的機率、該「病種」發生的機率）更輕鬆的判斷</li>
</ul></li>
</ul>
<h3 id="point-estimation點估計">Point estimation（點估計）</h3>
<ul>
<li>「點估計」：試著<strong>藉由樣本（單一的性質；單點）</strong>以估計<strong>母體未知的參數</strong>（<span class="math inline">\(\theta\)</span>；性質，有可能是平均值、標準差…等性質）
<ul>
<li>如：為了瞭解台北市民的平均月收入（假設有 260 萬人），挑選其中 1000 人計算月收入的算術平均數，假設為 60000，若使用點估計則會推論台北市民的月平均收入為 60000</li>
</ul></li>
<li>假設一個獨立同分佈（Independent and identically distributed；i.i.d.）隨機變數 <span class="math inline">\(\mathrm x\)</span> 有 <span class="math inline">\(n\)</span> 個的樣本記作 <span class="math inline">\(\left\{ x^{(1)},\ldots,x^{(n)} \right\}\)</span>
<ul>
<li>這些資料的點估計（Pointer estimator；Statistic）函數為
<ul>
<li><span class="math inline">\(\hat\theta_n = g(x^{(1)},\ldots,x^{(n)})\)</span></li>
</ul></li>
<li><span class="math inline">\(\hat \theta_n\)</span> 稱作 <span class="math inline">\(\theta\)</span> 性質的<strong>估計</strong>
<ul>
<li>在機器學習中目標就是希望能找出一個好的函數 <span class="math inline">\(g\)</span> 使得 <span class="math inline">\(\hat \theta_n\)</span> 性質與 <span class="math inline">\(\theta\)</span> 性質越相近越好</li>
</ul></li>
</ul></li>
</ul>
<h4 id="sample-mean-and-covariance">Sample mean and covariance</h4>
<ul>
<li>給定 <span class="math inline">\(X = \begin{bmatrix} x^{(1)} \\ \vdots \\ x^{(n)} \end{bmatrix} \in \mathbf R^{n\times d}\)</span> 為一個 i.i.d. 樣本（Design matrix），則 <span class="math inline">\(\mathrm x\)</span> 的「猜想平均數向量」與「猜想共變異矩陣」為何？
<ul>
<li>樣本平均數向量
<ul>
<li><span class="math inline">\(\hat\mu_x = \frac 1n\sum_{i = 1}^nx^{(i)}\)</span></li>
</ul></li>
<li>樣本共變異矩陣
<ul>
<li><span class="math inline">\(\hat\Sigma_{\mathrm x} = \frac 1n\sum_{i = 1}^n(x^{(i)}-\hat\mu_{\mathrm x})(x^{(i)}-\hat\mu_{\mathrm x})^T\)</span>
<ul>
<li>第 <span class="math inline">\((i)\)</span> 個樣本</li>
<li><span class="math inline">\((x^{(i)}-\hat\mu_{\mathrm x})(x^{(i)}-\hat\mu_{\mathrm x})^T\)</span> 為第 <span class="math inline">\((i)\)</span> 個樣本的共變異矩陣</li>
</ul></li>
<li><span class="math inline">\(\mathrm x_i, \mathrm x_j\)</span> 兩個<strong>隨機變數</strong>的「共變異數」
<ul>
<li><span class="math inline">\(\hat\sigma_{\mathrm x_i,\mathrm x_j}^2 = \frac1n\sum_{s = 1}^n(x^{(s)}_i-\hat\mu_{\mathrm x_i})(x^{(s)}_j-\hat\mu_{\mathrm x_j})\)</span>
<ul>
<li>第 <span class="math inline">\((s)\)</span> 個樣本</li>
<li><span class="math inline">\((x^{(s)}_i-\hat\mu_{\mathrm x_i})(x^{(s)}_j-\hat\mu_{\mathrm x_j})\)</span> 為第 <span class="math inline">\((s)\)</span> 個樣本對於 <span class="math inline">\(\mathrm x_i, \mathrm x_j\)</span> 兩個<strong>隨機變數</strong>的「共變異數」</li>
</ul></li>
</ul></li>
</ul></li>
<li>若將每個樣本 <span class="math inline">\(x^{(i)}\)</span> 歸位化（先將每個樣本減去 <span class="math inline">\(\hat\mu_{\mathrm x}\)</span>，成為零均值 zero-mean）
<ul>
<li>則 <span class="math inline">\(\hat\Sigma_{\mathrm x} = \frac {\sum_{i = 1}^nx^{(i)^T}x^{i}}{n} = \frac1n X^TX\)</span></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>假設只有一個歸位化的隨機變數 <span class="math inline">\(\mathrm Y\)</span>
<ul>
<li>其變異數 <span class="math inline">\(\sigma^2 = \mathrm {E(Y^2)}\)</span></li>
<li>在有 <span class="math inline">\(n\)</span> 個樣本資料 <span class="math inline">\(\mathrm {Y_1,Y_2,\ldots, Y_n}\)</span> 的情況下，其「猜想變異數」會等價於「猜想平均數」
<ul>
<li><span class="math inline">\(\hat\sigma^2_{\mathrm Y} = \hat\mu_{\mathrm Y} = \frac{\sum_{k = 1}^n Y_k^2}{n}\)</span></li>
</ul></li>
</ul></li>
<li>假設一個隨機向量 <span class="math inline">\(\mathrm X = \begin{bmatrix}\mathrm{X_1,\ldots,X_d} \end{bmatrix}\)</span>，每個元素皆為歸位化的隨機變數</li>
<li>其共變異數矩陣 <span class="math inline">\(\Sigma_{\mathrm X }\mathrm {= E(X^TX)}\)</span></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>Probability</tag>
        <tag>Information theories</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep learning - Probability and Information theories II</title>
    <url>/willywangkaa/2019/04/19/Deep-learning-Probability-and-Information-theories-II/</url>
    <content><![CDATA[<h1 id="deep-learning---probability-and-information-theories-ii">Deep learning - Probability and Information theories II</h1>
<h2 id="principal-components-analysispca主成份分析">Principal components analysis（PCA；主成份分析）</h2>
<blockquote>
<p>PCA 視覺化：<a href="http://setosa.io/ev/principal-component-analysis/?fbclid=IwAR0cSmfJGjg-IFsKNuU1h9ECUmOcE81J2naJaIjObHnHXlj-4mqWTNVaJwA">Principal Component Analysis</a></p>
</blockquote>
<ul>
<li>給定一組資料點 <span class="math inline">\(\mathbf X = \left\{x^{(i)}\right\}_{i = 1}^{N}\)</span>
<ul>
<li>每個資料點 <span class="math inline">\(x^{(i)} \in \mathbf R^D\)</span> ，意旨每個資料點都含有 <span class="math inline">\(D\)</span> 個特性（維度）</li>
</ul></li>
<li>欲對資料 <span class="math inline">\(\mathbf X\)</span> 的維度作<strong>有損壓縮（Lossily compression）</strong>
<ul>
<li>找到一個函數使得 <span class="math inline">\(f(x^{(i)}) = z^{(i)} \in \mathbf R^K, K&lt;D\)</span></li>
<li>在有損壓縮之下，如何減少原始資料 <span class="math inline">\(\mathbf X\)</span> 的<strong>特徵損失最少化</strong></li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>假設有一組資料變數包含身高與體重，欲求一個向量來投影這些資料點</li>
</ul>
<figure>
<img src="\willywangkaa\images\1554452077532.png" alt="1554452077532" /><figcaption aria-hidden="true">1554452077532</figcaption>
</figure>
<p>先將這些資料作「正規化」（Normalization）</p>
<figure>
<img src="\willywangkaa\images\1554452186787.png" alt="1554452186787" /><figcaption aria-hidden="true">1554452186787</figcaption>
</figure>
<p>先撇開中間橢圓與其兩軸，正規化的資料將原本絕對關係的資料轉換成相對關係的資料以避免資料的極端情形，但是仍無法對此資料進行更多著墨，所以欲求另外一組基底以標示這些資料點來更直覺的分析資料</p>
<ul>
<li>取得一組基底來標示這些正規化的資料
<ul>
<li>保留更多原始資料的信息或特徵，在減少某些特定的維度時，資料的特性還得以保留</li>
</ul></li>
<li>對於基底中某一向量
<ul>
<li>資料點投影在此向量上的分量可視為轉換後「變異量」的重要參考因素</li>
</ul></li>
</ul>
<p>在一組六個點的正規資料下，有兩個候選的基底向量 <span class="math inline">\(v, v&#39;\)</span> 分別如下</p>
<figure>
<img src="\willywangkaa\images\1554453026001.png" alt="1554453026001" /><figcaption aria-hidden="true">1554453026001</figcaption>
</figure>
<p>比較後可以發現以左側為基底的情形下，其投影分量的差距會比以右側為基底的狀況還大（其變異數的值亦會比較大）</p>
<figure>
<img src="\willywangkaa\images\1554453264290.png" alt="1554453264290" /><figcaption aria-hidden="true">1554453264290</figcaption>
</figure>
<ul>
<li>上述何者比較適合當作新的基底
<ul>
<li>每個點對於新基底的距離最短
<ul>
<li><span class="math inline">\(\mathrm{minimize_v} \sum_{n = 1}^6 ∥\mathrm{x_n-(v^Tx_n)v}∥^2\)</span></li>
<li>使上式最小化，則要最大化 <span class="math inline">\(\mathrm{(v^Tx_n)}\)</span>，整體來說需要最大化 <span class="math inline">\(\sum_{n = 1}^6 \mathrm{(v^Tx_n)}\)</span></li>
</ul></li>
<li>避免拉扯原始資料的間距
<ul>
<li><span class="math inline">\(\left \| \mathrm v \right \| = 1\)</span></li>
</ul></li>
</ul></li>
<li>綜合上述，可將問題轉換成
<ul>
<li><span class="math inline">\(\mathrm{maximize_v \frac 1n\sum_{n = 1}^6(v^Tx_n)^2}, \left\|v \right\|=1 \\ \equiv \mathrm{maximize_v \frac 1n\sum_{n = 1}^6(v^Tx_n)(x_n^Tv)}, \left\|v \right\|=1\\ \equiv \mathrm{maximize_v v^T \frac 1n\sum_{n = 1}^6x_nx_n^Tv}, \left\|v \right\|=1 \\ \equiv \mathrm{maximize_v v^T Cv}, \left\|v \right\|=1\)</span></li>
<li>最大化 <span class="math inline">\(\mathrm{(v^Tx_n)}\)</span> 意旨「最大化沿著基底向量 <span class="math inline">\(v\)</span> 的變異數」</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1554462474803.png" alt="1554462474803" /><figcaption aria-hidden="true">1554462474803</figcaption>
</figure>
</blockquote>
<ul>
<li>令 <span class="math inline">\(x^{(i)}\)</span> 為 i.i.d. 隨機變數 <span class="math inline">\(\mathrm x\)</span> 的樣本</li>
<li>讓有損壓縮函數 <span class="math inline">\(f\)</span> 為線性函數
<ul>
<li><span class="math inline">\(f(\mathrm {x) = W^Tx, W\in}\mathbf R^{D\times K}\)</span></li>
</ul></li>
<li>主成份分析的目的就是找到 <span class="math inline">\(K\)</span> 個正範向量（Orthonormal） <span class="math inline">\(W = [w^{(1)},\ldots,w^{(K)}]\)</span>
<ul>
<li>使轉換後的樣本 <span class="math inline">\(\mathrm z = W^T \mathrm x\)</span> 不會損失太多原本的性質（亦可視為座標軸 <span class="math inline">\(\mathbf R^D \to \mathbf R^K\)</span> 轉換）
<ul>
<li>讓轉換後的<strong>衍隨機變數</strong> <span class="math inline">\(\mathrm z_j = w^{(j)T}\mathrm x\)</span> 的變異數 <span class="math inline">\(\mathrm {Var(z_j)}\)</span> 最大化（原始資料沿著基底向量 <span class="math inline">\(w^{(j)}\)</span> 方向的隨機變數）</li>
</ul></li>
<li><span class="math inline">\(w^{(1)}, \ldots,w^{(K)}\)</span> 稱作「主成份軸」（Principle components）</li>
</ul></li>
<li>為何主成份軸 <span class="math inline">\(w^{(1)},\ldots,w^{(K)}\)</span> 需要相互正交？
<ul>
<li>避免新的衍隨機變數所保留的資訊與其他衍隨機變數所保留的資訊重疊，降低效率</li>
</ul></li>
<li>為何主成份軸 <span class="math inline">\(w^{(1)},\ldots,w^{(K)}\)</span> 長度需要為 1？
<ul>
<li>避免該向量的長度影響原始資料的間距讓新的衍隨機變數對應的變異數有變動</li>
</ul></li>
</ul>
<h3 id="solving-w">Solving W</h3>
<p><strong>Example</strong></p>
<ul>
<li>令壓縮後的維度簡化為 1（<span class="math inline">\(K = 1\)</span>）</li>
<li>如何求出新的衍隨機變數其變異數 <span class="math inline">\(\mathrm{Var(z_1)}\)</span>？
<ul>
<li>新的衍隨機變數是經由 <span class="math inline">\(\mathrm z_1 = w^{(1)T}\mathrm x\)</span> 求取
<ul>
<li>其隨機變數 <span class="math inline">\(\sigma_{\mathrm z_1}^2 = w^{(1)T}\Sigma_{\mathrm x}w^{(1)}\)</span></li>
</ul></li>
<li><span class="math inline">\(\Sigma_{\mathrm x}\)</span> 可經由已知的樣本（<strong>已正規化</strong>）去猜想</li>
<li><span class="math inline">\(\hat\Sigma_{\mathrm x} = \frac 1nX^TX\)</span></li>
</ul></li>
<li>欲解的最佳化問題
<ul>
<li><span class="math inline">\(\arg \underset{w^{(1)}\in\mathbf R^D}{\max} w^{(1)T}X^TXw^{(1)}, \mathrm{subject \; to }\left\|w^{(1)}\right\| = 1\)</span></li>
<li>在 <span class="math inline">\(\left\|w^{(1)}\right\| = 1\)</span> 的狀況下找到一個參數（<span class="math inline">\(w^{(1)}\in\mathbf R^D\)</span>）最大化函數（<span class="math inline">\(w^{(1)T}X^TXw^{(1)}\)</span>）</li>
</ul></li>
<li>Designed matrix <span class="math inline">\(X\)</span>
<ul>
<li><span class="math inline">\(X^TX\)</span> 為對稱矩陣，因此可被<strong>正交對角化</strong></li>
<li>由於「Rayleigh's quotient」，對於每個對稱矩陣
<ul>
<li><span class="math inline">\(\forall v, \lambda_{\min}\leq \frac{v^TX^TXv}{v^Tv}\leq\lambda_{\max}\)</span></li>
</ul></li>
<li>當 <span class="math inline">\(\frac{v^TX^TXv}{v^Tv}=\lambda_{\max}\)</span> 時，<span class="math inline">\(v\)</span> 為對應 <span class="math inline">\(\lambda_{\max}\)</span> 的特徵向量</li>
</ul></li>
</ul>
<p><strong>Example（Cont.）</strong></p>
<ul>
<li>令壓縮後的維度簡化為 2（<span class="math inline">\(K = 2\)</span>）</li>
<li>繼續找到最佳第二個主成份軸 <span class="math inline">\(w^{(2)}\)</span>
<ul>
<li><span class="math inline">\(\arg \underset{w^{(2)}\in\mathbf R^D}{\max} w^{(2)T}X^TXw^{(2)}, \mathrm{subject \; to }\left\|w^{(2)}\right\| = 1\)</span></li>
<li><span class="math inline">\(w^{(2)T}w^{(1)} = 0\)</span></li>
</ul></li>
<li>經由「Rayleigh's quotient」可知，次大的特徵值所對應的特徵向量就是欲求取的 <span class="math inline">\(w^{(2)}\)</span></li>
</ul>
<blockquote>
<p>由此可知，<span class="math inline">\(K&gt;1, w^{(1)}, \ldots, w^{(K)}\)</span> 為 <span class="math inline">\(X^TX\)</span> 前 <span class="math inline">\(K\)</span> 大的特徵值所對應的特徵向量（由歸納法可知）</p>
</blockquote>
<h2 id="technical-details-of-continuous-random-variables">Technical details of continuous random variables</h2>
<blockquote>
<p>連續型隨機變數與機率密度函數的深度理解需要用到「測度論」（Measure theory）的相關內容來擴展<strong>機率論</strong></p>
<ul>
<li><p>連續型隨機向量 <span class="math inline">\(\boldsymbol X\)</span> 落在一個集合 <span class="math inline">\(\mathbb S\)</span> 中的機率</p>
<ul>
<li>透過 <span class="math inline">\(f_{\boldsymbol X}(\boldsymbol x)\)</span> 對集合 <span class="math inline">\(\mathbb S\)</span> 積分得到</li>
</ul></li>
<li><p>在一些選擇之下可能引起悖論</p>
<ul>
<li>給兩集合 <span class="math inline">\(\mathbb S_1、\mathbb S_2 \ni f_{\boldsymbol X}(\boldsymbol x\in \mathbb S_1)+f_{\boldsymbol X}(\boldsymbol x\in \mathbb S_2)&gt;1\)</span></li>
<li>且 <span class="math inline">\(\mathbb S_1 \cap \mathbb S_2 = \O\)</span></li>
<li>這些集合通常是大量使用實數的無限精度來構造
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%BD%A2">碎形集合</a></li>
<li>透過有理數相關集合的變換定義集合</li>
</ul></li>
</ul></li>
<li><p>測度論提供一些集合的特徵，使計算該機率時不會遇到悖論</p></li>
<li><p>測度論提供一種嚴格的方式<strong>描述那些非常微小的點集</strong></p>
<ul>
<li>稱為「零測度」（Measure zero）</li>
<li>可以認為零測度集合在「度量空間」中不佔有任何<strong>體積</strong></li>
<li>在 <span class="math inline">\(\mathbb R^2\)</span> 空間中，一直線的測度為零，一多面體具有真正的測度</li>
<li>一個單獨的點其測度為零；「可數多個零測度集合的聯集」依然為零測度</li>
</ul></li>
<li><p><strong>幾乎處處（Almost everywhere）</strong></p>
<ul>
<li>某個性質是幾乎處處都成立
<ul>
<li><strong>其性質除了一個測度為零的集合以外皆成立</strong></li>
</ul></li>
<li>因為不成立的例外在該空間中只佔有極其微小的量</li>
<li>機率論中一些重要結果對於離散值成立但對於連續值只能是「幾乎處處」成立</li>
</ul></li>
</ul>
</blockquote>
<h3 id="sure-and-almost-sure-events">Sure and almost sure events</h3>
<blockquote>
<p><strong>機率公理（Axioms of probability）</strong></p>
<p>給定任何<strong>非空集合</strong> <span class="math inline">\(\Omega\)</span> 為<strong>樣本空間（Sample sapce）</strong>，接著我們定義一個<strong>函數</strong> <span class="math inline">\(\Pr\)</span> 在上述樣本空間 <span class="math inline">\(\Omega\)</span> 的子集合 <span class="math inline">\(\cal F\)</span> 上</p>
<p>則我們稱此函數 <span class="math inline">\(\Pr\)</span> 為一個<strong>機率測度（Probability measure）</strong>，若該函數能同時滿足下面四條公理</p>
<ol type="1">
<li>空集合 <span class="math inline">\(\O\)</span> 稱為<strong>「不可能發生事件」（Imposisible event）</strong>，此不可能發生的事件在樣本空間上的子集合中機率為 0，亦即 <span class="math inline">\(\Pr(\O) = 0\)</span></li>
<li><strong>（非負性質）</strong>機率 <span class="math inline">\(\Pr\)</span> 為非負值，亦對任意事件 <span class="math inline">\(\mathbb A\)</span> 而言，<span class="math inline">\(\Pr(\mathbb A)\geq0\)</span></li>
<li><strong>（可數加法性質）</strong>若 <span class="math inline">\(A_1, A_2,\ldots\)</span>為兩兩互斥事件（Pairwise disjoint or mutuallly exclusive），<span class="math inline">\(\forall n\neq m, A_n\cap A_m = \O\)</span>
<ul>
<li><span class="math inline">\(\Pr(\bigcup_{n = 1}^\infty A_n) = \sum_{n = 1}^\infty \Pr(A_n)\)</span></li>
<li>若事件本身互斥（如：丟一枚硬幣不可能<strong>同時</strong>出現正面與反面，稱「出現正面」與「出現反面」事件為互斥事件），則所有可能發生的事件機率為各自相加</li>
</ul></li>
<li>整個樣本空間的機率被稱作<strong>確定事件（Sure event）</strong>，此事件發生的機率為 1，<span class="math inline">\(\Pr(\Omega) = 1\)</span>
<ul>
<li>若一個事件 <span class="math inline">\(A\neq\Omega\)</span> 但滿足 <span class="math inline">\(\Pr(A) = 1\)</span>，則此事件 <span class="math inline">\(A\)</span> 為幾乎確定事件（Almost-sure event）</li>
</ul></li>
</ol>
<p>機率測度本質上為一個「函數」，考慮機率空間為 <span class="math inline">\((\Omega,\cal F, \Pr)\)</span> 其機率測度為 <span class="math inline">\(\Pr:\cal {F}\to [0,1]\)</span>，<span class="math inline">\(\cal F\)</span> 為 <span class="math inline">\(\Omega\)</span> 的子集合（<span class="math inline">\(\cal F\)</span> 稱為 <span class="math inline">\(\sigma\)</span>-algebra，其中元素稱為事件）</p>
</blockquote>
<ul>
<li>一個連續型的隨機變數 <span class="math inline">\(\mathrm x\)</span>，當 <span class="math inline">\(\mathrm x = x\)</span> 為任意值時 <span class="math inline">\(\Pr(\mathrm x = x) = 0\)</span>
<ul>
<li>那麼 <span class="math inline">\(\mathrm x = x\)</span> 事件會不會發生？</li>
<li><strong>會</strong>（機率等於 0 不代表其事件不會發生）</li>
<li><span class="math inline">\(\Pr(\mathrm x \neq x) = 1\)</span> 因為 <span class="math inline">\(\mathrm x \neq x\)</span> 事件不等於整個樣本空間 <span class="math inline">\(\Omega\)</span>，所以此事件為<strong>「幾近確定事件」（Almost-sure event）</strong></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example</strong>（<a href="http://mathcentral.uregina.ca/QQ/database/QQ.09.06/h/ben1.html">原文</a>）</p>
<p>在實驗的過程，所有可能的實驗結果 <span class="math inline">\(\omega\)</span> 組成之集合稱為「樣本空間」（Sample space）<span class="math inline">\(\Omega\)</span></p>
<ul>
<li>擲<strong>一次</strong>六面骰子
<ul>
<li>其樣本空間為｛1, 2, 3, 4, 5, 6｝</li>
</ul></li>
</ul>
<p>「事件」（Event）為樣本空間的<strong>子集合</strong></p>
<ul>
<li>擲<strong>一次</strong>六面骰子
<ul>
<li>其中一個事件「大於 4 點」的集合為｛5, 6｝</li>
<li>上述事件的機率為一分數（Fraction）
<ul>
<li>分母為樣本空間的元素個數 6</li>
<li>分子為其事件的元素個數 2</li>
<li><span class="math inline">\(機率(大於 \;4 \;點) = \frac 26 = \frac 13\)</span></li>
</ul></li>
</ul></li>
<li><strong>對於所有事件</strong>
<ul>
<li><strong>0 ≦ 事件對應的機率 ≦ 1</strong></li>
</ul></li>
</ul>
<p>如果樣本空間從上述的有限集合轉換為<strong>無限集合</strong>，考慮下述問題</p>
<ol type="1">
<li>在正整數 <span class="math inline">\(\mathbb Z\)</span> 中隨機挑一數，其大於 1 的機率？</li>
<li>在正整數 <span class="math inline">\(\mathbb Z\)</span> 中隨機挑一數，其小於等於 1 的機率？</li>
</ol>
<p>假設第二小題的答案為 <span class="math inline">\(p\)</span> ，則第一小題的答案為 <span class="math inline">\(1-p\)</span></p>
<p>然而第二小題無法求解，因為其樣本空間有無限多個元素，但是可以解下述簡化的第二小題</p>
<ul>
<li>在正整數｛1, 2, …, 100｝中隨機取一數，其小於等於 1 的機率？
<ul>
<li>機率為 <span class="math inline">\(\frac1{100} = 10^{-2}\)</span></li>
<li>因為第二小題的樣本空間遠比此樣本空間大，所以 <span class="math inline">\(p\)</span> 亦比 <span class="math inline">\(10^{-2}\)</span> 小</li>
</ul></li>
<li>在正整數｛1, 2, …, 1000｝中隨機取一數，其小於等於 1 的機率？
<ul>
<li>機率為 <span class="math inline">\(\frac1{1000} = 10^{-3}\)</span></li>
<li>因為第二小題的樣本空間遠比此樣本空間大，所以 <span class="math inline">\(p\)</span> 亦比 <span class="math inline">\(10^{-3}\)</span> 小</li>
</ul></li>
</ul>
<p>可知當樣本隨之增大，機率 <span class="math inline">\(p\)</span> 會隨之越來越小，由於 <span class="math inline">\(p\)</span> 為<strong>機率</strong>所以 <span class="math inline">\(0 \leq p\)</span>；所以 <span class="math inline">\(p\)</span> 介於 <span class="math inline">\([0,10^{-\infty}]\)</span> 中，其最好的可能取 <span class="math inline">\(p = 0\)</span> 所以第一小題的答案為 <span class="math inline">\(1\)</span></p>
<p>在正整數 <span class="math inline">\(\mathbb Z\)</span> 中隨機挑一數，<strong>其幾近確認（Almost surely）大於 1，但卻不必然確認（Absolutely certainly）大於 1</strong></p>
</blockquote>
<h3 id="equality-of-random-variables">Equality of random variables</h3>
<blockquote>
<p><strong>Definition（Equality）</strong></p>
<p>Two random variables <span class="math inline">\(\mathrm x\)</span> and <span class="math inline">\(\mathrm y\)</span> are <strong>equal</strong> iff thay maps the same events on unique sample space <span class="math inline">\(\Omega\)</span> to same values. <span class="math display">\[
\mathrm x(\omega) = \mathrm y(\omega), \forall \omega\in\Omega
\]</span> 隨機變數 <span class="math inline">\(\mathrm x\)</span> 與 <span class="math inline">\(\mathrm y\)</span> 為相等若且唯若在同一個樣本空間中 <span class="math inline">\(\Omega\)</span>，其函數將每個事件 <span class="math inline">\(\omega\)</span> 映射的值相同</p>
<p><strong>Example</strong></p>
<ul>
<li>擲一次兩個相互<strong>量子糾纏</strong>的六面骰子，一藍一紅
<ul>
<li>藍骰子無論擲出幾點紅骰子亦擲出幾點</li>
</ul></li>
<li>其擲出的結果標記為 <span class="math inline">\((藍骰子, 紅骰子)\)</span>
<ul>
<li>樣本空間為 <span class="math inline">\(｛(1,1),(2,2),\ldots,(6,6)｝\)</span></li>
</ul></li>
<li>令隨機變數 <span class="math inline">\(\mathrm x\)</span> 為藍骰子之點數，隨機變數 <span class="math inline">\(\mathrm y\)</span> 為紅骰子之點數
<ul>
<li><span class="math inline">\(\mathrm x(i,j) = i\)</span></li>
<li><span class="math inline">\(\mathrm y(i,j) = j\)</span></li>
</ul></li>
<li><span class="math inline">\(\mathrm{x,y}\)</span> 等價
<ul>
<li><span class="math inline">\(\mathrm x(\omega) = \mathrm y(\omega), \forall \omega\in\Omega\)</span></li>
</ul></li>
</ul>
</blockquote>
<blockquote>
<p><strong>Definition（Almost sure equality）</strong></p>
<p>Two random variables <span class="math inline">\(\mathrm x\)</span> and <span class="math inline">\(\mathrm y\)</span> are equal almost surely iff <span class="math inline">\(\Pr(\mathrm x = \mathrm y) = 1\)</span></p>
<p>Two random variables <em>X</em> and <em>Y</em> are <em>equal almost surely</em> (denoted <span class="math inline">\(\mathrm x\;\stackrel {a.s.}{=}\;\mathrm y\)</span>） if, and only if, the probability that they are different is zero：</p>
<p><span class="math inline">\(\Pr (X\neq Y)=0\)</span></p>
<p><a href="https://math.stackexchange.com/questions/980060/example-of-random-variables-x-and-y-where-x-neq-y-but-x-y-almost-sur">Example of random variables XX and YY where X≠YX≠Y, but X=YX=Y almost surely</a></p>
<p><a href="https://math.stackexchange.com/questions/1362292/do-two-almost-surely-equal-random-variables-necessarily-have-the-same-probabilit">Do two almost surely equal random variables necessarily have the same probability?</a></p>
<p><a href="https://math.stackexchange.com/questions/508212/almost-surely-equal-random-variables-and-expectation">Almost surely equal random variables and expectation</a></p>
</blockquote>
<blockquote>
<p><strong>Definition（Equality in distribution）</strong></p>
<p>Two random variables <span class="math inline">\(\mathrm x\)</span> and <span class="math inline">\(\mathrm y\)</span> are <strong>equal in distribution</strong> iff <span class="math inline">\(\Pr(\mathrm x\leq a) = \Pr(\mathrm y\leq a)\)</span> for all <span class="math inline">\(a\)</span>.</p>
<p>給任意常數 <span class="math inline">\(a\)</span> 使得 <span class="math inline">\(\Pr(\mathrm x\leq a) = \Pr(\mathrm y\leq a)\)</span>（擁有一樣的分佈函數 Distribution function），稱其為「Equality in distribution」，記作 <span class="math inline">\(\mathrm x\overset{d}{=}\mathrm y\)</span></p>
<p>To be equal in distribution, random variables <strong>need not be defined on the same probability space</strong>. Two random variables having equal <a href="https://en.wikipedia.org/wiki/Moment_generating_function">moment generating functions</a> have the same distribution. This provides, for example, a useful method of checking equality of certain functions of <a href="https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables">independent, identically distributed (IID) random variables</a>. However, the moment generating function exists only for distributions that have a defined <a href="https://en.wikipedia.org/wiki/Laplace_transform">Laplace transform</a>.</p>
<p><strong>Example</strong></p>
<ul>
<li>擲一次兩個六面骰子，一藍一紅</li>
<li>其擲出的結果標記為 <span class="math inline">\((藍骰子, 紅骰子)\)</span>
<ul>
<li>樣本空間為 <span class="math inline">\(｛(1,1),(1,2),\ldots,(6,6)｝\)</span></li>
</ul></li>
<li>令隨機變數 <span class="math inline">\(\mathrm x\)</span> 為藍骰子之點數，隨機變數 <span class="math inline">\(\mathrm y\)</span> 為紅骰子之點數
<ul>
<li><span class="math inline">\(\mathrm x(i,j) = i\)</span></li>
<li><span class="math inline">\(\mathrm y(i,j) = j\)</span></li>
</ul></li>
<li><span class="math inline">\(\mathrm{x,y}\)</span> 有相同的分佈（Equal in ditribution）
<ul>
<li>其「機率質量函數」（p.m.f.）皆為 <span class="math inline">\(\mathrm P(i) = \frac 16, i = 1,2,\ldots,6\)</span></li>
<li>但是 <span class="math inline">\(\mathrm x \neq \mathrm y\)</span></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>「Equality in distribution」與「Almost sure equality」的<strong>差異性</strong>為何？</li>
<li>「Equality in distribution」代表其分佈相同，但是其分佈相同時不代表其為「Almost sure equality」</li>
</ul>
<p><strong>Example</strong></p>
<ul>
<li>使 <span class="math inline">\(\mathrm x\)</span> 與 <span class="math inline">\(\mathrm y\)</span> 為二元隨機變數（Binary random variables）</li>
<li><span class="math inline">\(P_{\mathrm x}(0) = P_{\mathrm x}(1) = P_{\mathrm y}(0) = P_{\mathrm y}(1) = 0.5\)</span>
<ul>
<li><span class="math inline">\(\mathrm x\)</span> 與 <span class="math inline">\(\mathrm y\)</span> 為「Equal in distribution」</li>
<li>但是 <span class="math inline">\(\Pr(\mathrm {x = y}) = 0.5 \neq 1\)</span></li>
</ul></li>
</ul>
<h3 id="convergence-of-random-variables">Convergence of random variables</h3>
<blockquote>
<p><strong>實數序列之極限</strong></p>
<ul>
<li>給定實數序列｛<span class="math inline">\(b_1, \ldots, b_n\)</span>｝
<ul>
<li>對於任一 <span class="math inline">\(\varepsilon\)</span> 大於 0</li>
<li>存在一實數 <span class="math inline">\(b\)</span> 以及一整數 <span class="math inline">\(\mathrm N(\varepsilon)\)</span> 使得</li>
<li><span class="math inline">\(\vert b_n-b \vert&lt;\varepsilon, \forall n &gt;\mathrm N(\varepsilon)\)</span></li>
</ul></li>
<li>稱 <span class="math inline">\(b_n\)</span> 為實數序列｛<span class="math inline">\(b_n\)</span>｝的極限（Limit），記作
<ul>
<li><span class="math inline">\(\lim_{n\to\infty} b_n = b\)</span></li>
</ul></li>
</ul>
</blockquote>
<blockquote>
<p><strong>Definition（Convergence in distribution）</strong></p>
<p>A sequence of random variables <span class="math inline">\(｛\mathrm {X^{(1)}, X^{(2)},\ldots}｝\)</span> to <span class="math inline">\(\mathrm X\)</span> iff <span class="math inline">\(\lim_{n\to\infty}\mathrm P(\mathrm X^{(n)} = x) = \mathrm P(\mathrm X = x)\)</span></p>
</blockquote>
<blockquote>
<p><strong>Definition（Convergence in probability）</strong></p>
<p>A sequence of random variables <span class="math inline">\(｛\mathrm {X^{(1)}, X^{(2)},\ldots}｝\)</span> to <span class="math inline">\(\mathrm X\)</span> iff for any <span class="math inline">\(\varepsilon &gt; 0, \lim_{n\to\infty}\Pr(\vert\mathrm{X^{(n)}-X}\vert&lt;\varepsilon) = 1\)</span></p>
</blockquote>
<blockquote>
<p><strong>Definition（Almost sure convergence）</strong></p>
<p>A sequence of random variables <span class="math inline">\(｛\mathrm {X^{(1)}, X^{(2)},\ldots}｝\)</span> to <span class="math inline">\(\mathrm X\)</span> iff <span class="math inline">\(\Pr(\lim_{n\to\infty}\mathrm X^{(n)} = \mathrm X) = 1\)</span></p>
</blockquote>
<h3 id="distribution-of-derived-variables">Distribution of derived variables</h3>
<ul>
<li>如果隨機變數 <span class="math inline">\(\mathrm Y = f(\mathrm X)\)</span> 且 <span class="math inline">\(f^{-1}\)</span> 存在，則 <span class="math inline">\(\mathrm P(\mathrm Y = y) = \mathrm P(\mathrm X = f^{-1}(y))\)</span> 會永遠成立嗎？
<ul>
<li><strong>否</strong>，當隨機變數 <span class="math inline">\(\mathrm {X,Y}\)</span> 為連續時</li>
</ul></li>
<li>令連續隨機變數 <span class="math inline">\(\mathrm {X～Uniform}(0,1)\)</span> 且 <span class="math inline">\(P_{\mathrm X}(x) = c, x\in(0,1)\)</span></li>
<li>令 <span class="math inline">\(\mathrm Y = \mathrm X/2～\mathrm{Uniform}(0,1/2)\)</span></li>
<li>若 <span class="math inline">\(F_{\mathrm Y}(y) = F_{\mathrm X}(f^{-1}(y)) = F_{\mathrm X}(2y)\)</span>
<ul>
<li><span class="math inline">\(\int_{y = 0}^{\frac 12} F_{\mathrm Y}(y)\mathrm dy = \int_{y = 0}^{\frac 12}c\cdot\mathrm dy = \frac 12 \neq 1\)</span></li>
<li><strong>違反機率論的公理</strong></li>
</ul></li>
<li>若 <span class="math inline">\(\mathrm{X,Y}\)</span> 為連續隨機變數
<ul>
<li>則 <span class="math inline">\(\Pr(\mathrm Y = y) = F_{\mathrm Y}(y)\mathrm dy \\ \Pr(\mathrm X = x) = F_{\mathrm X}(x)\mathrm dx\)</span></li>
</ul></li>
<li>由於 <span class="math inline">\(f\)</span> 可能會拉扯空間軸，必須要保證
<ul>
<li><span class="math inline">\(\vert F_{\mathrm Y}(f(x))\mathrm dy \vert= \vert F_{\mathrm X}(x)\mathrm dx\vert\)</span></li>
<li>若 <span class="math inline">\(f^{-1}\)</span> 存在則 <span class="math inline">\(x = f^{-1}(y)\)</span></li>
<li>且 <span class="math inline">\(\Rightarrow F_{\mathrm Y}(f(x)) = F_{\mathrm Y}(y) = \frac{F_{\mathrm X}(x)\mathrm dx}{\mathrm dy}\)</span></li>
</ul></li>
<li>可以得到
<ul>
<li><span class="math inline">\(F_{\mathrm Y}(y) = \frac{F_{\mathrm X}(x)\mathrm dx}{\mathrm dy} = F_{\mathrm X}(f^{-1}(y))\vert \frac{\partial f^{-1}(y)}{\partial y}\vert\)</span> （或 <span class="math inline">\(F_{\mathrm X}(x) = F_{\mathrm Y}(f(x))\vert\frac{\partial f(x)}{\partial x}\vert\)</span>）</li>
<li>在之前的範例中：<span class="math inline">\(F_{\mathrm Y}(y) = 2\cdot F_{\mathrm X}(2y)\)</span></li>
</ul></li>
<li>在「多元隨機變數」中，則
<ul>
<li><span class="math inline">\(F_{\mathrm Y}(y) = F_{\mathrm X}(f^{-1}(y))\vert \det(J(f^{-1})(y))\vert\)</span></li>
<li>而 <span class="math inline">\(J(f^{-1})(y)\)</span> 為<strong>「雅可比矩陣」（Jacobian matrix）</strong>
<ul>
<li><span class="math inline">\(J(f^{-1})(y)_{i,j} = \partial f^{-1}_i(y)/\partial y_i\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="common-probability-distribution">Common probability distribution</h2>
<h3 id="random-experiments">Random experiments</h3>
<ul>
<li>隨機變數 <span class="math inline">\(\mathrm X\)</span> 的值可以視為一個隨機事件的結果
<ul>
<li>藉此定義其機率分佈（Probability distribution）函數 <span class="math inline">\(\mathrm {P(X)}\)</span></li>
</ul></li>
</ul>
<h3 id="bernoulli-distributiondiscrete">Bernoulli distribution（Discrete）</h3>
<blockquote>
<p>一次實驗兩種結果，「一個機率」在意某結果發生與否</p>
</blockquote>
<p><span class="math display">\[
\mathrm {X ～Bernoulli}(p)
\]</span></p>
<ul>
<li>機率質量函數（Probability mass function）
<ul>
<li>給定成功發生的機率 <span class="math inline">\(\mathrm P(success) = p\)</span></li>
<li>只作一次試驗，<span class="math inline">\(\mathrm X = 成功發生的次數\)</span></li>
<li><span class="math inline">\(P_{\mathrm X}(x)= \left\{\begin{matrix} p, &amp;if \;x = 1\\ 1-p, &amp; if \; x = 0 \\ 0, &amp;otherwise\end{matrix}\right. or \;p^x(1-p)^{1-x}\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1554962546955.png" alt="1554962546955" /><figcaption aria-hidden="true">1554962546955</figcaption>
</figure>
<ul>
<li>累進分佈函數（Cumulative distribution function）
<ul>
<li><span class="math inline">\(F_{\mathrm X}(x) = \left\{\begin{matrix}0,&amp; x&lt;0 \\ 1-p, &amp;0\leq x &lt; 1 \\ 1, &amp; x\geq 1 \end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1554963118110.png" alt="1554963118110" /><figcaption aria-hidden="true">1554963118110</figcaption>
</figure>
<p>Example</p>
<ul>
<li>亂停車被拖吊的機率為 0.8
<ul>
<li>定義隨機變數 <span class="math inline">\(\mathrm X(被拖吊) = 1 \\ \mathrm X(未拖吊) = 0\)</span></li>
<li>則 <span class="math inline">\(\mathrm {X ～Bernoulli}(0.8)\)</span></li>
</ul></li>
</ul>
<h3 id="binominal-distributiondiscrete">Binominal distribution（Discrete）</h3>
<blockquote>
<p>共 <span class="math inline">\(n\)</span> 次實驗，一個機率，在意 <span class="math inline">\(n\)</span> 次實驗中出現 <span class="math inline">\(k\)</span> 次某結果有之機率</p>
</blockquote>
<p><span class="math display">\[
\mathrm {X～BIN}(p)
\]</span></p>
<ul>
<li>機率質量函數（Probability mass function）
<ul>
<li>給定成功發生的機率 <span class="math inline">\(\mathrm P(success) = p\)</span></li>
<li>作 <span class="math inline">\(n\)</span> 次試驗，<span class="math inline">\(\mathrm X = 成功發生的次數\)</span></li>
<li><span class="math inline">\(P_{\mathrm X}(x) = \mathrm P(\mathrm X = x) = \left\{\begin{matrix}\binom nx p^x(1-p)^{n-x}, &amp; x = 0,1, \ldots,n \\ 0,&amp; otherwise \end{matrix}\right.\)</span>
<ul>
<li>#success = x</li>
<li>#failure = n-x</li>
</ul></li>
</ul></li>
<li>累進分佈函數（Cumulative distribution function）
<ul>
<li><span class="math inline">\(F_{\mathrm X}(x) = \sum_{m = -\infty}^{\lfloor x\rfloor}P_{\mathrm X}(m) = \sum_{m = -\infty}^{\lfloor x\rfloor} \binom nmp^m(1-p)^{n-m}\)</span></li>
</ul></li>
</ul>
<p><strong>Example</strong></p>
<ul>
<li>在三次亂停車之中，若每次被拖吊的機率為 0.8 ，則三次之中被拖吊兩次的機率為？
<ul>
<li>定義隨機變數 <span class="math inline">\(\mathrm X\)</span> 為亂停車三次中被拖吊的次數</li>
<li>則 <span class="math inline">\(\mathrm {X～BIN}(3, 0.8)\)</span></li>
</ul></li>
</ul>
<p><span class="math inline">\(P_{\mathrm X}(2) = \mathrm P(\mathrm X = 2) = \binom 32 0.8^20.2^{3-2}\)</span></p>
<h3 id="uniform-distributiondiscrete">Uniform distribution（Discrete）</h3>
<blockquote>
<p>一次實驗，<span class="math inline">\(n\)</span> 種結果，機會均等，在意某解果發生與否</p>
</blockquote>
<p><span class="math display">\[
\mathrm {X～UNIF}(a,b)
\]</span></p>
<ul>
<li>機率質量函數（Probability mass function）
<ul>
<li>給定隨機變數 <span class="math inline">\(\mathrm X\)</span> 等於 <span class="math inline">\(a, a+1,\ldots, or \; b\)</span> 的<strong>機率均等</strong></li>
<li><span class="math inline">\(P_{\mathrm X}(x) = \left\{\begin{matrix}\frac{1}{b-a+1}, &amp;x = a, a+1,\ldots,b \\ 0, &amp;otherwise \end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1554964948225.png" alt="1554964948225" /><figcaption aria-hidden="true">1554964948225</figcaption>
</figure>
<ul>
<li>累進分佈函數（Cumulative distribution function）
<ul>
<li><span class="math inline">\(F_{\mathrm X}(x) = \sum_{n = -\infty}^{\lfloor x\rfloor} P_{\mathrm X}(x) = \sum_{n = a}^{\lfloor x\rfloor} \frac{1}{b-a+1} = \frac{\lfloor x\rfloor-a+1}{b-a+1}\)</span></li>
<li><span class="math inline">\(F_{\mathrm X}(x) = \left\{\begin{matrix}0, &amp; x&lt;a \\ \frac{\lfloor x\rfloor-a+1}{b-a+1}, &amp; a\leq x &lt;b \\ 1, &amp; x\geq b \end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<p>Example</p>
<ul>
<li>擲一六面公平骰子
<ul>
<li>定義隨機變數 <span class="math inline">\(\mathrm X\)</span> 為出現的點數</li>
<li>則 <span class="math inline">\(\mathrm {X～UNIF}(1,6)\)</span>
<ul>
<li><span class="math inline">\(P_{\mathrm X} = \left\{\begin{matrix}\frac16, &amp;x = 1, 2,\ldots,6 \\ 0, &amp;otherwise\end{matrix}\right.\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="geometric-distributiondiscrete">Geometric distribution（Discrete）</h3>
<blockquote>
<p>實驗中某結果出現機率已知，重複操作實驗至某結果首次出現為止</p>
<p>在意某結果是在第幾次實驗才首次出現</p>
</blockquote>
<p><span class="math display">\[
\mathrm {X～GEO}(p)
\]</span></p>
<figure>
<img src="\willywangkaa\images\1554966200838.png" alt="1554966200838" /><figcaption aria-hidden="true">1554966200838</figcaption>
</figure>
<ul>
<li>機率質量函數（Probability distribution function）
<ul>
<li>給定成功的機率 <span class="math inline">\(\mathrm P(success) = p\)</span></li>
<li>隨機變數 <span class="math inline">\(\mathrm X\)</span> 為作了「幾次試驗」後得到第一次成功</li>
<li><span class="math inline">\(P_{\mathrm X}(x) = \mathrm P(\mathrm X = x) = \left\{\begin{matrix}(1-p)^{x-1}p, &amp;x = 1,2,\ldots \\ 0, &amp; otherwise\end{matrix}\right.\)</span>
<ul>
<li>成功必從第一次以後才有可能發生（<span class="math inline">\(x&gt;0\)</span>）</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1554966387154.png" alt="1554966387154" /><figcaption aria-hidden="true">1554966387154</figcaption>
</figure>
<ul>
<li>累進分佈函數（Cumulative distribution function）
<ul>
<li><span class="math inline">\(F_{\mathrm X}(x) = \sum_{n = -\infty}^{\lfloor x\rfloor} P_{\mathrm X}(x) = \left\{\begin{matrix}\sum_{n = 1}^{\lfloor x\rfloor}(1-p)^{n-1}p, &amp;x\geq1 \\ 0, &amp;x&lt;1\end{matrix}\right. \\ =\left\{\begin{matrix} p\frac{1-(1-p)^{\lfloor x\rfloor}}{1-(1-p)}, &amp;x\geq1 \\ 0, &amp;x&lt;1\end{matrix}\right. \\ =\left\{\begin{matrix} 1-(1-p)^{\lfloor x\rfloor}, &amp;x\geq1 \\ 0, &amp;x&lt;1\end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<p>Example</p>
<ul>
<li>一投手被上壘的機率為 0.01，第 27 位打者才第一次上壘的機率？
<ul>
<li>定義隨機變數 <span class="math inline">\(\mathrm X\)</span> 為第幾位打者首次上壘</li>
<li>則 <span class="math inline">\(\mathrm {X～GEO}(0.01)\)</span>
<ul>
<li><span class="math inline">\(P_{\mathrm X}(x) = \left\{\begin{matrix} 0.99^{x-1}0.01, &amp;x = 1,2,\ldots \\ 0, &amp; otherwise\end{matrix}\right.\)</span></li>
<li><span class="math inline">\(P_{\mathrm X}(27) = 0.99^{26}0.01\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="pascal-distributiondiscrete">Pascal distribution（Discrete）</h3>
<blockquote>
<p>實驗鍾某結果出現機率已知，重複操作實驗至某結果出現 k 次為止</p>
<p>在意是在第幾次實驗才看到某實驗結果第 k 次出現</p>
</blockquote>
<p><span class="math display">\[
\mathrm {X～PASCAC}(k, p)
\]</span></p>
<figure>
<img src="\willywangkaa\images\1554968485171.png" alt="1554968485171" /><figcaption aria-hidden="true">1554968485171</figcaption>
</figure>
<ul>
<li>機率質量函數（Probability mass function）
<ul>
<li>給定成功的機率 <span class="math inline">\(\mathrm P(success) = p\)</span></li>
<li>在意第 <span class="math inline">\(k\)</span> 次成功發生在第幾次實驗 <span class="math inline">\(\max\left\{＃success\right\} = k\)</span></li>
<li>隨機變數 <span class="math inline">\(\mathrm X\)</span> 為第幾次時間中可以看到第 k 次成功（<span class="math inline">\(\max\left\{＃success\right\}\)</span></li>
<li><span class="math inline">\(P_{\mathrm X}(x) = \mathrm P(\mathrm X = x) = \left\{\begin{matrix}\binom{x-1}{k-1}p^{k-1}(1-p)^{x-k}p, &amp; x = k, k+1,\ldots \\ 0, &amp; otherwise\end{matrix}\right.\)</span>
<ul>
<li><span class="math inline">\(k-1\)</span> successes，<span class="math inline">\(x-k\)</span> failures</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1554969621742.png" alt="1554969621742" /><figcaption aria-hidden="true">1554969621742</figcaption>
</figure>
<ul>
<li>累進分佈函數（Cumulative distribution function）
<ul>
<li><span class="math inline">\(F_{\mathrm X}(x) = \mathrm P(\mathrm X\leq x) \\ = \mathrm P(在 \;x\; 之前有發生過\; k－th \;成功)\\=\mathrm P(在 \;x\; 次實驗中有大於等於 \;k\;次成功) \\ \overset{\mathrm {Y～BIN}(x,p)}{=} \mathrm P(\mathrm Y\geq k)\)</span>
<ul>
<li>Passcal distribution 又稱作 Negative binomial</li>
</ul></li>
</ul></li>
</ul>
<p>Example</p>
<ul>
<li>一投手被上壘的機率為 0.01，被上壘 5 次便會換投，第 12 位打者時被換投的機率？
<ul>
<li>定義隨機變數 <span class="math inline">\(\mathrm X\)</span> 為第 5 次上壘發生於<strong>第幾個打者</strong></li>
<li>則 <span class="math inline">\(\mathrm {X～PASCAC}(5, 0.01)\)</span>
<ul>
<li><span class="math inline">\(P_{\mathrm X}(12) = \binom{11}{4}0.01^40.99^70.01\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="poisson-distributiondiscrete">Poisson distribution（Discrete）</h3>
<blockquote>
<p>某結果出現之平均速率（Rate：次數/時間）已知</p>
<p><strong>問持續觀察某時間長度後</strong>，看到該結果出現 k 次之機率？</p>
</blockquote>
<p><span class="math display">\[
\mathrm {X～POI}(\lambda T) \\ 令\;\mu = \lambda T, \mathrm {X～POI}(\mu)
\]</span></p>
<blockquote>
<p><strong>帕松小數定律</strong></p>
<p>在<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83">二項分佈</a>的<a href="https://zh.wikipedia.org/wiki/%E4%BC%AF%E5%8A%AA%E5%88%A9%E8%A9%A6%E9%A9%97">伯努利試驗</a>中，如果試驗次數 <span class="math inline">\(n\)</span> 很大，二項分佈的機率 <span class="math inline">\(p\)</span> 很小，且乘積 λ= <em>np</em> 比較適中，則事件出現的次數的機率可以用帕松分佈來逼近。事實上，二項分佈可以看作帕松分佈在離散時間上的對應物。</p>
<p>二項分佈定義 <span class="math display">\[
P_{\mathrm X}(x) = \mathrm P(\mathrm X = x) = \left\{\begin{matrix}\binom nx p^x(1-p)^{n-x}, &amp; x = 0,1, \ldots,n \\ 0,&amp; otherwise \end{matrix}\right.
\]</span> 如果令 <span class="math inline">\(p=\lambda /n\)</span> , <span class="math inline">\(n\)</span> 趨於無窮時 <span class="math inline">\(P\)</span> 的極限：</p>
<p><span class="math inline">\(\lim_{n\to\infty} P(X=k)=\lim_{n\to\infty}{n \choose k} p^k (1-p)^{n-k} \\ =\lim_{n\to\infty}{n! \over (n-k)!k!} \left({\lambda \over n}\right)^k \left(1-{\lambda\over n}\right)^{n-k}\\ =\lim_{n\to\infty} \underbrace{\left[\frac{n!}{n^k\left(n-k\right)!}\right]}F \left(\frac{\lambda^k}{k!}\right) \underbrace{\left(1-\frac{\lambda}{n}\right)^n}{\to\exp\left(-\lambda\right)} \underbrace{\left(1-\frac{\lambda}{n}\right)^{-k}}{\to 1} \\ = \lim_{n\to\infty} \underbrace{\left[ \left(1-\frac{1}{n}\right)\left(1-\frac{2}{n}\right) \ldots \left(1-\frac{k-1}{n}\right) \right]}{\to 1} \left(\frac{\lambda^k}{k!}\right) \underbrace{\left(1-\frac{\lambda}{n}\right)^n}{\to\exp\left(-\lambda\right)} \underbrace{\left(1-\frac{\lambda}{n}\right)^{-k}}_{\to 1} \\ = \left(\frac{\lambda^k}{k!}\right)\exp\left(-\lambda\right)\)</span></p>
</blockquote>
<ul>
<li>機率質量函數（Probability mass function）
<ul>
<li>給定<strong>平均出現的速率</strong>（Occurence rate = <span class="math inline">\(\lambda\)</span>）、觀察持續時間長度（Observation period = <span class="math inline">\(T\)</span>）</li>
<li>隨機變數 <span class="math inline">\(\mathrm X\)</span> 為在觀察時間長度 <span class="math inline">\(T\)</span> 下所看到<strong>事件發生的數量</strong></li>
<li><span class="math inline">\(P_{\mathrm X}(x) = \mathrm P(\mathrm X = x) = e^{-\lambda T}\frac{(\lambda T)^x}{x!} \overset{\mu = \lambda T}{=} e^{-\mu}\frac{(\mu)^x}{x!}\)</span></li>
</ul></li>
<li>累進分佈函數（Cumulative distribution function）
<ul>
<li><span class="math inline">\(F_{\mathrm x}(x) = \sum_{n = -\infty}^{\lfloor x\rfloor} P_{\mathrm X}(x) = \left\{\begin{matrix}\sum_{n = -\infty}^{\lfloor x\rfloor} e^{-\mu}\frac{\mu^n}{n!}, &amp; x = 0,1,2,\ldots \\ 0, &amp;otherwise \end{matrix}\right.​\)</span></li>
</ul></li>
</ul>
<p>Example</p>
<ul>
<li><em>費雯</em>在發文後，平均每分鐘會有 5 人噓之，問發文後二十分鐘被噓 100 次的機率？
<ul>
<li><span class="math inline">\(\lambda = 5 \quad\frac{噓}{分}\)</span>、<span class="math inline">\(T = 20 \quad 分\)</span></li>
<li>定義隨機變數 <span class="math inline">\(\mathrm X\)</span> 為二十分鐘內的噓的數量</li>
<li>則 <span class="math inline">\(\mathrm {X～POI}(5\times20) = \mathrm {POI}(100)\)</span>
<ul>
<li><span class="math inline">\(P_{\mathrm X}(100) = e^{-\lambda T}\frac{(\lambda T)^{100}}{100!} = e^{-100}\frac{(100)^{100}}{100!}\)</span></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>Probability</tag>
        <tag>Information theories</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep learning - Probability and Information theories III</title>
    <url>/willywangkaa/2019/04/19/Deep-learning-Probability-and-Information-theories-III/</url>
    <content><![CDATA[<h1 id="deep-learning---probability-and-information-theories-iii">Deep learning - Probability and Information theories III</h1>
<h2 id="common-probability-distribution">Common probability distribution</h2>
<blockquote>
<ul>
<li>離散的隨機變數以「Probability mass function」透漏某個數字發生的機率</li>
<li>對連續的隨機變數，欲知某數字發生的機會多大，可以使用 P.M.F.？
<ul>
<li>無法使用，因為每個數字恰發生的機率都為 0</li>
</ul></li>
<li>要在連續上討論，要以密度的方式討論，對其隨機變數 <span class="math inline">\(\mathrm X\)</span> 其機率密度為：
<ul>
<li>「Probability density function」：<span class="math inline">\(f_{\mathrm X}(x) = \lim_{\Delta x\to 0}\frac{P(x\leq\mathrm X\leq x+\Delta x)}{\Delta x} = \lim_{\Delta x\to 0}\frac{F_{\mathrm X}(x+\Delta x)-F_{\mathrm X}(x)}{\Delta x} = F&#39;_{\mathrm X}(x)\)</span></li>
</ul></li>
<li>「Probability density function」如何與機率連結？
<ul>
<li><span class="math inline">\(f_{\mathrm X}(x) = \lim_{\Delta x\to 0}\frac{P(x\leq\mathrm X\leq x+\Delta x)}{\Delta x}\)</span></li>
<li>當 <span class="math inline">\(\Delta x\)</span> 非常小時：<span class="math inline">\(P(x\leq\mathrm X\leq x+\Delta x)\approx f_{\mathrm X}(x)\Delta x\)</span></li>
</ul></li>
<li>「Probability density function」性質
<ul>
<li><span class="math inline">\(f_{\mathrm X}(x) = F&#39;_{\mathrm X}(x)\)</span>
<ul>
<li><span class="math inline">\(f_{\mathrm X}(x)\geq0\)</span></li>
</ul></li>
<li><span class="math inline">\(F_{\mathrm X}(x) = \int_{-\infty}^xf_{\mathrm X}(u)\mathrm du\)</span></li>
<li><span class="math inline">\(\int_{-\infty}^{\infty}f_{\mathrm X}(x)\mathrm dx = 1 = F_{\mathrm X}(\infty)\)</span></li>
<li><span class="math inline">\(P(x_1\leq\mathrm X\leq x_2) = \int_{x_1}^{x_2}f_{\mathrm X}(x)\mathrm dx\)</span>
<ul>
<li><span class="math inline">\(P(x_1\leq\mathrm X\leq x_2) = F_{\mathrm X}(x_2)-F_{\mathrm x}(x_1) \\ = \int_{-\infty}^{x_2}f_{\mathrm X}(x)\mathrm dx-\int_{-\infty}^{x_1}f_{\mathrm X}(x)\mathrm dx\\= \int_{x_1}^{x_2}f_{\mathrm X}(x)\mathrm dx\)</span></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1554983657822.png" alt="1554983657822" /><figcaption aria-hidden="true">1554983657822</figcaption>
</figure>
</blockquote>
<blockquote>
<p>與「Probability density function」有關的名詞</p>
<ul>
<li>pth percentile
<ul>
<li>如：30th percentile of <span class="math inline">\(\mathrm X\)</span>，表示為 <span class="math inline">\(\mathrm X_{0.3}\)</span></li>
<li><span class="math inline">\(\mathrm P(-\infty\leq\mathrm X\leq \mathrm X_{0.3}) = 0.3\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1554983848235.png" alt="1554983848235" /><figcaption aria-hidden="true">1554983848235</figcaption>
</figure>
<ul>
<li>Median（中位數）：50th percentile of <span class="math inline">\(\mathrm X\)</span>，即 <span class="math inline">\(\mathrm X_{0.5}\)</span></li>
</ul>
<figure>
<img src="\willywangkaa\images\1554984331534.png" alt="1554984331534" /><figcaption aria-hidden="true">1554984331534</figcaption>
</figure>
<ul>
<li>Mode：使 <span class="math inline">\(f_{\mathrm X}(x)\)</span> 發生最大值的 <span class="math inline">\(x\)</span> 值</li>
</ul>
<figure>
<img src="\willywangkaa\images\1554984389081.png" alt="1554984389081" /><figcaption aria-hidden="true">1554984389081</figcaption>
</figure>
</blockquote>
<h3 id="uniform-distributioncontinuous">Uniform distribution（Continuous）</h3>
<p><span class="math display">\[
\mathrm {X～UNIF}(a,b)
\]</span></p>
<figure>
<img src="\willywangkaa\images\1554984634190.png" alt="1554984634190" /><figcaption aria-hidden="true">1554984634190</figcaption>
</figure>
<ul>
<li>機率密度函數（Probability density function）
<ul>
<li><span class="math inline">\(f_{\mathrm X}(x) = \left\{\begin{matrix}\frac{1}{b-a}, &amp; a\leq x\leq b \\ 0, &amp; otherwise\end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1554984835136.png" alt="1554984835136" /><figcaption aria-hidden="true">1554984835136</figcaption>
</figure>
<ul>
<li>累進分佈函數（Cumulative distribution function）
<ul>
<li><span class="math inline">\(F_{\mathrm X}(x) = \int_{-\infty}^x f_{\mathrm X}(u)\mathrm du = \left\{\begin{matrix}0, &amp;x\leq a \\ \frac{x-a}{b-a}, &amp; a&lt;x\leq b \\ 1, &amp; x&gt;b\end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<p>Example</p>
<ul>
<li>已知公車每十分鐘一班，小美隨意出發至公車站，小美需等候公車的時間為 <span class="math inline">\(\mathrm X\)</span>
<ul>
<li><span class="math inline">\(\mathrm {X～UNIF}(0,10)\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1554984994261.png" alt="1554984994261" /><figcaption aria-hidden="true">1554984994261</figcaption>
</figure>
<h3 id="exponential-distributioncontinuous">Exponential distribution（Continuous）</h3>
<p><span class="math display">\[
\mathrm {X～Exponential}(\lambda)
\]</span></p>
<figure>
<img src="\willywangkaa\images\1554985301953.png" alt="1554985301953" /><figcaption aria-hidden="true">1554985301953</figcaption>
</figure>
<ul>
<li>機率密度函數（Probability density function）
<ul>
<li><span class="math inline">\(f_{\mathrm X}(x) = \left\{\begin{matrix}\lambda e^{-\lambda x}, &amp; x\geq 0 \\ 0, &amp; otherwise\end{matrix}\right.\)</span></li>
</ul></li>
<li>累進分佈函數（Cumulative distribution function）
<ul>
<li><span class="math inline">\(F_{\mathrm X}(x) = \int_{-\infty}^x f_{\mathrm X}(u)\mathrm du = \int_{-\infty}^x \lambda e^{-\lambda u}\mathrm du \\ = -\int_{-\infty}^x \lambda e^{-\lambda u}\mathrm d(-\lambda u)\\ = -[e^{-\lambda u}]_{-\infty}^x = 1-e^{-\lambda x}\)</span></li>
<li><span class="math inline">\(F_{\mathrm X}(x) = \left\{\begin{matrix}1-e^{-\lambda x}, &amp; x\geq0 \\ 0, &amp;x&lt;0\end{matrix}\right.\)</span></li>
</ul></li>
<li>Exponential distribution 有失憶的性質（Memoryless），常被用來 model 有這種性質的事情
<ul>
<li>如：小美出門化妝所需的時間</li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>在深度學習中經常會需要一個在 <span class="math inline">\(X = 0\)</span> 處取得邊界點（Sharp point） 的分佈
<ul>
<li>在實現中使用了<strong>指數分佈</strong></li>
<li><span class="math inline">\(f_{\mathrm X}(x) = \left\{\begin{matrix}\lambda e^{-\lambda x}, &amp; x\geq 0 \\ 0, &amp; otherwise\end{matrix}\right.\)</span> 亦可寫成 <span class="math inline">\(f_{\mathrm X}(x) = \lambda\cdot 1(x\geq 0)\cdot e^{-\lambda x}\)</span>
<ul>
<li>使用「Indicator function」來使得 <span class="math inline">\(X\)</span> 取負值時函數輸出為 0</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1555654177483.png" alt="1555654177483" /><figcaption aria-hidden="true">1555654177483</figcaption>
</figure>
<ul>
<li>關係緊密的機率分佈為 <strong>Laplace 分佈（Laplace distribution）</strong>
<ul>
<li>允許再任意一點 <span class="math inline">\(\mu\)</span> 處<strong>設置機率密度的最高點</strong></li>
<li>可想像成一個「兩面」的指數分佈
<ul>
<li><span class="math inline">\(\mathrm {X～Laplace}(\mu,\gamma) = \frac{1}{2\gamma}e^{-\frac{\vert x-\mu\vert}{\gamma}}\)</span></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1555654189924.png" alt="1555654189924" /><figcaption aria-hidden="true">1555654189924</figcaption>
</figure>
</blockquote>
<h3 id="erlang-distributioncontinuous">Erlang distribution（Continuous）</h3>
<p><span class="math display">\[
\mathrm {X～Erlang}(n,\lambda)
\]</span></p>
<figure>
<img src="\willywangkaa\images\1554986080345.png" alt="1554986080345" /><figcaption aria-hidden="true">1554986080345</figcaption>
</figure>
<ul>
<li><p>機率密度函數（Probability density function）</p>
<ul>
<li><span class="math inline">\(f_{\mathrm X}(x) = \left\{\begin{matrix} \frac{1}{(n-1)!}\lambda^nx^{n-1}e^{-\lambda x}, &amp; x\geq 0 \\ 0, &amp; otherwise \end{matrix}\right.\)</span></li>
</ul></li>
<li><p>累進分佈函數（Cumulative distribution function）</p>
<ul>
<li><span class="math inline">\(F_{\mathrm X}(x) = \left\{\begin{matrix} 1-\sum_{k=0}^{n-1}\frac{(\lambda x)^k}{k!}e^{-\lambda x}, &amp;x\geq 0 \\ 0, &amp; otherwise \end{matrix}\right.\)</span></li>
</ul></li>
<li><p><span class="math inline">\(\mathrm {Erlang}(n,\lambda)\)</span> 常被用來 model 一件有多個關卡而每個關卡所花的時間都為隨機的總時間</p>
<ul>
<li>關卡數：<span class="math inline">\(n\)</span></li>
<li>每關卡所需時間之機率分佈：<span class="math inline">\(\mathrm {Exponential}(\lambda)\)</span></li>
<li>如：打電動過三關所需時間 <span class="math inline">\(\mathrm{Erlang}(3,\lambda)\)</span></li>
</ul></li>
</ul>
<h3 id="normal-distrubutioncontinuous">Normal distrubution（Continuous）</h3>
<p><span class="math display">\[
\mathrm{X～Gaussian}(\mu, \sigma)
\]</span></p>
<ul>
<li>常態分佈，亦常被稱作 Gaussian distribution</li>
</ul>
<figure>
<img src="\willywangkaa\images\1554986768092.png" alt="1554986768092" /><figcaption aria-hidden="true">1554986768092</figcaption>
</figure>
<ul>
<li>機率密度函數（Probability density function）
<ul>
<li><span class="math inline">\(f_{\mathrm X}(x) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\)</span></li>
</ul></li>
</ul>
<blockquote>
<p><strong>定理（中央極限定理；Central limit theorem）</strong></p>
<ul>
<li>隨機變數 <span class="math inline">\(\mathrm X\)</span> 為許多相互獨立隨機變數之加總
<ul>
<li>獨立隨機變數之加總的同時，其機率密度函數作<strong>卷積（Convolution）</strong></li>
<li>近似於常態分佈</li>
<li><span class="math inline">\(\mathrm{X～Gaussian}(\mu, \sigma)\)</span></li>
</ul></li>
<li>在每個相互獨立的隨機變數之數量非常大的情況下
<ul>
<li>其各自的機率分佈不會改變此性質</li>
</ul></li>
<li><span class="math inline">\(\mu_{\mathrm X} = \mu \\ \sigma_{\mathrm X} = \sigma\)</span></li>
</ul>
</blockquote>
<blockquote>
<p>在取機率密度函數值時，需要對 <span class="math inline">\(\sigma\)</span> 取平方與倒數</p>
<p>在經常需要對不同餐數下的機率密度函數求值時</p>
<ul>
<li>定義 <span class="math inline">\(\beta = \sigma^{-2} \in (0,\infty)\)</span> 為<strong>精度（Percision）</strong>
<ul>
<li><span class="math inline">\(P_{\mathrm X}(x) = \sqrt{\frac{\beta}{2\pi}}e^{-\frac12\beta(x-\mu)^2}\)</span></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>常態分佈在自然界很常出現
<ul>
<li>如：人口身高分佈、體重分佈</li>
</ul></li>
<li>亦常被用來 model <strong>很多隨機量的總和行為</strong>
<ul>
<li>如：100 人吃飯時間的總和</li>
<li>來自<strong>「中央極限定理」</strong></li>
</ul></li>
</ul>
<h4 id="standard-normal-distribution">Standard normal distribution</h4>
<p><span class="math display">\[
\mathrm{X～Gaussian}(\underset \mu0, \underset \sigma1)
\]</span></p>
<ul>
<li>亦稱作 Unit Gaussian distribution</li>
</ul>
<figure>
<img src="\willywangkaa\images\1555324513637.png" alt="1555324513637" /><figcaption aria-hidden="true">1555324513637</figcaption>
</figure>
<ul>
<li>機率密度函數（Probability density function）
<ul>
<li><span class="math inline">\(f_{\mathrm Z}(z) = \frac{1}{\sqrt{2\pi}}e^{-\frac{z^2}{2}}\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1555324589928.png" alt="1555324589928" /><figcaption aria-hidden="true">1555324589928</figcaption>
</figure>
<ul>
<li>累進分佈函數（Cumulative distribution function）
<ul>
<li><span class="math inline">\(\Phi(z) = \int_{-\infty}^z\frac{1}{\sqrt{2\pi}}e^{-\frac{u^2}{2}}\mathrm du\)</span></li>
<li>無法取其積分函數，只能以數值方法求出建表供人查詢</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1555324891173.png" alt="1555324891173" /><figcaption aria-hidden="true">1555324891173</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1555325058757.png" alt="1555325058757" /><figcaption aria-hidden="true">1555325058757</figcaption>
</figure>
<ul>
<li><span class="math inline">\(\Phi(z)\)</span> 的性質
<ul>
<li><span class="math inline">\(\Phi(-z) = 1-\Phi(z)\)</span>（上圖一）</li>
<li>Complementary of standard normal distribution（上圖二）
<ul>
<li><span class="math inline">\(Q(z) = \mathrm P(\mathrm Z\geq z) = 1-\Phi(z)\)</span></li>
</ul></li>
</ul></li>
</ul>
<h5 id="一般-normal-random-variable-的-cdf">一般 Normal random variable 的 CDF？</h5>
<ul>
<li>對任何 <span class="math inline">\(\mathrm{X～Gaussian}(\mu, \sigma)\)</span>，<span class="math inline">\(\mathrm{\frac{X-\mu}{\sigma}～Gaussian}(0, 1)\)</span></li>
</ul>
<p><strong>證明</strong>（<span class="math inline">\(\mathrm{\frac{X-\mu}{\sigma}}\)</span> 與 <span class="math inline">\(\mathrm{Gaussian}(0, 1)\)</span> 的 CDF 一致）</p>
<ol type="1">
<li><span class="math inline">\(\mathrm P(\frac{\mathrm X-\mu}{\sigma}\leq z) = \mathrm P(\mathrm X\leq \mu+\sigma z)\)</span>
<ul>
<li><span class="math inline">\(f_{\mathrm X}(x) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\)</span></li>
</ul></li>
<li><span class="math inline">\(\int_{-\infty}^{\mu+\sigma z} \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}} \mathrm dx\)</span>
<ul>
<li>令 <span class="math inline">\(w = \frac{x-\mu}{\sigma}\)</span></li>
<li><span class="math inline">\(\mathrm P(\frac{\mathrm X-\mu}{\sigma}\leq z) = \int_{-\infty}^{z} \frac{1}{\sqrt{2\pi}}e^{-\frac{w^2}{2}} \mathrm dw = \Phi(z)\)</span></li>
</ul></li>
</ol>
<ul>
<li>對任何 <span class="math inline">\(\mathrm{X～Gaussian}(\mu, \sigma)\)</span>，<span class="math inline">\(F_{\mathrm X}(x) = \Phi(\frac{x-\mu}{\sigma})\)</span></li>
</ul>
<p><strong>證明</strong></p>
<p><span class="math inline">\(F_{\mathrm X}(x) = \mathrm P(\mathrm X\leq x) \\ = \mathrm P(\underset{～\mathrm{Gaussian(0,1)}}{\frac{X-\mu}{\sigma}}\leq \frac{x-\mu}{\sigma}) \\ = \Phi(\frac{x-\mu}{\sigma})\)</span></p>
<ul>
<li>若 <span class="math inline">\(\left\{\begin{matrix}\mathrm{X～Gaussian}(\mu^{(X)}, \sigma^{(X)}) \\ \mathrm{Y～Gaussian}(\mu^{(Y)}, \sigma^{(Y)}) \end{matrix}\right.\)</span> <strong>相互獨立</strong>
<ul>
<li>則 <span class="math inline">\(\mathrm{X+Y～Gaussian}(\underset{Mean}{\mu^{(X)}+\mu^{(Y)}}, \underset{Variance}{\sigma^{2(X)}+\sigma^{2(Y)}})\)</span></li>
<li>若 <span class="math inline">\(\mathrm X、\mathrm Y\)</span> <strong>互不獨立則此式不成立</strong></li>
</ul></li>
</ul>
<p><strong>證明</strong></p>
<p>新的隨機變數為 <span class="math inline">\(\mathrm {Z = X+Y}\)</span></p>
<p>其對應的機率密度函數 <span class="math inline">\(f_{\mathrm Z}\)</span> 為 <span class="math inline">\(f_{\mathrm X}\)</span> 與 <span class="math inline">\(f_{\mathrm Y}\)</span> 的卷積 <span class="math display">\[
f_Z(z)=\int _{-\infty }^{\infty }f_Y(z-x)f_X(x)\mathrm dx
\]</span></p>
<ol type="1">
<li><span class="math inline">\(f_{X}(x)=\frac {1}{\sqrt{2\pi}\sigma _{X}}e^{-(x-\mu _X)^2/(2\sigma _X^2)}\\f_{Y}(y)=\frac {1}{\sqrt{2\pi}\sigma _{Y}}e^{-(y-\mu _Y)^2/(2\sigma _Y^2)}\)</span></li>
<li><span class="math inline">\(f_Z(z)=\int _{-\infty }^{\infty }f_Y(z-x)f_X(x)\mathrm dx\)</span>
<ul>
<li><span class="math inline">\(f_Z(z)=\int _{-\infty}^{\infty}\frac {1}{\sqrt {2\pi}\sigma _Y}\exp \left[-\frac{(z-x-\mu _Y)^2}{2\sigma _Y^2}\right]\frac {1}{\sqrt{2\pi}\sigma _X}\exp\left[-\frac{(x-\mu_X)^2}{2\sigma_X^2}\right]\mathrm dx \\ =\int _{-\infty}^{\infty}\frac {1}{\sqrt{2\pi}\sqrt{2\pi}\sigma _X\sigma _Y} \exp\left[-\frac{\sigma _X^2(z-x-\mu _Y)^2+\sigma_Y^2(x-\mu _X)^2}{2\sigma _X^2\sigma _Y^2}\right]\mathrm dx \\ =\int _{-\infty }^{\infty }\frac {1}{\sqrt {2\pi}\sqrt {2\pi}\sigma _X\sigma _Y}\exp \left[-\frac {\sigma _X^2(z^2+x^2+\mu _Y^2-2xz-2z\mu _Y+2x\mu _Y)+\sigma _Y^2(x^2+\mu _X^2-2x\mu _X)}{2\sigma _Y^2\sigma _X^2}\right]\mathrm dx \\ =\int _{-\infty}^{\infty }\frac {1}{\sqrt {2\pi}\sqrt {2\pi}\sigma _X\sigma _Y} \exp \left[-\frac {x^2(\sigma _X^2+\sigma _Y^2)-2x(\sigma _X^2(z-\mu _Y)+\sigma _Y^2\mu _X)+\sigma _X^2(z^2+\mu _Y^2-2z\mu _Y)+\sigma _Y^2\mu _X^2}{2\sigma _Y^2\sigma _X^2}\right]\mathrm dx\)</span></li>
</ul></li>
<li>令 <span class="math inline">\(\sigma _Z = \sqrt{\sigma _X^2 + \sigma _Y^2}\)</span>
<ul>
<li><span class="math inline">\(f _Z(z) =\int _{-\infty}^{\infty}\frac {1}{\sqrt {2\pi}\sigma _Z}\frac {1}{\sqrt {2\pi}\frac {\sigma _X\sigma _Y}{\sigma _Z}} \exp\left[-{\frac {x^2-2x \frac{\sigma _X^2(z-\mu _Y)+\sigma _Y^2\mu _X}{\sigma _Z^2}+\frac {\sigma _X^2(z^2+\mu _Y^2-2z\mu _Y)+\sigma _Y^2\mu _X^2}{\sigma _Z^2}} { 2\left(\frac {\sigma _X\sigma _Y}{\sigma _Z}\right)^2} }\right]\mathrm dx \\ = \int _{-\infty }^{\infty }\frac {1}{\sqrt{2\pi}\sigma _Z}\frac {1}{\sqrt {2\pi} \frac{\sigma _X\sigma _Y}{\sigma _Z}} \exp\left[-\frac{\left(x-\frac {\sigma _X^2(z-\mu _Y)+\sigma _Y^2\mu _X}{\sigma _Z^2}\right)^2-\left(\frac {\sigma _X^2(z-\mu _Y)+\sigma _Y^2\mu _X}{\sigma _Z^2}\right)^2+\frac {\sigma _X^2(z-\mu _Y)^2+\sigma _Y^2\mu _X^2}{\sigma _Z^2}} {2\left(\frac {\sigma _X\sigma _Y}{\sigma _Z}\right)^2}\right]\mathrm dx \\ = \int _{-\infty}^{\infty}\frac {1}{\sqrt {2\pi}\sigma _Z} \exp\left[-\frac {\sigma _Z^2\left(\sigma _X^2(z-\mu _Y)^2+\sigma _Y^2\mu _X^2\right)-\left(\sigma _X^2(z-\mu _Y)+\sigma _Y^2\mu _X\right)^2}{2\sigma _Z^2\left(\sigma _X\sigma _Y\right)^2}\right]\frac {1}{\sqrt {2\pi}{\frac{\sigma _X\sigma _Y}{\sigma _Z}}} \exp\left[-\frac{\left(x-\frac {\sigma _X^2(z-\mu _Y)+\sigma _Y^2\mu _X}{\sigma _Z^2}\right)^2}{2\left(\frac {\sigma _X\sigma _Y}{\sigma _Z}\right)^2}\right]\mathrm dx \\ = \frac {1}{\sqrt{2\pi}\sigma _Z} \exp \left[-\frac{(z-(\mu _X+\mu _Y))^2 }{ 2\sigma _Z^2}\right] \underline{\int _{-\infty }^{\infty }\frac {1}{\sqrt {2\pi}\frac {\sigma _X\sigma _Y}{\sigma _Z}}\exp \left[-\frac {\left(x- \frac {\sigma _X^2(z-\mu _Y)+\sigma _Y^2\mu _X}{\sigma _Z^2}\right)^2}{2\left(\frac {\sigma _X\sigma _Y}{\sigma _Z}\right)^2}\right]\mathrm dx}\)</span></li>
</ul></li>
<li>上述底線項為對隨機變數 <span class="math inline">\(X\)</span> 的機率密度函數作積分，所以其等於 1
<ul>
<li><span class="math inline">\(f _Z(z) = \frac {1}{\sqrt{2\pi}\sigma _Z} \exp \left[-\frac{(z-(\mu _X+\mu _Y))^2 }{ 2\sigma _Z^2}\right]\)</span></li>
</ul></li>
</ol>
<p><strong>Example</strong></p>
<ul>
<li>已知 50 位同學拉贊助總金額 <span class="math inline">\(\mathrm X\)</span> 之機率分佈為 <span class="math inline">\(\mathrm {Gaussian(50000,1000)}\)</span></li>
<li>問本月業績少於 25000 之機率為？</li>
</ul>
<p><span class="math inline">\(F_{\mathrm X}(25000) = \mathrm P(\mathrm X\leq 25000) \\ = \mathrm P(\frac{X-\mu}{\sigma}\leq \frac{25000-\mu}{\sigma}) = \mathrm P(\frac{X-\mu}{\sigma}\leq \frac{25000-50000}{1000}) \\ = \Phi(-25)\)</span></p>
<h4 id="信賴區間">信賴區間</h4>
<figure>
<img src="\willywangkaa\images\1555329512233.png" alt="1555329512233" /><figcaption aria-hidden="true">1555329512233</figcaption>
</figure>
<ul>
<li>在抽樣的情況下，有 <strong>95% 信心水準</strong>其母體的<strong>期望值</strong>會落在<strong>信賴區間</strong> <span class="math inline">\([\mu-2\sigma, \mu+2\sigma]\)</span></li>
<li><a href="https://www.learnmode.net/upload/flip/book/e9/e9694f1cae726b07/926608d6e409.pdf">信賴區間與信心水準的解讀</a></li>
</ul>
<h4 id="為何高斯分佈會如此受歡迎">為何高斯分佈會如此受歡迎？</h4>
<ol type="1">
<li><p>可 model 複雜的系統</p>
<ul>
<li><p>根據中央極限定理</p></li>
<li><p>其隨機變數代表系統許多隨機變數加總而成</p></li>
<li><p><a href="https://zh.wikipedia.org/zh-tw/%E7%99%BD%E9%9B%9C%E8%A8%8A">白雜訊- 維基百科</a>（Gaussian white noise）</p>
<ul>
<li>訊號在各個頻段上的功率一致</li>
</ul></li>
</ul></li>
<li><p>在相同變異數的所有<strong>機率分佈</strong>中</p>
<ul>
<li>常態分佈具有最大的<strong>「不確定性」（Uncertainty）</strong></li>
<li>是<strong>對模型加入最少的前驗知識（Priori knowledge）之分佈</strong>
<ul>
<li>之後解說</li>
</ul></li>
</ul></li>
<li><p>計算友善</p>
<ul>
<li>連續、可微分…等</li>
</ul></li>
</ol>
<h3 id="multinoulli-distributiondiscrete">Multinoulli distribution（Discrete）</h3>
<blockquote>
<p>一次實驗 <span class="math inline">\(k\)</span> 種結果，「<span class="math inline">\(k-1\)</span> 個機率」在意 <span class="math inline">\(i–th\)</span> 結果發生與否</p>
<p><span class="math inline">\(k–th\)</span> 結果發生的機率：<span class="math inline">\(1-\sum_{i = 1}^{k-1} p_i\)</span> （這個結果換言之就是前 <span class="math inline">\(k-1\)</span> 個結果都不發生；相較於「Bernoulli distribution」就是失敗事件）</p>
</blockquote>
<p><span class="math display">\[
\mathrm {X～CAT}(p_1, p_2,\ldots,p_{k-1})
\]</span></p>
<blockquote>
<p>又稱為<strong>「範疇分佈」（Categorical distribution）</strong></p>
</blockquote>
<ul>
<li>機率質量函數（Probability mass distribution）
<ul>
<li>一個隨機變數 <span class="math inline">\(\mathrm X\)</span> 具有 <span class="math inline">\(k\)</span> 個不同狀態</li>
<li>給定每個狀態成功發生的機率 <span class="math inline">\(P(success \;of\; state_i) = p_i\)</span></li>
<li>只作一次試驗，<span class="math inline">\(\mathrm X = 成功發生的狀態編號\)</span></li>
<li><span class="math inline">\(P_{\mathrm X}(x) = \left\{\begin{matrix}p_i, &amp; x = i \\ 1-\sum_{i = 1}^{k-1} p_i, &amp; x = 0 \\ 0, &amp;otherwise\end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<blockquote>
<p>有時候每個狀態成功發生的機率可以一個向量 <span class="math inline">\(\boldsymbol p \in [0,1]^{k-1}\)</span> 參數化 <span class="math display">\[
\mathrm {X～CAT}(\boldsymbol p)
\]</span></p>
<ul>
<li>機率質量函數（Probability mass distribution）
<ul>
<li><span class="math inline">\(P_{\mathrm X}(x) = \left(\prod_{i = 1}^{k-1}p_i^{1(x = i)}\right)\cdot\left(1-\sum_{i = 1}^{k-1} p_i\right)^{1(x = 0)}\)</span></li>
<li>其中 <span class="math inline">\(1(x = i)\)</span> 為指示函數（Indecator function），當 <span class="math inline">\(x\)</span> 等於 <span class="math inline">\(i\)</span> 時等於 1，反之等於 0</li>
<li>令 <span class="math inline">\(\boldsymbol 1 = \begin{bmatrix}1 \\ 1 \\ \vdots \\ 1\end{bmatrix} \in \mathbb R^{k-1}\)</span>
<ul>
<li>則 <span class="math inline">\(1^T\boldsymbol p \leq 1\)</span></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>累進分佈函數（Cumulative distribution function）
<ul>
<li><span class="math inline">\(F_{\mathrm X}(x) = \left\{\begin{matrix} 0, &amp;x&lt;0 \\ 1-\sum_{i = 1}^{k-1} p_i , &amp; 0\leq x &lt;1\\ 1-\sum_{i = q+1}^{k-1} p_i, &amp; q\leq x&lt;q+1 \\ 1, &amp; x\geq k\end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<blockquote>
<p>另外，「Categorical distribution」也可如此表示</p>
<ul>
<li><p>一次實驗 <span class="math inline">\(k\)</span> 種結果，「<span class="math inline">\(k\)</span> <strong>個機率</strong>」在意 <span class="math inline">\(i–th\)</span> 結果發生與否</p></li>
<li><p>機率質量函數（機率向量 <span class="math inline">\(\boldsymbol p \in [0,1]^k\)</span>）</p>
<ul>
<li><span class="math inline">\(P_{\mathrm X}(x) = \prod_{i = 1}^kp^{1(x = i)}\)</span></li>
<li>隨機變數 <span class="math inline">\(\mathrm X\)</span> 為「成功發生狀態編號」</li>
<li><span class="math inline">\(1^T\boldsymbol p = 1\)</span></li>
</ul></li>
</ul>
</blockquote>
<h3 id="multinomial-distributiondiscrete">Multinomial distribution（Discrete）</h3>
<blockquote>
<p>共 <span class="math inline">\(n\)</span> 次實驗，<span class="math inline">\(k–1\)</span> 個機率，在意 <span class="math inline">\(n\)</span> 次實驗中 <span class="math inline">\(狀態_i\)</span> 有出現 <span class="math inline">\(r_i\)</span> 次之機率</p>
</blockquote>
<p><span class="math display">\[
\mathrm {X～Multi}(n,\;p_1,p_2,\ldots,p_{k-1}) \\ or \; \mathrm {X～Multi}(n,\; \boldsymbol p)
\]</span></p>
<ul>
<li>機率質量函數（Probability mass distribution）
<ul>
<li>一個隨機變數 <span class="math inline">\(\mathrm X\)</span> 具有 <span class="math inline">\(k\)</span> 個不同狀態</li>
<li>給定每個狀態成功發生的機率，並向量 <span class="math inline">\(\boldsymbol p \in [0,1]^{k-1}\)</span> 表示之</li>
<li>作 <span class="math inline">\(n\)</span> 次實驗，<span class="math inline">\(\mathrm X = \boldsymbol x \in \mathbb R^{k-1}\)</span>
<ul>
<li>向量中每個元素 <span class="math inline">\(x_i = r_i = 狀態_i\;成功發生的次數\)</span></li>
</ul></li>
<li><span class="math inline">\(P_{\mathrm X}(\boldsymbol x) = \left\{\begin{matrix} \binom{n}{r_1,\ldots,r_{k-1}}\left(\prod_{i = 1}^{k-1} p_i^{r_i}\right)\cdot\left(1-\sum_{i = 1}^{k-1} p_i\right)^{n-\sum_{j = 1}^{k-1}r_j}, &amp; \sum_{i = 1}^{k-1}r_i \leq n \\ 0, &amp;otherwise\end{matrix}\right.\)</span>
<ul>
<li><span class="math inline">\(＃｛success \;of \;state_i｝ = r_i = x_i\)</span></li>
<li><span class="math inline">\(＃｛failure \;of \;all\;state｝ = n-\sum_{j = 1}^{k-1}r_j\)</span></li>
</ul></li>
</ul></li>
<li>累進分佈函數（Cumulative distribution function）
<ul>
<li><span class="math inline">\(F_{\mathrm X}(\boldsymbol x) = \sum_{\boldsymbol m = -\infty}^{\lfloor \boldsymbol x\rfloor}P_{\mathrm X}(\boldsymbol m) \\= \sum_{\boldsymbol m = -\infty}^{\lfloor \boldsymbol x\rfloor} \binom{n}{r_1,\ldots,r_{k-1}}\left(\prod_{i = 1}^{k-1} p_i^{r_i}\right)\cdot\left(1-\sum_{i = 1}^{k-1} p_i\right)^{n-\sum_{j = 1}^{k-1}r_j}\)</span>
<ul>
<li><span class="math inline">\(\boldsymbol m = -\infty = \begin{bmatrix}r_1\\\vdots\\ r_{k-1}\end{bmatrix} =\begin{bmatrix}0\\\vdots\\ 0\end{bmatrix}\)</span></li>
<li><span class="math inline">\(\lfloor \boldsymbol x\rfloor = \begin{bmatrix}\lfloor x_1\rfloor\\\vdots\\ \lfloor x_{k-1}\rfloor\end{bmatrix}\)</span></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>另外，「Multinomial distribution」也可這樣表示</p>
<ul>
<li><p>共 <span class="math inline">\(n\)</span> 次實驗，<span class="math inline">\(k\)</span> <strong>個機率</strong>，在意 <span class="math inline">\(n\)</span> 次實驗中 <span class="math inline">\(狀態_i\)</span> 有出現 <span class="math inline">\(r_i\)</span> 次之機率</p></li>
<li><p>機率質量函數（機率向量 <span class="math inline">\(\boldsymbol p \in [0,1]^k\)</span>）</p>
<ul>
<li><span class="math inline">\(P_{\mathrm X}(\boldsymbol x)\binom{n}{r_1,\ldots,r_{k}}\left(\prod_{i = 1}^k p_i^{r_i}\right)\)</span></li>
<li>隨機變數 <span class="math inline">\(\mathrm X = \boldsymbol x \in \mathbb R^k\)</span>
<ul>
<li>向量中每個元素 <span class="math inline">\(x_i = r_i = 狀態_i\;成功發生的次數\)</span></li>
</ul></li>
<li><span class="math inline">\(\sum_{i = 1}^k r_i = n\)</span></li>
<li><span class="math inline">\(1^T\boldsymbol p = 1\)</span></li>
</ul></li>
</ul>
<p><strong>性質</strong></p>
<ul>
<li><strong>期望值（Mean）</strong>
<ul>
<li><span class="math inline">\(\mathrm E(X) = n\boldsymbol p\)</span></li>
</ul></li>
</ul>
<ol type="1">
<li>令隨機變數 <span class="math inline">\(\mathrm X = \boldsymbol x \in \mathbb R^k\)</span>
<ul>
<li>向量中每個元素 <span class="math inline">\(x_i = r_i = 狀態_i\;成功發生的次數\)</span></li>
<li>則 <span class="math inline">\(\boldsymbol m\)</span> 為一種狀態出現的可能</li>
<li><span class="math inline">\(\boldsymbol X = \begin{bmatrix} m_1 \\ \vdots \\ m_{k} \end{bmatrix} = \boldsymbol m\)</span> 出現的機率定義為</li>
<li><span class="math inline">\(P_{\mathrm X}(\boldsymbol m) = \binom n{\boldsymbol m}p^{\boldsymbol m}\)</span></li>
<li><span class="math inline">\(\binom n{\boldsymbol m} = \frac {n}{m_1!\ldots m_k!}\)</span></li>
<li><span class="math inline">\(p^{\boldsymbol m} = p_1^{m_1}\ldots p_k^{m_k}\)</span></li>
</ul></li>
<li>展開 <span class="math inline">\(k\)</span> 次多項式
<ul>
<li><span class="math inline">\(1 = 1^n = (p_1+\ldots+p_k)^n = \sum_{\boldsymbol m}\binom n{\boldsymbol m}p^{\boldsymbol m}\)</span></li>
</ul></li>
<li>先求 <span class="math inline">\(\mathrm E(X_1) = \sum_{x_1 = 0}^n x_1\mathrm P(X_1 = x_1)\)</span>
<ul>
<li>當 <span class="math inline">\(x_1 = 0\)</span> 時，<span class="math inline">\(x_1\mathrm P(X_1 = x_1)\)</span> 等於 0
<ul>
<li><span class="math inline">\(\Rightarrow \sum_{x_1 = 0}^n x_1\mathrm P(X_1 = x_1) = \sum_{x_1 = 1}^n x_1\mathrm P(X_1 = x_1)\)</span></li>
<li><span class="math inline">\(\Rightarrow \sum_{x_1 = 1}^n x_1\sum_{x_2,\ldots,x_k} \mathrm P(X_2 = x_2,\ldots,X_k = x_k)\\, \forall x_2+\ldots+x_k = n-x_1\)</span></li>
<li><span class="math inline">\(\Rightarrow \sum_{x_1 = 1}^n x_1\sum_{x_2,\ldots,x_k} \frac{n!}{x_1!\ldots x_k!}p_1^{x_1}\ldots p_k^{x_k}\)</span></li>
</ul></li>
<li>將 <span class="math inline">\(x_1\)</span> 乘進 <span class="math inline">\(\sum_{x_2,\ldots,x_k} \frac{n!}{x_1!\ldots x_k!}p_1^{x_1}\ldots p_k^{x_k}\)</span>
<ul>
<li><span class="math inline">\(\Rightarrow \sum_{x_2,\ldots,x_k} \frac{n\cdot (n-1)!}{(x_1-1)!\ldots x_k!}p_1\cdot p_1^{x_1-1}\ldots p_k^{x_k}\)</span></li>
<li>已知 <span class="math inline">\(x_1+x_2+\ldots+x_k = n\)</span> 令 <span class="math inline">\(x_1&#39; = x_1-1\)</span></li>
<li><span class="math inline">\(x_1&#39;+x_2+\ldots+x_k = n-1\)</span></li>
<li><span class="math inline">\(\Rightarrow np_1\sum_{x_1&#39; = 0}^n \sum_{x_2,\ldots,x_k} \frac{(n-1)!}{x_1&#39;!\ldots x_k!}p_1^{x_1&#39;}\ldots p_k^{x_k} \\ ,\forall x_1&#39;+\ldots+x_k = n-1\)</span></li>
<li><span class="math inline">\(\Rightarrow np_1\sum_{x_1&#39;,x_2,\ldots,x_k} \frac{(n-1)!}{x_1&#39;!\ldots x_k!}p_1^{x_1&#39;}\ldots p_k^{x_k} \\ , \forall x_1&#39;+\ldots+x_k = n-1\)</span></li>
<li><span class="math inline">\(\Rightarrow np_1\cdot1 = np_1\)</span></li>
</ul></li>
</ul></li>
<li><span class="math inline">\(\mathrm E(\boldsymbol X) = n\begin{bmatrix}p_1 \\ p_2 \\ \vdots \\ p_k \end{bmatrix} = n\boldsymbol p\)</span></li>
</ol>
<ul>
<li><strong>變異數（Variance）</strong>
<ul>
<li><span class="math inline">\(\mathrm {Var}(\boldsymbol X) = n(\mathrm{diag}(\boldsymbol p)-\boldsymbol {pp}^T)\)</span></li>
<li><span class="math inline">\(\mathrm{Var}(X_i) = np_i(1-p_i)\)</span></li>
<li><span class="math inline">\(\mathrm{Cov}(x_i,x_j) = -np_ip_j\)</span></li>
</ul></li>
</ul>
<ol type="1">
<li><p><span class="math inline">\(\mathrm{Var}(X_i) = \mathrm E((X_i-\mu_{X_i})^2) = \mathrm E(X_i^2)-\underset{n^2p_i^2}{[\mathrm E(X_i)]^2}\)</span></p>
<ul>
<li>先從 <span class="math inline">\(\mathrm{Var}(X_1) = \mathrm E(X_1^2)-\underset{n^2p_1^2}{[\mathrm E(X_1)]^2}\)</span> 討論</li>
</ul></li>
<li><p><span class="math inline">\(\mathrm E(X_1^2) = \sum_{x_1 = 0}^n x_1^2 \mathrm P(X_1 = x_1)\)</span></p>
<ul>
<li><span class="math inline">\(\Rightarrow \sum_{x_1 = 1}^n x_1^2 \mathrm P(X_1 = x_1) = \sum_{x_1 = 1}^n x_1^2\sum_{x_2,\ldots,x_k}\frac{n!}{x_1!\ldots x_k!}p_1^{x_1}\ldots p_k^{x_k}\)</span>
<ul>
<li><span class="math inline">\(x_2+\ldots+x_k = n-x_1\)</span></li>
</ul></li>
<li><span class="math inline">\(\Rightarrow \sum_{x_1 = 1}^n x_1 \sum_{x_2,\ldots,x_k}\frac{n!}{(x_1-1)!\ldots x_k!}p_1^{x_1}\ldots p_k^{x_k}\)</span></li>
<li><span class="math inline">\(\Rightarrow \sum_{x_1&#39; = 0}^{n-1} (x_1&#39;+1) \sum_{x_2,\ldots,x_k}\frac{n!}{x_1&#39;!\ldots x_k!}p_1^{x_1&#39;+1}p_2^{x_2}\ldots p_k^{x_k}\)</span>
<ul>
<li><span class="math inline">\(x_1&#39; = x_1-1 \\ x_1 = x_1&#39;+1\\x_2+\ldots+x_k = n - x_1&#39;-1\)</span></li>
</ul></li>
<li><span class="math inline">\(\Rightarrow \sum_{x_1&#39; = 0}^{n-1} (x_1&#39;) \sum_{x_2,\ldots,x_k}\frac{n!}{x_1&#39;!\ldots x_k!}p_1^{x_1&#39;+1}p_2^{x_2}\ldots p_k^{x_k} \\\quad + \sum_{x_1&#39; = 0}^{n-1} \sum_{x_2,\ldots,x_k}\frac{n!}{x_1&#39;!\ldots x_k!}p_1^{x_1&#39;+1}p_2^{x_2}\ldots p_k^{x_k}\)</span></li>
<li><span class="math inline">\(\Rightarrow np_1 \sum_{x_1&#39;,x_2,\ldots,x_k}x_1&#39;\frac{(n-1)!}{x_1&#39;!\ldots x_k!}p_1^{x_1&#39;}p_2^{x_2}\ldots p_k^{x_k} \\\quad + np_1 \sum_{x_1&#39;,x_2,\ldots,x_k}\frac{(n-1)!}{x_1&#39;!\ldots x_k!}p_1^{x_1&#39;}p_2^{x_2}\ldots p_k^{x_k}\)</span>
<ul>
<li><span class="math inline">\(x_1&#39;+x_2+\ldots+x_k = n-1\)</span></li>
<li>此式等價於 <span class="math inline">\(np_1(n-1次實驗下的期望值)+np_1(n-1次實驗下的全部機率和) \\ = np_1(n-1)p_1+np_1\cdot1\)</span></li>
</ul></li>
</ul></li>
<li><p><span class="math inline">\(\mathrm{Var}(X_1) = \mathrm E(X_1^2)- n^2p_1^2 \\= np_1(n-1)p_1+np_1 - n^2p_1^2 = np_1(1-p_1)\)</span></p></li>
<li><p><span class="math inline">\(\mathrm{Cov}(X_i, X_j) = \mathrm E(X_iX_j)-\mathrm E(X_i)\mathrm E(X_j) \\ = \mathrm E(X_iX_j)-n^2p_ip_j\)</span></p>
<ul>
<li>先從 <span class="math inline">\(\mathrm E(X_1X_2)-n^2p_1p_2\)</span> 討論</li>
</ul></li>
<li><p><span class="math inline">\(\mathrm E(X_1X_2) = \sum_{x_1,x_2}x_1x_2\mathrm P(X_1 = x_1,X_2 = x_2)\)</span></p>
<ul>
<li><span class="math inline">\(\Rightarrow \sum_{x_1,x_2}x_1x_2\frac{n!}{x_1!x_2!\ldots x_r!}p_1^{x_1}\ldots p_k^{x_k}\)</span>
<ul>
<li><span class="math inline">\(x_1+x_2+\ldots+x_k = n\)</span></li>
</ul></li>
<li><span class="math inline">\(\Rightarrow p_1p_2\sum_{x_1,x_2}\frac{n!}{(x_1-1)!(x_2-1)!\ldots x_r!}p_1^{x_1-1}p_2^{x_2-1}\ldots p_k^{x_k}\)</span></li>
<li><span class="math inline">\(\Rightarrow p_1p_2\sum_{x_1&#39;,x_2&#39;,\ldots,x_k} \frac{n!}{x_1&#39;!x_2&#39;!\ldots x_r!}p_1^{x_1&#39;}p_2^{x_2&#39;}\ldots p_k^{x_k}\)</span>
<ul>
<li><span class="math inline">\(x_1&#39; = x_1-1 \\ x_2&#39; = x_2-1\\ x_1&#39;+x_2&#39;+\ldots+x_k = n-2\)</span></li>
</ul></li>
<li><span class="math inline">\(\Rightarrow n(n-1)p_1p_2\sum_{x_1&#39;,x_2&#39;,\ldots,x_k} \frac{(n-2)!}{x_1&#39;!x_2&#39;!\ldots x_r!}p_1^{x_1&#39;}p_2^{x_2&#39;}\ldots p_k^{x_k} \\= n(n-1)p_1p_2\)</span></li>
</ul></li>
<li><p><span class="math inline">\(\mathrm{Cov}(X_i, X_j)=n(n-1)p_1p_2-n^2p_ip_j = -np_1p_2\)</span></p></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>Probability</tag>
        <tag>Information theories</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep learning - Probability and Information theories V</title>
    <url>/willywangkaa/2019/04/24/Deep-learning-Probability-and-Information-theories-V/</url>
    <content><![CDATA[<h1 id="deep-learning---probability-and-information-theories-v">Deep learning - Probability and Information theories V</h1>
<h2 id="common-probability-distribution">Common probability distribution</h2>
<h3 id="dirac-distributioncontinuous">Dirac distribution（Continuous）</h3>
<p><span class="math display">\[
\mathrm{X～Dirac}(\mu)
\]</span></p>
<ul>
<li>在一些情況下，希望機率分佈中的所有質量集中在一點 <span class="math inline">\(\mu\)</span> 上</li>
<li>透過 Dirac delta 函數 <span class="math inline">\(\delta(x)\)</span> 定義機率密度函數
<ul>
<li><span class="math inline">\(f_X(x) = \delta(x-\mu)\)</span></li>
<li>Dirac delta 函數被定義成<strong>除了在</strong> <span class="math inline">\(X=0\)</span> <strong>以外的所有點的值都為 0，但是整體積分為 1</strong></li>
</ul></li>
<li>下圖為 Dirac delta 函數以 <span class="math inline">\(X = 0\)</span> 為中心的<strong>常態分佈</strong>
<ul>
<li><span class="math inline">\(\delta _{a}(x)=\frac {1}{a\sqrt{\pi}}e^{-x^{2}/a^{2}}\)</span> 隨著 <span class="math inline">\(a\to0\)</span> 的極限（<strong>分佈意義上的</strong>）</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\Dirac_function_approximation.gif" alt="1555656295794" /><figcaption aria-hidden="true">1555656295794</figcaption>
</figure>
<blockquote>
<p>Dirac delta 函數不像普通函數依樣對 <span class="math inline">\(x\)</span> 的每個值皆有一個實數值的輸出，此為一中不同類型的數學對象，稱作<strong>廣義函數（Generalized function）</strong></p>
<ul>
<li>廣義函數依據積分性質定義的數學對象
<ul>
<li>Dirac delta 函數可以想成一系列函數的<strong>極限點</strong></li>
<li>此系列函數將除 0 以外所有點的機率密度<strong>越變越小</strong></li>
</ul></li>
</ul>
<p>透過將機率密度函數 <span class="math inline">\(f_X(x)\)</span> 定義成 delta 函數左移 <span class="math inline">\(-\mu\)</span> 個單位，得到一個在 <span class="math inline">\(X = \mu\)</span> <strong>具有無限窄也無限高的峰值機率質量</strong></p>
</blockquote>
<h4 id="empirical-distribution經驗分佈continuous">Empirical Distribution（經驗分佈；Continuous）</h4>
<blockquote>
<p>Dirac 分佈經常做為經驗分佈的一個組成部分</p>
</blockquote>
<p><span class="math display">\[
\mathrm{X～Empirical}(\mathbb X)
\]</span></p>
<ul>
<li>給定一個資料集 <span class="math inline">\(\mathbb X = \{x^{(i)}\}_{i = 1}^N\)</span>
<ul>
<li><span class="math inline">\(x^{(i)}\)</span> 相互為 <span class="math inline">\(X\)</span> 的 i.i.d. 樣本</li>
</ul></li>
<li>在訓練集上訓練模型時，可以從這個<strong>訓練集上得到的經驗分佈指明了採樣來源的分佈</strong>
<ul>
<li>經驗分佈為訓練數據相似度最大的<strong>機率密度函數</strong></li>
</ul></li>
<li>怎樣的機率分佈 <span class="math inline">\(\mathrm P(\theta)\)</span> 可以將 <span class="math inline">\(\mathrm P(\theta\vert\mathbb X)\)</span> 相似度最大化
<ul>
<li>找到此資料集的<strong>機率分佈</strong></li>
</ul></li>
<li>若 <span class="math inline">\(X\)</span> 為<strong>離散型</strong>，經驗分佈可以被「Multinoulli」分佈所組成
<ul>
<li><span class="math inline">\(f_X(x) = \frac 1N\sum_{i = 1}^N 1(x = x^{(i)})\)</span></li>
</ul></li>
<li>若 <span class="math inline">\(X\)</span> 為<strong>連續型</strong>，經驗分佈需要藉由 Dirac delta 函數定義
<ul>
<li><span class="math inline">\(f_X(x) = \frac 1N \sum_{i = 1}^N\delta(x-x^{(i)})\)</span></li>
</ul></li>
</ul>
<h3 id="mixtures-of-distribution機率分佈的混合">Mixtures of distribution（機率分佈的混合）</h3>
<blockquote>
<ul>
<li>透過組合一些簡單的機率分佈以定義新的機率分佈
<ul>
<li>機率分佈集合 <span class="math inline">\(\{\mathrm P^{(i)}(\theta^{(i)})\}\)</span></li>
<li><span class="math inline">\(\theta^{(i)}\)</span> 為第 <span class="math inline">\((i)\)</span> 個機率分佈函數的參數</li>
</ul></li>
</ul>
</blockquote>
<p><span class="math display">\[
\mathrm {X～Mixture}(\boldsymbol p, \{\theta^{(i)}\}_i)
\]</span></p>
<p><strong>一種機率分佈的混和</strong></p>
<ul>
<li>取決於從一個 <strong>Categorical 分佈</strong>中取樣的結果</li>
</ul>
<p><span class="math display">\[
P_X(x)= \sum_i \mathrm P^{(i)}_X(x)\mathrm P_C(i)
\]</span></p>
<ul>
<li><span class="math inline">\(\mathrm P_C(\cdot)\)</span> 為對各「子分佈」的 Categorical 機率質量函數
<ul>
<li>其每個子分佈機率由 <span class="math inline">\(\mathrm {X～Mixture}(\boldsymbol p, \{\theta^{(i)}\}_i)\)</span> 的 <span class="math inline">\(p^{(i)}\)</span> 決定</li>
<li><span class="math inline">\(C～\mathrm{Categorical}(\boldsymbol p)\)</span></li>
</ul></li>
<li><span class="math inline">\(\mathrm P^{(i)}_X(\cdot)\)</span> 為第 <span class="math inline">\((i)\)</span> 個「子機率分佈函數」
<ul>
<li>其參數為 <span class="math inline">\(\theta^{(i)}\)</span></li>
</ul></li>
</ul>
<blockquote>
<p>實數隨機變數的「經驗分佈」（Empirical distribution）對於每個<strong>訓練樣本</strong>，是以 <em>Dirac 分佈</em>為子分佈的<strong>混合分佈</strong></p>
<ul>
<li>經驗分佈：<span class="math inline">\(f_X(x) = \frac 1N \sum_{i = 1}^N\delta(x-x^{(i)})\)</span>
<ul>
<li><span class="math inline">\(\Rightarrow \sum_{i = 1}^N \delta(x-x^{(i)})\frac 1N =\sum_{i = 1}^N \delta(x-x^{(i)}) P_C(i)\)</span></li>
<li><span class="math inline">\(C～\mathrm{Categorical}(\boldsymbol p)\)</span>，<span class="math inline">\(\forall i, p_i = \frac 1N\)</span></li>
</ul></li>
<li>子分佈的編號隨機變數 <span class="math inline">\(C\)</span> 為一個<strong>「潛變量」（Latent variable）</strong>
<ul>
<li>是一個不能直接觀測到的隨機變數</li>
<li>在聯合分佈（Joint distribution）下可能與 <span class="math inline">\(X\)</span> 有關
<ul>
<li>則 <span class="math inline">\(P_{X,C}(x,c)= \mathrm P_{X,C}(x\vert c)\mathrm P_C(c)\)</span></li>
<li><span class="math inline">\(\mathrm P_C(\cdot)\)</span> 為潛變量的分佈</li>
<li><span class="math inline">\(\mathrm P_{X,C}(x\vert c)\)</span> 為關聯潛變量與觀測變量的條件分佈</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h4 id="gaussian-mixture-model高斯混合模型">Gaussian mixture model（高斯混合模型）</h4>
<ul>
<li>其每個子分佈皆為高斯分佈
<ul>
<li><span class="math inline">\(\mathrm {X～Mixture}(\boldsymbol p, \{\mu^{(i)}, \Sigma^{(i)}\}_i)\)</span></li>
<li><span class="math inline">\(P^{(i)}_X(x)\)</span>：<span class="math inline">\(X～\mathrm{Gaussian}^{(i)}(\mu^{(i)}, \Sigma^{(i)})\)</span></li>
</ul></li>
<li>混合模型可擁有更多限制
<ul>
<li>共變數矩陣在各個子分佈間共享 <span class="math inline">\(\Sigma^{(i)} = \Sigma,\forall i\)</span></li>
<li>限制共變數矩陣為對角陣 <span class="math inline">\(\Sigma^{(i)} = \mathrm{diag}(\boldsymbol \sigma)\)</span></li>
<li>限制每個高斯分佈皆有「等向性」（Isotropic） <span class="math inline">\(\Sigma^{(i)} = \boldsymbol \sigma I\)</span></li>
</ul></li>
<li>任何平滑的<strong>機率密度函數</strong>皆可以被高斯混合模型逼近</li>
</ul>
<figure>
<img src="\willywangkaa\images\1555918141695.png" alt="1555918141695" /><figcaption aria-hidden="true">1555918141695</figcaption>
</figure>
<h2 id="common-parameterizing-function">Common parameterizing function</h2>
<blockquote>
<ul>
<li>一個機率的分佈函數 <span class="math inline">\(\mathrm P_X\)</span>
<ul>
<li><span class="math inline">\(X～\mathrm{Distribution}(\theta)\)</span></li>
<li>其參數由 <span class="math inline">\(\theta\)</span> 決定</li>
</ul></li>
<li>在機器學習的領域中，<span class="math inline">\(\theta\)</span> 的控制會由一個給定函數來決定
<ul>
<li>稱為「Parameterizing function」</li>
</ul></li>
</ul>
</blockquote>
<h3 id="logistic-function">Logistic function</h3>
<ul>
<li>「Logistic sigmoid function」為其中一個特別的函數
<ul>
<li><span class="math inline">\(\sigma(x) = \frac{\exp(x)}{\exp(x)+1} = \frac{1}{1+\exp(-x)} = \frac{1}{1+e^{-x}}\)</span></li>
</ul></li>
<li>值域
<ul>
<li><span class="math inline">\((0,1)\)</span>，實數域</li>
</ul></li>
<li>常用來決定 Bernoulli 分佈中的參數 <span class="math inline">\(p\)</span>
<ul>
<li><span class="math inline">\(p\in(0,1)\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1555919224741.png" alt="1555919224741" /><figcaption aria-hidden="true">1555919224741</figcaption>
</figure>
<h3 id="softplus-function">Softplus function</h3>
<p><span class="math display">\[
\zeta(x) = \log(1+\exp(x)) = \log(1+e^x)
\]</span></p>
<ul>
<li>Softplus 函數為 <span class="math inline">\(x^+\)</span> 函數（正部函數）的平滑版本
<ul>
<li><span class="math inline">\(x^+ = \max(0,x)\)</span></li>
</ul></li>
<li>值域
<ul>
<li><span class="math inline">\((0,\infty)\)</span></li>
</ul></li>
<li>可用來產生常態分佈的
<ul>
<li><span class="math inline">\(\beta\)</span> 精度（變異數倒數）</li>
<li><span class="math inline">\(\sigma\)</span> 標準差</li>
</ul></li>
</ul>
<h3 id="properties">Properties</h3>
<ul>
<li><span class="math inline">\(1-\sigma(x) = \sigma(-x)\)</span></li>
</ul>
<p><span class="math display">\[
1-\frac{1}{1+e^{-x}} = \frac{e^{-x}}{1+e^{-x}} = \frac{1}{1+e^{-(-x)}} = \sigma(-x)
\]</span></p>
<ul>
<li><span class="math inline">\(\log \sigma(x) = -\zeta(-x)\)</span></li>
</ul>
<p><span class="math display">\[
\log(\frac{1}{1+e^{-x}}) = -\log(1+e^{-x}) = -\zeta(-x)
\]</span></p>
<ul>
<li><span class="math inline">\(\frac{\mathrm d}{\mathrm dx}\sigma(x) = \sigma(x)(1-\sigma(x))\)</span></li>
</ul>
<p><span class="math display">\[
\frac{\mathrm d}{\mathrm dx}\frac{1}{1+e^{-x}} = \frac{\mathrm d}{\mathrm dx}(1+e^{-x})^{-1} = -(1+e^{-x})^{-2}\cdot-(e^{-x}) \\ = \frac{1}{1+2e^{-x}+(e^{-x})^2}\cdot e^{-x} = \frac{1}{e^x+2+e^{-x}} = \frac{1}{1+e^{-x}}\frac{1}{1+e^x}\\= \sigma(x)\sigma(-x) = \sigma(x)(1-\sigma(x))
\]</span></p>
<ul>
<li><span class="math inline">\(\frac{\mathrm d}{\mathrm dx} \zeta(x) = \sigma(x)\)</span></li>
</ul>
<p><span class="math display">\[
\frac{\mathrm d}{\mathrm dx} \log(1+e^x) = \frac{e^x}{1+e^x} = \frac{1}{1+e^{-x}} = \sigma(x)
\]</span></p>
<ul>
<li><span class="math inline">\(\forall x\in(0,1), \sigma^{-1}(x) = \log(\frac{x}{1-x})\)</span>
<ul>
<li>稱作<strong>分對數（Legit）</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
x = \frac{1}{1+e^{-y}} \\ {\Rightarrow} x+xe^{-y} = 1 \\ \Rightarrow e^{-y} = \frac{1-x}{x} \\ \Rightarrow e^y = \frac{x}{1-x} \\ \Rightarrow y = \sigma^{-1}(x) = \ln(\frac{x}{1-x})
\]</span></p>
<ul>
<li><span class="math inline">\(\forall x&gt;0, \zeta^{-1}(x) = \log(e^x-1)\)</span></li>
</ul>
<p><span class="math display">\[
x = \ln(1+e^y) \\ \Rightarrow e^x = 1+e^y \\ \Rightarrow e^y = e^x-1 \\ \Rightarrow y = \zeta^{-1}(x) = \ln(e^x-1)
\]</span></p>
<ul>
<li><span class="math inline">\(\zeta(x) = \int_{-\infty}^x \sigma(y)\mathrm dy\)</span>
<ul>
<li><span class="math inline">\(\mathrm de^y = e^{y}\mathrm dy\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\int_{-\infty}^x \frac{e^y}{1+e^{y}} \mathrm dy = \int_{-\infty}^x \frac{1}{1+e^y}(e^y\mathrm dy) = \int_{-\infty}^x \frac{1}{1+e^y} \mathrm de^y \\ = \log(1+e^y)\vert_{-\infty}^x = \log(1+e^x)-\log(1+e^{-\infty})\\ = \log(1+e^x)-\log(1) = \log(1+e^x)
\]</span></p>
<ul>
<li><span class="math inline">\(\zeta(x)-\zeta(-x) = x\)</span>
<ul>
<li>正部函數 <span class="math inline">\(x^+ = \max\{0,x\}\)</span>
<ul>
<li>其平滑函數為「softplus 函數」<span class="math inline">\(\zeta(x)\)</span></li>
</ul></li>
<li>負部函數 <span class="math inline">\(x^- = \max\{0,-x\}\)</span>
<ul>
<li>其平滑函數為 <span class="math inline">\(\zeta(-x)\)</span></li>
</ul></li>
<li><span class="math inline">\(x = x^+-x^-\)</span>
<ul>
<li><span class="math inline">\(x = \zeta(x)-\zeta(-x)\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="information-theory資訊論">Information theory（資訊論）</h2>
<blockquote>
<p><strong>基本概念</strong></p>
<ul>
<li><strong>一個不太可能發生的事件</strong>比<strong>一個非常可能發生的事件</strong>所攜帶的資訊還多
<ul>
<li>「早上太陽升起」的資訊量少到沒有必要發送</li>
<li>「早上發生日蝕」的資訊量非常豐富</li>
</ul></li>
<li>欲透過此基本想法來<strong>量化（Quantify）</strong>資訊
<ul>
<li>機率論可以確立一個事件發生的不確定性的百分比</li>
<li>資訊論可以<strong>量化該不確定性</strong></li>
</ul></li>
</ul>
<ol type="1">
<li><p><strong>非常可能發生的事件資訊量要比較少</strong></p>
<ul>
<li>在極端狀況下，確保能夠發生的事件應該沒有資訊量</li>
</ul></li>
<li><p><strong>較不可能發生的事件具有更高的資訊量</strong></p></li>
<li><p><strong>獨立事件應具有增量的資訊</strong></p>
<ul>
<li>投擲硬幣兩次皆為正面攜帶的資訊量，應為擲幣一次為正面所攜帶的訊量還高</li>
</ul></li>
</ol>
</blockquote>
<h3 id="self-information自資訊">Self-information（自資訊）</h3>
<p>定義一個事件 <span class="math inline">\(X = x\)</span> 的<strong>自資訊</strong> <span class="math display">\[
I_X(x) = -\log P_X(x)
\]</span></p>
<blockquote>
<p>通常 <span class="math inline">\(\log\)</span> 沒有指定時，在此會是底數為 <span class="math inline">\(e\)</span> 的自然對數</p>
</blockquote>
<ul>
<li>定義 <span class="math inline">\(I_X(x)\)</span> 的單位為<strong>「奈特」（nat）</strong>
<ul>
<li>一奈特為「以 <span class="math inline">\(\frac 1e\)</span> 的機率觀測到一個事件獲得的資訊量」</li>
<li><span class="math inline">\(-\log P_X(x) = \log_{\frac 1e}P_X(x)\)</span></li>
<li><span class="math inline">\(\frac 1e^{奈特} = 事件\;x\;的機率\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1556025616392.png" alt="1556025616392" /><figcaption aria-hidden="true">1556025616392</figcaption>
</figure>
<ul>
<li>當對數底數為 2 時，單位稱作<strong>「比特」（bit）</strong>
<ul>
<li>或稱作<strong>夏農（Shannons）</strong></li>
<li><span class="math inline">\(\frac12^{比特} = 事件\;x\;的機率\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1556025648289.png" alt="1556025648289" /><figcaption aria-hidden="true">1556025648289</figcaption>
</figure>
<blockquote>
<p><strong>連續型隨機變數</strong></p>
<ul>
<li>可能喪失原為離散型隨機變數的性質</li>
<li>一個具有大機率的事件其<strong>資訊量為 0</strong>
<ul>
<li>但不保證其一定發生，或一定不發生</li>
</ul></li>
</ul>
</blockquote>
<h3 id="entropy熵-ㄕ_ㄤ">Entropy（熵 <span class="math inline">\(^ㄕ_ㄤ\)</span>）</h3>
<p>對<strong>整個機率分佈其不確定性</strong>的量化稱為「熵」（Entropy） <span class="math display">\[
\mathrm H(X～\mathrm{Distribution})\\ = \mathrm E_{X～\mathrm{Distribution}}[I_X(x)] = -\mathrm E_{X～\mathrm {Distribution}}[\log P_X(x)]
\]</span></p>
<ul>
<li>亦記作 <span class="math inline">\(\mathrm {H(Distribution)}\)</span></li>
<li>當 <span class="math inline">\(X\)</span> 為離散型隨機變數
<ul>
<li><span class="math inline">\(\mathrm {H(Distribution)} = -\sum_x P_X\log P_X(x)\)</span></li>
<li>稱作<strong>「夏農熵」（Shannon entropy）</strong></li>
</ul></li>
<li>當 <span class="math inline">\(X\)</span> 為連續型隨機變數
<ul>
<li><span class="math inline">\(\mathrm {H(Distribution)} = -\int f_X\log f_X(x)\mathrm dx\)</span></li>
<li>稱作<strong>「微分熵」（Differential entropy）</strong></li>
</ul></li>
<li><strong>接近確定性的機率分佈（輸出幾乎肯定）具有較低的熵</strong>
<ul>
<li>反之，接近均勻的機率分佈具有較高的熵</li>
</ul></li>
<li>（下圖）Bernoulli distribution 的夏農熵
<ul>
<li>水平軸為 <span class="math inline">\(\mathrm{X～Bernoulli}(p)\)</span> 中的 <span class="math inline">\(p\)</span>
<ul>
<li><span class="math inline">\(\mathrm {H(Bernoulli)} = -(1-p)\log(1-p)-p\log p\)</span></li>
</ul></li>
<li>更接近確定性的分佈有較低的夏農熵
<ul>
<li>當 <span class="math inline">\(p\)</span> 接近 <span class="math inline">\(0\)</span>（或接近 <span class="math inline">\(1\)</span>）時，分佈幾乎確定，因為隨機便量總是為 <span class="math inline">\(0\)</span>（為 <span class="math inline">\(1\)</span>）</li>
</ul></li>
<li>接近均勻的分佈有高的夏農滴
<ul>
<li>當 <span class="math inline">\(p = 0.5\)</span>，因為分佈在兩個結果之上是均勻的，所以熵最大</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1555929886554.png" alt="1555929886554" /><figcaption aria-hidden="true">1555929886554</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1556023800324.png" alt="1556023800324" /><figcaption aria-hidden="true">1556023800324</figcaption>
</figure>
<blockquote>
<figure>
<img src="\willywangkaa\images\1556026885048.png" alt="1556026885048" /><figcaption aria-hidden="true">1556026885048</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1556026848421.png" alt="1556026848421" /><figcaption aria-hidden="true">1556026848421</figcaption>
</figure>
</blockquote>
<h3 id="average-code-length期望編碼長度">Average code length（期望編碼長度）</h3>
<blockquote>
<p>資訊論為應用數學的一個分支，主要研究一個信號包含的資訊多寡進行量化</p>
<p>最初被發明用來研究一個含有雜訊的信道上用離散的字母表來發送消息，例如無線電通信</p>
<p>資訊論可以對消息進行最優編碼、計算消息的期望長度</p>
<p>夏農熵（Shannon entropy）原始就是要解決此通訊問題</p>
</blockquote>
<ul>
<li>從機率分佈 <span class="math inline">\(P_X\)</span> 中的值（<span class="math inline">\(X = x\)</span>）
<ul>
<li>夏農熵可以計算「將每個 <span class="math inline">\(x\)</span> 進行編碼」後平均最低的「比特」（Bit）數量</li>
</ul></li>
<li>一個隨機變數 <span class="math inline">\(X～\mathrm{Uniform}\)</span>
<ul>
<li>有八個機率相等的狀態
<ul>
<li><span class="math inline">\(P_X(x) = \frac 18,\forall x\)</span></li>
</ul></li>
<li>欲將 <span class="math inline">\(x\)</span> 傳送，勢必要將其編碼
<ul>
<li>由<strong>夏農熵</strong>可知，平均最低的比特數為 <span class="math inline">\(3\)</span></li>
<li><span class="math inline">\(\mathrm {H(Uniform)} = 8\cdot(-\frac18\log_2\frac 18) = 3\)</span></li>
<li>其最佳編碼為 000, 001, 010, 011, 100, 101, 110, 111</li>
</ul></li>
<li>每個狀態出現的機率相等，當一個未知的狀態出現時，<strong>很難猜測</strong>是哪個狀態
<ul>
<li><strong>亂度大</strong></li>
</ul></li>
</ul></li>
<li>若八個狀態的機率為 <span class="math inline">\((\frac12,\frac14,\frac18,\frac1{16}, \frac1{64},\frac1{64},\frac1{64},\frac1{64})\)</span>
<ul>
<li><span class="math inline">\(\mathrm {H(X)} = 2\)</span></li>
<li>其最佳的編碼為 0, 10, 110, 1110, 111100, 111101, 111110, 111111
<ul>
<li>平均編碼長度為 <span class="math inline">\(2\)</span> 比特</li>
</ul></li>
<li>每個狀態出現的機率不等，當一個未知的狀態出現時，<strong>較易猜測</strong>可能是前面幾個狀態會發生
<ul>
<li><strong>亂度小</strong></li>
</ul></li>
</ul></li>
<li>此編碼的演算法為<strong>「霍夫曼編碼」（Huffman Coding）</strong>
<ul>
<li>將每個狀態表示為一個<strong>二元決策樹的葉節點</strong></li>
<li>每個<strong>決策節點（內節點）</strong>皆有兩個決策，令其各個決策選到的機率為 <span class="math inline">\(\frac12\)</span></li>
</ul></li>
<li>熵的另一種解釋是<strong>「亂度」（Impurity）</strong>，由此可知如果亂度越大，代表其<strong>平均資訊量（期望資訊量）</strong>會越大
<ul>
<li><strong>資訊量：Bit、Nat</strong></li>
<li>因為比特與奈特兩個資訊量的度量只差一個倍數所以在機器學習的範疇中，<strong>通常使用奈特作為資訊量的度量</strong>
<ul>
<li><span class="math inline">\(-\ln P_X(x) = -\log_2 P_X(x)\times\frac{1}{\log_2(e)}\)</span></li>
<li><span class="math inline">\(\log_{\frac 1e}P_X(x) = \log_{\frac12}P_X(x)\times\frac{1}{\log_2(e)}\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="kullback-leibler-divergencekl散度relative-entropy">Kullback-Leibler divergence（KL散度；Relative entropy）</h3>
<blockquote>
<p>對於<strong>一個隨機變數</strong> <span class="math inline">\(X\)</span>，有兩個單獨的機率分佈 <span class="math inline">\(P_X(x)、Q_X(x)\)</span></p>
</blockquote>
<p>從機率分佈 <span class="math inline">\(Q\)</span> 至 <span class="math inline">\(P\)</span> 的 KL 散度（KL divergence from distribution <span class="math inline">\(Q\)</span> to <span class="math inline">\(P\)</span>） <span class="math display">\[
\mathrm {D_{KL}(P\Vert Q)} = \mathrm E_{X～P_X}\left[\log\frac{P_X(x)}{Q_X(x)}\right] = \mathrm E_{X～P_X}[\log P_X(x)-\log Q_X(x)] \\= \underset{\mathrm{entropy}}{\mathrm E_{X～P_X}[\log P_X(x)]}-\mathrm E_{X～P_X}[\log Q_X(x)] \\ = -\mathrm H_X(P_X)-\mathrm E_{X～P_X}[\log Q_X(x)] \\ = 
\underset{\mathrm{cross \; entropy}}{\left(-\mathrm E_{X～P_X}[\log Q_X(x)]\right)}-\mathrm H_X(P_X)
\]</span></p>
<ul>
<li>在<strong>離散型隨機變數</strong>下
<ul>
<li>編碼集合 <span class="math inline">\(\mathbb Q\)</span> 為一種能夠使「機率分佈 <span class="math inline">\(Q_X\)</span> 產生的消息」平均<em>長度</em> <span class="math inline">\(k\)</span> 是最小的</li>
<li>使用 <span class="math inline">\(\mathbb Q\)</span> 來對「機率分佈 <span class="math inline">\(P_X\)</span> 產生的消息」編碼時，「KL 散度」用來衡量此平均編碼的<em>長度</em> <span class="math inline">\(l\)</span> 與<em>長度</em> <span class="math inline">\(k\)</span> 的差異（使用 <span class="math inline">\(\mathbb Q\)</span> 來對「機率分佈 <span class="math inline">\(P_X\)</span> 產生的消息」編碼時，所需的額外平均編碼長度）</li>
</ul></li>
<li>當使用的對數底數為 <span class="math inline">\(2\)</span> 時
<ul>
<li>資訊<em>長度</em>的單位為<strong>比特</strong></li>
</ul></li>
<li>機器學習中，使用的對數底數通常為 <span class="math inline">\(e\)</span>
<ul>
<li>資訊<em>長度</em>的單位為<strong>奈特</strong></li>
</ul></li>
<li><strong>交叉熵（Cross entropy）</strong>
<ul>
<li><span class="math inline">\(\mathrm {H(P,Q) = H(P)+D_{KL}(P\Vert Q)} = -\mathrm E_{X～P_X}[\log Q_X(x)]\)</span></li>
<li>當 <span class="math inline">\(P_X\)</span> 與 <span class="math inline">\(Q_X\)</span> 相互獨立
<ul>
<li><span class="math inline">\(\arg \underset{\mathrm Q}{\min}\mathrm {D_{KL}(P\Vert Q)}\)</span> 可以由 <span class="math inline">\(\arg \underset{\mathrm Q}{\min}-\mathrm E_{X～P_X}[\log Q_X(x)]\)</span> 解出</li>
<li>因為 <span class="math inline">\(Q_X\)</span> 不參與被省略的那一項</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<ul>
<li><span class="math inline">\(0 \log 0 = 0\)</span>
<ul>
<li>在資訊論中，將上式表達為 <span class="math inline">\(\lim_{x\to 0} x\log x = 0\)</span></li>
</ul></li>
</ul>
</blockquote>
<h4 id="properties-1">Properties</h4>
<p>KL 散度的性質</p>
<ul>
<li><span class="math inline">\(\mathrm {D_{KL}(P\Vert Q)} \geq 0 , \forall \mathrm {P,Q}\)</span>
<ul>
<li>對於「機率分佈 <span class="math inline">\(Q_X\)</span> 產生的消息」所進行的最好編碼，拿來對「機率分佈 <span class="math inline">\(P_X\)</span> 產生的消息」編碼，其平均長度必比較長</li>
</ul></li>
<li><span class="math inline">\(\mathrm {D_{KL}(P\Vert Q)} = 0\)</span>
<ul>
<li><span class="math inline">\(\mathrm{P、Q}\)</span> 在離散型隨機變數下為<strong>相同的機率分佈</strong></li>
<li><span class="math inline">\(\mathrm{P、Q}\)</span> 在連續型隨機變數下為<strong>幾乎處處相同</strong></li>
</ul></li>
<li><span class="math inline">\(\mathrm {D_{KL}(P\Vert Q)}\neq\mathrm {D_{KL}(Q\Vert P)}\)</span>
<ul>
<li>經常被視為分佈之間的<em>某種距離</em>，但<strong>非真正的距離</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1555937595977.png" alt="1555937595977" /><figcaption aria-hidden="true">1555937595977</figcaption>
</figure>
<h4 id="minimizer-of-kl-divergence">Minimizer of KL divergence</h4>
<p>在給定一個分佈 <span class="math inline">\(P_X\)</span> 希望用另一個分佈 <span class="math inline">\(Q^＊_X\)</span> 近似之，要選擇 <span class="math inline">\(\mathrm {D_{KL}(P\Vert Q)}\)</span> 或 <span class="math inline">\(\mathrm {D_{KL}(Q\Vert P)}\)</span>？</p>
<ul>
<li>令 <span class="math inline">\(P_X\)</span> 為高斯混合模型（兩個高斯分佈）、<span class="math inline">\(Q_X\)</span> 為單一高斯分佈</li>
<li><span class="math inline">\(\mathrm{Q^{＊(from)}} = \arg \underset{\mathrm Q}{\min}\mathrm {D_{KL}(P\Vert Q)}\)</span> 或 <span class="math inline">\(\mathrm{Q^{＊(to)}} = \arg \underset{\mathrm Q}{\min}\mathrm {D_{KL}(Q\Vert P)}\)</span> ？
<ul>
<li>在不同的情況下，會選擇不同的近似手段</li>
</ul></li>
<li><span class="math inline">\(\mathrm{Q^{＊(from)}}\)</span> 會選擇一個 <span class="math inline">\(Q^＊_X\)</span> <strong>在「</strong><span class="math inline">\(P_X\)</span> <strong>有高機率密度」的地方使其具有高機率密度</strong>
<ul>
<li>當 <span class="math inline">\(P_X\)</span> 的機率密度函數同時有多個峰值時</li>
<li><span class="math inline">\(Q^＊_X\)</span> 會選擇將這些峰值模糊到一起，以便將高機率值量同時放到所有峰上</li>
</ul></li>
<li><span class="math inline">\(\mathrm{Q^{＊(to)}}\)</span> 會選擇一個 <span class="math inline">\(Q^＊_X\)</span> <strong>在「</strong><span class="math inline">\(P_X\)</span> <strong>有低機率密度」的地方使其具有低機率密度</strong>
<ul>
<li>當 <span class="math inline">\(P_X\)</span> 的機率密度函數同時有多個峰值且峰值之間隔很寬時</li>
<li><span class="math inline">\(Q^＊_X\)</span> 會選擇其中一個峰以避免將機率質量放置於 <span class="math inline">\(P_X\)</span> 低機率質量的區域中
<ul>
<li>下圖 <span class="math inline">\(Q^＊_X\)</span> 是選擇強調左峰的結果，當然也可以選擇右峰以達到 <span class="math inline">\(\mathrm{Q^{＊(to)}}\)</span></li>
<li>如果 <span class="math inline">\(P_X\)</span> 的多峰無法被足夠強的低機率區域分離，那 <span class="math inline">\(\mathrm{Q^{＊(to)}}\)</span> 仍可能<strong>選擇模糊這些峰</strong></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1555982692715.png" alt="1555982692715" /><figcaption aria-hidden="true">1555982692715</figcaption>
</figure>
]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>Probability</tag>
        <tag>Information theories</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine learning - Decision Tree Learning</title>
    <url>/willywangkaa/2018/04/18/Machine-learning-Decision-Tree-Learning/</url>
    <content><![CDATA[<h1 id="decision-tree-learning-決策樹學習">Decision Tree Learning 決策樹學習</h1>
<hr />
<h2 id="簡介">簡介</h2>
<ul>
<li><p>最受歡迎的<strong>歸納推理演算法( inductive inference algorithm )</strong>。</p></li>
<li><p>廣泛且實務的方法。</p></li>
<li><p><strong>對於干擾值( Noise )相當敏感</strong>。</p></li>
<li><p>可用來學習如何以<strong>聯集( Disjunctive )</strong>表示<strong>限制集( Constraints )</strong>。 ( <a href="">Concept Learning</a> 以<strong>交集( Conjunctive )</strong>表示 )</p></li>
<li><p>呈現的方式相當簡單。</p></li>
<li><p>樹狀結構( Tree Structure )、若則表示式( If-Then rules )</p></li>
</ul>
<h2 id="ex.-play-tennis"><span class="math inline">\(Ex.\)</span> Play Tennis</h2>
<h3 id="範例訓練資料-training-example">範例訓練資料( Training Example )</h3>
<figure>
<img src="\willywangkaa\images\decisiontreelearning_training%20example.png" alt="decisiontreelearning_training example" /><figcaption aria-hidden="true">decisiontreelearning_training example</figcaption>
</figure>
<h3 id="決策樹-decision-tree">決策樹( Decision Tree )</h3>
<figure>
<img src="\willywangkaa\images\decisiontreelearning_exampletree.png" alt="decisiontreelearning_exampletree" /><figcaption aria-hidden="true">decisiontreelearning_exampletree</figcaption>
</figure>
<h2 id="決策樹-decision-tree-的介紹">決策樹( Decision Tree )的介紹</h2>
<h3 id="決策樹表示法-decision-tree-representation">決策樹表示法( Decision Tree Representation )</h3>
<ul>
<li>每個<strong>內節點 Internal node ( 包括根結點 Root node )</strong>代表對一個<strong>環境狀態( Attribute )</strong>檢驗。</li>
<li>而<strong>分支( Branch )</strong>出來的意義我們可以視為是該<strong>環境狀態( Attribute )</strong>的一種可能<strong>值( Attribute value )</strong>。</li>
<li>每個<strong>葉節點 Leaf node </strong>給予一個適當的<strong>分類結果( Classification )</strong>。</li>
<li>我們將每個<strong>案例( Instances )</strong>分類到一個離散的<strong>類別( Categories )</strong>之中。</li>
<li>藉由<strong>決策樹</strong>由<strong>根結點</strong>至<strong>葉節點</strong>找到該<strong>類別</strong>。</li>
</ul>
<h3 id="決策樹引導的假說-hypotheses">決策樹引導的假說( Hypotheses )</h3>
<ul>
<li>先 AND 再 OR ( 原文：Disjunctions (OR’s) of conjunctions (AND’s) )。</li>
<li>經由根結點往葉節點走可視為是一種對於該環境狀態限制的交集( Conjunction of constraints on attributes )。</li>
<li>而連上兄弟節點( Sibling )的兩個邊( Edges )可視為是一種對於該環境狀態限制的聯集( Separate branches are disjunctions )。</li>
<li><span class="math inline">\(Ex \; ( Cont. )\)</span>
<div style="text-align: center">
(Outlook=Sunny and Humidity=Normal)
</div>
<div style="text-align: center">
or
</div>
<div style="text-align: center">
(Outlook=Overcast)
</div>
<div style="text-align: center">
or
</div>
<div style="text-align: center">
(Outlook=Rain and Wind=Weak)
</div></li>
</ul>
<h4 id="注意">注意！</h4>
<ul>
<li>每個用來訓練的<strong>案例 ( Instances )</strong>都必須要以「因素-結果」( Attribute - value pairs )的方式給予訓練。</li>
<li>目標訓練函式 ( Target function )的值域是<strong>離散的值 ( Discrete value )</strong>。</li>
<li>這種方法最後呈現的<strong>假說 ( Hypotheses )</strong>有可能是一些<strong>環境狀態限制( Constraints on attributes )</strong>的聯集( Disjunctive )。</li>
<li>極有可能會被不乾淨的資料( Noise )擾亂了學習。</li>
<li>應用於：</li>
<li>醫療或是設備的診斷。</li>
<li>信用額度分析( 銀行 )。</li>
</ul>
<h3 id="決策樹的種類">決策樹的種類</h3>
<p>世界上有許多有特殊的<strong>決策樹演算法( decision-tree algorithms )</strong>，比較著名的有： - ID3 (Iterative Dichotomiser 3) - C4.5, C5.0 (successor of ID3) - CART (Classification And Regression Tree) - CHAID (CHi-squared Automatic Interaction Detector). - MARS: extends decision trees to handle numerical data better.</p>
<h4 id="注意-1">注意</h4>
<ul>
<li>ID3 is the algorithm discussed in textbook.( 在書本中有更詳細的介紹 )</li>
<li>Simple, but representative. ( 簡單但representative? )</li>
<li>Source code publicly available. ( 程式碼是開放的 )</li>
</ul>
<h3 id="id3演算法">ID3演算法</h3>
<ul>
<li><strong>概述</strong>：Top-down, greedy search through <strong>space of possible decision trees</strong>. ( 在所有可以出現的決策樹中用貪心法由上而下找到較佳的那棵樹。 )<br> ID3在建構決策樹過程中，以資訊獲利(Information Gain)為準則，並選擇最大的資訊獲利值作為分類屬性。這個算法是建立在奧卡姆剃刀的基礎上：越是小型的決策樹越優於大的決策樹。儘管如此，該算法也不是總是生成最小的樹形結構，而是一個啟發式算法。另外，C4.5算法是ID3的升級版。<br><br></li>
<li>Decision trees represent hypotheses, so this is a search through hypothesis space. ( 決策樹亦也代表是一種假說，所以這個演算法也可以說是在所有的假說中找到一個較佳的假說。 )</li>
<li><strong>那個演算法該如何起手呢？</strong> 決定甚麼<strong>環境因素( Attribute )</strong>應該放在<strong>根結點( Root node )</strong>？</li>
<li>接著由上而下( Top-down )的建構決策樹，對每個後繼的節點( Successive node )使出一樣的決策手段選出該節點應該置入何種<strong>環境因素( Attribute )</strong>。</li>
<li><strong>注意！</strong>千萬不要由下往上參考之前選過的值，因為我們以貪心法則，所以目前的最佳解決不可能出現在之前選過的<strong>環境因素( Attribute )</strong>之中，或是受其干擾。 ( Never backtracks to reconsider earlier choices. )</li>
<li>同上述，在每次的選擇之中，由於我們認知這種情況適用<strong>貪心法( Greedy Method )</strong>，所以我們每次<strong>環境因素( Attribute )</strong>的選擇都朝向我們最後最佳的<strong>假說</strong>靠近。</li>
</ul>
<h4 id="虛擬碼-pseudo-code">虛擬碼( Pseudo Code )</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用屬性計算與之相關的樣本熵值</span><br><span class="line">2. 選取其中熵值最小的屬性(資訊獲利最大)</span><br><span class="line">3. 生成包含該屬性的節點</span><br><span class="line">4. 遞迴直到終止</span><br></pre></td></tr></table></figure>
<figure>
<img src="\willywangkaa\images\decisiontreelearning_builddecisiontree_algorithm.png" alt="decisiontreelearning_builddecisiontree_algorithm" /><figcaption aria-hidden="true">decisiontreelearning_builddecisiontree_algorithm</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\decisiontreelearning_howtochoosenode.png" alt="decisiontreelearning_howtochoosenode" /><figcaption aria-hidden="true">decisiontreelearning_howtochoosenode</figcaption>
</figure>
<p><strong>＜討論＞</strong> ID3演算法的終極目標，就是要將決策樹中每個節點都擺上最優的<strong>環境因素( Attributes )</strong>。<br> <span class="math inline">\(Question.\)</span><br> 到底以甚麼條件決定甚麼因素要擺放於哪個節點？ <span class="math inline">\(Answer.\)</span> 資訊獎賞 or 資訊獲利( Information gain )。 - 資訊獲利( Information gain ) 統計該價值以檢視該環境因素置於何處來分類我們的資料，我們使用<strong>熵( entropy 又稱"亂度" )</strong>來定義這邊的<strong>資訊獲利( Information gain )</strong>。( 原文：Statistical quantity measuring how well an attribute classifies the data. Use entropy to define information gain. )</p>
<h3 id="id3-和-c4.5---information-gain-資訊獲利-與-gain-ratio">ID3 和 C4.5 - Information gain ( 資訊獲利 ) 與 Gain ratio</h3>
<h4 id="定義">定義</h4>
<p>關心其中一個環境因素( Attribute )<span class="math inline">\(A\)</span> 的資訊獲利( Information gain )我們標記為 <span class="math inline">\(Gain( S, A )\)</span>，且我們關心的目標樣本群體為 <span class="math inline">\(S\)</span>，其中： <span class="math display">\[Gain( S, A ) = Entropy( S ) - \sum_{ v \in Values(A) } ( \frac{S_v}{S}Entropy(S_v) )\]</span> - <span class="math inline">\(v\)</span> ranges over values of <span class="math inline">\(A\)</span> - <span class="math inline">\(S_v\)</span>: members of <span class="math inline">\(S\)</span> with <span class="math inline">\(A = v\)</span> - <span class="math inline">\(1^{st}\)</span> term: the entropy of <span class="math inline">\(S\)</span> - <span class="math inline">\(2^{nd}\)</span> term: expected value of entropy after partitioning with <span class="math inline">\(A\)</span></p>
<h4 id="example-playtennies">Example： PlayTennies</h4>
<ul>
<li><p>四個環境變因</p>
<ul>
<li>Outlook = {Sunny, Overcast, Rain}</li>
</ul></li>
<li><p>Temperature = {Hot, Mild, Cool}</p>
<ul>
<li>Humidity = {High, Normal} Wind = {Weak, Strong}</li>
</ul></li>
<li><p>欲看討的結果 - <strong>開心</strong>或是<strong>不開心</strong>( Target Attributes - Binary )</p>
<ul>
<li>PlayTennis = {Yes, No}</li>
</ul></li>
<li><p>今天有14組訓練資料</p></li>
<li><p>9筆的結果是開心的 ( Positive )</p></li>
<li><p>5筆的結果是不開心的( Negative )</p></li>
<li><p>訓練資料表</p></li>
</ul>
<figure>
<img src="\willywangkaa\images\decisiontreelearning_trainningdataform.png" alt="decisiontreelearning_trainningdataform" /><figcaption aria-hidden="true">decisiontreelearning_trainningdataform</figcaption>
</figure>
<h5 id="step-1.-計算整體的亂度-entropy">Step 1. 計算整體的亂度( Entropy )</h5>
<p><span class="math inline">\(N_\oplus = 9, N_\ominus = 5, N_{Total} = 14\)</span> <span class="math inline">\(Entropy( S ) = -\frac{9}{14} \cdot \lg (\frac{9}{14}) - \frac{5}{14} \cdot \lg ( \frac{5}{14} ) = 0.940\)</span></p>
<h5 id="step2.-不斷計算資訊獲利-找亂度比較低attribute的-選擇最大值當作根結點">Step2. 不斷計算<strong>資訊獲利( 找亂度比較低attribute的 )</strong>，選擇最大值當作根結點</h5>
<ul>
<li>Outlook</li>
<li>Outlook = Sunny</li>
</ul>
<p><span class="math display">\[N_\oplus = 2, N_\ominus = 3, N_{Sunny} = 5\]</span></p>
<p><span class="math display">\[Entropy(S_{Sunny}) = -(\frac{2}{5})\cdot \log_2(\frac{2}{5}) - (\frac{3}{5}) \cdot \log_2(\frac{3}{5}) = 0.971\]</span></p>
<ul>
<li>Outlook = Overcast <span class="math display">\[N_\oplus = 4, N_\ominus = 0, N_{Overcast} = 4\]</span> <span class="math display">\[Entropy(S_{Overcast}) = -(\frac{4}{4})\cdot \log_2(\frac{4}{4}) - (\frac{0}{4}) \cdot \log_2(\frac{0}{4}) = 0.0\]</span></li>
<li>Outlook = Rain <span class="math display">\[N_\oplus = 3, N_\ominus = 2, N_{Rain} = 5\]</span> <span class="math display">\[Entropy(S_{Rain}) = -(\frac{3}{5})\cdot \log_2(\frac{3}{5}) - (\frac{2}{5}) \cdot \log_2(\frac{2}{5}) = 0.971\]</span></li>
<li>計算環境因素的 Outlook 之資訊獲利</li>
</ul>
<p><span class="math display">\[Gain(S, Outlook) = Entropy(S) - (N_{Sunny} / N_{total}) * Entropy(S_{Sunny})\]</span></p>
<p><span class="math display">\[ - (N_{Overcast} / N_{total}) * Entropy(S_{Overcast})\]</span></p>
<p><span class="math display">\[ - (N_{Rain} / N_{total} ) * Entropy(S_{Rain})\]</span></p>
<p><span class="math display">\[\Rightarrow 0.940 - (5/14) \cdot 0.971 - (4/14) \cdot 0.00 - (5/14) \cdot 0.971 = 0.246\]</span></p>
<ul>
<li>Temperature</li>
<li>Repeat process over { Hot, Mild, Cool } <span class="math display">\[ Gain( S, Temperature ) = 0.029 \]</span></li>
<li>Humidity</li>
<li>Repeat process over { High, Normal } <span class="math display">\[ Gain( S, Humidity ) = 0.151 \]</span></li>
<li>Wind</li>
<li>Repeat process over { Weak, Strong } <span class="math display">\[ Gain( S, Wind ) = 0.048 \]</span></li>
</ul>
<p>再來，我們要找到最佳的資訊獲利( Information gain )，其中：</p>
<p><span class="math display">\[Gain(S, Outlook) = 0.246\]</span></p>
<p><span class="math display">\[ Gain( S, Temperature ) = 0.029 \]</span></p>
<p><span class="math display">\[ Gain( S, Humidity ) = 0.151 \]</span></p>
<p><span class="math display">\[ Gain( S, Wind ) = 0.048 \]</span></p>
<p>從亂度的點看來，似乎Outlook的亂度最低( 與宇亂度相減後剩餘比較多資訊獲利 )，所以我們選擇<strong>Outlook</strong>作為我們根結點( root node )，如下圖：</p>
<figure>
<img src="\willywangkaa\images\decisiontreelearning_choosenode.png" alt="decisiontreelearning_choosenode" /><figcaption aria-hidden="true">decisiontreelearning_choosenode</figcaption>
</figure>
<p>選擇了Outlook做為決策樹的根結點後，緊接著，我們可以將三種不同的Outlook作為分支，其中特別的是，Overcast狀態之中( 上圖中間綠色部分 )，全部皆為開心狀態( Positive outcome )，所以可以直接決定Overcast輸出為開心( Positive )。</p>
<h5 id="step-2.-conti.---選擇下一個節點-子樹的根結點">Step 2. Conti. - 選擇下一個節點( 子樹的根結點 )</h5>
<p>( 從何子節點開始建子樹？ I don't know yet. )</p>
<ul>
<li>Same steps as earlier but only examples sorted to the node are used in Gain computations.( 無法理解 )</li>
<li>選一個點( 隨機？ )繼續建子樹</li>
<li>Outlook = Sunny</li>
</ul>
<p><span class="math display">\[Gain(S_{Sunny}, Humidity) = 0.97 - (3/5) \cdot 0 - (2/5) \cdot 0 = 0.97 bits\]</span></p>
<p><span class="math display">\[Gain(S_{Sunny}, Temperature) = 0.97 - (2/5) \cdot 0 - (2/5) \cdot 1 - (1/5) \cdot 0 = 0.57 bits\]</span></p>
<p><span class="math display">\[Gain(S_{Sunny}, Wind) = 0.97 - (2/5) \cdot 1 - (3/5) \cdot 0.918 = 0.019 bits\]</span></p>
<p>由上式可以看出來<strong>Humidity</strong>的亂度最小，所以選擇之為此子樹的根。</p>
<h5 id="final-decision-tree">Final Decision Tree</h5>
<figure>
<img src="\willywangkaa\images\decisiontreelearning_finaldecisiontree.png" alt="decisiontreelearning_finaldecisiontree" /><figcaption aria-hidden="true">decisiontreelearning_finaldecisiontree</figcaption>
</figure>
<h1 id="熵亂度-entropy">熵、亂度 (Entropy)</h1>
<hr />
<h2 id="介紹">介紹</h2>
<p>在資訊理論中，熵被用來衡量一個<strong>隨機變數出現的期望值</strong>(機率與統計)。它代表了在被接收之前，訊號傳輸過程中損失的資訊量，又被稱為資訊熵。熵是對<strong>不確定性</strong>的測量。在資訊界，熵<strong>越高</strong>則能<strong>傳輸越多的資訊</strong>( 資訊越多意味著有<strong>更多的可能性</strong> )，熵<strong>越低</strong>則意味著<strong>傳輸的資訊越少</strong>( 資訊越少意味著有<strong>更少的可能性</strong> )。<br><br> 如果有一枚理想的硬幣，其出現正面和反面的機會相等，則拋硬幣事件的熵等於其能夠達到的最大值。我們無法知道下一個硬幣拋擲的結果是什麼，因此每一次拋硬幣都是不可預測的。( 越是不可預測的結果 <span class="math inline">\(\rightarrow\)</span> 亂度越大，而這種結果，正是造成人類<strong>選擇障礙</strong>的原因，所以我們希望熵越低越好，我們可以立即做出判斷 )</p>
<h3 id="ex1."><span class="math inline">\(Ex1.\)</span></h3>
<p>使用一枚<strong>正常硬幣</strong>進行拋擲，這個事件的熵是一位元，若進行n次獨立實驗，則熵為<span class="math inline">\(n\)</span>，因為可以用長度為 <span class="math inline">\(n\)</span> 的位元流表示。但是如果一枚硬幣的兩面完全相同，那個這個系列拋硬幣事件的熵等於<strong>零</strong>，因為結果<strong>能被準確預測</strong>。</p>
<h3 id="ex2."><span class="math inline">\(Ex2.\)</span></h3>
<p><span class="math inline">\(Let \; y \; be \; a \; Boolean \; function, and \; let \; P \; denote \; Probability.\)</span> What is the most pure (亂度低) probability distribution? <span class="math display">\[P(y = 0) = 1, P(y = 1) = 0\]</span> <span class="math display">\[P(y = 0) = 0, P(y = 1) = 1\]</span></p>
<p>What is the most impure (亂度高) probability distribution? <span class="math display">\[P(y = 0) = 0.5, P(y = 1) = 0.5\]</span> 意同於最大的亂度。</p>
<h2 id="定義-1">定義</h2>
<p>首先，我們可以先從簡單的看討當目前的結果最多只有兩種情況，如拋硬幣，最多只有正面或是反面，下圖<span class="math inline">\(x\)</span>軸<span class="math inline">\(P_\oplus\)</span>代表擲出正面的機率函數，而<span class="math inline">\(y\)</span>軸則是對應的熵值，而<span class="math inline">\(P_\ominus\)</span>的機率軸則是會隨著<span class="math inline">\(P_\oplus\)</span>下降而上升( 兩者互補 )，但是對應到的熵值會一樣大。</p>
<figure>
<img src="\willywangkaa\images\decisiontreelearning_entropygraph.png" alt="decisiontreelearning_entropygraph" /><figcaption aria-hidden="true">decisiontreelearning_entropygraph</figcaption>
</figure>
<p><span class="math inline">\(S\)</span> is a sample of training examples( 隨機變量 ). 當今天的結果只有正與反 ( 與硬幣一樣 )時，觀察目前的<strong>隨機變量</strong> - 我們令： - <span class="math inline">\(P_\oplus\)</span> ( 就目前隨機變數產生的機率 ) is the portion of the positive examples ( 正面 ) in <span class="math inline">\(S\)</span>. - <span class="math inline">\(P_\ominus\)</span> ( 就目前隨機變數產生的機率 ) is the portion of the negative examples ( 反面 ) in <span class="math inline">\(S\)</span>. Entropy ( 熵 ) measures the impurity ( 亂度 ) of <span class="math inline">\(S\)</span>.</p>
<p>我們先定義熵值 ( Entropy ) 如下： <span class="math display">\[ Entropy( S ) = E( I( S ) ) = E(- \ln ( P ( S ) ) ) \]</span> 其中，<span class="math inline">\(E\)</span>為<strong>期望函數</strong>，<span class="math inline">\(I( S )\)</span>是 <span class="math inline">\(S\)</span> 的<strong>資訊量</strong>（又稱為<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E4%BF%A1%E6%81%AF">資訊本體</a>），<span class="math inline">\(I( S )\)</span>也是一個<strong>隨機變數</strong>。 所以在取硬幣的樣本( <span class="math inline">\(S\)</span> )完後，我們可以將熵值寫成：</p>
<p><span class="math display">\[ Entropy( S ) = \sum_{i = 1}^{2} P(S_i)I(S_i)\]</span></p>
<p><span class="math display">\[ \Rightarrow -\sum_{i = 1}^{2} P(S_i)\log_{2} P(S_i) \]</span></p>
<p><span class="math display">\[ \Rightarrow  -P_{\oplus}\log_2 P_{\oplus} - P_{\ominus}\log_2 P_{\ominus}\]</span></p>
<p><strong>＜Note＞</strong> <span class="math display">\[\sum_{i = 1}^N P_i = 1 \; and \;  0 \leq P_i \leq 1 \]</span></p>
<h3 id="推廣至一般式"><strong>推廣至一般式</strong></h3>
<figure>
<img src="\willywangkaa\images\decisiontreelearning_generalentropygraph.png" alt="decisiontreelearning_generalentropygraph" /><figcaption aria-hidden="true">decisiontreelearning_generalentropygraph</figcaption>
</figure>
<p>當取自有限的樣本時，熵的公式可以表示為： <span class="math display">\[H(X) = \sum _{i} P(x_i) \, I(x_i)=-\sum_i P(x_i)\log _b P(x_i)\]</span></p>
<p>在這裏 <span class="math inline">\(b\)</span> 通常是<span class="math inline">\(2\)</span>,自然常數 <span class="math inline">\(e\)</span>，或是<span class="math inline">\(10\)</span>。當<span class="math inline">\(b = 2\)</span>，熵的單位是<span class="math inline">\(bit\)</span>；當<span class="math inline">\(b = e\)</span>，熵的單位是<span class="math inline">\(nat\)</span>；而當<span class="math inline">\(b = 10\)</span>,熵的單位是<span class="math inline">\(Hart\)</span>。</p>
<p><strong>＜Note＞</strong> 定義當<span class="math inline">\(P_i = 0\)</span>時，對於一些 <span class="math inline">\(i\)</span> 值，對應的被加數 <span class="math inline">\(0 \log_b 0\)</span> 的值將會是 <span class="math inline">\(0\)</span>，這與極限一致。 <span class="math display">\[ \Rightarrow \lim_{p\to0+} ( p\log p ) = 0 \]</span></p>
<h1 id="cart-classification-and-regression-tree">CART (Classification and Regression Tree)</h1>
<hr />
<p>見 <a href="http://mropengate.blogspot.tw/2015/06/ai-ch13-2-decision-tree.html">Mr' opengate - AI - Ch14 機器學習(2), 決策樹 Decision Tree</a></p>
<h1 id="決策樹學習的常見問題">決策樹學習的常見問題</h1>
<hr />
<h2 id="避免過度適配資料-prevent-overfitting">避免過度適配資料( Prevent Overfitting )</h2>
<p>首先，相較於很冗長的樹，在機器學習中其實比較偏向於比較矮的樹，然而，為何？我們可以由<a href="https://zh.wikipedia.org/wiki/%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80">Occam’s Razor ( 奧坎剃刀 )</a>得知，若有兩個假說同時都能解釋該現象，我們偏向於比較沒那麼嚴個的假說( 可以表達比較廣的概念 )。<br>過度配適是指模型對於範例的過度訓練，導致模型記住的不是訓練資料的一般特性，反而是訓練資料的局部特性。對測試樣本的分類將會變得很不精確。</p>
<p><strong>＜注意＞</strong>通常過度適配發生在訓練範例含有雜訊和離異值時，但當訓練數據沒有雜訊時，過度適配也有可能發生，特別是當訓練範例的數量太少，使得某一些屬性「恰巧」可以很好地分割目前的訓練範例，但卻與實際的狀況並無太多關係。</p>
<figure>
<img src="\willywangkaa\images\decisiontreelearning_overfitting1.png" alt="decisiontreelearning_overfitting1" /><figcaption aria-hidden="true">decisiontreelearning_overfitting1</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\decisiontreelearning_overfitting2.png" alt="decisiontreelearning_overfitting2" /><figcaption aria-hidden="true">decisiontreelearning_overfitting2</figcaption>
</figure>
<h2 id="解決方案修剪決策樹移除不可信賴的分支">解決方案：修剪決策樹移除不可信賴的分支</h2>
<ul>
<li>事前修剪 (Prepruning) : 透過決策樹不再增長的方式來達到修剪的目的。選擇一個合適的臨界值往往很困難。</li>
<li>事後修剪 (Postpruning) :</li>
<li>子樹置換 (Subtree Replacement)：選擇某個子樹，並用單個樹葉來置換它。</li>
<li>子樹提升 (Subtree Raising)：</li>
</ul>
<figure>
<img src="\willywangkaa\images\decisiontreelearning_subtreeraising.png" alt="decisiontreelearning_subtreeraising" /><figcaption aria-hidden="true">decisiontreelearning_subtreeraising</figcaption>
</figure>
<h2 id="合併連續值屬性">合併連續值屬性</h2>
<p>透過動態地定義新的離散值屬性來實現，即先把連續值屬性的值域分割為離散的區間集合，或設定門檻值以進行二分法。</p>
<h2 id="屬性選擇指標的其他度量標準">屬性選擇指標的其他度量標準</h2>
<ul>
<li>訊息獲利 : 趨向於包含多個值的屬性</li>
<li>獲利比率 : 會產生不平均的分割，也就是分割的一邊會非常小於另一邊</li>
<li>吉尼係數 : 傾向於包含多個值的屬性，當類別個數很多時會有困難，傾向那些會導致平衡切割並且兩邊均為純粹的測試</li>
</ul>
<p><strong>＜尚有其他的度量標準，也都各有利弊＞</strong></p>
<h1 id="例題">例題</h1>
<hr />
<ul>
<li>A data set has 4 Boolean variables. What is the maximum number of leaves in a decision tree? <span class="math inline">\(2^4\)</span></li>
<li>To each leaf in the decision, the number of corresponding rule is <strong>1</strong></li>
<li>If a decision tree achieves 100% accuracy on the training set, then it will also get 100% accuracy on the test set? <strong>No</strong></li>
<li>Using information gain to pick attributes, decision tree learning can be considered <strong>A* search algorithm.</strong> <strong>No</strong></li>
<li>A decision tree can describe any Boolean function? <strong>Yes</strong></li>
</ul>
<h1 id="補充">補充</h1>
<hr />
<ul>
<li>C4.5 演算法
<ul>
<li>C4.5演算法利用屬性的獲利比率(Gain Ratio)克服問題，獲利比率是資訊獲利正規化後的結果。求算某屬性A的獲利比率時除資訊獲 利外，尚需計算該屬性的分割資訊值(Split Information) : SplitInfoA(S)=∑t∈T|Sj||S|×log2|Sj||S|</li>
</ul></li>
<li>C4.5的改善：對連續屬性的處理
<ul>
<li>改善ID3傾向選擇擁有許多不同數值但不具意義的屬性：之所以使用獲利比率(Gain Ratio)，是因為ID3演算法所使用的資訊獲利會傾向選擇擁有許多不同數值的屬性，例如：若依學生學號(獨一無二的屬性)進行分割，會產生出許多分支，且每一個分支都是很單一的結果，其資訊獲利會最大。但這個屬性對於建立決策樹是沒有意義的。</li>
</ul></li>
<li>C5.0 演算法
<ul>
<li>C5.0 是 C4.5的商業改進版，可應用於海量資料集合上之分類。主要在執行準確度和記憶體耗用方面做了改進。因其採用Boosting方式來提高模型準確率，且佔用系統資源與記憶體較少，所以計算速度較快。其所使用的演算法沒有被公開。</li>
</ul></li>
<li>C5.0 的優點：
<ul>
<li>C5.0模型在面對遺漏值時非常穩定。</li>
<li>C5.0模型不需要很長的訓練次數。</li>
<li>C5.0模型比較其他類型的模型易於理解。</li>
<li>C5.0的增強技術提高分類的精度。</li>
</ul></li>
</ul>
<h1 id="參考">參考</h1>
<hr />
<p><a href="http://mropengate.blogspot.tw/2015/06/ai-ch13-2-decision-tree.html">Mr' opengate - AI - Ch14 機器學習(2), 決策樹 Decision Tree</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%86%B5_%E4%BF%A1%E6%81%AF%E8%AE%BA">Wiki - 熵 - 資訊理論</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80">奧坎剃刀</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Decision Tree Lrearning</tag>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System - Basic Concept 1</title>
    <url>/willywangkaa/2018/07/10/Operating-System-Basic-Concept/</url>
    <content><![CDATA[<h1 id="基礎觀念---basic-concept-壹">基礎觀念 - Basic Concept (壹)</h1>
<hr />
<h2 id="機器種類---machine-type">機器種類 - Machine type</h2>
<ul>
<li>Bare Machine（裸機）
<ul>
<li>只有「Hardware Components」所組成（CPU、memory、I/O device），<strong>沒有任何輔助使用者（ User ）的系統程式（System Program）存在</strong></li>
</ul></li>
<li>Extended Machine
<ul>
<li>以「Bare Machine」為底加上輔助使用者的系統程式－System Programs（OS、Compiler、Database management system…）</li>
</ul></li>
</ul>
<h3 id="cpu-的等待時間idle-time">CPU 的等待時間（Idle time）</h3>
<ul>
<li>人類手動操作相對於「CPU cycle time」太慢
<ul>
<li>以「Automatic Job Sequence」的軟體<strong>常駐於</strong>在早期的電腦上，利用少量的記憶體執行<strong>非常駐於的電腦上的軟體</strong>，類似於現今的作業系統，<strong>稱之為「Resident Monitor」</strong></li>
</ul></li>
<li>I/O 裝置的工作速度遠比 CPU 的工作速度還慢，<strong>CPU 針對某些工作必須等待 I/O 工作完成後才能繼續執行，所以造成 CPU 等待時間（idle time）太久</strong>
<ul>
<li>以<strong>較快速的裝置介入 CPU 與 I/O 裝置之間作為緩衝</strong></li>
</ul></li>
</ul>
<h4 id="脫機-off-line-非即時運作-io">脫機 (Off-line 非即時運作 I/O)</h4>
<figure>
<img src="\willywangkaa\images\1529920981306.png" alt="1529920981306" /><figcaption aria-hidden="true">1529920981306</figcaption>
</figure>
<p>不即時的將 CPU 演算完的資料給予讀取或是列印，<strong>利用專門的外圍控制機，將低速 I/O 設備上的數據傳送到高速磁碟（磁帶）上；或者相反，CPU 直接對於磁帶讀寫，使電腦加快讀取的速度</strong></p>
<ul>
<li><strong>以磁帶機緩解讀卡機（Input）與印表機（Output）造成過慢的等待（Idle）</strong>
<ul>
<li>電腦中間以磁帶機的方式加速與讀卡機與印表機的溝通（讀卡機與印表機不直接由 CPU 直接操作）</li>
</ul></li>
<li>磁帶機實作
<ul>
<li>以專用的 I/O 裝置對於磁帶讀寫（CPU 直接控制）</li>
<li>以一個小型的子電腦對於磁帶讀寫，習慣稱之為衛星機（Satellite processing），主要負責磁帶拷貝的工作，<strong>CPU 不直接參與磁帶機的讀寫運作</strong></li>
</ul></li>
<li>Pros
<ul>
<li>CPU 不<strong>受到讀卡機或是印表機的速度限制</strong>（CPU 受到磁碟機的速度限制）</li>
<li>已寫好的程式不必更動，只要把原本直接交付給裝置執行的指令存入磁帶中再給該裝置執行</li>
<li>裝置獨立性（Device Independent）
<ul>
<li><strong>泛指同一程式可以在不同的 I/O 裝置上執行的能力</strong></li>
</ul></li>
</ul></li>
<li>Cons
<ul>
<li>因為要先讓電腦先將指令載入至磁帶，再交由該機器執行，導致設定時間需求長</li>
<li>磁帶只能以循序讀取（Sequential Access）的方式讀寫</li>
</ul></li>
</ul>
<h4 id="緩衝區-buffering">緩衝區 ( Buffering )</h4>
<p>用以實現 CPU 能與 I/O 同時運作。可以想像成有一個超強者( CPU )，但是要跟一對弱者( I/O device )合作，是必要強者等待弱者將事情做完再交付給強者執行，而強者若要等到某一位弱者執行完後再執行太沒效率了，所以強者準備一個空間( 緩衝區 )給弱者將作完的工作丟入，再來就交由強者以不同策略使用緩衝區的資料達到最佳化。</p>
<ul>
<li>I/O Bound Job
<ul>
<li>因為需要大量的 I/O 工作，速度受限於 I/O 裝置速度。</li>
</ul></li>
<li>CPU Bound Job
<ul>
<li>因為需要大量的 CPU 計算，速度受限於 CPU 的處理速度。</li>
</ul></li>
</ul>
<h4 id="假脫機線上同時周邊處理技術-simultaneous-peripheral-operation-on-line-spool">假脫機－線上同時周邊處理技術( Simultaneous Peripheral Operation On-Line, SPOOL )</h4>
<p>又稱為「排隊緩存技術」；當系統中引入了多程序技術（Multiprocess）後，完全可以利用其中的一道程序，<strong>來模擬脫機輸入時的外圍控制機功能</strong>，把低速 I/O 設備上的數據傳送到高速磁碟上；<strong>再用另一道程序來模擬脫機（Off-line）輸出時外圍控制機的功能</strong>，把數據從磁碟傳送到低速輸出設備上。這樣，便可在主機的直接控制（On-line）下實現脫機輸入、輸出功能</p>
<figure>
<img src="\willywangkaa\images\1529918563313.png" alt="1529918563313" /><figcaption aria-hidden="true">1529918563313</figcaption>
</figure>
<ul>
<li>外圍操作與 CPU 對數據的處理可以<strong>同時進行</strong></li>
<li>「SPOOL」的需求
<ul>
<li>建立在具有多程序（Multiprocess）功能的作業系統</li>
<li><strong>高速隨機外存</strong>（磁碟存儲技術）</li>
</ul></li>
<li>組成
<ul>
<li>井：<strong>在磁碟上開闢的兩個大存儲空間</strong>
<ul>
<li>輸入井：模擬脫機輸入時的磁碟設備，<strong>用於暫存 I/O 設備輸入的數據</strong></li>
<li>輸出井：模擬脫機輸出時的磁碟，<strong>用於暫存用戶程序的輸出數據</strong></li>
</ul></li>
<li>緩衝區：為了緩解 CPU 和磁碟之間速度不匹配的矛盾，<strong>在內存（RAM）中要開闢兩個緩衝區</strong>
<ul>
<li>輸入緩衝區：<strong>暫存由輸入設備送來的數據，一旦緩衝區要滿出來了，再傳送到輸入井</strong></li>
<li>輸出緩衝區：暫存要送往輸出井送來的數據，往後再傳送給輸出設備</li>
</ul></li>
<li>「輸入程序 <span class="math inline">\(SP_i\)</span> 」 和「輸出程序 <span class="math inline">\(SP_o\)</span>」，利用兩個程序來模擬脫機 I/O 時的外圍控制機
<ul>
<li>「程序 <span class="math inline">\(SP_i\)</span>」：模擬脫機輸入時的外圍控制機，將用戶要求的數據從輸入機通過輸入緩衝區再送到輸入井，當CPU 需要輸入數據時，直接從輸入井讀入內存</li>
<li>「程序 <span class="math inline">\(SP_o\)</span>」模擬脫機輸出時的外圍控制機，把用戶要求輸出的數據先從內存送到輸出井，待輸出設備空閒時，再將輸出井中的數據經過輸出緩衝區送到輸出設備上。</li>
</ul></li>
</ul></li>
<li><strong>達到共享 I/O 裝置的目的</strong>
<ul>
<li>印表機（獨占設備）：當用戶進程請求列印輸出時，「SPOOLing 系統」<strong>同意為它列印輸出，但並不真正立即把印表機分配給該用戶進程，而只為它做兩件事：</strong>
<ul>
<li>（1） 由「輸出程序」在輸出井中為之<strong>申請一個空閒磁碟塊區</strong>，並將要列印的數據送入其中</li>
<li>（2） 「輸出程序」再為用戶程序<strong>申請一張空白的用戶請求列印表，並將用戶的列印要求填入其中，再將該表掛到請求列印隊列上</strong></li>
<li>（3）<strong>如果還有進程要求列印輸出，系統仍可接受該請求，</strong>也同樣為該進程做上述兩件事</li>
<li>（4）如果印表機空閒，輸出進程將從請求列印隊列的隊首取出一張請求列印表，根據表中的要求將要列印的數據，從輸出井傳送到內存緩衝區，再由印表機進行列印</li>
<li>（5）列印後，輸出進程再查看請求列印隊列中是否還有等待列印的請求表。若有，又取出隊列中的第一張表，並根據其中的要求進行列印</li>
<li>（6）直至請求列印隊列為空，輸出進程才將自己阻塞( Blocked )，僅當下次再有列印請求時，輸出進程才被喚醒( Wake up )</li>
</ul></li>
</ul></li>
<li>Pros
<ul>
<li><strong>提高 I/O 的速度</strong>
<ul>
<li>從對低速 I/O 設備進行操作，<strong>演變為對輸入井或輸出井中數據的存取，如同脫機輸入輸出一樣</strong>，提高了 I/O 使用率，<strong>緩解了 CPU 與 I/O 設備之間速度不匹配的矛盾</strong></li>
</ul></li>
<li><strong>將獨占設備視為為共享設備</strong>
<ul>
<li>「SPOOLing 系統」中，<strong>實際上並沒為任何進程分配設備，而只是在輸入井或輸出井中為進程分配一個存儲區和建立一張「I/O 請求表」</strong></li>
</ul></li>
<li><strong>實現了虛擬設備功能</strong>
<ul>
<li>宏觀上，雖然是多個程序在同時使用一台獨占設備，而對於每一個程序會認為自己獨占了一個設備（ 邏輯上的設備）</li>
<li>「SPOOLing 系統」<strong>實現了將獨占設備變換為若干台對應的邏輯設備的功能</strong></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>Spool 與 Buffer 的差異性</p>
<ul>
<li>Spool 允許有程序在執行 CPU 運算時，<strong>可以有其他的程序的 I/O 運算同時進行（Overlay execution）</strong></li>
<li>Buffer 允許有<strong>程序執行 CPU 運算時同時運算（Overlay execution）該程序的 I/O 運算</strong></li>
</ul>
</blockquote>
<h2 id="系統種類---system-type">系統種類 - System Type</h2>
<h3 id="多元程序系統---multiprogramming-system">多元程序系統 - Multiprogramming System</h3>
<p><strong>允許系統 ( 或在記憶體 ) 中存在多個 Process ( 處理程序 ) 同時執行</strong>；透過 CPU Scheduling 技術，當某個 Process 取得 CPU 執行時，若因為某些事件發生（如：Wait for I/O completed 、Resource Not Available...）而無法往下執行時，作業系統可將 CPU 切換給其他 Process 使用，則 CPU 在各個 Processes 切換，可以使 CPU 的使用率提升</p>
<ul>
<li><p>主要用於避免 CPU 的空等（Idle），提高 CPU 效能（Utilization）</p></li>
<li><p>Multiprogramming Degree</p>
<ul>
<li><strong>系統中存在執行的 Process 個數</strong></li>
<li>通常 Multiprogramming Degree 越高，<strong>且非為 Thrashing 狀態</strong>，則 CPU 效能越高</li>
</ul></li>
</ul>
<p>多個 Process 同時執行的方法：</p>
<ul>
<li>Concurrent ( 並行 )：<strong>一個 CPU，多個 Processes 共同使用</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530087435637.png" alt="1530087435637" /><figcaption aria-hidden="true">1530087435637</figcaption>
</figure>
<ul>
<li>Parallel ( 平行 )：<strong>多核心 CPU 共同執行多個 Processes</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530087726413.png" alt="1530087726413" /><figcaption aria-hidden="true">1530087726413</figcaption>
</figure>
<h3 id="分時系統---time-sharing-system">分時系統 - Time Sharing System</h3>
<p>It's a <strong>logical extension of multiprogramming system, the CPU in this kind of system switch highly frequently.</strong></p>
<ul>
<li>Multiprogramming 的一種，又可以稱為「Multitasking」
<ul>
<li><strong>與 Multiprogramming 的差異在於 CPU 切換的頻率極高</strong></li>
</ul></li>
<li><strong>排班使用「RR(Round-Robin) 法則」</strong>：作業系統規定一個 CPU Time Quantum，<strong>若 Process 在取得CPU後，未能於區段內完成工作，則必須被迫放棄CPU，等待下一次輪迴</strong>
<ul>
<li><strong>通常 Quantum 時間很短</strong></li>
<li>對每個使用者 ( 程序 ) 是公平的</li>
</ul></li>
<li>適用在「User Interactive System」（互動式作業系統 ）或「Response Time」（反應時間）要求較短的系統</li>
<li>透過「Resource Sharing 技術」（CPU資源 - CPU scheduling、記憶體資源 - Memory sharing、I/O 裝置資源 - Spooling )，<strong>使得每個使用者 ( 程序 ) 皆認為享有專屬的資源</strong>
<ul>
<li><strong>Virtual Memory 技術，擴展邏輯的記憶體空間 ( Virtual Memory Space )。</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530091014614.png" alt="1530091014614" /><figcaption aria-hidden="true">1530091014614</figcaption>
</figure>
<h3 id="分散式系統---distributed-system">分散式系統 - Distributed System</h3>
<h4 id="多處理器系統---multiprocessors-system-緊密耦合---tightly-coupled">多處理器系統 - Multiprocessors System ( 緊密耦合 - Tightly Coupled )</h4>
<p>又稱為 Mulitprocessing、Parallel system。</p>
<ul>
<li>在一台機器 ( 或是在主機板 ) 中，具有多顆 CPUs ( 或是 Processors )。
<ul>
<li><strong>共享此機器的資源：</strong><br>1. Memory<br>2. Bus<br>3. I/O - Devices<br>4. Power supplier</li>
<li><strong>通常聽從同一個時脈器 ( Clock )。</strong></li>
<li><strong>通常由通一個作業系統管理。</strong></li>
<li><strong>CPUs 溝通藉由「共享記憶體 - Shared memory」的方式完成。</strong></li>
<li>可以進行平行運算 ( Parallel computing )。</li>
</ul></li>
<li><strong>Pros</strong>
<ul>
<li><strong>增加吞吐量 ( Throughput )</strong>：可以使多個程序在不同的 CPUs 上執行 ( Parallel computing )。<br><strong>＜Note＞：「 N 個 CPUs 之產能」&lt;&lt;「一個有 N 倍 CPU 的產能」，因為會有問題存在使得產能抵銷：</strong><br>1. Resource contention - 資源競爭。<br>2. Processor 之間的 communication。</li>
<li><strong>增加可靠度 ( Reliability )：若有一個 CPUs 在執行時失效，然而還有其餘的 CPUs 可以繼續執行，使得系統不會因此停頓。</strong><br><strong>＜Note＞</strong><br>1. <strong>Graceful degradation</strong> ( 漸進式滅亡 )：又稱為「Fail - soft」，<strong>系統不會因為某些硬體或是軟體元件故障而停頓，仍然保持運作的能力。</strong><br>2. <strong>Faild - Tolerent system ( 容錯系統 )：具有「Graceful degradation」特性的系統。</strong></li>
<li><strong>提升運算的經濟效益 ( Economy of scale )</strong>：因為「N 個 CPUs 在同一部機器」<strong>可共享該機器的資源 ( Memory、Bus、I/O - devices ... ) </strong>，所以較於「N 部機器」更為便宜而寫有效率。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530093944139.png" alt="1530093944139" /><figcaption aria-hidden="true">1530093944139</figcaption>
</figure>
<h5 id="symmtric-multiprocessor---smp">Symmtric Multiprocessor - SMP</h5>
<p><strong>每個 Processors 的工作能力是相同的 ( Identical )，並且每個 Processors 皆有對等的權利存取資源。</strong></p>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>可靠度較為 ASMP 高。</strong></li>
<li><strong>效能較高。</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>SMP 的作業系統開發互斥存取的機制，使得設計較為複雜。</strong></li>
</ul></li>
</ul>
<h5 id="asymmtric-multiprocessor---asmp">Asymmtric Multiprocessor - ASMP</h5>
<figure>
<img src="\willywangkaa\images\ASMP_2.png" alt="ASMP_2" /><figcaption aria-hidden="true">ASMP_2</figcaption>
</figure>
<p><strong>每個 Processors 的工作能力不盡相同，通常採取「Master-Slave ( Boss-Employee )」架構。Master Processor 負責工作分派、資源分配與監督 Slave Processor 等管理工作，</strong>其餘的 Slave Processors 負責執行工作。</p>
<ul>
<li>Pros
<ul>
<li><strong>因為與開發「Single - CPU」的作業系統相似，所以相較為簡單。</strong></li>
</ul></li>
<li>Cons
<ul>
<li><strong>可靠度較為 SMP 低。</strong></li>
<li><strong>由於 Master Procrssor 是效能的瓶頸，所以效能較低。</strong></li>
</ul></li>
</ul>
<h5 id="multiprocessor-v.s-multicore-processor">「Multiprocessor」 V.S 「Multicore Processor」</h5>
<ul>
<li><strong>依作業系統的設計觀點是沒有差異的。( 將一個 Core 視為一個 logical CPU 資源 )</strong>
<ul>
<li>$Ex. $ 主機板中有 4 顆 Duel-core CPUs ，對於作業系統來說，視為 <span class="math inline">\(4 \times 2 = 8\)</span> 個 CPUs 可以使用。</li>
</ul></li>
<li>Multiprocessor</li>
</ul>
<figure>
<img src="\willywangkaa\images\1530099598137.png" alt="1530099598137" /><figcaption aria-hidden="true">1530099598137</figcaption>
</figure>
<ul>
<li>Multicore Processor
<ul>
<li>Pros<br>1. Power Saving<br>2. 因為在同一個晶片之內，傳輸的速度較快。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\multicore.png" alt="multicore" /><figcaption aria-hidden="true">multicore</figcaption>
</figure>
<h4 id="分散式系統---distributed-system-1">分散式系統 - Distributed System</h4>
<p>又<strong>稱為「Loosely-Coupled system ( 鬆散耦合系統 )」。</strong></p>
<ul>
<li>多部機器彼此透過網路( Network )、Bus 的方式相互串聯。</li>
<li>每部機器之 CPU 都有各個自有的 Memory、Bus、I/O-device ... ，<strong>且並不共享，Clock time 也不盡相同</strong>。</li>
<li>每部機器的作業系統也不盡相同。</li>
<li><strong>溝通採用「Message Passing」的方式。</strong>
<ol type="1">
<li>建立連線 ( Communication Link )。</li>
<li>Message 相互傳輸。</li>
<li>釋放連結 ( Link )。</li>
</ol></li>
<li>實現「Client - Server Computing Model」
<ul>
<li>Server：提供服務的機器。<br>$Ex. $ Mail server、File server、DNS、Printer server、Computing server...。</li>
<li>Client：本身不提供服務，當需要某項服務時，向對應的 Server 發出請求，當 Server 服務完成，再將結果回傳至 Client。</li>
<li><strong>＜Note＞：「Peer-to-Peer Model」</strong><br>Peer：同時具有 Server 與 Client 的角色。</li>
</ul></li>
<li><strong>用以實現「Remote site communication」</strong>
<ul>
<li>$Ex. $ 透過網際網路可以實現 Email、FTP。</li>
</ul></li>
<li>Pros
<ul>
<li><strong>Computation speed up - 增加吞吐量 ( Throughput )</strong>：</li>
<li><strong>增加可靠度 ( Reliability )</strong>：</li>
<li><strong>Resource Sharing - 提升運算的經濟效益 ( Economy of scale )</strong>：所以成本低。</li>
</ul></li>
</ul>
<h3 id="即時系統---real-time-system">即時系統 - Real-time System</h3>
<h4 id="hard-real-time-system">Hard Real-time System</h4>
<figure>
<img src="\willywangkaa\images\1530103496272.png" alt="1530103496272" /><figcaption aria-hidden="true">1530103496272</figcaption>
</figure>
<p><strong>This system must ensure the critical task completed on time.</strong></p>
<p><strong>工作必須要再規定的時間內完成，否則會有重大危害的狀況發生。</strong></p>
<ul>
<li>設計考量：
<ul>
<li>所有時間延遲之因素皆須納入考量( 如：感測器資料傳輸速度、運算速度、Signal 傳輸速度... )，<strong>並且確保這些時間加總能在 Deadline 前做完</strong>。</li>
<li><strong>所有會造成時間過久或無法預測之設備或機制，最好少用或不要使用。</strong><br>$Ex. $ <strong>磁碟 ( Disk ) 最好少用或不用、虛擬記憶體 ( Virtual Memory ) 絕不使用。</strong></li>
<li>針對 CPU 排班的設計，<strong>需要先考量是否可排程化 ( Schedulable )，在進行排程規劃 ( 如：Rate-monotonic、EDF scheduling )。</strong></li>
</ul></li>
<li><strong>Time sharing system 無法與 Hard real-time system 並存。</strong></li>
<li><strong>現行的商用作業系統不支援 Hard Real-time 的特性</strong>。( 通常保留於客製化的作業系統之中。 )</li>
<li><strong>作業系統造成的「Dispatch latency」要盡量降低。</strong>
<ul>
<li><strong>＜Note＞：一般實務上，Hard Real-time System 少有作業系統的存在。</strong></li>
</ul></li>
<li>應用於：<strong>軍事防衛系統、核能安控系統、工廠自動化生產、機器人控制 ...。</strong></li>
</ul>
<h4 id="soft-real-time-system">Soft Real-time System</h4>
<p><strong>This system must ensure the real-time process get the highest priority than the others and retain this priority level until it completed.</strong></p>
<ul>
<li>應用於：<strong>Multimedia system、Simulation system、VR system ...。</strong></li>
<li>針對 CPU 排班的設計
<ul>
<li><strong>必須支持「Preemptive priority scheduling - 可插隊排程」。</strong></li>
<li><strong>不可提供「Aging」功能。</strong></li>
</ul></li>
<li>儘量降低核心 ( kernel ) 的 Dispatch latency time。</li>
<li><strong>可支援 Virtual memory，但是要求 Real-time processes 的全部 pages 在完工前，必須置於記憶體之中。</strong></li>
<li><strong>可以與「Time-sharing system」並存。</strong>
<ul>
<li>$Ex. $ <strong>Solaris</strong>。</li>
</ul></li>
<li><strong>一般商用作業系統皆支持 Soft real-time system 的功能。</strong></li>
</ul>
<h3 id="批次系統---batch-system">批次系統 - Batch system</h3>
<p><strong>將一些較不緊急、定期性、非交談互動性 ( non-interactive ) 的工作，</strong>累積成堆，再分批送入系統處理。</p>
<ul>
<li><p><strong>主要目的：提高資源的利用度 ( Resource utilization )</strong></p>
<ul>
<li>利用冷門時段的時間批次將工作送入執行。</li>
</ul></li>
<li><p><strong>不適合用於 Real-time system、User-interactive application。</strong></p></li>
<li><p>$Ex. $ <strong>庫存盤點、報稅、掃毒、磁碟重組、清算系統 ...。</strong></p></li>
</ul>
<h3 id="掌上型系統---hand-held-system">掌上型系統 - Hand Held System</h3>
<ul>
<li>$Ex. $ PDA、Smartphone (智慧型手機)、PAD (平板) ...。</li>
<li><strong>硬體天生的限制會導致軟體必須配合的功能。</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th>硬體限制</th>
<th>軟體應對設計</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>因為<strong>電源供應、散熱不易</strong>所以閹割處理器的性能</td>
<td><strong>運算量宜簡單</strong></td>
</tr>
<tr class="even">
<td><strong>記憶體有限</strong></td>
<td>程式量宜小，並且要適當的管理記憶體，將不用的記憶體立刻釋放。</td>
</tr>
<tr class="odd">
<td><strong>顯示器很小 ( 解析度、長寬比 )</strong></td>
<td><strong>顯示內容精簡化</strong> ( 手機網站須有所刪減 )</td>
</tr>
</tbody>
</table>
<h2 id="io-運作方式">I/O 運作方式</h2>
<h3 id="詢問式-io---polling-io">詢問式 I/O - Polling I/O</h3>
<p>又稱為 Busy-waiting I/O、programmed I/O 。</p>
<ul>
<li>操作流程
<ol type="1">
<li>User process 發出 I/O 要求給作業系統。</li>
<li>作業系統收到請求後，( 有可能 )會暫停目前此 process 的執行，並執行對應的 System calls。</li>
<li>Kernel 的「 I/O 子系統 ( subsystem )」會將該請求傳給「裝置驅動程式 ( Device driver )」。</li>
<li>裝置驅動程式依照此請求設定對應的「 I/O 指令參數( Commands )」給予「裝置控制器 ( Device Controller )」。</li>
<li>裝置控制器起動，監督 I/O 設備的運作進行，</li>
<li>在這個時候，作業系統 ( 可能 ) 將 CPU 交付給另一個 Process 執行。</li>
<li><strong>但是 CPU 在執行 Process 工作的過程中，卻要不斷去 Polling 裝置控制器以確保 I/O 運作是否完成或有 I/O-Error。</strong></li>
</ol></li>
<li><strong>Cons</strong>
<ul>
<li><strong>CPU 耗費大量時間用於 Polling I/O 裝置控制器上，並未全用於 Process 執行，所以 CPU 的效能 ( Utilization ) 低，產量 ( Throughput ) 低。</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530157733165.png" alt="1530157733165" /><figcaption aria-hidden="true">1530157733165</figcaption>
</figure>
<h3 id="中斷式-io---interrupted-io">中斷式 I/O - Interrupted I/O</h3>
<ul>
<li>操作流程
<ol type="1">
<li>User process 發出 I/O 要求給作業系統</li>
<li>作業系統收到請求後，<strong>( 有可能 )</strong>會暫停目前此 process 的執行，並執行對應的 System calls。</li>
<li>Kernel 的「 I/O 子系統 ( subsystem )」會將該請求傳給「裝置驅動程式 ( Device driver )」。</li>
<li>裝置驅動程式依照此請求設定對應的「 I/O 指令參數( Commands )」給予「裝置控制器 ( Device Controller )」。</li>
<li>裝置控制器起動，監督 I/O 設備的運作進行，</li>
<li>在這個時候，作業系統 ( 可能 ) 將 CPU 交付給另一個 Process 執行。</li>
<li><strong>當 I/O 運作完成，裝置控制器會發出「I/O-completed」的中斷 ( Interrupt ) 通知作業系統 ( CPU )。</strong></li>
<li><strong>作業系統收到中斷後 ( 可能 ) 會先暫停目前 Process 的執行。</strong></li>
<li><strong>作業系統必須查詢「Interrupt Vector ( 中斷向量表 )」，確認是何種中斷發生，同時也要找到該中斷之服務處理程式的位置 ( ISR：Interrupt service routine )。</strong></li>
<li><strong>跳至 ISR 位置並執行 ISR。</strong></li>
<li><strong>ISR 完成後，交還使用權給 Kernel，</strong>Kernel 可能會作通知的動作給 User process。</li>
<li><strong>恢復 ( Resume ) 原先中斷前的中作執行 ( 或交由 CPU 排程器決定 )。</strong></li>
</ol></li>
<li>Pros
<ul>
<li><strong>CPU 不需耗費時間用於 Polling I/O 裝置上，而是可以用於 Process 執行上，所以 CPU 效能 ( Utilization ) 提升、產量 ( Throughput ) 提升。</strong></li>
</ul></li>
<li>Cons
<ul>
<li>中斷 ( Interrupt ) 處理仍需耗費 CPU 的工作時間。</li>
<li><strong>＜Note＞：若「I/O 運作的時間」&lt;「中斷處理時間」，則使用中斷 I/O 就不是一個好選擇，因此 Polling 還是有其存在必要性。</strong></li>
<li>若<em>中斷發生的頻率太高</em>，則大量的中段處理會占用幾乎全部的 CPU 工作時間，導致系統效能很差。</li>
<li><strong>CPU 仍需耗費一些時間用於監督 I/O 裝置與記憶體之間的「資料傳輸」過程。</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530159007395.png" alt="1530159007395" /><figcaption aria-hidden="true">1530159007395</figcaption>
</figure>
<h3 id="dma-direct-memory-access-io">DMA (Direct Memory Access) I/O</h3>
<p>DMA-controller 負責 I/O 裝製與記憶體之間的資料傳輸工作，過程中<strong>無須 CPU 5 參與監督，所以讓 CPU 有更多時間用於 Process 執行上。</strong></p>
<ul>
<li>Pros
<ul>
<li><strong>CPU 效能 ( Utilization ) 更高。</strong></li>
<li><strong>適合用在「Block-transfer oriented I/O-device」上 ( 因為中斷發生頻率不至於過高 )，如：Disk</strong>。<br><strong>＜Note＞：不適合用在「Byte-transfer oriented I/O-device」。</strong></li>
</ul></li>
<li>Cons
<ul>
<li><strong>因為 DMA 控制器( controller ) 會與 CPU 競爭記憶體與 Bus 的使用權，當控制器占用記憶體或是Bus時，CPU 要被迫等待，所以引進 DMA 控制器增加硬體設計的複雜度。</strong></li>
</ul></li>
<li><strong>DMA controller</strong>
<ul>
<li><strong>通常採用「Cycle stealing (Interleaving)」技術，與 CPU 輪替使用記憶體以及 Bus，若 CPU 與 DMA controller 發生衝突 ( conflict：同時要使用記憶體或 Bus )，則會給予 DMA 較高的優先權。</strong></li>
<li>通常系統會給予「對該資源需求量頻率較小」的對象<strong>有較高的優先權，可以使得</strong><br>1. 平均等待時間較小。<br>2. 平均產能較高。</li>
</ul></li>
</ul>
<h1 id="參考">參考</h1>
<hr />
<ul>
<li><a href="https://read01.com/zh-tw/6m34Gn.html">SPOOLing技術</a></li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Basic Concept</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System - Disk Management</title>
    <url>/willywangkaa/2018/09/10/Operating-System-Disk-Management/</url>
    <content><![CDATA[<h1 id="disk-management">Disk management</h1>
<h2 id="disk-system">Disk system</h2>
<figure>
<img src="\willywangkaa\images\disksystem.png" alt="disksystem" /><figcaption aria-hidden="true">disksystem</figcaption>
</figure>
<ul>
<li>硬碟系統由多片「Disk」( 磁片 ) 組成
<ul>
<li>每片磁片通常雙面都可存取資料。</li>
<li>每一面劃分為多個同心圓軌道，稱為「Track」( 磁軌 )。</li>
<li>每條「Track」由多個「Sector」( 磁區 ) 組成。</li>
<li>不同面之相同「Track no.」組成之集合叫做「Cyclinder」( 磁柱 )。</li>
</ul></li>
<li>Ex
<ul>
<li>Disk system 有 10 片磁片</li>
<li>每片皆雙面存取</li>
<li>每面有 2048 條磁軌</li>
<li>每條磁軌有 4096 個磁區。</li>
<li>每個磁區可以存 16 kB 資料</li>
<li>求 Disk system 可存放大小？</li>
</ul></li>
</ul>
<p><span class="math display">\[
( 10 \times 2 ) \times 2048 \times 4096 \times 16 kB = 2.5 \;TB
\]</span></p>
<h2 id="disk-access-time">Disk access time</h2>
<ul>
<li><p><strong>Seek time</strong>：<strong>將磁頭移至愈存取的磁軌上方所花的時間</strong>。</p></li>
<li><p><strong>Latency time ( or Rotation time )：將欲存取之磁區轉到磁頭下方所花的時間。</strong></p></li>
<li><p><strong>Transfer time：資料在磁碟與記憶體之間傳輸的時間</strong>，與傳輸量呈正比關係。</p></li>
<li><p>Ex</p>
<ul>
<li>磁碟轉速 7200 RPM</li>
<li>求平均 Latency ( rotation ) time？</li>
</ul></li>
</ul>
<p><span class="math display">\[
Avg. Latency \;( rotation ) \;time = \frac12 \times \frac{1}{7200} \;MPR = \frac{60}{14400} \;SPM = \frac{1}{240} \;second
\]</span></p>
<ul>
<li>Ex
<ul>
<li>Disk system 有 3 片磁片</li>
<li>雙面可存</li>
<li>每面有 1024 條磁軌</li>
<li>每條磁軌有 4096 個磁區</li>
<li>每個磁區可存 32 kB</li>
<li>轉速 6000 RPM</li>
<li>求 Transfer rate ( 每秒可傳輸多少量的資料 )</li>
<li><strong>＜Note＞ 每轉一圈可傳輸一個磁柱的容量</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
\frac{6000}{60} \;RPS \times ( ( 3 \times 2 )\;磁軌 \times (4096 \times 32 \;kB) ) = 600 \times 128 \;MB/sec
\]</span></p>
<ul>
<li>Ex
<ul>
<li>Disk system 有 3 片磁片</li>
<li>雙面可存</li>
<li>每面有 1024 條磁軌</li>
<li>每條磁軌有 4096 個磁區</li>
<li>每個磁區可存 32 kB</li>
<li>轉速 6000 RPM</li>
<li><strong>磁碟的平均「Seek time」 = 10 ms</strong></li>
<li>讀取一個大小為 2 MB 的檔案，要花多少 I/O time？</li>
</ul></li>
</ul>
<p><span class="math display">\[
10 \;ms + \frac{1}{2} \times \frac{60}{6000} \;SPR + \frac{2 \;MB}{600\times128 \;MB/sec} \\
= 10 ms + 5ms + \frac{10}{3\times128} ms
\]</span></p>
<h2 id="disk-free-space-management">Disk free space management</h2>
<ul>
<li><strong>Block</strong>
<ul>
<li><strong>磁碟配置空間及存取的最基本單位。</strong></li>
</ul></li>
</ul>
<h3 id="bit-vector-bitmap">Bit vector ( Bitmap )</h3>
<p>每一個 Block 皆用一個bit 表示空閒與否 <span class="math inline">\(\left\{\begin{matrix}0 &amp;：&amp; 代表空閒\\1 &amp;：&amp; 代表已被配置 \end{matrix}\right.\)</span> 。若磁碟有 n 個 Blocks，則 Bit vector 大小為 <strong>n bits</strong>。</p>
<ul>
<li>Pros
<ul>
<li>簡單容易實施。</li>
<li><strong>容易找到連續的閒置空間 ( 利用演算法找到連續足夠的 0 )。</strong></li>
</ul></li>
<li>Cons
<ul>
<li><strong>適用於小型磁碟；不適用於大型磁碟 ( Blocks 數量龐大造成 Bit vector size 太大，占用記憶體空間 )。</strong></li>
</ul></li>
<li>Ex</li>
</ul>
<figure>
<img src="\willywangkaa\images\bitvector.png" alt="bitvector" /><figcaption aria-hidden="true">bitvector</figcaption>
</figure>
<h3 id="link-list">Link list</h3>
<figure>
<img src="\willywangkaa\images\linklistfreespace.png" alt="linklistfreespace" /><figcaption aria-hidden="true">linklistfreespace</figcaption>
</figure>
<p>作業系統直接在磁碟上，將這些「Free block」以鍊結的方式串接管理。</p>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>適用於大型磁碟</strong></li>
<li><strong>插入/刪除「Free block」簡單</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li>找尋大量的可用「Block」不夠迅速( <strong>因為在磁碟上進行 I/O 讀取「鍊結資訊」非常耗時</strong> )<br><strong>＜Note＞ 使用「Grouping」改善</strong></li>
<li><strong>不容易找到「連續的Free block」</strong><br><strong>＜Note＞ 使用 「Counting」改善</strong></li>
</ul></li>
</ul>
<h4 id="grouping">Grouping</h4>
<p><strong>在「Free block」內除了紀錄「鍊結資訊」，額外紀錄其他「Free block」之編號。 ( Address )</strong></p>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>可快速找到大量的「Free block」</strong></li>
</ul></li>
<li>Ex ( 令一個 Block 可以記錄 5 個欄位 )</li>
</ul>
<figure>
<img src="\willywangkaa\images\Linklist_grouping.png" alt="Linklist_grouping" /><figcaption aria-hidden="true">Linklist_grouping</figcaption>
</figure>
<h4 id="counting">Counting</h4>
<p>利用連續性配置以及歸還的特性，改變鍊結串列紀錄的方式；Free block 內除了紀錄 鍊結資訊以外，<strong>另外紀錄在此 Free block 之後的連續「Free block」的個數。</strong></p>
<ul>
<li>Pros
<ul>
<li><strong>適用於連續性配置，方便找到「連續的 Free block」，若連續的 Free block 很多「Link list」 長度也可大幅縮短。</strong></li>
</ul></li>
<li>Ex</li>
</ul>
<figure>
<img src="\willywangkaa\images\Linklist_counting.png" alt="Linklist_counting" /><figcaption aria-hidden="true">Linklist_counting</figcaption>
</figure>
<h2 id="file-allocation-method">☆File Allocation method</h2>
<h3 id="contiguous-allocation">Contiguous allocation</h3>
<figure>
<img src="\willywangkaa\images\contiguousallocation.png" alt="contiguousallocation" /><figcaption aria-hidden="true">contiguousallocation</figcaption>
</figure>
<p>若檔案的大小為 n Block，則作業系統必須在磁碟中找到 n 個「連續的 Free block」，才能配置給它，此外作業系統在「Physical directory」會記錄下列資訊。</p>
<ol type="1">
<li><p>File name</p></li>
<li><p>Start block number</p></li>
<li><p>Size ( 區塊數量 )</p></li>
</ol>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>因為連續的 Block 大多落在同一條磁軌或鄰近的磁軌上，所以平均的 Seek time 較小。</strong></li>
<li><strong>可以支持 Random direct access</strong> ( 任意存取該檔案 i-th block )與 Squential access。<br><span class="math inline">\(i－th \;block \;no. = Start \;no. + (i-1)\)</span></li>
<li><strong>與「Linked allocation」相比，可靠度較高。</strong></li>
<li><strong>與「Linked allocation」相比，循序存取速度較快。</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>會有外部碎裂的問題</strong><br>磁碟使用磁碟重組 ( Repack )方式解決，<strong>類似記憶體中的「Compaction」</strong><br><strong>＜Note＞ 因為所有的檔案是以 Block 為單位在配置，所以所有配置方法都有「內部碎裂」問題</strong>
<ul>
<li>Ex
<ul>
<li>Block size = 10 kB</li>
<li>檔案大小 = 44 kB</li>
<li>所以配置 5 block</li>
<li>內部碎裂 = (5 × 16) - 44 = 6 kB</li>
</ul></li>
</ul></li>
<li><strong>檔案不易動態擴充</strong></li>
<li><strong>建檔之前必須事先宣告大小</strong></li>
</ul></li>
<li>Ex (如上圖)
<ul>
<li>檔案{ Count } 的大小為 2 block ( Block1 , Block2 )</li>
<li>作業系統在「Physical directory」紀錄資訊如上圖右側。</li>
</ul></li>
</ul>
<h3 id="linked-allocation">Linked allocation</h3>
<figure>
<img src="\willywangkaa\images\Linkallocation.png" alt="Linkallocation" /><figcaption aria-hidden="true">Linkallocation</figcaption>
</figure>
<p>若檔案大小為 n Block，則作業系統只需要在磁碟中找到 n 個 Free blocks <strong>(不需連續)</strong> 即可配置，且「Allocates block」 之間以鍊結方式串聯，另外作業系統在「Physical directory」紀錄：</p>
<ol type="1">
<li>File name</li>
<li>Start block no.</li>
<li>End block no.</li>
</ol>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>無外部碎裂的問題</strong></li>
<li><strong>檔案容易動態擴充</strong></li>
<li><strong>建檔之前必不須事先宣告大小</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>因為不連續的 Block 可能散落在不同條磁軌上，所以平均的 Seek time 較大。</strong></li>
<li><strong>不支援 Random direct access</strong> 使用者的觀點還仍是 Random access 但實際上是先經由 Sequential access 讀至記憶體。</li>
<li><strong>與「Contiguous allocation」相比，若鍊結一旦斷裂資料毀損，可靠度較低。</strong></li>
<li><strong>與「Contiguous allocation」相比，要在磁碟上讀取鍊結的資訊，才知道下一個 Block 為何，所以循序存取速度較慢。</strong></li>
</ul></li>
</ul>
<h4 id="file-allocation-table-fat-method---microsoft-windows-採用">File Allocation Table (FAT) method - Microsoft windows 採用</h4>
<figure>
<img src="\willywangkaa\images\fileallocationtable.png" alt="fileallocationtable" /><figcaption aria-hidden="true">fileallocationtable</figcaption>
</figure>
<p><strong>「Allocates block」之間的鍊結資訊存在於「作業系統記憶體區塊」中的一個表格稱為 FAT</strong>，並非存於磁碟中。</p>
<ul>
<li><strong>Pros</strong>
<ul>
<li>讓「Link allocation」在作「Random access」時能加速
<ul>
<li>因為可使用存在於記憶體中的「FAT」快速 ( 不用 I/O ) 找到第 i 個 Block 的編號，接著再到磁碟存取該 Block 即可。( <strong>不用在磁碟中追蹤該鍊結的資訊</strong> )</li>
</ul></li>
</ul></li>
</ul>
<h3 id="index-allocation">Index allocation</h3>
<figure>
<img src="\willywangkaa\images\indexallocation.png" alt="indexallocation" /><figcaption aria-hidden="true">indexallocation</figcaption>
</figure>
<p>若檔案大小為 n 個 Block，則作業系統配置 n 個 Block ( <strong>無須連續</strong> ) 存放資料之外，<strong>另外需要額外配置「Index block」，儲存所有 Data block 的編號( Address )，</strong>且作業系統在「Physical directory」紀錄：</p>
<ol type="1">
<li>File name</li>
<li><strong>Index block no.</strong></li>
</ol>
<ul>
<li>Pros
<ul>
<li><strong>不會有外部碎裂問題</strong></li>
<li><strong>支援「有效率的 Random access」</strong>與 Sequential access</li>
<li>檔案大小容易動態擴充</li>
<li>建檔之前無須事先宣告大小</li>
</ul></li>
<li>Cons
<ul>
<li><strong>Index block 會占用額外的空間</strong></li>
<li><strong>Link space 浪費 ( Overhead ) 比「Linked allocation」大很多</strong></li>
<li><strong>若檔案很大，則單一個 Index block 可能無法容 ( 保存 ) 納所有 data block no.</strong></li>
</ul></li>
</ul>
<blockquote>
<p><strong>＜解決單一個 Index block 不夠存放所有 data block 的問題＞</strong></p>
<ul>
<li>Linking scheme - 使用多個 Index block，<strong>且彼此以鍊結串接。</strong>
<ul>
<li><strong>Cons</strong>
<ul>
<li>要對 i-th block 作 Random access 之平均 I/O 次數大幅增加</li>
</ul></li>
<li>Ex ( 令一個 Index block 可存放 5 個 no. )</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\linksheme.png" alt="linksheme" /><figcaption aria-hidden="true">linksheme</figcaption>
</figure>
<ul>
<li>Multilevel scheme - 使用階層式的 Index 架構
<ul>
<li>Pros
<ul>
<li>要對 i-th block 作 Random access 之平均 I/O 次數一致</li>
</ul></li>
<li>Cons
<ul>
<li>因為 index block 太佔空間，甚至多於 data block 數量，<strong>所以極不適合小型檔案</strong>。</li>
</ul></li>
<li>Ex ( Two-level index structure )</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\mulitilevelscheme.png" alt="mulitilevelscheme" /><figcaption aria-hidden="true">mulitilevelscheme</figcaption>
</figure>
<ul>
<li>Combined scheme - UNIX i-node
<ul>
<li>見下面細述</li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>Ex (如上圖)  - 若檔案 ｛jeep｝ 大小為 5 block  - 作業系統已配置 ｛9 , 16, 1, 10 ,25｝ 號 block 給它存放資料，另外配置 19 號 block 作為「Index block」
<ul>
<li>「Physical directory」( 上圖右上側 )</li>
</ul></li>
</ul>
<h4 id="unix-i-node">☆ UNIX i-node</h4>
<figure>
<img src="\willywangkaa\images\unix_inode.png" alt="unix_inode" /><figcaption aria-hidden="true">unix_inode</figcaption>
</figure>
<ul>
<li>Ex ( i-node with 15 entry，一個 block 可存放 n 個指標 )
<ul>
<li><strong>1st ~ 12th entry：直接紀錄 data block no.</strong> ( 目前可記錄的 data block：12 )</li>
<li><strong>13th entry：為一指標指向「Single-level index」</strong> ( 目前可記錄的 data block：12 + n )</li>
<li><strong>14th entry：為一指標指向「Two-level index」</strong>( 目前可記錄的 data block：<span class="math inline">\(12 + n + n^2\)</span> )</li>
<li><strong>15th entry：為一指標指向「Three-level index」</strong>( 目前可記錄的 data block：<span class="math inline">\(12 + n + n^2+n^3\)</span> )</li>
</ul></li>
<li>Ex ( 正常的 i-node 定義沿用 )
<ul>
<li>Block size：16 kB</li>
<li>Block no. 占用 4 B</li>
<li>求 max file size 大小？</li>
</ul></li>
</ul>
<p>一個 index block 可存 <span class="math inline">\(\frac{16 \;kB}{4 \;B} = 2^{12}\)</span> data block no，所以</p>
<p><span class="math display">\[
max \;file \;size = ( 12 + 2^{12} + 2^{12^2} + 2^{12^3} ) block \\ 
= ( 12 + 2^{12} + 2^{12^2} + 2^{12^3} ) \times 16 \;kB \approx 2^{36} \times 16 \;kB = 2^{50} B = 1 \;PB
\]</span></p>
<ul>
<li>Ex ( 正常的 i-node 定義沿用 )
<ul>
<li>檔案大小為 8000 block</li>
<li>假設 i-node 已經在記憶體之中，則要存取此檔案的第 6000 data block 需要幾次 I/O？</li>
</ul></li>
</ul>
<p><span class="math display">\[
6000 - 12 = 5988 \\
6000 - 12 - 4096 = 1892 \\
\]</span></p>
<p><strong>在「Two level index」的 1892th block，所以需要三次 I/O 存取。</strong></p>
<ul>
<li>Ex ( 正常的 i-node 定義沿用 )
<ul>
<li>檔案大小為 8000 block</li>
<li>循序存取前 6000 個 data block，需要幾次 I/O？</li>
</ul></li>
</ul>
<p><span class="math display">\[
6000 + (1 \;single－level+ 2 \;two－level) = 6003
\]</span></p>
<h2 id="disk-scheduling-algorithm">Disk scheduling algorithm</h2>
<blockquote>
<p><strong>＜Note＞：Disk schduling 既無「最好」也無「最差」。</strong></p>
</blockquote>
<h3 id="fcfs-first-come-first-service">FCFS (First come first service)</h3>
<figure>
<img src="\willywangkaa\images\FCFSdiskscduale.png" alt="FCFSdiskscduale" /><figcaption aria-hidden="true">FCFSdiskscduale</figcaption>
</figure>
<p><strong>最早到達的磁軌請求</strong>優先服務。</p>
<ul>
<li><strong>Cons</strong>
<ul>
<li><strong>排班效果不佳、磁軌移動量大，「Seek time」較長</strong></li>
</ul></li>
<li>Pros
<ul>
<li><strong>公平；No starvation</strong></li>
</ul></li>
<li>Ex
<ul>
<li>磁碟有 200 軌，編號：0~199，<strong>磁頭目前停在第 53 軌</strong>，方才服務完第 60 軌，現在「Disk queue」中有上圖磁軌請求。</li>
<li>求磁軌移動總數</li>
</ul></li>
</ul>
<p><span class="math display">\[
|183-53|+|37-183|+|122-37|+\\
|14-122|+|124-14|+|65-124|+|67-65| = 640 \;軌
\]</span></p>
<h3 id="sstf-shortest-seek-time-track-first">SSTF ( Shortest seek time track first )</h3>
<figure>
<img src="\willywangkaa\images\SSTFdiskscheduale.png" alt="SSTFdiskscheduale" /><figcaption aria-hidden="true">SSTFdiskscheduale</figcaption>
</figure>
<p><strong>距離磁頭目前為址最近的磁軌要求</strong>，最優先服務。</p>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>排班效果不錯，需移動之磁軌數較少、「Seek time」小，【但並非為 Optimal scheduling】</strong>。<br>依照目前的題目使用 Look 法則會比較好。</li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>不公平，有可能會 Starvation</strong></li>
</ul></li>
<li>Ex
<ul>
<li>磁碟有 200 軌，編號：0~199，<strong>磁頭目前停在第 53 軌</strong>，方才服務完第 60 軌，現在「Disk queue」中有上圖磁軌請求。</li>
<li>求磁軌移動總數</li>
</ul></li>
</ul>
<p><span class="math display">\[
|67 - 53| + |14 - 67| + |183 - 14| = 236 \; 軌
\]</span></p>
<h3 id="scan">Scan</h3>
<figure>
<img src="\willywangkaa\images\SCANdiskschedule.png" alt="SCANdiskschedule" /><figcaption aria-hidden="true">SCANdiskschedule</figcaption>
</figure>
<p>磁頭來回雙向移動掃描，遇到有「磁軌請求」即執行服務，當磁頭遇到磁軌的開端或是盡頭時，才「折返」提供服務。</p>
<figure>
<img src="\willywangkaa\images\SCANdemo.png" alt="SCANdemo" /><figcaption aria-hidden="true">SCANdemo</figcaption>
</figure>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>適用於「大量負載的情況」</strong>，排班效能尚可接受。<br>由於磁軌請求有比較均勻的等待時間。</li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>在某些時候，對某些「磁軌請求」不盡公平。</strong>(下圖一)<br>＜Note＞：用「C-Scan 方法」解決。</li>
<li>磁頭需要遇到「磁軌開端或盡頭」才折返<strong>會耗費不必要的 Seek time</strong>。(下圖二)<br>＜Note＞：用「Look 方法」解決。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\SCANdemo2.png" alt="SCANdemo2" /><figcaption aria-hidden="true">SCANdemo2</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\SCANdemo3.png" alt="SCANdemo3" /><figcaption aria-hidden="true">SCANdemo3</figcaption>
</figure>
<ul>
<li>Ex
<ul>
<li>磁碟有 200 軌，編號：0~199，<strong>磁頭目前停在第 53 軌</strong>，<strong>方才服務完第 60 軌</strong>，現在「Disk queue」中有上圖磁軌請求。</li>
<li>求磁軌移動總數</li>
</ul></li>
</ul>
<p>(往小的方向) <span class="math display">\[
|53 - 0| + |0 - 183| = 236
\]</span></p>
<h4 id="c-scan-circular-scan">C-Scan ( Circular-scan )</h4>
<figure>
<img src="\willywangkaa\images\CSCANschedule.png" alt="CSCANschedule" /><figcaption aria-hidden="true">CSCANschedule</figcaption>
</figure>
<p><strong>只提供「單向的服務」</strong>，折返回程不提供服務。</p>
<blockquote>
<p><strong>＜爭議＞</strong></p>
<p><strong>是否需要將磁軌回程的移動量</strong><span class="math inline">\(\left\{\begin{matrix}列入\\ 不列入 \end{matrix}\right.\)</span> <strong>計算。</strong> ( 通常不列入 )</p>
</blockquote>
<ul>
<li>Ex</li>
<li><ul>
<li>磁碟有 200 軌，編號：0~199，<strong>磁頭目前停在第 53 軌</strong>，現在「Disk queue」中有上圖磁軌請求。</li>
<li>求磁軌移動總數</li>
</ul></li>
</ul>
<p><span class="math display">\[
|199-53|+|37-0|\\
OR \\
|199-53|+|37-0| + |199 - 0|
\]</span></p>
<h4 id="look">Look</h4>
<p>磁頭服務完該方向的最後一個「磁軌請求」後，<strong>即可折返提供回程服務。</strong></p>
<ul>
<li>Ex
<ul>
<li>磁碟有 200 軌，編號：0~199，<strong>磁頭目前停在第 53 軌</strong>，<strong>方才服務完第 60 軌</strong>，現在「Disk queue」中有上圖磁軌請求。</li>
<li>求磁軌移動總數</li>
</ul></li>
</ul>
<p>(往小的方向) <span class="math display">\[
|14 - 53| + |183 - 14|
\]</span></p>
<h5 id="c-look">C-Look</h5>
<figure>
<img src="\willywangkaa\images\CLOOKschedule.png" alt="CLOOKschedule" /><figcaption aria-hidden="true">CLOOKschedule</figcaption>
</figure>
<p><strong>只提供單向的服務。</strong></p>
<blockquote>
<p><strong>＜無爭議＞</strong></p>
<p><strong>需要將磁軌回程的移動量列入計算。</strong></p>
</blockquote>
<ul>
<li>Ex
<ul>
<li>磁碟有 200 軌，編號：0~199，<strong>磁頭目前停在第 53 軌</strong>，現在「Disk queue」中有上圖磁軌請求。</li>
<li>求磁軌移動總數</li>
</ul></li>
</ul>
<p><span class="math display">\[
|183 - 53| + |14-183| + |37 - 14|
\]</span></p>
<h3 id="補充">補充</h3>
<ul>
<li><strong>不同版本比對</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">恐龍教科書</th>
<th style="text-align: center;">Modern、其他版本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Scan</td>
<td style="text-align: center;">X</td>
</tr>
<tr class="even">
<td style="text-align: center;">C-Scan</td>
<td style="text-align: center;">X</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Look</td>
<td style="text-align: center;"><strong>Scan ( Elevator 法則 )</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">C-Look</td>
<td style="text-align: center;"><strong>C-Scan</strong></td>
</tr>
</tbody>
</table>
<h2 id="其它名詞">其它名詞</h2>
<h3 id="formatting-格式化">Formatting ( 格式化 )</h3>
<figure>
<img src="\willywangkaa\images\lowlevelformat.png" alt="lowlevelformat" /><figcaption aria-hidden="true">lowlevelformat</figcaption>
</figure>
<ul>
<li><strong>Physical format</strong> ( Low-level format )
<ul>
<li>工廠生產「Disk system」時執行</li>
<li>劃分出「Disk controller」可以存取的「磁區」(如上圖)</li>
<li>偵測有無「Bad sector」( 壞磁區 )</li>
</ul></li>
<li><strong>Logical format</strong>：在使用者使用磁碟之前必須執行
<ul>
<li>Partition：切割分區，即為「Logical drive」( E.g. C、D、E 磁碟機 )</li>
<li><strong>Logical format：作業系統製作(寫入) 「File management system」所需的資料結構。</strong>
<ul>
<li>空閒空間管理 ( E.g. bitvector )</li>
<li>FAT、i-node</li>
<li>空的「Physical directory」</li>
</ul></li>
</ul></li>
</ul>
<h3 id="row---io">Row - I/O</h3>
<p>將磁碟視為一個大型的陣列使用，一個「磁區」就視為陣列的一個 entry。</p>
<ul>
<li><p>沒有「File system」的支援。</p></li>
<li><p>Pros</p>
<ul>
<li><strong>存取速度快</strong></li>
</ul></li>
<li><p>Cons</p>
<ul>
<li>使用者不易使用，<strong>通常用在資料庫系統的底層。</strong></li>
</ul></li>
</ul>
<h3 id="bootstrap-loader">☆Bootstrap loader</h3>
<figure>
<img src="\willywangkaa\images\windowsMBR.png" alt="windowsMBR" /><figcaption aria-hidden="true">windowsMBR</figcaption>
</figure>
<p><strong>開機時讓電腦可以從磁碟載入作業系統的「Object code」到記憶體的特殊「Loader」。</strong></p>
<h4 id="早期">早期</h4>
<figure>
<img src="\willywangkaa\images\boot1.png" alt="boot1" /><figcaption aria-hidden="true">boot1</figcaption>
</figure>
<ul>
<li>流程
<ol type="1">
<li>Power-on</li>
<li>執行存在 ROM 裡的「Bootstrap loader」</li>
<li>「Bootstrap loader」將存在於磁碟中的「作業系統目的碼」載入到記憶體之中</li>
<li>作業系統執行「System configuration」</li>
<li>開機完成，等待使用者下命令</li>
</ol></li>
<li><strong>Cons</strong>
<ul>
<li>「Bootstrap loader」無法任意變更</li>
<li>ROM 大小有限，「Bootstrap loader」無法做大</li>
</ul></li>
</ul>
<h4 id="現今">現今</h4>
<figure>
<img src="\willywangkaa\images\boot2.png" alt="boot2" /><figcaption aria-hidden="true">boot2</figcaption>
</figure>
<blockquote>
<p>完整的 Bootstrap Loader 位於磁碟的固定「Block」位置，稱為「Boot block」；</p>
<p>擁有「Boot block」的磁碟稱為「Boot disk」或「System disk」。</p>
</blockquote>
<ul>
<li>流程
<ol type="1">
<li>Power-on</li>
<li>執行存在 ROM 裡的「Simple bootstrap loader」( 固定 5 - 10 條指令 )</li>
<li>「Simple bootstrap loader」將存在於磁碟中的「Complete bootstrap loader」載入到記憶體之中</li>
<li>執行「Complete bootstrap loader」</li>
<li>「Complete bootstrap loader」將 「OS object code」載入記憶體之中。</li>
<li>作業系統執行「System configuration」</li>
<li>開機完成，等待使用者下命令</li>
</ol></li>
</ul>
<h3 id="處理-bad-sector">處理 Bad sector</h3>
<ul>
<li>磁區毀壞原因
<ul>
<li>工廠生產時已經毀壞</li>
<li>正常使用後一段時間正常毀損</li>
</ul></li>
<li>處裡方法
<ul>
<li><strong>Mark bad sector</strong>
<ul>
<li>標註完後之後看到這個標記就不使用之</li>
<li>Ex：<strong>IDE disk controller</strong> 採用</li>
</ul></li>
<li><strong>Spare(備料) sector</strong> ( 下圖一 )
<ul>
<li><strong>作業系統無法看到及使用「Spare sector area」，只有「Disk controller」可使用。</strong></li>
<li><strong>工廠生產時，就已經在「Low-level formatting」中預留。</strong></li>
<li>一旦有「Bad sector」<strong>則「Disk controller」會從「Spare sector」選擇一個 Spare sector 來替代 Bad sector</strong>，將來作業系統在存取該「Bad sector」 時，<strong>SCSI controller 會將它導向至替換後的 sector</strong> ( 作業系統不知情 )。</li>
<li><strong>Cons</strong>
<ul>
<li><strong>「充新導向」的動作，可能會破壞作業系統「Disk scheduling」的效益。( 下圖二 )</strong><br>改善：將「Spare sector」分散到每條磁軌( 或磁柱 )上，不要集中存放；若磁區發生毀壞，<strong>則使用相同或鄰近的磁軌上的「Spare sector」來作替代。</strong></li>
</ul></li>
<li>Ex：<strong>SCSI disk controller 採用</strong></li>
</ul></li>
<li><strong>Sector slipping ( 下圖三 )</strong>
<ul>
<li>Cons
<ul>
<li>讀寫次數過大，業界不常使用</li>
</ul></li>
</ul></li>
</ul></li>
<li>圖一</li>
</ul>
<figure>
<img src="\willywangkaa\images\sparesector.png" alt="sparesector" /><figcaption aria-hidden="true">sparesector</figcaption>
</figure>
<ul>
<li>圖二</li>
</ul>
<figure>
<img src="\willywangkaa\images\SCSIsparesector.png" alt="SCSIsparesector" /><figcaption aria-hidden="true">SCSIsparesector</figcaption>
</figure>
<ul>
<li>圖三</li>
</ul>
<figure>
<img src="\willywangkaa\images\sectorslipping.png" alt="sectorslipping" /><figcaption aria-hidden="true">sectorslipping</figcaption>
</figure>
<h3 id="swap-space-management">Swap space management</h3>
<p>在「Vitrual memory」裡，「Medium-term scheduler」會將磁碟作為「Swap out」的分頁或「Process image」之暫存處。</p>
<p>決定「Swap space」大小時，<strong>最好超估( Overestimate )，比較安全。</strong></p>
<figure>
<img src="\willywangkaa\images\swapspace.png" alt="swapspace" /><figcaption aria-hidden="true">swapspace</figcaption>
</figure>
<h4 id="方法">方法</h4>
<p>用甚麼方式保存 Swap out page/process image？</p>
<h5 id="使用-file-system">使用 File system</h5>
<p>仍用檔案的形式保存。</p>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>實現簡單</strong></li>
</ul></li>
<li>Cons
<ul>
<li>因為通常使用連續性配置 ( Seek time 小；I/O 時間小 )，<strong>所以會有外部碎裂</strong></li>
<li><strong>效能比較差</strong></li>
</ul></li>
</ul>
<h5 id="使用獨立的partition來保存">使用獨立的「Partition」來保存</h5>
<ul>
<li>Pros
<ul>
<li>因為採用「Raw-I/O」，無須「File system」支持，<strong>所以效能佳</strong></li>
</ul></li>
<li>Cons
<ul>
<li>內部碎裂</li>
<li><strong>若「Partition」不夠大，則需要「Re-partition」</strong></li>
</ul></li>
</ul>
<h2 id="提升disk-data-access效能">提升「Disk data access」效能</h2>
<ul>
<li>「Data striping」( Interleaving )
<ul>
<li>將多部「Physical disk」組成一個單一的「Logical disk」，<strong>運用「平行存取技巧」來提升效能。</strong>
<ol type="1">
<li><strong>Bit-level striping</strong></li>
<li><strong>Block-level striping</strong> ( 下圖 )</li>
</ol></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\datastriping.png" alt="datastriping" /><figcaption aria-hidden="true">datastriping</figcaption>
</figure>
<h2 id="提升disk-availibility-可靠度">提升「Disk availibility」( 可靠度 )</h2>
<blockquote>
<p>當「Block」毀損，發生「Data lost」時要如何作「Data recovery」？</p>
</blockquote>
<h3 id="mirror-shadow-技術">Mirror ( shadow ) 技術</h3>
<p>每一部正常的磁碟均配備有對應的「Mirror disk」，資料須同時存入正常磁碟與該「Mirror disk」；將來若正常的磁碟發生毀損，則使用「Mirror disk」來取代。</p>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>可靠度高</strong></li>
<li><strong>「Data recovery」最快</strong>。</li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>價格盎貴</strong></li>
</ul></li>
</ul>
<h3 id="parity-check-技術">Parity-check 技術</h3>
<p>多準備一部磁碟用來儲存<strong>「Parity-check block」之用</strong>，資料寫入時，需額外算出「Parity-check block」內容；<strong>將來，若某一「Block」發生毀損，只要用其它「Block」與「Parity block」作偶同位，即可「Recovery data」。</strong></p>
<ul>
<li>Pros
<ul>
<li>成本比起 Mirror 技術便宜許多</li>
</ul></li>
<li>Cons
<ul>
<li>可靠度低於 Mirror 技術<br>若多個 Block 同時毀壞，則無法恢復資料</li>
<li>因為需要偶同位的計算，「Data recovery」的速度比 Mirror 技術的慢</li>
<li><strong>因為資料的寫入也需要偶同位的計算，所以寫入的速度比 Mirror 技術的慢</strong></li>
</ul></li>
</ul>
<h4 id="使用-parity-disk-重建資料">使用 Parity disk 重建資料</h4>
<p>假設 P(i) 為「Parity disk」， i 可以是「單位區塊 (block)」或「單位位元 (bit)」，其他四個磁碟儲存資料 ( D(i) ) <span class="math display">\[
P(i) = D_3(i) \oplus D_2(i) \oplus D_1(i) \oplus D_0(i)
\]</span> 若 <span class="math inline">\(D_1\)</span> 發生錯誤透過 P、<span class="math inline">\(D_3、D_2、D_0\)</span> 重建 <span class="math display">\[
D_1(i) = P(i) \oplus D_3(i) \oplus D_2(i) \oplus D_0(i)
\]</span></p>
<h4 id="小量寫入與更新同位位元資料">小量寫入與更新同位位元資料</h4>
<p>假設 P(i) 為「Parity disk」， i <strong>只可以是「單位區塊 (block)」</strong>，其他四個磁碟儲存資料 ( D(i) ) <span class="math display">\[
P(i) = D_3(i) \oplus D_2(i) \oplus D_1(i) \oplus D_0(i)
\]</span> 將 <span class="math inline">\(D&#39;_1 (i)\)</span> 寫入 <span class="math inline">\(D_1(i)\)</span>： <span class="math display">\[
P&#39;(i) = D_3(i) \oplus D_2(i) \oplus D&#39;_1(i) \oplus D_0(i) \\
 = D_3(i) \oplus D_2(i) \oplus D&#39;_1(i) \oplus D_0(i) \oplus (\; D_1(i) \oplus D_1(i) \;) \\
 = (\;D_3(i) \oplus D_2(i) \oplus D_1(i) \oplus D_0(i)\;) \oplus D&#39;_1(i) \oplus D_1(i)\\
 = P(i) \oplus D&#39;_1(i) \oplus D_1(i)
\]</span></p>
<blockquote>
<ul>
<li>需要兩次硬碟讀取 ( P、<span class="math inline">\(D_1\)</span> ) ，兩次硬碟寫入 ( P'、<span class="math inline">\(D&#39;_1\)</span> )</li>
</ul>
</blockquote>
<h2 id="redundant-array-of-implement-disk-raid">Redundant Array of Implement Disk ( RAID )</h2>
<p>使用多個容量小的硬碟以替代一個容量大的硬碟，由於多個硬碟可有多個讀寫頭，所以可以使<strong>磁碟存取效能獲得提升、改善</strong></p>
<blockquote>
<p>使用多個磁碟所組成之「磁碟系統」會使得可靠度 ( Reliability ) 降低，假設兩兩磁碟之錯誤的發生情況是<strong>獨立事件</strong>，所以： <span class="math display">\[
N \; 個磁碟之「Reliability」 = \frac{1 \;個磁碟之「Reliability」}{N}
\]</span></p>
<ul>
<li>解決可靠度降低之辦法
<ul>
<li>磁碟陣列技術 ( RAID )：結合多個容量小、便宜之磁碟以獲得一個容量大之磁碟 ( Large expensive drive；SLED )，且<strong>在存取上有更好的效能</strong></li>
</ul></li>
</ul>
</blockquote>
<p>兩種技術以提升磁碟陣列的「Performance」與「Availability」：</p>
<ul>
<li>Data stripping ( Interleaving )
<ul>
<li>將資料分散存儲到不同磁碟，在「資料存取」時，多個磁碟會同時存取以增加「Performance」</li>
<li>E.g. 「Block level striping」</li>
</ul></li>
<li>Redundancy
<ul>
<li>使用部分磁碟作為資料之「備份資訊」或「還原資訊」以提升磁碟陣列的「Availability」( Mean time to repair；MTTR )</li>
</ul></li>
</ul>
<blockquote>
<p>使用「Redundancy」可以改善磁碟陣列系統的「Avaliability」，但無法改善其「Reliability」( Mean time to failure；MTTR )；「Reliability」只能透過<strong>改善製造技術</strong>，或是<strong>使用較少的磁碟建構磁碟系統</strong>才能改善</p>
</blockquote>
<figure>
<img src="\willywangkaa\images\RAID.png" alt="RAID" /><figcaption aria-hidden="true">RAID</figcaption>
</figure>
<h3 id="raid-0">RAID 0</h3>
<p>只提供「Block-level striping ( interleaving )」，未提供任何<strong>「Availability」技術</strong> ( 未使用附加的磁碟以保護資料 )</p>
<ul>
<li>Pros
<ul>
<li>用在<strong>存取效能高，但可靠度不重要的場合</strong>
<ul>
<li>E.g. VOD server</li>
</ul></li>
</ul></li>
<li>Cons
<ul>
<li>任意一硬碟發生錯誤即發生資料遺失</li>
</ul></li>
</ul>
<h3 id="raid-1-mirroring">RAID 1 ( Mirroring )</h3>
<p>提供「Mirror」技術以容忍硬碟錯誤 ( 提升「Redundancy」以提升「Availability」 ) ，當資料寫入陣列時，這些資料也會一併寫入「Redundant disk」，使得資料總是有兩個備份</p>
<p>一個硬碟發生錯誤時，磁碟系統會改讀取對應的「Mirror disk」</p>
<ul>
<li>儲存資料量</li>
</ul>
<p><span class="math display">\[
Size =\min \left(S_1,S_2,S_3\ldots \right), S_i \; 為一磁碟容量\; i = 1, 2, 3, \ldots
\]</span></p>
<ul>
<li>Pros
<ul>
<li>磁碟陣列錯誤容忍度高</li>
</ul></li>
<li>Cons
<ul>
<li>因為需要最多的「備份磁碟」，所以為<strong>最昂貴之磁碟陣列技術</strong></li>
</ul></li>
</ul>
<h3 id="raid-2-double-error-detecting-and-single-correcting-code">RAID 2 ( Double error detecting and single correcting code )</h3>
<figure>
<img src="\willywangkaa\images\RAID2.png" alt="RAID2" /><figcaption aria-hidden="true">RAID2</figcaption>
</figure>
<p>採用記憶體的「Error correcting code」( Hamming code ) 技術來改善「Availability」，希望降低「Mirror」成本，<strong>但是成本降低有限 ( 比「RAID 1」少一部磁碟 )</strong></p>
<blockquote>
<p>寫入磁碟陣列時，需要讀出所有磁碟之資料，重新計算「Hamming code」並寫入「ECC 硬碟」，效率不佳</p>
</blockquote>
<ul>
<li>Pros
<ul>
<li>還原資料時間短</li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>與「RAID 3」相比，雖然「Availability」相同但成本卻比較高</strong> ( 次昂貴之成本 )</li>
<li>寫入磁碟陣列時需要更新漢明碼不易，維護成本太高</li>
</ul></li>
</ul>
<blockquote>
<p><strong>RAID 2 並無實際產品</strong></p>
</blockquote>
<h3 id="raid-3-bit-interleaved-parity">RAID 3 ( Bit-interleaved parity )</h3>
<figure>
<img src="\willywangkaa\images\RAID3.png" alt="RAID3" /><figcaption aria-hidden="true">RAID3</figcaption>
</figure>
<p><strong>採用「Bit-level striping」與「Parity check」技術</strong></p>
<ul>
<li>提升「Availiability」所需之成本 <span class="math inline">\(\frac 1N\)</span>
<ul>
<li>N 表示同一個「保護群組」( Protection group ) 中的磁碟數量</li>
</ul></li>
<li>Pros
<ul>
<li>與「RAID 1」相比，使用較少的「還原磁碟」</li>
<li>因為使用「Bit-interleaved」所以可以使「Latency」降很低，所以在操作單一「I/O operation」時速度極快</li>
</ul></li>
<li>Cons
<ul>
<li>與「RAID 1」相比需要使用更多時間以恢復資料</li>
<li>由於資料內的位元分散在不同的硬碟上，因此就算要<strong>讀取一小段資料資料都可能需要所有的硬碟進行工作</strong>，不允許多個「I/O operation」同時執行 ( 「Throughput」低 )</li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>由於資料內的位元分散在不同的硬碟上，因此就算要讀取一小段資料資料都可能需要所有的硬碟進行工作，所以這種規格比較<strong>適於讀取大量資料時使用</strong></li>
<li>每次的<strong>資料存儲</strong>都必須從同位元檢查的那個硬碟中取出對應的同位元資料進行核對，由於過於頻繁的使用，所以對硬碟 ( Parity disk ) 的損耗可能會提高</li>
</ul>
</blockquote>
<h3 id="raid-4-block-interleaved-parity">RAID 4 ( Block-interleaved parity )</h3>
<figure>
<img src="\willywangkaa\images\RAID4.png" alt="RAID4" /><figcaption aria-hidden="true">RAID4</figcaption>
</figure>
<p><strong>採用「Block-level striping」與「Parity check」技術</strong></p>
<p>同位資訊以<strong>區塊的方式</strong>儲存，與一組「Data block」相關聯</p>
<ul>
<li>提升「Availiability」所需之成本 <span class="math inline">\(\frac 1N\)</span>
<ul>
<li>N 表示同一個「保護群組」( Protection group ) 中的磁碟數量</li>
</ul></li>
<li>Pros
<ul>
<li>相對於「RAID 3」，如果資料存取量為「Block」則可以在不同的磁碟上獨立存，所以可以進行「平行存取」
<ul>
<li>在大量存取資料時，還是必須存取所有位於<strong>同一保護群組之磁碟</strong></li>
<li>在少量寫入磁碟時 ( &lt; block )，計算該「新同位元區塊」：「新資料區塊」、「舊資料區塊」與「舊同位元區塊」執行「XOR」計算即可，<strong>不需要「同一保護群組」之其他磁碟中的區塊參與</strong></li>
</ul></li>
</ul></li>
<li>Cons
<ul>
<li>需要較多時間以回復毀損資料</li>
<li>平行寫入時必須排隊寫入「Parity desk」( Bottleneck )</li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>每次的<strong>資料存儲</strong>都必須從同位元檢查的那個硬碟中取出對應的同位元資料進行核對，由於過於頻繁的使用，所以對硬碟 ( Parity disk ) 的損耗可能會提高</li>
</ul>
</blockquote>
<h3 id="raid-5-distributed-block-interleaved-parity">RAID 5 ( Distributed block-interleaved parity )</h3>
<figure>
<img src="\willywangkaa\images\RAID5.png" alt="RAID5" /><figcaption aria-hidden="true">RAID5</figcaption>
</figure>
<p><strong>採用「Block-level striping」與「Parity check」技術</strong></p>
<p>為了改良頻繁對「Parity desk」之讀寫使得該磁碟易損耗，也避免平行寫入時會有「Bottleneck」，將「Parity block」<strong>分散存於不同的磁碟之中，並非集中在一部磁碟</strong></p>
<ul>
<li>資料儲存量</li>
</ul>
<p><span class="math display">\[
Size = (N-1) \times \min (S_1,S_2,S_3\ldots, S_N), S_i \; 為一磁碟容量\; i = 1, 2, 3, \ldots
\]</span></p>
<ul>
<li>Pros
<ul>
<li>可以平行讀寫</li>
<li>避免對單一磁碟過度使用</li>
</ul></li>
<li>Cons
<ul>
<li>回復毀損資料需時較久</li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>至少需要三部磁碟組成 RAID5</li>
<li>RAID 5可以理解為是RAID 0和RAID 1的折衷方案；RAID 5可以為系統提供資料安全保障，但保障程度要比<a href="https://zh.wikipedia.org/wiki/%E9%8F%A1%E5%83%8F">鏡像</a>低而磁碟空間利用率要比鏡像高
<ul>
<li>RAID 5具有和RAID 0相近似的資料讀取速度，只是因為多了一個奇偶校驗資訊，寫入資料的速度相對單獨寫入一塊硬碟的速度略慢，若使用「Write back cache」可以讓效能改善不少</li>
<li>同時由於多個資料對應一個奇偶校驗資訊，RAID 5的磁碟空間利用率要比RAID 1高，儲存成本相對較便宜</li>
</ul></li>
</ul>
</blockquote>
<h3 id="raid-6-pq-redundancy">RAID 6 ( P+Q redundancy )</h3>
<figure>
<img src="\willywangkaa\images\RAID6.png" alt="RAID6" /><figcaption aria-hidden="true">RAID6</figcaption>
</figure>
<p>不用「Parity check」技術，改用類似「Reed-Solomon」( 李德-索羅門碼 ) 技術，任兩塊「Disk block」同時出錯還是能恢復資料</p>
<ul>
<li>資料儲存量</li>
</ul>
<p><span class="math display">\[
Size = (N-2) \times \min (S_1,S_2,S_3\ldots, S_N), S_i \; 為一磁碟容量\; i = 1, 2, 3, \ldots
\]</span></p>
<ul>
<li><strong>Cons</strong>
<ul>
<li><strong>比起「RAID 2」的製作成本太高</strong></li>
<li>「校正區塊」為 RAID5 的兩倍</li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>RAID 6需要分配給奇偶校驗資訊更大的磁碟空間和額外的校驗計算，相對於RAID 5有更大的IO操作量和計算量，其「寫入效能」強烈取決於具體的實現方案，因此RAID 6通常不會通過軟體方式來實現，而更可能通過硬體方式實現</li>
<li>必須具備四個以上的磁碟才能生效</li>
<li>硬體磁碟陣列卡的功能中，也是最常見的磁碟陣列等級</li>
</ul>
</blockquote>
<h3 id="raid-01">RAID 01</h3>
<figure>
<img src="\willywangkaa\images\RAID01.png" alt="RAID01" /><figcaption aria-hidden="true">RAID01</figcaption>
</figure>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/RAID_01.svg/600px-RAID_01.svg.png" alt="File:RAID 01.svg" /><figcaption aria-hidden="true">File:RAID 01.svg</figcaption>
</figure>
<p>先 Striping 再整體 Mirror</p>
<ul>
<li><p>雖然成本相當昂貴，但是通常用在高效能與高可靠度的場合</p></li>
<li><p><strong>Cons</strong></p>
<ul>
<li><strong>一部磁碟毀壞，須整組替換</strong></li>
</ul></li>
</ul>
<h3 id="raid-10-優秀">RAID 10 ( 優秀 )</h3>
<figure>
<img src="\willywangkaa\images\RAID10.png" alt="RAID10" /><figcaption aria-hidden="true">RAID10</figcaption>
</figure>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bb/RAID_10.svg/600px-RAID_10.svg.png" alt="File:RAID 10.svg" /><figcaption aria-hidden="true">File:RAID 10.svg</figcaption>
</figure>
<p>先個別 Mirror 再整體Striping</p>
<ul>
<li>雖然成本相當昂貴，但是通常用在高效能與高可靠度的場合</li>
</ul>
<h3 id="結論">結論</h3>
<p>p.9-31</p>
<ul>
<li>RAID 0 用在「高性能( 高存取效能 ) 」且「資料的損失並不重要」的應用場合。</li>
<li>RAID 1 用在「快速復建」且「高可靠度」的應用場合。</li>
<li>RAID 01、RAID 10 用在「高性能」與「高可靠度」的應用場合。</li>
<li>RAID 5 通常適合「儲存大量資料」的應用場合。</li>
<li>Mirror 高可靠度，但卻非常昂貴。</li>
<li>Striping 提供高資料傳輸速率，但卻<strong>不能</strong>增進可靠度。</li>
<li>RAID 3 比起 RAID 1，「增加可靠度但卻使用較少的磁碟完成」、「Bit-level striping 存取效能高」。
<ul>
<li>但是 RAID 3 的磁碟使用度 ( Utilization ) 比較低，一次只能一個執行一個 I/O 操作。</li>
</ul></li>
<li><del><strong>RAID 4 大量讀取傳輸速率高，因為磁碟可以平行的讀取/寫入。</strong></del>
<ul>
<li><del><strong>小規模獨立寫入必須存取所有硬碟的資料( 包括 Parity disk 資料 )，算出 Parity 值後再寫入。</strong></del></li>
</ul></li>
<li><del><strong>RAID 5 </strong>藉由散布同未位元到所有磁碟機之中，避免對單一台位元磁碟機過度使用( RAID4 、RAID3 )。</del></li>
</ul>
<p>＜Note＞ 解釋不完整，稍後更正。</p>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Disk Management</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System - Deadlock</title>
    <url>/willywangkaa/2018/07/10/Operating-System-Deadlock/</url>
    <content><![CDATA[<h1 id="deadlock">Deadlock</h1>
<hr />
<p>系統中存在一組 processes，彼此形成 <em>循環等待</em> 的情況，<strong>造成這些 processes 皆無法往下執行，並降低產量 ( throughput ) 的現象。</strong></p>
<figure>
<img src="\willywangkaa\images\1530163891325.png" alt="1530163891325" /><figcaption aria-hidden="true">1530163891325</figcaption>
</figure>
<ul>
<li>死結成立的四個必要條件 ( 所以有一個不成立，則死結必不發生，<strong>但是若四個條件全部成立時，死結不一定會發生。</strong> )<br>If there are 4 conditions are true, then the deadlock <strong>will/can</strong> arise. <span class="math inline">\(\rightarrow\)</span> <strong>false/true.</strong>
<ul>
<li>Mutual exclusion：<strong>對於 Resource 而言，</strong>具有此性質的 resource ，在<strong>任何時間點最多只允許一個 process 持有/使用</strong>，不可多個 processes 同時持有/使用。<br>$Ex. $ 大多數的資源皆具有此性質。如：CPU, memory, disk, printer...<br>$Counter ; Ex. $ <strong>Read-only file 不具此性質。</strong></li>
<li>Hold and wait：<strong>Process 持有部分的資源，且又在等待其他 processes 所持有的資源。</strong></li>
<li>No preemption：<strong>Process 不可以任意剝奪其他 processes 所持有的資源</strong>，必須等待對方釋放資源才有機會取得資源。<br><strong>＜Note＞：</strong>若可 Preemption 則必無 Deadlock 頂多只有 Starvation。</li>
<li>Circular waiting：<strong>系統中存在一組 Processes 形成循環等待之情況。 </strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530163425234.png" alt="1530163425234" /><figcaption aria-hidden="true">1530163425234</figcaption>
</figure>
<p>＜Note＞<br>1. (恐龍版本)Circular waiting 代表 Hold and wait。<br>2. (其他版本)Circular waiting 代表 Mutual exclusion、Hold and wait、No preemption。<br>3. <strong>為何 Single-process 必不會造成 Deadlock ？ 因為 Circular waiting 不存在，所以 Deadlock 不發生。</strong></p>
<ul>
<li>交通十字路口 Deadlock
<ul>
<li><strong>路口：資源</strong></li>
<li><strong>車子：Process</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\deadlock.png" alt="deadlock" /><figcaption aria-hidden="true">deadlock</figcaption>
</figure>
<ul>
<li>與 Starvation 比較。
<ul>
<li>相同之處為都是 <em>資源分配管理機制設計不恰當所導致。</em></li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Deadlock</th>
<th style="text-align: center;">Starvation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">一組 Processes 形成 Circular waiting ，造成這些 Process 皆無法往下執行。</td>
<td style="text-align: center;">Process 因為長期無法取得完工所需的各式資源，造成遲遲無法完工。</td>
</tr>
<tr class="even">
<td style="text-align: center;">不可能有機會完工。</td>
<td style="text-align: center;">有完工的機會，但是機會渺茫、Indefinited block。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">會連帶造成 Throughput 低落。</td>
<td style="text-align: center;">與 Throughput 高低無關聯。(其中 SJF、SRTF 效能示好的。)</td>
</tr>
<tr class="even">
<td style="text-align: center;">一定會在 Non-preemption 的環境下。</td>
<td style="text-align: center;">容易發生在 Preemption 的環境。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">解決方案：Prevention、Avoidance、Detection and recovery。</td>
<td style="text-align: center;">使用「Aging」技術解決。</td>
</tr>
</tbody>
</table>
<h2 id="resource-allcation-graph-r.-a.-g.-資源分配圖">Resource allcation graph ( R. A. G. ) 資源分配圖</h2>
<p>令 <span class="math inline">\(G= ＜V, E＞\)</span> 為一有向圖，代表 R.A.G.，其中：</p>
<ul>
<li>Vertex ( 頂點 )</li>
<li>Process</li>
</ul>
<figure>
<img src="\willywangkaa\images\1530164365297.png" alt="1530164365297" /><figcaption aria-hidden="true">1530164365297</figcaption>
</figure>
<ul>
<li>Resource</li>
</ul>
<figure>
<img src="\willywangkaa\images\1530164408843.png" alt="1530164408843" /><figcaption aria-hidden="true">1530164408843</figcaption>
</figure>
<p>其中「。」數目代表該項資源的數目。</p>
<ul>
<li>Edge ( 邊 )：</li>
<li>Allocation edge</li>
</ul>
<figure>
<img src="\willywangkaa\images\1530164614789.png" alt="1530164614789" /><figcaption aria-hidden="true">1530164614789</figcaption>
</figure>
<ul>
<li>Request edge</li>
</ul>
<figure>
<img src="\willywangkaa\images\1530164672585.png" alt="1530164672585" /><figcaption aria-hidden="true">1530164672585</figcaption>
</figure>
<ul>
<li>$Ex. $</li>
</ul>
<figure>
<img src="\willywangkaa\images\1530166364004.png" alt="1530166364004" /><figcaption aria-hidden="true">1530166364004</figcaption>
</figure>
<h3 id="結論">結論</h3>
<ul>
<li><p>No cycle <span class="math inline">\(\rightarrow\)</span> No deadlock。</p></li>
<li><p><strong>Cycle 不一定有 deadlock。</strong></p></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530166810415.png" alt="1530166810415" /><figcaption aria-hidden="true">1530166810415</figcaption>
</figure>
<p>此圖雖然有 Cycle，但因為 P3 必可以完工且會釋出一個 R2 Resource，再配置給 P2 使用，所以無死結。</p>
<figure>
<img src="\willywangkaa\images\1530166364004.png" alt="1530166364004" /><figcaption aria-hidden="true">1530166364004</figcaption>
</figure>
<p>因為 P4 必可以完工且會釋出 R3 Resource，再配置給 P3 使用，所以無死結。</p>
<ul>
<li><strong>除非每一類型的資源皆為 single-instance ( 單一數量 )，則有 Cycle 必有死結。</strong></li>
</ul>
<h2 id="解決-deadlock">解決 Deadlock</h2>
<p>Prevention、Avoidance</p>
<ul>
<li>Pros
<ul>
<li><strong>保證系統為 deadlock free。( 不可能進入「Deadlock state」)</strong></li>
</ul></li>
<li>Cons
<ul>
<li><strong>對資源的使用與限制與取得限制多，所以 Resource utilization 偏低，連帶 throughput 偏低。</strong></li>
<li><strong>不可能造成 Starvation。</strong></li>
</ul></li>
</ul>
<p>Detection and Recovery</p>
<ul>
<li>Pros
<ul>
<li><strong>Resource utilization 相對較高， throuput 也較高。</strong></li>
</ul></li>
<li>Cons
<ul>
<li><strong>System 可能進入 deadlock state。</strong></li>
<li><strong>Detection and recovery 的成本很高。</strong></li>
</ul></li>
</ul>
<h3 id="deadlock-prevention">Deadlock prevention</h3>
<p><strong>破除四個必要條件之其中一個，則死結必不發生。</strong></p>
<ul>
<li>針對「Mutual exclution」
<ul>
<li><strong>因為 Resource 本來就有的性質，以致無法解決「Mutual exclution」帶來的問題。</strong></li>
</ul></li>
<li>針對「Hold and wait」
<ul>
<li>方法一：作業系統可以決定<strong>除非該 Process 可以一次取得全部所需資源，才允許持有資源，否則不得持有任何資源。</strong></li>
<li>方法二：<strong>Process 可先持有部分資源，但當該 Process 要申請其他資源時，必須先釋出所持有的資源，才可以提出申請。</strong></li>
</ul></li>
<li>針對「No preemptive」
<ul>
<li><strong>將該法則改為可強奪( Premptive )，並以優先權作為搶奪基準。</strong>( 但可能會造成 Starvation )</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th>Process</th>
<th>持有的資源</th>
<th>欲申請的資源</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>P1</td>
<td>R1</td>
<td>R3 ( 可以申請 )</td>
</tr>
<tr class="even">
<td>P2</td>
<td>R5</td>
<td>R3 ( 必須先釋出 R5 )</td>
</tr>
<tr class="odd">
<td>P3</td>
<td>R1、R5</td>
<td>R3 (必須先釋出 R5 )</td>
</tr>
</tbody>
</table>
<ul>
<li>*針對「Circular waiting」
<ul>
<li>「Resource ordering」：<strong>作業系統賦予每一類型資源一個唯一的 Resource ID，再規定 Process 必須按照 Resource ID asending (遞增) 的方式對資源提出申請。</strong></li>
<li>證明「Resource ordering」：<br>假設在這樣的規定下，系統仍存在一組 Processes 形成 Circular waiting 如下圖，依規定，我們可以推導出資源 ID 大小關係如：<span class="math inline">\(r_0 &lt; r_1 &lt; r_2 \ldots &lt; r_n \quad , r_i \; is \; unique.\)</span>，但又 <span class="math inline">\(r_0 &lt; r_n &lt; r_0\)</span> ，矛盾，所以 Circular waiting 必不存在。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530168967415.png" alt="1530168967415" /><figcaption aria-hidden="true">1530168967415</figcaption>
</figure>
<h3 id="deadlock-aviodance">Deadlock aviodance</h3>
<p>當某個 process 提出某些資源申請時，則作業系統必須執行「Banker's algorithm」以確認<strong>倘若分配給 Process 其申請資源後，系統未來是否處於「Safe state」；若為「Saft state」，則核准申請，否則為「Unsafe state」系統會否決該資源申請，</strong>Process 必須等一段時間後再重新申請資源，系統會再確認當時的狀態是否安全。</p>
<figure>
<img src="\willywangkaa\images\1528970642055.png" alt="1528970642055" /><figcaption aria-hidden="true">1528970642055</figcaption>
</figure>
<p>Deadlock 是 Unsafe 集合的 Subset。</p>
<h4 id="bankers-algorithm">Banker's Algorithm</h4>
<ul>
<li>資料結構
<ul>
<li>n：Process 個數。</li>
<li>m：Resource 種類數。</li>
<li><span class="math inline">\(Request_i：[1 \ldots m] \; of \; int \Rightarrow P_i\)</span> 提出的各式資源申請量。</li>
<li><span class="math inline">\(Allocation：n \times m \; matrix \Rightarrow\)</span> 各個 Process 目前持有的各式資源數量。</li>
<li><span class="math inline">\(Max：n \times m \; matrix \Rightarrow\)</span> 各 Process 完工所需之各式資源最大數量。</li>
<li><span class="math inline">\(Need：n \times m matrix = Max - Allocation \Rightarrow\)</span> <strong>各 Process 還需各式資源才能完工。</strong></li>
<li><span class="math inline">\(Available：[1 \ldots m] \; of \; int = 資源總量 - Allocation\Rightarrow\)</span> <strong>系統目前可用的各式資源數量。</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1528971381784.png" alt="1528971381784" /><figcaption aria-hidden="true">1528971381784</figcaption>
</figure>
<ul>
<li>演算步驟
<ol type="1">
<li>確認 <span class="math inline">\(Request_i \leq Need_i\)</span><br><strong>若成立進入第二步，否則因為申請不合理導致終止</strong> <span class="math inline">\(P_i\)</span>。</li>
<li>確認 <span class="math inline">\(Request_i \leq Available\)</span><br><strong>若成立進入第三步，否則</strong> <span class="math inline">\(P_i\)</span> <strong>一直等待直到資源可以使用時。</strong></li>
<li>( 演算結果 ) <span class="math inline">\(Allocation_i = Allocation_i + Request_i \quad Need_i = Need_i - Request_i \quad Available = Available - Request_i\)</span></li>
<li><strong>依照第三步的演算值執行「Safety Algorithm」，若回傳「Saft state」則可以核准該申請，但若回傳「Unsafe state」則核駁該次申請。</strong><br><span class="math inline">\(P_i\)</span> <strong>必須等待一段時間再重新提出申請。</strong></li>
</ol></li>
</ul>
<h4 id="safty-algorithm">Safty algorithm</h4>
<ul>
<li>資料結構
<ul>
<li>n：Process 個數。</li>
<li>m：Resource 種類數。</li>
<li><span class="math inline">\(Request_i：[1 \ldots m] \; of \; int \Rightarrow P_i\)</span> 提出的各式資源申請量。</li>
<li><span class="math inline">\(Allocation：n \times m \; matrix \Rightarrow\)</span> 各個 Process 目前持有的各式資源數量。</li>
<li><span class="math inline">\(Max：n \times m \; matrix \Rightarrow\)</span> 各 Process 完工所需之各式資源最大數量。</li>
<li><span class="math inline">\(Need：n \times m matrix = Max - Allocation \Rightarrow\)</span> <strong>各 Process 還需各式資源才能完工。</strong></li>
<li><span class="math inline">\(Available：[1 \ldots m] \; of \; int = 資源總量 - Allocation\Rightarrow\)</span> <strong>系統目前可用的各式資源數量。</strong></li>
<li><span class="math inline">\(Work：[1\ldots m] \; of \; int \Rightarrow\)</span> <strong>代表系統目前可用的資源累積數量。</strong></li>
<li><span class="math inline">\(Finish：[1\ldots n] \; of \; int\)</span> <br><span class="math inline">\(\Rightarrow \{\begin{matrix}True \quad 代表P_i可完工 \\False \quad 尚未完工 \end{matrix}\)</span></li>
</ul></li>
<li>演算步驟
<ol type="1">
<li>設定初值<br>$Work = Availabe Finish[i] ; i, 1 i n ; 設定為 ; false $</li>
<li><strong>試找一個</strong> <span class="math inline">\(P_i\)</span> 滿足：<br><span class="math inline">\(Finish[i] 為 False\)</span><br><span class="math inline">\(Need_i \leq Work\)</span><br>若可以找到進入第三步，否則進入第四步。</li>
<li><strong>設定</strong><span class="math inline">\(Finish[i] = True \quad Work = Work + Allocation_i\)</span>，<strong>接著進入第二步。</strong></li>
<li>確認 <span class="math inline">\(Finish\)</span> 陣列，若全部皆為 True 回傳「Safe state」，否則回傳「Unsafe state」。</li>
</ol></li>
<li>Safe sequence / Safe stete
<ul>
<li><strong>至少可以找出大於一組 「Safe sequence」稱為 Safe state 否則稱為 Unsafe state ，代表作業系統未來依此 Processes 順序可分配各 Process 所需的資源使得大家皆可以順利完工。</strong></li>
</ul></li>
</ul>
<h4 id="實際演練一">實際演練一</h4>
<ul>
<li>5 個 Processes：<span class="math inline">\(P_0, \ldots, P_4\)</span></li>
<li>3 種類型的 Resource：<span class="math inline">\(A, B, C\)</span></li>
<li>起始資源量：<span class="math inline">\((A, B, C) = (10, 5, 7)\)</span><br>求取 <span class="math inline">\(Need[]\)</span> 與<span class="math inline">\(Available[]\)</span><br><span class="math inline">\(P_1\)</span> 提出 <span class="math inline">\((A, B, C) = (1, 0, 2)\)</span> 之資源申請，請問是否予以核准或是核駁，請說明。</li>
</ul>
<figure>
<img src="\willywangkaa\images\1531184487179.png" alt="1531184487179" /><figcaption aria-hidden="true">1531184487179</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1531184825933.png" alt="1531184825933" /><figcaption aria-hidden="true">1531184825933</figcaption>
</figure>
<ul>
<li><p><strong>Banker's algorithm</strong></p>
<ul>
<li><span class="math inline">\(Request_1 = (1, 0, 2)\)</span></li>
</ul>
<ol type="1">
<li>確認 $ Request_1 (1, 0, 2) Need_1(1, 2, 2)$，OK ( goto step2 )。</li>
<li>確認 $ Request_1 (1, 0, 2) Available(3, 3, 2)$，OK ( goto step3 )。</li>
<li>Safty algorithm。</li>
</ol></li>
<li><p>Safty algorithm</p>
<ol type="1">
<li>Initial value：<span class="math inline">\(Work = Available = ＜2, 3, 0＞\)</span></li>
<li>因為可以找到一個 Process <span class="math inline">\(P_1\)</span> 供應 Resource 並使之得以完成該工作。<br>滿足：<span class="math inline">\(Finish[1] = False\quad Need_1 \leq Work\)</span>，OK ( goto step3 )。</li>
<li><strong>設定</strong> <span class="math inline">\(Finish[1] = True \quad Work = Work + Allocation_i\)</span>，<strong>goto step2。</strong><br>...<strong>在 Step2 不斷重複的尋找是否有 <span class="math inline">\(P_i\)</span> 尚未完工且目前資源可以予以完工</strong>...</li>
<li>最後確認 <span class="math inline">\(Finish[]\)</span> 全皆為 <span class="math inline">\(True\)</span> 後回傳「Safe state」。</li>
</ol></li>
<li><p>列出其 Safe sequence</p>
<ul>
<li><span class="math inline">\(＜P_1, P_3, P_4, P_0, P_2＞\)</span></li>
</ul></li>
</ul>
<h4 id="實際演練二">實際演練二</h4>
<ul>
<li>5 個 Processes：<span class="math inline">\(P_0, \ldots, P_4\)</span></li>
<li>3 種類型的 Resource：<span class="math inline">\(A, B, C\)</span></li>
<li>起始資源量：<span class="math inline">\((A, B, C) = (10, 5, 7)\)</span><br>求取 <span class="math inline">\(Need[]\)</span> 與<span class="math inline">\(Available[]\)</span><br><span class="math inline">\(P_4\)</span> 提出 <span class="math inline">\((A, B, C) = (3, 3, 0)\)</span> 之資源申請，請問是否予以核准或是核駁，請說明。</li>
</ul>
<figure>
<img src="\willywangkaa\images\1531184487179.png" alt="1531184487179" /><figcaption aria-hidden="true">1531184487179</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1531184825933.png" alt="1531184825933" /><figcaption aria-hidden="true">1531184825933</figcaption>
</figure>
<ul>
<li>Banker's algorithm
<ol type="1">
<li>確認 $ Request_4 (3, 3, 0) Need_4(4, 3, 1)$，OK ( goto step2 )。</li>
<li>確認 $ Request_1 (3, 3, 0) Available(3, 3, 2)$，OK ( goto step3 )。</li>
<li>Safty algorithm。</li>
</ol></li>
<li>Safty algorithm
<ol type="1">
<li>Initial value：<span class="math inline">\(Work = Available = ＜0, 0, 2＞\)</span></li>
<li>因為不能找到一個 Process <span class="math inline">\(P_i\)</span> 供應 Resource 並使之得以完成該工作 Fall ( goto step4 )。</li>
<li>最後確認 <span class="math inline">\(Finish[]\)</span> 非全皆為 <span class="math inline">\(True\)</span> 後回傳「Not safe state」。</li>
</ol></li>
</ul>
<h4 id="bankers-algorithm-的-time-complexity">Banker's algorithm 的 Time complexity</h4>
<ul>
<li>令 n：process 數目、m：resource 種類數。
<ul>
<li>Step1 需要 <span class="math inline">\(O(m)\)</span>。(檢查 request 是否大於 need)</li>
<li>Step2 需要 <span class="math inline">\(O(m)\)</span>。(檢查目前剩下資源是否充足可以給予 request)</li>
<li>Step3 需要 <span class="math inline">\(O(m)\)</span>。(若可以給予，將原本的 need、allocation、available)</li>
<li>Safty algorithm 的 time complexity。</li>
</ul></li>
<li>Safty algorithm
<ul>
<li>初值設定、每次工作需要 <span class="math inline">\(O(m)\)</span>、將所有 processes 確認一遍需要 <span class="math inline">\(O(n)\)</span>。</li>
<li><strong>最多檢查 </strong><span class="math inline">\(n + (n-1) + (n-2) + \ldots + 1 = \frac{(n+1) \cdot n}{2}\)</span> 個 process 每次檢查 <span class="math inline">\(Need_i \leq work\)</span> 需要 <span class="math inline">\(O(m)\)</span> ，加總起來為 $O(n^2 m) $。</li>
<li>使用 $ O(n) $ 確認所有 processes 都做完檢查。</li>
</ul></li>
</ul>
<h4 id="single-instance-resource-algorithm">Single-instance resource algorithm</h4>
<ul>
<li>可以化簡較為簡易的 avoidance 檢查方法。</li>
<li>利用 RAG，加上<strong>「Claim edge」使用。</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530172024919.png" alt="1530172024919" /><figcaption aria-hidden="true">1530172024919</figcaption>
</figure>
<ul>
<li><p>clam edge (虛線)：代表 <span class="math inline">\(P_i\)</span> <strong>未來</strong>會對 <span class="math inline">\(R_j\)</span> 提出申請。(即為 Max/Need 的意義)</p></li>
<li><p>演算法 ( 當 <span class="math inline">\(P_i\)</span> 提出 <span class="math inline">\(R_j\)</span> 申請 )</p>
<ol type="1">
<li>檢查原本有無該宣告邊之存在，若有進入第二步，否則終止 <span class="math inline">\(P_i\)</span>。</li>
<li>確認 <span class="math inline">\(R_j\)</span> 是否可供使用，若可以進入第三步，否則 <span class="math inline">\(P_i\)</span> 等待該資源 ( 由 Claim edge 轉為 Request edge )。</li>
<li><strong>( 演算結果 ) 暫時將宣告邊改為配置邊( Allocation edge )，進入第四步</strong>。</li>
<li><strong>確認途中是否有 Cycle 存在，若無則為「Safe state (核准)」，若有 cycle 為「Unsafe ( 核駁 )」</strong>。</li>
</ol></li>
<li><p><span class="math inline">\(Ex .\)</span></p></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530172534581.png" alt="1530172534581" /><figcaption aria-hidden="true">1530172534581</figcaption>
</figure>
<ul>
<li>若<span class="math inline">\(P_1\)</span> 對 <span class="math inline">\(R_2\)</span> 提出申請是否核准？<strong>因為沒有 Cycle 存在，所以 Safe 核准申請。</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530172797528.png" alt="1530172797528" /><figcaption aria-hidden="true">1530172797528</figcaption>
</figure>
<ul>
<li>若為 <span class="math inline">\(P_2\)</span> 對 <span class="math inline">\(R_2\)</span> 提出申請是否核准？<strong>因為有 cycle 存在，所以核駁申請。</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530172966437.png" alt="1530172966437" /><figcaption aria-hidden="true">1530172966437</figcaption>
</figure>
<ul>
<li><strong>＜Note＞：Deadlock 位於 Unsafe state 的集合之中，也就是說若目前的狀態是 unsafe state 有可能會導致死結，但也有可能不會導致死結。</strong></li>
</ul>
<h4 id="theorem-deadlock-free">*＜Theorem＞ Deadlock free</h4>
<figure>
<img src="\willywangkaa\images\1530173438706.png" alt="1530173438706" /><figcaption aria-hidden="true">1530173438706</figcaption>
</figure>
<p>系統若有 n 個 processes、m 個 resources intsance ( 單一種類 )，<strong>且滿足下列條件</strong>：</p>
<ol type="1">
<li><span class="math inline">\(1 \leq Max_i \leq m\)</span> ，單一 Process 不得要求超過該種類資源的上限。</li>
<li><span class="math inline">\(\sum_{i = 1}^n Max_i &lt; n + m \Rightarrow \sum_{i = 1}^n Max_i - n &lt; m\)</span> ，假設目前所有的 processes 都剩下一個資源未取得，而剩下的資源小於 m 代表的意思就是 $ m - （_{i = 1}^n (Max_i - n) ）$，<strong>代表我們還有至少一個以上的資源可以使某些 processes 可以先結束</strong>，接著回收的資源就可以再分配給其他 processes。</li>
</ol>
<p>則<strong>系統是不可能會有死結的 ( Deadlock free )</strong>。</p>
<ul>
<li><span class="math inline">\(Ex1 .\)</span> 有 6 部印表機現在正被 Process 使用，每個 process 最多需要 2 部印表機才可以完工，則系統最多允許 <strong>幾個</strong> process 執行以確保 Peadlock free ？
<ul>
<li>m = 6, <span class="math inline">\(Max_i = 2\)</span>。<br>(1) <span class="math inline">\(1\leq Max_i \leq m \Rightarrow 1\leq 2 \leq 6\)</span>，OK。<br>(2) <span class="math inline">\(\sum_{i = 1}^n Max_i &lt; n+m \Rightarrow 2n &lt; n+6 \Rightarrow n &lt; 6 \Rightarrow\)</span> <strong>最多 5 個 Processes</strong>。</li>
</ul></li>
<li>$Ex2 . 有 10 部印表機現在正被 Process 使用，每個 process 最多需要 3 部印表機才可以完工，則系統最多允許 <strong>幾個</strong> process 執行以確保 Peadlock free ？
<ul>
<li><span class="math inline">\(Max_i = 3, m = 10\)</span>。<br><span class="math inline">\(3n &lt; n+10, 2n &lt; 10 \Rightarrow n &lt; 5 \Rightarrow\)</span> <span class="math inline">\(最多 4 個 \; Processes。\)</span></li>
</ul></li>
<li>Proof<br>假設資源全部配置出去即為 <span class="math inline">\(\sum_{i = 1}^n Allcation_i = m\)</span>，又 <span class="math inline">\(\sum_{i = 1}^n Need_i = \sum_{i = 1}^n Max_i - \sum_{i = 1}^n Allocation_i \Rightarrow \sum_{i = 1}^n (Max_i) - m \Rightarrow \sum_{i = 1}^n Max_i = \sum_{i = 1}^n Need_i + m\)</span>。<br>因為依照定理第二點 <span class="math inline">\(\sum_{i = 1}^n Max_i &lt; n+m \Rightarrow \sum_{i = 1}^n Need_i + m &lt; n+m\)</span><br>，所以 <span class="math inline">\(\sum_{i = 1}^n Need_i &lt; n\)</span>，<strong><br>此式代表至少有大於等於 1 個process 之 Need_i 為 0 代表 Process_i 可以完工，</strong>且 P_i 至少會釋出超過 1 個 Resource (<strong>因為按照定理第一點可以知道每個 process 只少會占用大於 1 個資源 Max_i 大於等於 1</strong>)，使得剩下的 processes 中又會有大於等於 1 個 processes 可以取得資源並完工。</li>
</ul>
<blockquote>
<p>Example（106 清華大學資工計算機系統）</p>
<p>Consider a system consisting of m resources of the same type that are shared by n processes, each of which needs at most k resources. What is the minimum number of <strong>instances of resources</strong> to guarantee that the system is deadlock free?</p>
<p>假設每個「Resource」有 x 個「Instance」，則：</p>
<p><span class="math inline">\(n\times (k-1) &lt; x \times m \Rightarrow x &gt; \frac{n\times(k-1)}{m} \\ \Rightarrow x \geq \lceil\frac{n\times(k-1)}{m}\rceil+1\)</span></p>
</blockquote>
<h3 id="deadlock-detection-and-recovery">Deadlock detection and recovery</h3>
<p>如果放任 Resources 無限制的使用，雖然 Utilization 高，<strong>但是系統有可能進入死結而不自知，所以需要有一個死結偵測的演算法以及解決 ( Recovery ) 死結的方法。</strong></p>
<h4 id="detection">Detection</h4>
<ul>
<li><strong>＜Note＞</strong>
<ul>
<li>Avoidance ( Banker's algorithm ) 含有<strong>未來</strong>的資訊 (Max, Need)。</li>
<li>Detection 只有<strong>目前的資訊 ( Current infomation )</strong>。</li>
</ul></li>
<li>資料結構
<ul>
<li>n：Process 個數。</li>
<li>m：Resource 種類數。</li>
<li><span class="math inline">\(Allocation：n \times m \; matrix \Rightarrow\)</span> 各個 Process 目前持有的各式資源數量。</li>
<li><span class="math inline">\(Available：[1 \ldots m] \; of \; int = 資源總量 - Allocation\Rightarrow\)</span> <strong>系統目前可用的各式資源數量。</strong></li>
<li><span class="math inline">\(Work：[1\ldots m] \; of \; int \Rightarrow\)</span> <strong>代表系統目前可用的資源累積數量。</strong></li>
<li><span class="math inline">\(Finish：[1\ldots n] \; of \; int\)</span> <br><span class="math inline">\(\Rightarrow \{\begin{matrix}True \quad 代表P_i可完工 \\ False \quad 尚未完工 \end{matrix}\)</span></li>
<li>*<span class="math inline">\(Request：n \times m \; matrix \Rightarrow\)</span> <strong>各 Process 目前對各式資源提出的申請量。</strong></li>
</ul></li>
<li>演算法
<ol type="1">
<li>初值設定<br><span class="math inline">\(Work = Available\)</span>，因為目前沒資源的 process 不會導致 deadlock，因為不會有 <strong>hold</strong> <em>and wait</em> 的問題所以<span class="math inline">\(Finish[i] = \{\begin{matrix}True \quad if \; Allocation_i = 0 \\ False \quad if \; Allocation_i \neq 0 \end{matrix}\)</span></li>
<li>試找一個 <span class="math inline">\(P_i\)</span> 滿足<br><span class="math inline">\(Finish[i] = False \; AND \; Request_i \leq Work\)</span><br>若找到進入第三步，否則進入第四步。</li>
<li>設定 <span class="math inline">\(Finish[i] = True \quad Work = Work + Allocation_i\)</span>，<strong>回到第二步。</strong></li>
<li>確認 <span class="math inline">\(Finish\)</span> <strong>陣列，若全部皆為 true，而我們可以得知目前沒有死結的可能。<br>否則我們可以得知目前有死結的存在，而且</strong> <span class="math inline">\(Finish[i] = false\)</span> <strong>的 Process 會陷入該死結之中。</strong></li>
</ol></li>
<li><strong>Time complexity</strong>
<ul>
<li><span class="math inline">\(O(n^2 \cdot m)\)</span>：<strong>死結偵測一次的時間需求很高，還要再乘上偵測的頻率，所以總體的成本很可觀。</strong></li>
</ul></li>
</ul>
<h4 id="實際演練一-1">實際演練一</h4>
<figure>
<img src="\willywangkaa\images\1531188159444.png" alt="1531188159444" /><figcaption aria-hidden="true">1531188159444</figcaption>
</figure>
<ul>
<li><ol type="1">
<li><span class="math inline">\(Work = Available (0, 0, 0)\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li>可以找到 <span class="math inline">\(P_0\)</span> 予以 Resource 後可完工且 <span class="math inline">\(Finish[0] = False\)</span>，<span class="math inline">\(Request_0 \leq Work\)</span> 前往第三步。</li>
</ol></li>
<li><ol start="3" type="1">
<li>設 <span class="math inline">\(Finish[0] = True\)</span> ，<span class="math inline">\(Work&#39; = Work + (0, 1, 0) = (0, 1, 0)\)</span> 前往第二步。</li>
</ol></li>
<li><ol start="2" type="1">
<li>可以找到 <span class="math inline">\(P_2\)</span> 予以 Resource 後可完工且 <span class="math inline">\(Finish[2] = False\)</span>，<span class="math inline">\(Request_2 \leq Work\)</span> 前往第三步。</li>
</ol></li>
<li><ol start="3" type="1">
<li>設 <span class="math inline">\(Finish[2] = True\)</span> ，<span class="math inline">\(Work = Work + (3, 0, 3) = (3, 1, 3)\)</span> 前往第二步。</li>
</ol></li>
<li>在不斷的 (2) <span class="math inline">\(\Leftrightarrow\)</span> (3) 之下，可以再找到 <span class="math inline">\(P_1, P_3, P_4\)</span> 可以完工進入第四步。</li>
<li><ol start="4" type="1">
<li>最後確認 <span class="math inline">\(Finish[]\)</span> 全皆為 <span class="math inline">\(True\)</span> 後得知目前「Deadlock free」。</li>
</ol></li>
</ul>
<h4 id="實際演練二-1">實際演練二</h4>
<figure>
<img src="\willywangkaa\images\1531188115016.png" alt="1531188115016" /><figcaption aria-hidden="true">1531188115016</figcaption>
</figure>
<ul>
<li><span class="math inline">\(Work = Available = (0, 0, 0)\)</span></li>
<li><ol start="2" type="1">
<li>可以找到 <span class="math inline">\(P_0\)</span> 予以 Resource 後可完工且 <span class="math inline">\(Finish[0] = False\)</span>，<span class="math inline">\(Request_0 \leq Work\)</span> 前往第三步。</li>
</ol></li>
<li><ol start="3" type="1">
<li>設 <span class="math inline">\(Finish[0] = True\)</span> ，<span class="math inline">\(Work&#39; = Work + (0, 1, 0) = (0, 1, 0)\)</span> 前往第二步。</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>找不到</strong> <span class="math inline">\(P_i\)</span> <strong>可以利用目前資源完工，進入第四步。</strong></li>
</ol></li>
<li><ol start="4" type="1">
<li>最後確認 <span class="math inline">\(Finish[]\)</span> 非全皆為 <span class="math inline">\(True\)</span> 後<strong>得知目前有「Deadlock」，而在死結內的程序有</strong> <span class="math inline">\(P_1, P_2, P_3, P_4\)</span>。</li>
</ol></li>
</ul>
<h4 id="single-instance-resource-algorithm-1">Single instance resource algorithm</h4>
<ul>
<li>令 <span class="math inline">\(G = ＜V, E＞\)</span> 有向圖代表「Wait-for Graph」，其中<br>1. Vertex：<strong>只有 Process 而已，無 Resource 頂點</strong>。<br>2. Edge：Wait-for edge。</li>
</ul>
<figure>
<img src="\willywangkaa\images\1530174622303.png" alt="1530174622303" /><figcaption aria-hidden="true">1530174622303</figcaption>
</figure>
<ul>
<li>從 RAG 簡化而成，即為：</li>
</ul>
<figure>
<img src="\willywangkaa\images\1530174725109.png" alt="1530174725109" /><figcaption aria-hidden="true">1530174725109</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1530174756704.png" alt="1530174756704" /><figcaption aria-hidden="true">1530174756704</figcaption>
</figure>
<ul>
<li>較為 Detection 演算法<strong>簡單</strong>
<ul>
<li><strong>使用「Wait-for graph」：在「Wait-for graph」中，若有 cycle 存在則目前有死結存在，否則目前無死結存在。</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1529287297237.png" alt="1529287297237" /><figcaption aria-hidden="true">1529287297237</figcaption>
</figure>
<ul>
<li>此「Wait-for Graph」有 Cycle，所以有死結存在。</li>
</ul>
<figure>
<img src="\willywangkaa\images\1529287327536.png" alt="1529287327536" /><figcaption aria-hidden="true">1529287327536</figcaption>
</figure>
<h4 id="recovery">Recovery</h4>
<ul>
<li>Kill processes in the deadlock
<ul>
<li><strong>Kill 「all」 processes in the deadlock</strong>：先前的工作成果全部作廢，成本太高。</li>
<li><strong>Kill process one by one</strong>，刪除一個 process 之後再使用<strong>偵測死結演算法，若死結仍存在，再多刪除一個 process。( 因為這種做法需要：O(loop 刪除次數</strong>$ $<strong>偵測成本 )，時間成本太高不值得 )</strong></li>
</ul></li>
<li><strong>Resource preemption (資源剝奪)</strong>
<ol type="1">
<li>選擇受害 Process。</li>
<li>剝奪該 Process 的資源。</li>
<li><strong>回復該受害 Process 當初未被剝奪資源的狀態。(太困難，成本太高也可能會有 Starvation 的問題)</strong></li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Deadlock</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System - Memory Management</title>
    <url>/willywangkaa/2018/09/08/Operating-System-Memory-Management/</url>
    <content><![CDATA[<h1 id="memory-management">Memory Management</h1>
<h2 id="binding">Binding</h2>
<p><strong>為決定程式( 或 Process ) 執行的起始位址的動作。</strong></p>
<ul>
<li><strong>時機分類</strong>
<ul>
<li><strong>Compiling time</strong>：由編譯器主導 Binding，<strong>也稱為 Static binding。(通常用在作業系統的命令檔之中 )</strong>
<ul>
<li>產生的 Object code 又稱為<strong>「Absolute object code」</strong>；而在之後的 Loader 稱為<strong>「Abslolute Loader」</strong>，先做完 Loading 的工作之後，會將指定位址的程式碼對作業系統進行詢問( Allocation )，若該位址不可擺放，會對開發者丟出<em>錯誤回報</em>。</li>
<li><strong>Cons</strong>
<ul>
<li><strong>Process 若要改變執行檔的起始位址，必須要重新對原始碼重新編譯，非常不便。</strong></li>
</ul></li>
<li>Note：通常用於 .com ( 作業系統命令檔 )。</li>
</ul></li>
<li><strong>Loading time 或 Linking loading time</strong>：由 Linking loader 或 Linkage editor 主導 Binding<strong>，也稱為 Static binding。</strong>
<ul>
<li>Compiler 所產生出的 Object code <strong>稱為 「Relocatable object code」( 可重新定位目的碼 )</strong></li>
<li><strong>Pros</strong>
<ul>
<li><strong>程式起始位址若要修改，只要重新做「Relocation loading」，而無須重新編譯。</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li>程式充新執行時，若「Module ( 外部參考 )」的數量很多，則會花很多時間在「Re-linking」上。</li>
<li><strong>Process 執行期間，不可以更改程式在記憶體的起始位址。</strong></li>
</ul></li>
</ul></li>
<li><strong>Execution time</strong>：由作業系統動態決定起始位址<strong>，也稱為 Dynamic binding。</strong>
<ul>
<li>決定 Process 起始位址之工作，延到<strong>執行時期 ( execution time )才動態執行，也就是說 Process 在執行期間可以任意變更起始位址且 Process 仍能正確執行。</strong></li>
<li><strong>需要硬體額外的支持。</strong></li>
<li><strong>Pros：</strong>Process 的起始位址可在執行期間任意更動且能正確地執行，<strong>有助於作業系統在記憶體管理上的彈性度，像是「Compaction」、「Process 的 Swap out 與Swap in」都很需要這種技術才能完美的執行。</strong></li>
<li><strong>Cons：</strong>需要硬體額外的支持；<strong>Process 在執行時需時較久，效能較差</strong>。</li>
</ul></li>
</ul></li>
<li>Relocation</li>
</ul>
<figure>
<img src="\willywangkaa\images\relocation.png" alt="relocation" /><figcaption aria-hidden="true">relocation</figcaption>
</figure>
<ul>
<li>Linking</li>
</ul>
<figure>
<img src="\willywangkaa\images\linking.png" alt="linking" /><figcaption aria-hidden="true">linking</figcaption>
</figure>
<ul>
<li>Relocation</li>
</ul>
<figure>
<img src="\willywangkaa\images\relocation_2.png" alt="relocation_2" /><figcaption aria-hidden="true">relocation_2</figcaption>
</figure>
<ul>
<li>Dynamic relocation</li>
</ul>
<figure>
<img src="\willywangkaa\images\dynamicrelocation.png" alt="dynamicrelocation" /><figcaption aria-hidden="true">dynamicrelocation</figcaption>
</figure>
<ul>
<li><p><strong>＜補充＞</strong></p>
<ul>
<li>Relocation－修正：<strong>當程式執行起始位址改變，某些 Object code 內容必須隨之修正，</strong>才能正確執行。
<ul>
<li>當有採用「直接定址 ( Direct addressing mode )」指令時，當起始位址改變，就必須改變其地址。</li>
</ul></li>
<li><strong>Linking－修正：解決「外部參考 (External symbol reference)」之修正。</strong>
<ul>
<li>屬於「外部符號；外部參考」：<strong>副程式名稱、外部變數 ( entern )、函式庫 ( Librery )...。</strong></li>
</ul></li>
<li>「Linking loader」負責：
<ul>
<li>Allocation：向作業系統要求起始位址。</li>
<li>Loading：將目的碼載入到記憶體之中。</li>
<li><strong>Linking：依照編譯器所交辦的「Linking 修正資訊」，執行 Linking 修正。</strong></li>
<li>Relocation：做重新定位的目的碼相關修正。</li>
</ul></li>
</ul></li>
<li><p><strong>＜Note＞凡是以「Static binding」的方式定位程式碼，皆無法在執行的期間更改該 Process 在記憶體的起始位址。</strong></p></li>
<li><p>Relocatable object code</p></li>
</ul>
<figure>
<img src="\willywangkaa\images\relocatiableobjectcode.png" alt="relocatiableobjectcode" /><figcaption aria-hidden="true">relocatiableobjectcode</figcaption>
</figure>
<ul>
<li><strong>記憶體位址探討</strong>
<ul>
<li>Logical address：generateby CPU</li>
<li>Phosical address：時竟去 Physical memory ( i.e. RAM ) 存取之位址。</li>
<li>若發生<span class="math inline">\(\left\{\begin{matrix} Logical\; address = physical\; address \Rightarrow Static\; binding \\ Logical\; address \neq physical\; address \Rightarrow {\left\{\begin{matrix} Dynamic\; binding \\ Page \\ Segement \\ Page—segement \end{matrix}\right.} \end{matrix}\right.\)</span></li>
<li>當電腦要將「Logical address」要轉成「Physical address」時，會交由<strong>硬體的 Memory Manegement Unit (MMU) 負責完成。( 不適合交給作業系統處理，因為一直不斷的中斷很浪費效能。 )</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\compilingflow.png" alt="compilingflow" /><figcaption aria-hidden="true">compilingflow</figcaption>
</figure>
<h2 id="dynamic-loading">Dynamic Loading</h2>
<p>也稱為「Load-on-call」，在執行期間時，若「Mudule」真正被呼叫到而且不在記憶體中，則當下「Loader」才能將它載入到記憶體中。</p>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>節省記憶體空間。</strong></li>
<li><strong>不需要作業系統額外的支持。</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>Process 執行的時間比較久。</strong></li>
</ul></li>
<li>＜Note＞
<ul>
<li>早期稱為「Overlay 結構」技巧，是開發人員的責任，而作業系統無介入管理。</li>
<li>現在的技術都已經交給作業系統提供的「虛擬記憶體 ( Vrtual memory )」。</li>
</ul></li>
</ul>
<h2 id="dynamic-linking">Dynamic Linking</h2>
<p>在執行期間時，若「Module」被呼叫到，才將之載入並且與<strong>其他「Module」進行「Linking - 修正」( 解決外部符號參考 )。</strong></p>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>適用在「函式庫鏈結 ( Library linking )」，如：Dynamic linking library。</strong></li>
<li><strong>節省不必要的 Linking time。</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>需要作業系統的支援。</strong></li>
<li>執行所需時間比較久。</li>
</ul></li>
</ul>
<h2 id="memory-allocation">Memory Allocation</h2>
<h3 id="external-fragmentation-情形">External Fragmentation 情形</h3>
<p>在連續性配置的要求下，目前 AV-list 中任何一個 Hole 的大小均小於某個 Process 的大小，<strong>但是當這些 Holes 大小的加總時，卻大於等於 Process 大小，而這些零碎的可用記憶體空間因為不連續，所以仍然無法配置給 Process</strong>，這種情況就稱為「External Fragmentation」。</p>
<ul>
<li>空閒空間不能使用，記憶體使用度低 ( Low memory utilzation )。</li>
<li>＜Note＞
<ul>
<li>一般而言，每當配置 N 大小的空間給 Process 時，會有大約 0.5N 的外部碎裂，所以外部碎裂的比例為 <span class="math inline">\(\frac{0.5 \times N}{N + 0.5 \times N} = \frac{1}{3}\)</span> 稱為「One third rule」，<strong>顯現出外部碎裂是非常嚴重的問題。</strong></li>
</ul></li>
</ul>
<h4 id="解決方法">解決方法</h4>
<h5 id="使用compaction-壓縮聚集-技術">使用「Compaction ( 壓縮；聚集 )」技術</h5>
<figure>
<img src="\willywangkaa\images\compaction.png" alt="compaction" /><figcaption aria-hidden="true">compaction</figcaption>
</figure>
<p>移動<strong>執行中的 Process</strong>，使得原本非連續的可用記憶體空間 ( Hole )，可以聚集形成一個夠大的連續可用的記憶體空間。</p>
<ul>
<li><strong>演算法難以實作</strong>
<ul>
<li><strong>不易在最段時間制定最佳的 Compaction 策略。</strong></li>
<li><strong>Processes 必須為「Dynamic binding」才可於執行期間移動。</strong>(大多數程式傾向於 Static binding)</li>
</ul></li>
</ul>
<h5 id="使用-page-memory-management-分頁記憶體管理">☆使用 Page Memory Management (分頁記憶體管理)</h5>
<ul>
<li>將「Physical memory」( RAM ) 視為一組 <strong>Frame (頁框) 的集合</strong>，且個各個 <strong>Frame size 相同</strong>。
<ul>
<li><strong>注意：Frame size 是硬體決定，作業系統只是配合</strong>，Paging 使採用「Physical」的觀點。</li>
</ul></li>
<li>「Logical memory」( User process 大小 ) 視為一組 <strong>Paging ( 頁面 )</strong>的集合，<strong>且 Page size 要使它等於 Frame size。</strong></li>
<li>作業系統以<strong>「非連續性」的配置原則</strong>，即若 Process 大小等於 n 個 Pages ，則作業系統只需在「Physical memory」中找出<strong>n 個可用的頁框(不一定要連續)，即可配置給 Process。</strong></li>
<li>作業系統會針對每一個 Processe 建立一個<strong>Page table ( 分頁表 )，紀錄各個 Page 實際置於哪個編號的頁框，當 Process 大小等於 n 個頁面，則他的分頁表就有 n 個 entry。</strong>
<ul>
<li><strong>注意：分頁表被儲存於 PCB ( Process control block ) 之中。</strong></li>
</ul></li>
<li>圖示</li>
</ul>
<figure>
<img src="\willywangkaa\images\paging.png" alt="paging" /><figcaption aria-hidden="true">paging</figcaption>
</figure>
<ul>
<li><strong>Logical address 轉譯 physical address ( 使用 Memory Manegemeny Unit )</strong>
<ol type="1">
<li>Logical address 初始是<strong>單一量</strong>，CPU 自動拆解成 p d(如下圖)，<strong>其中 P 代表分頁編號， d 代表 Page offset ( 偏移量 )。</strong>( Note：<span class="math inline">\(單一量位址 = Page\;size \times &quot;p&quot; + &quot;d&quot;\)</span> )</li>
<li>依據 P 查詢分頁表，取得該 Process 的頁框編號 f 。</li>
<li>f 與 d 合成為 f d (如下圖) 即為「Physical address」或 $ f Page ; size + d $。</li>
</ol></li>
</ul>
<figure>
<img src="\willywangkaa\images\logical2physicaladdress.png" alt="logical2physicaladdress" /><figcaption aria-hidden="true">logical2physicaladdress</figcaption>
</figure>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>沒有外部碎裂問題。</strong></li>
<li><strong>可以支援記憶體共享( Memory sharing )與記憶體保護( Memory protection )的實施。</strong></li>
<li><strong>可支持 Dynamic loading 、Dynamic linking 與 Virtual memory 的實現。</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li>由於 Process 的大小不一定會是分頁大小的整數倍數，所以<strong>會發生內部碎裂的問題 ( Internal fragementation )。</strong>
<ul>
<li><strong>＜Note＞：若分頁大小愈大，則內部碎裂愈嚴重。</strong></li>
</ul></li>
<li><strong>需要額外的硬體支援。</strong>
<ul>
<li><strong>分頁表的製作。</strong></li>
<li>邏輯位址利用 <strong>MMU</strong> 轉換成實體位址。</li>
<li>因為要轉換記憶體位址，所以<strong>「Effective memory acess time」比較長( 與連續記憶體配置比相比)。</strong></li>
</ul></li>
</ul></li>
</ul>
<h6 id="memory-sharing">Memory sharing</h6>
<figure>
<img src="\willywangkaa\images\memorysharing.png" alt="memorysharing" /><figcaption aria-hidden="true">memorysharing</figcaption>
</figure>
<p>若多個 Process 彼此具有共通的<strong>唯讀分頁( Code、Data )</strong>，則我們可以藉由 Process 各自的分頁表將共通的分頁<em>映射</em> 到同一個頁框，如此可以節省記憶體空間。</p>
<ul>
<li>Copy on write</li>
</ul>
<h6 id="memory-protection">Memory protection</h6>
<p>在分頁表中多加一個「Protection bit」欄位，<span class="math inline">\(\left\{\begin{matrix} R：Page \; 唯讀。 \\ W： Page \; 可以讀寫。 \end{matrix}\right.\)</span></p>
<h5 id="multiple-baselimit-regisers-不建議">Multiple base/limit regisers (不建議)</h5>
<ul>
<li>拆解 Process 的記憶體為「Code section」與「Data section」，分開連續配置的空間 ( Hole ) ，以<strong>降低外部碎裂發生的機率(非解決外部碎裂為題)。</strong></li>
<li>因為每個 Process 需要兩套的 Base 與 Limit 暫存器，分別記錄「Code section」與「Data section」的起始位址與大小。</li>
</ul>
<h3 id="internal-fragmentation-情形">Internal Fragmentation 情形</h3>
<p><strong>配置的記憶體空間超過 Process 大小，而該差值的記憶體空間無法給該 Process 使用，亦其他 Processes 無法使用</strong>，這種情況稱為「Internal Fragmentation」。</p>
<h3 id="contiguous-memory-allocation---連續性記憶體配置">Contiguous Memory Allocation - 連續性記憶體配置</h3>
<p>也稱為 Dynamic Variable Parition Memory Managememt ( 動態變動分區記憶體配置 )。</p>
<ul>
<li>作業系統配置 Process 一個<strong>連續的可用記憶體空間 ( Free memory space )。</strong></li>
<li>Dynamic Variable Parition Memory Managememt
<ul>
<li>名詞解釋
<ul>
<li><strong>Partition ( 分區 )：Process 所占用的記憶體空間。</strong></li>
<li><strong>Partition 數量等價於「Process 數量」亦等價於「Multiprogramming Degree」。</strong></li>
</ul></li>
<li>不同時間點，系統內 Process 數量不固定，所以<strong>Partition 數量不固定而稱為「Dynamic」。</strong></li>
<li>由於各個 Process 大小不盡相同，所以<strong>各個 Partition 大小也就不一定相同而稱為「Variable」。</strong></li>
</ul></li>
<li>記憶體中會有一些可用的記憶空間 ( Free memory space or Free memory block ) 稱之為「Hole」，通常作業系統會使用「鏈結串列」的概念管理 Holes ，稱為可用空間串列 ( Available list；AV-list )。</li>
</ul>
<figure>
<img src="\willywangkaa\images\avlist.png" alt="avlist" /><figcaption aria-hidden="true">avlist</figcaption>
</figure>
<h4 id="配置方法">配置方法</h4>
<ul>
<li><p><strong>First-fit：</strong>從 AV-list 的開頭找，直到找到<strong>第一個 Hole ，其大小大於等於 Process 的大小，</strong>即可配置之；若找完串列中，所有 Hole 沒有一個適合的則終止。</p></li>
<li><p><strong>Best-fit：</strong>必須檢查 AV-list 中<strong>所有 Holes</strong> ，找出一個符合「其大小大於等於 Process 的大小」且<strong>「其大小與 Process 大小的差值為最小」的 Hole 配置給 Process。</strong></p></li>
<li><p><strong>Worst-fit：</strong>必須檢查 AV-list 中<strong>所有 Holes</strong> ，找出一個符合「其大小大於等於 Process 的大小」且<strong>「其大小與 Process 大小的差值為最大」的 Hole 配置給 Process。</strong></p></li>
<li><p>Ex ( 依上圖 )</p>
<ul>
<li>有一 Process 為 90 K
<ul>
<li>則使用「First-fit」，會配置 <strong>（A）</strong> Block 之 90 K 給Process，剩下 <strong>210</strong> K。</li>
<li>則使用「Best-fit」，會配置 <strong>（B）</strong> Block 之 90 K 給Process，剩下 <strong>10</strong> K。</li>
<li>則使用「Worst-fit」，會配置 <strong>（C）</strong> Block 之 90 K 給Process，剩下 <strong>410</strong> K。</li>
</ul></li>
</ul></li>
<li><p><strong>比較表</strong></p></li>
</ul>
<table>
<thead>
<tr class="header">
<th>綜合比較</th>
<th style="text-align: center;"></th>
<th>時間效率</th>
<th>空間利用度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>佳</td>
<td style="text-align: center;">First-fit</td>
<td>最佳</td>
<td>佳</td>
</tr>
<tr class="even">
<td></td>
<td style="text-align: center;">Best-fit</td>
<td>差</td>
<td>最佳</td>
</tr>
<tr class="odd">
<td></td>
<td style="text-align: center;">Worst-fit</td>
<td>差</td>
<td>差</td>
</tr>
</tbody>
</table>
<h4 id="問題與討論">問題與討論</h4>
<ul>
<li>Ex
<ul>
<li>Page size：10 kB</li>
<li>Process 大小：32 kB</li>
</ul></li>
</ul>
<p><span class="math display">\[
\because 需要配置 4 個分頁給 \;Process \\
\therefore 內部碎裂 = 4\times10 - 32 = 8 \;kB
\]</span></p>
<h3 id="分頁表的實現">分頁表的實現</h3>
<h4 id="使用暫存器保存分頁表">使用暫存器保存分頁表</h4>
<p>使用暫存器保存分頁表中每個 Entry 的頁框編號。</p>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>存取分頁表時無須記憶體存取，速度最快。</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li>因為數量有限，<strong>不適合用於大型的分頁表( 大型 Process )。</strong></li>
</ul></li>
</ul>
<h4 id="使用記憶體保存分頁表-不太採用">使用記憶體保存分頁表 ( 不太採用 )</h4>
<p>用兩個個暫存器 ( PTBR；Page table base register 、PTLR；Page table length register ) 紀錄該分頁表位於記憶體中的位址與分頁表大小。</p>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>適用於大型分頁表。</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>需額外多一次的記憶體存取，所以速度很慢。</strong></li>
</ul></li>
</ul>
<h4 id="使用-tlb-translation-lookasdie-buffer-加速">使用 TLB ( Translation lookasdie buffer ) 加速</h4>
<p>使用 <strong>TLB ( Translation lookasdie buffer ) register ( or Associative register ) 保存分頁表中經常被存取之分頁編號與頁框編號</strong>，而完整的分頁表還是置於記憶體之中。</p>
<ul>
<li>圖示</li>
</ul>
<figure>
<img src="\willywangkaa\images\TLB.png" alt="TLB" /><figcaption aria-hidden="true">TLB</figcaption>
</figure>
<ul>
<li><strong>使用 TLB 的「Effective memory acess time」 = </strong><span class="math inline">\(P \times ( TLB\; time + Memory \;acess \;time + (1-P) \times (TLB + 2 \times Memory \;acess \;time) )\)</span>
<ul>
<li>P 為 TLB 的 hit ratio。</li>
</ul></li>
</ul>
<h4 id="問題">問題</h4>
<h5 id="使用-tlb-之effective-memory-aceess-time">使用 TLB 之「Effective memory aceess time」</h5>
<p>Ex</p>
<ul>
<li>Register acess time：0 ns ( ignored )。</li>
<li>Memory access time：200ns。</li>
<li>TLB time：100 ns</li>
<li>TLB hit ratio：90%</li>
<li>求 Effective memory acess time 當分頁表儲存於：
<ul>
<li>暫存器：200 ns</li>
<li>記憶體：400 ns</li>
<li>記憶體、TLB 加速：<span class="math inline">\(0.9 \times (100 +200) + 0.1 \times (100 + 0.1\times200) = (100 + 200) + 0.1 \times 200\)</span><br> = 320 ns。</li>
</ul></li>
</ul>
<h5 id="logical-address-與-physical-address-bit-數量計算">Logical address 與 Physical address bit 數量計算</h5>
<ul>
<li><p>Page size = 1KB。</p></li>
<li><p>Process 最大有 8 個 Pages。</p></li>
<li><p>Physical memory 有 32 個 frames。</p></li>
<li><p>求取</p>
<ul>
<li>Logical memory 需要多少 bits。</li>
<li>Physical memory 需要多少 bits。</li>
</ul></li>
<li><p>Logical address</p></li>
</ul>
<p>因為一個分頁大小為 1 KB 也就是 <span class="math inline">\(2^{32}\)</span> bytes，所以 d 佔有 10 bits；</p>
<p>Process 最多 8 個分頁也就是 <span class="math inline">\(2^3\)</span> 個分頁，p 需要 3 個 bits 紀錄，所以需要 3 + 10 = 13 bits ( Logical )。</p>
<p>Physical memory 有 32 個頁框，也就是 <span class="math inline">\(2^5\)</span> 個頁框， f 需要 5 個 bits 紀錄，所以總共需要 5 + 10 = 15 bits ( Physical )。</p>
<h5 id="page-table-大小計算">Page table 大小計算</h5>
<p>Ex1</p>
<ul>
<li>Page size = 8 KB。</li>
<li>Process 大小 = 2MB。</li>
<li>Page table entry 佔有 4 bytes。</li>
<li>求此 Process 的 Page table size。</li>
</ul>
<p>一個 Process 中最多有 <span class="math inline">\(\frac{2 \; MB}{8 \;KB} = 2^8\)</span> 個分頁，也就是說每個 Process 的分頁表都有 <span class="math inline">\(2^8\)</span> 個 Entry ，所以分頁表大小為 <span class="math inline">\(2^8 \times 4 \; B = 1 \; KB\)</span>。</p>
<p>Ex2</p>
<ul>
<li>Logical address = 32 bit。</li>
<li>Page size = 16 KB。</li>
<li>Page table entry 佔有 4 B。</li>
<li>求 Max page table size。</li>
</ul>
<p>一個 Process 中最多有 <span class="math inline">\(\frac{4 \; GB}{16 \;KB} = 2 ^{18}\)</span> 個分頁，也就是說每個 Process 的分頁表都有 $2^{18} $ 個 Entry ，所以分頁表大小為 <span class="math inline">\(2^{18} \times 4 \;B = 1 \; MB\)</span>。</p>
<ul>
<li>承上，若 Logical address 改為 48 bit 。</li>
</ul>
<p>一個 Process 中最多有 <span class="math inline">\(\frac{ 2^{48}\;B}{16 \;KB} = 2 ^{34}\)</span> 個分頁，也就是說每個 Process 的分頁表都有 $2^{34} $ 個 Entry ，所以分頁表大小為 <span class="math inline">\(2^{34} \times 4 \;B = 64 \; GB\)</span>。</p>
<p><strong>＜Note＞：Page table 太大。</strong></p>
<p>Ex3</p>
<ul>
<li>Page size = 16 KB</li>
<li>Page table entry 佔有 4B</li>
<li>Max page table size 恰為 one page。</li>
<li>求 Logical address length。</li>
</ul>
<p>因為一個分頁表的大小為一個分頁的大小 ( 16 KB ) ，而一個 Page entry 的大小為 4 B ，所以總共會有 <span class="math inline">\(\frac{16\;KB}{4 \; B} = 4K\)</span> entries (<span class="math inline">\(2^{12}\)</span>)，所以 p 為 12 bits，而每個分頁的大小為 16 KB (<span class="math inline">\(2^{14}\)</span>)所以 d 為 14 個 bits，最後羅技位址的長度為 12 + 14 = 26 bits。</p>
<h5 id="解決-page-table-size-過大的問題">解決 Page table size 過大的問題</h5>
<p>下一節細述。</p>
<h3 id="處理過大分頁表">☆處理過大分頁表</h3>
<h4 id="multilevel-paging-hierarchical-paging-paging-the-page-table-forward-mapping">☆☆Multilevel paging ( Hierarchical paging; Paging the page table; Forward mapping )</h4>
<p>並不是將分頁表縮小，而是將不需要的分頁表先存在磁碟之中，縮小分頁表在 RAM 佔有的空間，<strong>所以提出多層次的分頁，藉由此作法，不須將整個分頁表全部載入 RAM ，而是載入部分所需的內容，。</strong></p>
<figure>
<img src="\willywangkaa\images\twolevelpaging.png" alt="twolevelpaging" /><figcaption aria-hidden="true">twolevelpaging</figcaption>
</figure>
<ul>
<li>Ex ( Two-level paging ) 下圖
<ul>
<li>Level-1 page table：<strong>有</strong> <span class="math inline">\(2^x\)</span> <strong>個 Entries，每個 Enteries 記錄某個 level-2 page table 的指標 (位址)。</strong></li>
<li>Level-2 page table：<strong>有</strong> <span class="math inline">\(2^y\)</span> <strong>個 Entries，每個 Enteries 紀錄著頁框的編號。</strong></li>
<li>可以將原本<strong>分頁表為</strong> <span class="math inline">\(2^{x+y}\)</span> 大小，拆成同樣可以記錄一樣多頁框編碼的 Multilevel page table (outer：<span class="math inline">\(2^x\)</span>, inner：<span class="math inline">\(2^y\)</span>、total：<span class="math inline">\(2^x\times2^y\)</span>)</li>
<li>雖然要記載頁框編號的<strong>分頁表容量(存於硬碟)變多</strong>，但是<strong>每次需載至 RAM 的容量大幅減少</strong> (Process 在執行時，只需要一個 Level1-page table 與某一個 Level2-page table 在 RAM 中即可)。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\twolevelpaging_2.png" alt="twolevelpaging_2" /><figcaption aria-hidden="true">twolevelpaging_2</figcaption>
</figure>
<ul>
<li>Ex( Three-level paging )</li>
</ul>
<figure>
<img src="\willywangkaa\images\threelevelpaging.png" alt="threelevelpaging" /><figcaption aria-hidden="true">threelevelpaging</figcaption>
</figure>
<ul>
<li>Cons
<ul>
<li><strong>Effect memory access time 更久</strong>：需要更多次的存取在記憶體的分頁表。
<ul>
<li>Ex two-level paging 需要 3 次的記憶體存取，three-level paging 需要 4 次的記憶體存取。</li>
</ul></li>
</ul></li>
</ul>
<h5 id="相關計算題">相關計算題</h5>
<ul>
<li>Ex1
<ul>
<li>TLB time：100 ns</li>
<li>TLB hit ratio：80 %</li>
<li>Memory access time：200 ns</li>
<li>採用 Two-level paging</li>
<li>求出 Effect memory access time</li>
</ul></li>
</ul>
<p>則 $ ( 100 ;ns+ 200 ; ns ) + 20％ (100 ; ns + 3  ; ns) = 420 ;ns$</p>
<ul>
<li>Ex2
<ul>
<li>Logical address = 32 bits</li>
<li>Page size = 4 kB</li>
<li>Page table entry 佔有 4B</li>
<li>求 Max page table size
<ul>
<li>Single-level paging</li>
<li>在 level-1 page table 與 level-2 page table 大小相等之下的 Two-level paging</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>Single-level paging</p>
</blockquote>
<p>因為 Page size 為 <span class="math inline">\(4 KB = 2^{12} B\)</span> 所以會有 <span class="math inline">\(\frac{2^{32} B}{2^{12} B} = 1M \; entries\)</span> ，而每個 Entry 佔有 4B，所以分頁表總量為 <span class="math inline">\(1 \;M \times 4 \;B = 4 \;MB\)</span>。</p>
<blockquote>
<p>Two-level paging</p>
</blockquote>
<p>每次要抓入 RAM 的 Page table 大小為 <span class="math inline">\((1 \;K + 1 \; K) \times 4B = 8KB\)</span>。</p>
<blockquote>
<p>因為 Page size 為 <span class="math inline">\(4 KB = 2^{12} B\)</span> 所以會有 <span class="math inline">\(\frac{2^{32} B}{2^{12} B} = 1M \; entries\)</span> ，解著，將分頁表分成兩層，也就是 level 1 應有 <span class="math inline">\(2^{10}\)</span> 個 entries ，level 2 也有 <span class="math inline">\(2^{10}\)</span> 個 entries，但是總共有 <span class="math inline">\(2^{10}\)</span> 個 level 2 page table，而每個 Entry 佔有 4B，所以分頁表總量為 <span class="math inline">\((1 \;M + 1K) \times 4 \;B = 4.004 \;MB\)</span>。</p>
</blockquote>
<ul>
<li><strong>☆Ex 3</strong>
<ul>
<li>Logical address = 64 bits</li>
<li>page size = 16 KB</li>
<li>Page table entry 佔有 4 B</li>
<li><strong>任一 level paging 之 Max page table size 頂多為一個分頁</strong>，則至少分幾層 (？-level paging)。</li>
</ul></li>
</ul>
<p>總共有 <span class="math inline">\(\frac{2^{64} \;B}{2^{14} \;B} = 2^{50} \;entries\)</span> ，然而任一 level paging 之 Max page table size 頂多為一個分頁(16 K)，<strong>所以任一 level 之分頁表最多有</strong> <span class="math inline">\(\frac{16 \; KB}{4 \;B} = 2^{12} entries\)</span>，最後 <span class="math inline">\(\lceil \frac{50}{12} \rceil = 5 \;levels\)</span> 所以最少可以分 2 層。</p>
<h4 id="hashing-page-table">Hashing page table</h4>
<figure>
<img src="\willywangkaa\images\hashpagetable.png" alt="hashpagetable" /><figcaption aria-hidden="true">hashpagetable</figcaption>
</figure>
<p>利用雜湊的技巧將分頁表視為雜湊表，具有<strong>相同雜湊碼(位址)</strong>的分頁碼與它的頁框碼資訊會置於同一個 Entry ( bucket ) 中，且以「Link list」(chain) 串接。</p>
<ul>
<li>一開始先將雜湊表(指標陣列) 載入到 RAM ，算完雜湊函數之後，將該雜湊串列載入至 RAM 中，最後，當 RAM 位址不夠時，可將先前載入 RAM 的串列移除。</li>
<li><strong>Cons</strong>
<ul>
<li><strong>在「Link list」中使用線性搜尋找尋符合的分頁編號是很耗時的工作。</strong></li>
</ul></li>
</ul>
<h5 id="相關計算題-1">相關計算題</h5>
<ul>
<li>Ex
<ul>
<li><span class="math inline">\(H(x) = x \;％\; 53\)</span></li>
<li>Page table entry 佔有 4 B</li>
<li>求 Hashing Page table size？</li>
</ul></li>
</ul>
<p>總共應有 53 個 Entries ，所以 <span class="math inline">\(53 \times 4 B= 212 B\)</span>。</p>
<h4 id="inverted-page-table-反轉分頁表">☆Inverted page table ( 反轉分頁表 )</h4>
<figure>
<img src="\willywangkaa\images\invertpagetable.png" alt="invertpagetable" /><figcaption aria-hidden="true">invertpagetable</figcaption>
</figure>
<p><strong>以實體記憶體為記錄對象</strong>，並非以 Process ( 虛擬記憶體 ) 為對象，<strong>即若有 n 個頁框，則此表就有 n 個 entry，每個 entry 紀錄（Process id, Page no.）之配對資訊，代表這個頁框存放哪個 Process 之 Page相對於該分頁標號。</strong></p>
<ul>
<li><p>整個作業系統只需要<strong>一份表格( 不同的 Process 之間) </strong>即可。</p></li>
<li><p>Cons</p>
<ul>
<li>必須使用（Process id, Page no.）資訊一一比對查詢分頁表<strong>相當耗時</strong>。</li>
<li><strong>☆因為還需多比對「Process id」才能找到該頁框，所以當同時有兩個 Process 共享同一塊程式碼時，是必須要多使用一個 entry 來放置該對應的頁框碼，然而一個 entry 即是一個頁框，所以對應到同一塊位址的區塊會存於相異的頁框，無法實現「Memory sharing 」的功能。( 下圖 )</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\invertpagetable2.png" alt="invertpagetable2" /><figcaption aria-hidden="true">invertpagetable2</figcaption>
</figure>
<h5 id="相關計算題-2">相關計算題</h5>
<ul>
<li>Ex
<ul>
<li>Page size = 8 KB</li>
<li>Physical memory = 16 KB</li>
<li>Page table entry 佔有 4 B</li>
<li>求 Inverted page table size？</li>
</ul></li>
</ul>
<p>現在有 <span class="math inline">\(\frac{16\;GB}{8\;KB} = 2\;M \;entries\)</span>，也就是有 2 M 個頁框，所以 Inverted page table 大小為 <span class="math inline">\(2 \;M \times 4 \;B = 8 MB\)</span>。</p>
<h3 id="segement-memory-management">Segement memory management</h3>
<figure>
<img src="\willywangkaa\images\segementation.png" alt="segementation" /><figcaption aria-hidden="true">segementation</figcaption>
</figure>
<ul>
<li>將<strong>實體記憶體</strong>視為一個夠大的連續可用空間。</li>
<li>將<strong>邏輯記憶體 ( Process )</strong> 視為一組 <strong>Segement 的集合，且各 Segement 大小不一定相同。</strong>
<ul>
<li><strong>CPU 以「Logical address」看待該 Process 的所有 Segement。</strong>( User 相對於 RAM )
<ul>
<li><strong>Code segement、Data segement、Stack segement ...</strong></li>
</ul></li>
</ul></li>
<li>配置原則
<ul>
<li><strong>Segement 之間可以是非連續性記憶體配置。</strong></li>
<li><strong>每一個 Segement 必須占用連續的記憶體空間。</strong></li>
</ul></li>
<li><strong>作業系統</strong>會替每個 Process 建立<strong>分段表 (Segement table)</strong>，紀錄每個 Segement 的<strong>大小( limit )與起始位址( Base )</strong>。</li>
<li><strong>邏輯位址轉換實體位址。</strong>
<ul>
<li>邏輯位址有兩個<strong>變量 ( 變量為獨立不相關，因為不同分段之間大小不等 )</strong>。
<ul>
<li>s：分段編號</li>
<li>d：該分段的偏移量 ( offset )</li>
</ul></li>
<li><strong>依照 s 在分段表查找，取得該分段的大小與起始位址。</strong></li>
<li><strong>必須檢查偏移量是否小於該分段大小。</strong>
<ul>
<li>若成立則將該實體位址返回給正在執行的 Process。( Physical address = base + d )</li>
<li>若不成立則<strong>「MMU」</strong>會產生一個<strong>非法存取的 exception 給作業系統</strong>，將該 Process 終止。</li>
</ul></li>
</ul></li>
<li><strong>Pros</strong>
<ul>
<li><strong>沒有內部碎裂。</strong></li>
<li>可以支持「Memory sharing」與「Memory protection」。</li>
<li>可以支持「Dynamic loading」、「Dynamic linking」與「Virtual memory」的實現。</li>
<li><strong>因為 Segement 以邏輯位址查找，比起「Paging」更容易實現「Memory sharing」與「Memory protection」。</strong></li>
</ul></li>
</ul>
<blockquote>
<p>以 Protection 為例：</p>
<ul>
<li>分段</li>
</ul>
<figure>
<img src="\willywangkaa\images\segementprotection.png" alt="segementprotection" /><figcaption aria-hidden="true">segementprotection</figcaption>
</figure>
<ul>
<li>分頁 ( Page size = 100 K )</li>
</ul>
<figure>
<img src="\willywangkaa\images\pageprotection.png" alt="pageprotection" /><figcaption aria-hidden="true">pageprotection</figcaption>
</figure>
</blockquote>
<figure>
<img src="\willywangkaa\images\segementhw.png" alt="segementhw" /><figcaption aria-hidden="true">segementhw</figcaption>
</figure>
<ul>
<li><strong>Cons</strong>
<ul>
<li><strong>有外部碎裂。</strong></li>
<li>需要有額外硬體的支持。
<ul>
<li>分段表的保存。</li>
<li>邏輯位址轉換需要「MMU」 的協助。</li>
</ul></li>
<li>Effective memory access time <strong>更久</strong>。
<ul>
<li>需檢查分段偏移量是否小於該分段大小。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="相關計算題-3">相關計算題</h4>
<table>
<thead>
<tr class="header">
<th></th>
<th>Limit</th>
<th>Base</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>100</td>
<td>4200</td>
</tr>
<tr class="even">
<td>1</td>
<td>500</td>
<td>80</td>
</tr>
<tr class="odd">
<td>2</td>
<td>830</td>
<td>7300</td>
</tr>
<tr class="even">
<td>3</td>
<td>940</td>
<td>1000</td>
</tr>
</tbody>
</table>
<ul>
<li>Ex
<ul>
<li>給一分段表如上圖，求出下列相對於該邏輯位址的實體位址為多少？
<ul>
<li>（1）(0, 90)</li>
<li>（2）(1, 380)</li>
<li>（3）(2, 900)</li>
<li><strong>（4）(3, 940)</strong></li>
</ul></li>
<li>Ans：
<ul>
<li>（1）4290</li>
<li>（2）460</li>
<li>（3）非法存取</li>
<li>（4）非法存取</li>
</ul></li>
</ul></li>
</ul>
<h3 id="分頁分段比較表">分頁分段比較表</h3>
<table>
<colgroup>
<col style="width: 49%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Page</th>
<th style="text-align: center;">Segement</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>各個 Page size 均同</strong></td>
<td style="text-align: center;"><strong>各個分段大小不一定相同</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">以「Physical address」的觀點處理</td>
<td style="text-align: center;">以「Logical address」的觀點處理</td>
</tr>
<tr class="odd">
<td style="text-align: center;">無外部碎裂，有內部碎裂</td>
<td style="text-align: center;">有外部碎裂，無內部碎裂</td>
</tr>
<tr class="even">
<td style="text-align: center;">「Memory protection」與「Memory sharing」較難以實施</td>
<td style="text-align: center;">「Memory protection」與「Memory sharing」較容易以實施</td>
</tr>
<tr class="odd">
<td style="text-align: center;">無須檢查分頁偏移量</td>
<td style="text-align: center;">需要檢查分段偏移量</td>
</tr>
<tr class="even">
<td style="text-align: center;">邏輯位址為「單一變量」</td>
<td style="text-align: center;">邏輯位址為「雙變量」(分段編號、分段偏移量)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">分頁表紀錄「頁框編號」</td>
<td style="text-align: center;">分段表紀錄分段的「起始位址」與「大小」</td>
</tr>
</tbody>
</table>
<h3 id="page-segement-memory-management-分頁式分段">☆Page segement memory management (分頁式分段)</h3>
<p><span class="math display">\[
Process \rightarrow Segement \rightarrow Page
\]</span></p>
<figure>
<img src="\willywangkaa\images\segementpaging.png" alt="segementpaging" /><figcaption aria-hidden="true">segementpaging</figcaption>
</figure>
<ul>
<li>希望保有分段的優點「Logical viewpoint」，並解決外部碎裂，<strong>所以先將 Process 先分段再分頁。</strong></li>
</ul>
<h1 id="結論">結論</h1>
<table>
<thead>
<tr class="header">
<th></th>
<th>Continue allocation</th>
<th>Page</th>
<th>Segement</th>
<th>Page segement</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>外部碎裂</strong></td>
<td>有</td>
<td><strong>無</strong></td>
<td>有</td>
<td>無</td>
</tr>
<tr class="even">
<td><strong>內部碎裂</strong></td>
<td>無</td>
<td><strong>有</strong></td>
<td>無</td>
<td>有</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Memory Management</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System - Process Synchronization 2</title>
    <url>/willywangkaa/2018/08/04/Operating-System-Process-Synchronization-2/</url>
    <content><![CDATA[<h1 id="process-synchronization-process-communication-inter-process-communication">Process Synchronization ( Process Communication, Inter Process Communication )</h1>
<hr />
<h2 id="race-condition-problem-in-memory-communication">Race Condition Problem in Memory Communication</h2>
<figure>
<img src="\willywangkaa\images\thesolutionofracecondition.png" alt="thesolutionofracecondition" /><figcaption aria-hidden="true">thesolutionofracecondition</figcaption>
</figure>
<h3 id="monitor">Monitor</h3>
<figure>
<img src="\willywangkaa\images\thestructofmonitor.png" alt="thestructofmonitor" /><figcaption aria-hidden="true">thestructofmonitor</figcaption>
</figure>
<p>monitor 是一個用來解決同步問題的高階「資料結構」，是一種 <strong>ADT ( Abstract data type )</strong>。</p>
<ul>
<li>組成架構
<ul>
<li><strong>共享變數宣告區</strong></li>
<li><strong>一組 local funtions or procedures</strong></li>
<li><strong>初始區 ( Initialization area )</strong></li>
</ul></li>
<li>語法架構</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">type Monitor-Name = Monitor</span><br><span class="line">var 共享變數宣告</span><br><span class="line">procedure entry fun1-Name</span><br><span class="line">	begin</span><br><span class="line">		BODY;</span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">...</span><br><span class="line">procedure entry fun2-Name</span><br><span class="line">	begin</span><br><span class="line">		BODY;</span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">begin</span><br><span class="line">	初始區</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>Pros
<ul>
<li><strong>Monitor 本身已保證互斥( mutual exclusive )，即「任和時間點，最多只允許 1 個 Process 在 Monitor 內進行活動 ( active )」</strong>：在任何時間點，最多只允許 1 個 Process 呼叫 ( calling ) Monitor 的某一個 function or procedure 執行，不可有多個 processes 同時呼叫 Monitor 的 funciton 執行。</li>
<li>上述的互斥性質，是將<strong>「共享變數區的共享變數」設成只能以 Monitor 的 local function 存取</strong>，而不能直接從 Process 直接存取，<strong>而 Monitor 保障互斥，所以也會不會造成「Race condition」，完全無需再在意額外的演算法以防止 Race condition</strong>，只需專心解決同步問題即可( 在這一點比起 semaphore 好用很多，因為 semaphore 並不會保證 mutex 存取變數還須要演算法以輔助之 )。</li>
</ul></li>
<li><strong>Ex. 當我們在解決同步問題時，Semaphore 比起 Monitor 容易使用？</strong>
<ul>
<li><strong>False。</strong></li>
</ul></li>
</ul>
<h4 id="condition-資料型別">Condition ( 資料型別 )</h4>
<p>Condition 型別是用在 Monitor 中，提供給開發者解決同步問題之用。</p>
<ul>
<li><strong>Operatior</strong>：令 <span class="math inline">\(x\)</span> 為一 Condition type 變數。
<ul>
<li><strong>wait</strong> ( x.wait )：<strong>因為某些同步條件而被卡住時，執行此運作的該 Process 會 Blocked</strong>，並且置入 Monitor 內該資料變數的所屬之等待佇列( Waiting Queue：預設為 FIFO )</li>
<li><strong>signal</strong> ( x.signal )：<strong>如果先前有 Processes 卡在該變數 ( x ) 的「Waiting queue」中，則此運作會自此「Waiting queue」移走一個 Process 並且恢復 ( Resume ) 其執行，否則無任何作用。</strong></li>
</ul></li>
</ul>
<h4 id="解決-dining-philosophers-problem">解決 Dining-philosophers Problem</h4>
<ol type="1">
<li>先定義所需的 Monitor ADT。<br>type Dining-ph = Monitor<br>var state：[0...4] of ｛ think, hungry, eating ｝。</li>
<li>self：[0...4] of condition</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">procedure entry <span class="title">pickup</span><span class="params">(i:<span class="number">0.</span>.<span class="number">.4</span>)</span></span></span><br><span class="line"><span class="function">    state[i] </span>= <span class="function">hungry</span></span><br><span class="line"><span class="function">    <span class="title">test</span><span class="params">(i)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(state[i] != eating) then</span><br><span class="line">    	self[i].wait              <span class="comment">// 繼續餓著，將該 Process blocked</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">procedure <span class="title">test</span><span class="params">(k:<span class="number">0.</span>.<span class="number">.4</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span><span class="params">(state[(k+<span class="number">4</span>)%<span class="number">5</span>]!= eating &amp;&amp;     <span class="comment">// 左邊哲學家沒吃飯</span></span></span></span><br><span class="line"><span class="params"><span class="function">           state[k] == hungry &amp;&amp;      <span class="comment">// 由於 putdown 會要讓左右邊的哲學家是否要吃飯，所以必須存在 </span></span></span></span><br><span class="line"><span class="params"><span class="function">           state[(k+<span class="number">1</span>)%<span class="number">5</span>] != eating   <span class="comment">// 右邊哲學家沒吃飯</span></span></span></span><br><span class="line"><span class="params"><span class="function">           )</span> then</span></span><br><span class="line"><span class="function">    	state[k] </span>= eating            <span class="comment">// 改為正在吃飯</span></span><br><span class="line">    	self[k].signal               <span class="comment">// *將自己喚醒</span></span><br></pre></td></tr></table></figure>
<p><strong>＜Note＞：</strong> <code>state[...]!= eating</code> <strong>為何是測試「是否正在吃飯而不是測試是否飢餓」？</strong><br><strong>因為能呼叫到目前的函式代表該 Process 是正在進行的 ( Active )</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">procedure entry <span class="title">putdown</span><span class="params">(i:<span class="number">0.</span>.<span class="number">.4</span>)</span></span></span><br><span class="line"><span class="function">	state[i] </span>= <span class="function">thinking</span></span><br><span class="line"><span class="function">	<span class="title">test</span><span class="params">((i+<span class="number">4</span>)%<span class="number">5</span>)</span>               <span class="comment">// 給左右邊哲學家機會使用</span></span></span><br><span class="line"><span class="function">	<span class="title">test</span><span class="params">((i+<span class="number">1</span>)%<span class="number">5</span>)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">init</span>()</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        state[i] = thinking</span><br></pre></td></tr></table></figure>
<h5 id="使用方式">使用方式</h5>
<ul>
<li>共享變數宣告：
<ul>
<li>dp：Dining-ph</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">    repeat</span><br><span class="line">        <span class="comment">// hungry</span></span><br><span class="line">        dp.<span class="built_in">pickup</span>(i);  <span class="comment">// active in monitor</span></span><br><span class="line">        <span class="comment">// eating</span></span><br><span class="line">        dp.<span class="built_in">putdowm</span>(i); <span class="comment">// active in monitor</span></span><br><span class="line">        <span class="comment">// thinking</span></span><br><span class="line">    until <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="conditional-monitor">Conditional Monitor</h3>
<p>Condition 變數所屬的 Waiting queue 一般皆是 FIFO queue ( 甚至 Monitor 的 entry queue 也是 FIFO )，<strong>可是有時候我們會需要「Priority queue」優先移除高優先權的 Process ，恢復執行或讓他進入 Monitor 內進行活動，此時我們就會需要 Conditional monitor。</strong></p>
<ul>
<li><strong>Operatior</strong>：令 <span class="math inline">\(x\)</span> 為一 Condition type 變數。
<ul>
<li><strong>wait</strong> ( <strong>x.wait(c)</strong> )：c 為此 Process 的 Priority number。</li>
</ul></li>
</ul>
<h4 id="解決互斥問題之應用">解決互斥問題之應用</h4>
<h5 id="互斥資源配置問題">互斥資源配置問題</h5>
<ul>
<li><p>Process ID 越小者優先權越高可以優先取得資源。</p></li>
<li><p>定義 Monitor<br>type ResourceAllocator = Monitor<br>var busy：boolean // 代表資源已經配置與否<br>var x：condition // 用以將 Process blocked</p></li>
<li><p>想法</p>
<ul>
<li><span class="math inline">\(\left\{\begin{matrix} 非優先權需求 \Rightarrow 寫入\; Monitor \; 的函式定義中處理。 \\ 優先權需求 \Rightarrow 只須告知閱卷人你的\; Monitor \; 是以 \;Priority \; queue\; 實現的。 \end{matrix}\right.\)</span></li>
<li><span class="math inline">\(此題之分析\left\{\begin{matrix} 非優先權需求 \Rightarrow 互斥資源配置。\\ 優先權需求 \Rightarrow Process \;ID \;之優先權。 \end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">procedure entry <span class="title">Apply</span><span class="params">(pid:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span><span class="params">(Busy)</span> then</span></span><br><span class="line"><span class="function">    	x.<span class="title">wait</span><span class="params">(pid)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">else</span></span></span><br><span class="line"><span class="function">    	Busy </span>= <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">procedure entry <span class="title">Release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	Busy </span>= <span class="literal">false</span></span><br><span class="line">	x.signal</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">init</span>()</span><br><span class="line">	Busy = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h6 id="使用方式-1">使用方式</h6>
<ul>
<li>共享變數
<ul>
<li>RA：ResourceAllocator</li>
<li>Pi ( i 代表 ProcessID )</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">    ...</span><br><span class="line">    RA.<span class="built_in">Apply</span>(i)</span><br><span class="line">        <span class="comment">// 使用資源</span></span><br><span class="line">    RA.<span class="built_in">Release</span>()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>此 Monitor 的</strong> <span class="math inline">\(x\)</span> <strong>condition 變數之 waiting queue 及 monitor 的 entry queue 是 priority queue，且 process ID 越小優先權越高，也優先移出。</strong></li>
</ul>
<h5 id="共享檔案問題">共享檔案問題</h5>
<p>有一個「檔案」可以被多個 Processes 所使用，每一個 Process 有唯一的優先權值( Unique priority number )，存取檔案時必須要： <strong>1. 所有正在存取此檔案的 Process 的優先權值加總必須</strong> <span class="math inline">\(&lt; n\)</span>。 <strong>2. 優先權值小的優先權越高。</strong></p>
<ul>
<li>定義 Monitor<br>type FileAccess = Monitor<br>var sum：int<br><span class="math inline">\(x\)</span>：condition</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">procedure entry <span class="title">Access</span><span class="params">(i:priorityNum)</span></span></span><br><span class="line"><span class="function">	<span class="title">while</span><span class="params">((sum+i) &gt;= h)</span> <span class="keyword">do</span> x.<span class="title">wait</span><span class="params">(i)</span>  <span class="comment">// !!</span></span></span><br><span class="line"><span class="function">    sum +</span>= i</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">procedure entry <span class="title">Leave</span><span class="params">(i:priorityNum)</span></span></span><br><span class="line"><span class="function">    sum -</span>= i</span><br><span class="line">    x.<span class="built_in">signal</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">init</span>()</span><br><span class="line">	sum = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h6 id="使用方式-2">使用方式</h6>
<ul>
<li>共享變數
<ul>
<li>FA：FileAccess</li>
<li>Pi ( i：process priority number ) 程式</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">    ...</span><br><span class="line">    FA.<span class="built_in">Access</span>(i)</span><br><span class="line">    <span class="comment">// 使用檔案</span></span><br><span class="line">    FA.<span class="built_in">Leave</span>(i)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>此 Monitor 的</strong> <span class="math inline">\(x\)</span> <strong>condition 變數之 waiting queue 及 monitor 的 entry queue 是 priority queue，且 process ID 越小優先權越高，也優先移出。</strong></li>
</ul>
<h5 id="印表機使用權問題">印表機使用權問題</h5>
<p>(P.6-72) 有三部 Printer 被 processes 使用且規定 process ID 越小優先權越高。</p>
<ul>
<li>定義 Monitor<br>type Allocator = Monitor<br>var p：[0...2] of boolean<br>x：condition</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Acquire</span><span class="params">(i:processID)</span></span></span><br><span class="line"><span class="function">	<span class="title">if</span><span class="params">(p[<span class="number">0</span>] &amp;&amp; p[<span class="number">1</span>] &amp;&amp; p[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function">		x.<span class="title">wait</span><span class="params">(i)</span></span></span><br><span class="line"><span class="function">	<span class="title">if</span><span class="params">(!p[<span class="number">0</span>])</span></span></span><br><span class="line"><span class="function">		tmp </span>= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!p[<span class="number">1</span>])</span><br><span class="line">		tmp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		tmp = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    p[tmp] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(y:printerNum)</span></span></span><br><span class="line"><span class="function">    p[y] </span>= <span class="literal">false</span></span><br><span class="line">    x.<span class="built_in">signal</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">init</span>()</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        p[i] = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h6 id="使用方式-3">使用方式</h6>
<ul>
<li>共享變數
<ul>
<li>RA：Allocator</li>
<li>Pi (i = Process ID)</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">    ...</span><br><span class="line">    pno: printer number</span><br><span class="line">    pno = PA.<span class="built_in">Acquire</span>(i)</span><br><span class="line">    <span class="comment">// 使用編號 pno 的印表機</span></span><br><span class="line">    PA.<span class="built_in">Release</span>(pno)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>此 Monitor 的</strong> <span class="math inline">\(x\)</span> <strong>condition 變數之 waiting queue 及 monitor 的 entry queue 是 priority queue，且 process ID 越小優先權越高，也優先移出。</strong></li>
</ul>
<h5 id="使用-monitor-定義-semaphore">使用 Monitor 定義 Semaphore？</h5>
<ul>
<li>定義 Monitor
<ul>
<li>type semaphore = Monitor<br>var value：int // 號誌值<br><span class="math inline">\(x\)</span>：condition</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">procedure entry <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	value--</span></span><br><span class="line"><span class="function">    <span class="title">if</span><span class="params">(value &lt; <span class="number">0</span>)</span> then x.<span class="title">wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">procedure entry <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	value++</span></span><br><span class="line"><span class="function">	x.<span class="title">signal</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">init</span>()</span><br><span class="line">    value = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="monitor-的種類-3種">Monitor 的種類 ( 3種 )</h3>
<ul>
<li><strong>探討</strong>
<ul>
<li>假設 Process Q 目前因為先前有執行了 x.wait ，所以卡在 x condition 變數之 Waiting queue 中，<strong>接著，目前的 Process P 在 Monitor 中進行活動，當 P 執行了 x.signal 後，P 會將 Q 從 Waiting queue 中恢復 ( Resume ) 執行，此時代表 P 與 Q 同時在 Monitor 中進行活動( Active )，但是如此一來會違反 Mutual exclusive，</strong>因此我們要<em>抉擇</em> 讓 P 或 Q 其中一個能夠在 Monitor 中活動。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\thetypeofmonitor.png" alt="thetypeofmonitor" /><figcaption aria-hidden="true">thetypeofmonitor</figcaption>
</figure>
<h4 id="type-1---hoare-monitor-效果最好">Type 1 - Hoare Monitor ( 效果最好 )</h4>
<p><strong>P waits Q until Q completed function or Q is blocked again.</strong></p>
<ul>
<li>Pros
<ul>
<li>保證 Q 一定可以被恢復執行 ( Resume execution )。</li>
<li>在不會退出 Monitor 的情況下可以恢復比較多的 Processes ，但是是效果其實與 Type3 的相去不遠。</li>
</ul></li>
</ul>
<h4 id="type-2-效果最差">Type 2 ( 效果最差 )</h4>
<p>Q waits P until P completed function or P is blocked.</p>
<ul>
<li>Cons
<ul>
<li><strong>不保證 Q 一定可以被恢復執行</strong>，因為允許 P 繼續往下執行的過程中，P 有可能改變可能讓 Q 可以恢復行為的同步條件值，使得 Q 仍被卡住。</li>
</ul></li>
</ul>
<h4 id="type-3">Type 3</h4>
<p><strong>P leaves monitor ( 將 P 重新插在 Monitor entry queue 的第一個 ) and let Q resume execution 直到 Q finished or Q is blocked again,</strong> then P reenter Monitor.</p>
<ul>
<li>Consurrent C / Consurrent PASCAL 所採用。</li>
<li><strong>Pros</strong>
<ul>
<li><strong>保證 Q 一定可以被立刻恢復執行( Resume execution )。</strong></li>
</ul></li>
<li>Cons
<ul>
<li>效果不若 <strong>Type1 Monitor，因為在 P 一進一出的期間，頂多只能恢復一個 Q，然而 Type1 可以一次恢復多個 Q。</strong></li>
</ul></li>
</ul>
<h3 id="目前的分類-2種">目前的分類 ( 2種 )</h3>
<h4 id="signal-and-wait">Signal-and-wait</h4>
<ul>
<li>Type1 Hoare Monitor</li>
<li>Type3 Monitor</li>
</ul>
<h4 id="signal-and-continue">Signal-and-continue</h4>
<ul>
<li>Type2 Monitor</li>
</ul>
<h3 id="實作-monitor">實作 Monitor</h3>
<ul>
<li>使用 Semaphore 。</li>
<li>架構
<ul>
<li><strong>保證「互斥」</strong>：最多只能有一個 Process 在 Monitor 中進行活動。</li>
<li><strong>「Hoare」的設計手法。</strong></li>
<li><strong>Condition 變數</strong> <span class="math inline">\(x\)</span> <strong>：x.wait()、x.signal。</strong></li>
</ul></li>
<li>共享變數
<ul>
<li>mutex：semaphore = 1 ( 用以保障函式使用的「互斥控制」)</li>
<li>next：semaphore = 0 ( 若 P 執行 x.signal，則用來 block P )</li>
<li>next_count：int = 0 ( 統計 P 的個數 )</li>
<li>x_sem：semaphore = 0 ( 當 Q 執行 x.wait() ，則用以 block Q )</li>
<li>x_count：int = 0 ( 統計 Q 的個數 )</li>
</ul></li>
<li><strong>控制碼 - 確保互斥</strong>：在 Monitor 的每個<strong>函式</strong>的「body」之<strong>前</strong>及<strong>後</strong>加入一些額外的控制碼。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">procedure entry _monitorfunction()</span><br><span class="line">	<span class="built_in">wait</span>(mutex)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// body</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(next_count &gt; <span class="number">0</span>)      <span class="comment">// 若 P 存在，必先讓 P 恢復執行</span></span><br><span class="line">		<span class="built_in">signal</span>(next)</span><br><span class="line">	<span class="keyword">else</span>                    <span class="comment">// 若沒有 P 在等待，才讓下一個 Q 進入執行</span></span><br><span class="line">		<span class="built_in">signal</span>(mutex)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>控制碼 - 「</strong><span class="math inline">\(x\)</span><strong>.wait()」</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x.wait</span></span><br><span class="line">	x_count++                    <span class="comment">// Q 的個數加一</span></span><br><span class="line">	<span class="keyword">if</span>(next_count &gt; <span class="number">0</span>)           <span class="comment">// 將要 blocked 前的準備動作(與上述程式碼相同)</span></span><br><span class="line">		<span class="built_in">signal</span>(next)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">signal</span>(mutex)</span><br><span class="line">	<span class="built_in">wait</span>(x_sem)                  <span class="comment">// Q 將自己 block</span></span><br><span class="line">	x_count--                    <span class="comment">// 當 Q resume 後，將 x_count 減一</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>控制碼 - 「</strong><span class="math inline">\(x\)</span><strong>.signal()」</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x.signal</span></span><br><span class="line">	<span class="keyword">if</span>(x_count &gt; <span class="number">0</span>)     <span class="comment">// 先前若有 Q blocked 才有作用</span></span><br><span class="line">		next_count++</span><br><span class="line">		<span class="built_in">signal</span>(x_sem)  <span class="comment">// resume Q</span></span><br><span class="line">		<span class="built_in">wait</span>(next)</span><br><span class="line">		next_count--</span><br></pre></td></tr></table></figure>
<h4 id="問題與討論">問題與討論</h4>
<ul>
<li>證明 <em>Monitor</em> 與 <em>Semaphore</em> 解決同步問題的能力是<strong>一樣的( idemtical; equivalent )</strong>。
<ul>
<li><strong>由於 Monitor 與 semaphore 可以「相互實作」</strong>，所以兩者解決「同步問題」的能力是<em>相同的</em>。</li>
</ul></li>
<li>當開發者在解決同步問題時，<strong>Monitor 的使用會比起 Semaphore 容易</strong>，因為 Monitor 本身已經保證「互斥」，所以 condition variable 不會有「race condition」的問題，所以只要專心解決「同步問題」即可，<strong>但是當開發者要使用 Semaphore 解決同步問題時還需要關心「Race condition」與「同步條件」的滿足。</strong></li>
</ul>
<h2 id="message-passing">Message Passing</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Direct ( symmtric ) communication</th>
<th style="text-align: center;">Indirect communication</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>收、送雙方須相互指名對方 ID</strong>，才能建立通訊鏈結。</td>
<td style="text-align: center;"><strong>雙方透過「Shared mailbox」</strong>才能建立通訊鏈結。</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>通訊鏈結是專屬於溝通的雙方，不得與其他 Processes 共享</strong>。下圖(一)</td>
<td style="text-align: center;"><strong>可以多 Processes 一起共享。</strong>下圖(二)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">溝通雙方<strong>最多只能一條通訊鏈結(禁止多條通訊鏈結)。</strong>下圖(三)</td>
<td style="text-align: center;"><strong>溝通雙方可以同時存在多條通訊鏈結，每一條皆須有「Shared mailbox」。</strong>下圖(四)</td>
</tr>
</tbody>
</table>
<figure>
<img src="\willywangkaa\images\thetypeofmessagepassing.png" alt="thetypeofmessagepassing" /><figcaption aria-hidden="true">thetypeofmessagepassing</figcaption>
</figure>
<h3 id="直接通訊-direct-communication">直接通訊 ( Direct Communication )</h3>
<h4 id="symmetric">Symmetric</h4>
<p>雙方須「互相指名」對方的 Process ID ，才能建立通訊鏈結 ( Communication link )，<strong>OS 提供 send()、receive() 的 System call。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_1</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">sent</span>(P_2_ID, message)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">receive</span>(P_1_ID, message)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h4 id="asummetric">Asummetric</h4>
<p><strong>只有「送出的 Process」需要指名「收受的 Process 之 ID」</strong>，但收受方無須指名送方，即任何 Process 皆可以收下這則訊息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_1</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">send</span>(P_2_ID, message)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">receive</span>(id, message)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>當 P_2 收到訊息後，<strong>會將「送出訊息的 Process」之 ID 存在</strong><code>id</code><strong>變數之中。</strong></p>
<h3 id="間接通訊-indirect-communication">間接通訊 ( Indirect Communication )</h3>
<p>收、送雙方是透過「Shared mailbox」，才能建立通訊鏈結。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_1</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">send</span>(A, message)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">receive</span>(A, message)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h3 id="用-message-passing-解決-producer-comsumer-problem">用 Message Passing 解決 Producer-comsumer Problem</h3>
<ul>
<li>Producer</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Producer</span></span><br><span class="line">    <span class="keyword">while</span>(condition != <span class="literal">false</span>) &#123;</span><br><span class="line">        produce an item in next_tp;</span><br><span class="line">        <span class="built_in">send</span>(Consumer, next_tp);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Comsumer</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Consumer</span></span><br><span class="line">    <span class="keyword">while</span>(condition != <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="built_in">receive</span>(Producer, next_tp);</span><br><span class="line">        Consumer the item in next_tp</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步意義之呈現">「同步」意義之呈現</h3>
<h4 id="link-capacity">Link capacity</h4>
<p>假設「收受的 Process」是以：若未收到訊息則<strong>暫停執行，直到收到訊息後才往下執行</strong>；<strong>而對於「傳送的 Process」看待 Link capacity 時，其實針對每條傳輸鏈結裡的「Message queue」</strong>( 用以保存「除了正在傳輸中的訊息以外之其他 <em>送方</em> 訊息」)<strong>之容量</strong>。</p>
<figure>
<img src="\willywangkaa\images\linkcapacity.png" alt="linkcapacity" /><figcaption aria-hidden="true">linkcapacity</figcaption>
</figure>
<ul>
<li><strong>★ Zero capacity</strong>
<ul>
<li>送方直到<strong>收方收到訊息後才能繼續往下執行</strong>，此時雙方的同步模式也稱為<strong>「Rendezvous」</strong>( 法文：約會一次；偶遇 )</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_1</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">send</span>(P_2_ID, message)</span><br><span class="line">    <span class="built_in">receive</span>(P_2_ID, <span class="string">&quot;Acknowledge&quot;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">receiver</span>(P_1_ID, message)</span><br><span class="line">    <span class="built_in">sned</span>(P_1_ID, <span class="string">&quot;Acknowledge&quot;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li>Bounded capacity
<ul>
<li>當 Queue 滿了之後，送方會被迫暫停執行。</li>
</ul></li>
<li>Unbounded capacity
<ul>
<li>送方無須被迫暫停執行。</li>
</ul></li>
</ul>
<h4 id="條指令之組合來表現不同之同步模式">4 條指令之組合來表現不同之「同步模式」</h4>
<ul>
<li><strong>Blocking send</strong>
<ul>
<li>送出訊息後直到收方收到訊息後才繼續往下執行。(Like zero capacity)</li>
</ul></li>
<li><strong>Nonblocking send</strong>
<ul>
<li>送出訊息後無須收方確認收到訊息即可繼續往下執行。(Like unbounded capacity)</li>
</ul></li>
<li><strong>Blocking receive</strong>
<ul>
<li>一定要收到訊息才能繼續往下執行。</li>
</ul></li>
<li><strong>Nonblocking receive</strong>
<ul>
<li>不一定要確認<strong>訊息的正確性</strong>亦能繼續向下執行。</li>
</ul></li>
</ul>
<h5 id="問題與討論-1">問題與討論</h5>
<ul>
<li>Ex1.「Rendezvous」模式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_1</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Blocking_send</span>(P_2_ID, message)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Blocking_receive</span>(P_1_ID, message)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li>Ex2. 假設收方的程式如下，則代表著甚麼含意：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">   <span class="built_in">Nonblocking_receive</span>(A, message)</span><br><span class="line">   <span class="keyword">if</span>(message == null) &#123;</span><br><span class="line">       <span class="built_in">Blocking_receive</span>(B, message)</span><br><span class="line">       <span class="built_in">Blocking_receive</span>(A, message)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">Blocking_receive</span>(B, message)</span><br><span class="line">   &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>選項：</p>
<ol type="1">
<li><del>從 A 或 B 收到訊息後，即可往下。</del></li>
<li>一定要從 A 與 B 收到訊息後且要先 A 後 B，才可以繼續往下執行。</li>
<li>同上，但 A、B 順序無所謂。</li>
</ol>
<p><strong>Ans： (3)</strong></p>
<h4 id="exception-handling">Exception handling</h4>
<ol type="1">
<li>在「Rendezvous」模式之下，若收或送任一方的 Process 以死亡( terminate )，但另一方不知情時，<strong>則另一方會永久停滯 ( <del>Starvation、Deadlock</del> )</strong>：作業系統會以「Exception」的方式刪除另一個 Process。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_1</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Blocking_send</span>(P_2_ID, message)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Blocking_receive</span>(P_1_ID, message)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>在直接通訊 ( Direct symmtric communication )下</strong>，若「未通報其他 Process 自己的 ID」且 「New Process 也不知道他人 Process 的 ID」，則<em>無法溝通</em>。</li>
<li>訊息的傳輸過程之中，有可能會丟失訊息( Lost message ) ，作業系統負責偵測訊息是否已丟失，<strong>若丟失訊息時，作業系統會通知「送方」重送訊息，</strong>偵測丟失訊息的方法類似於「網路概論」中談到的<strong>封包丟失偵測有關 ( Time-out 法則 )</strong>。</li>
</ol>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Process</tag>
        <tag>Synchronization</tag>
      </tags>
  </entry>
  <entry>
    <title>Data structure - Search and sort</title>
    <url>/willywangkaa/2018/11/17/Data-structure-Search-and-sort/</url>
    <content><![CDATA[<h1 id="binary-search">Binary search</h1>
<p>Example</p>
<p>n 筆資料作「Binary search」最多比較次數？</p>
<p><span class="math inline">\(\lceil \lg (n+1) \rceil\)</span></p>
<blockquote>
<ul>
<li><p>200 筆資料：最多 8 次的搜尋</p></li>
<li><p>1024 筆資料：最多 11 次的搜尋</p></li>
</ul>
</blockquote>
<p><strong>Example</strong></p>
<ol type="1">
<li>n 筆資料作「Binary search」
<ul>
<li>其「Worst case」為 O(log n)</li>
</ul></li>
<li>n 筆資料以「Binary search tree」作查找
<ul>
<li>其「Worst case」為 <strong>O( n )</strong> ( Skew tree )</li>
<li>其「Best case」為 <strong>O( log n )</strong></li>
</ul></li>
</ol>
<h1 id="internal-sort-and-external-sort">Internal sort and external sort</h1>
<h2 id="internal-sort">Internal sort</h2>
<p>資料量少可一次載入到記憶體中進行排序</p>
<h2 id="external-sort">External sort</h2>
<p>資料量太多無法一次全部置入記憶體之中，需藉由外部儲存體 ( Disk ) 來保存再進行排序</p>
<ul>
<li>常用的「External sorting method」
<ul>
<li><strong>Merge sort</strong> ( Selection tree 輔佐 )</li>
<li>M-way search tree、B-tree、B<span class="math inline">\(^+\)</span>-tree</li>
</ul></li>
</ul>
<h1 id="排序性質比較表">排序性質比較表</h1>
<blockquote>
<p>此表為方便比較用圖，欲瞭解其推倒原因詳見下方細述</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>Sort algorithm</th>
<th>T.C. (Best)</th>
<th>T.C. (Worst)</th>
<th>T.C. (Avg.)</th>
<th>S.C.</th>
<th>Stable</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insertion</td>
<td><strong>O(n)</strong></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>O(1)</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Selection</td>
<td><span class="math inline">\(O(n^2)\)</span>☆</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>O(1)</td>
<td>No</td>
</tr>
<tr class="odd">
<td>Bubble</td>
<td>O(n)</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>O(1)</td>
<td><strong>Yes</strong></td>
</tr>
<tr class="even">
<td>Shell</td>
<td><span class="math inline">\(O(n^\frac 32)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>O(1)</td>
<td>No</td>
</tr>
<tr class="odd">
<td>Quick</td>
<td>O(nlogn)</td>
<td><span class="math inline">\(O(n^2)\)</span>☆</td>
<td>O(nlogn)</td>
<td><strong>O(lgn)~O(n)☆</strong></td>
<td>No</td>
</tr>
<tr class="even">
<td>Merge</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Heap</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td><strong>O(1)☆</strong></td>
<td>No</td>
</tr>
<tr class="even">
<td>Radix</td>
<td>N/A</td>
<td>N/A</td>
<td>O(d×(n+r))</td>
<td><strong>O(r×n)☆</strong></td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Counting</td>
<td>N/A</td>
<td>N/A</td>
<td>O(n+k)</td>
<td><strong>O(n+k)☆</strong></td>
<td>Yes</td>
</tr>
</tbody>
</table>
<ul>
<li>註
<ul>
<li>T.C. = Time complecity</li>
<li>S.C. = Space complexity</li>
<li>r 為「Redix sort」的基數大小</li>
<li>d 為「Redix sort」以 r 作為基數之位數最大值</li>
<li>k 為「Counting sort」之資料值域範圍</li>
</ul></li>
</ul>
<h1 id="初等排序">初等排序</h1>
<h2 id="insertion-sort">Insertion sort</h2>
<ul>
<li>演算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 將資料 r 插入到已排好的區塊 A[0] ~ A[i]</span></span><br><span class="line"><span class="built_in">Insert</span>(A[], r, i) &#123;</span><br><span class="line">    j = i;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; A[j]) &#123;</span><br><span class="line">        A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">        j = j<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A[j+<span class="number">1</span>] = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Insort</span>(A[], n) &#123;</span><br><span class="line">    A[<span class="number">0</span>] = -oo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">Insert</span>(A, A[i], i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity</p>
<ul>
<li>Best case：O(n)
<ul>
<li>當「Input data」恰巧為小到大，每回合檢查一次即可確定 r 的插入位置，共作 n-1 回合所以 O(n)</li>
</ul></li>
<li>Worst case：O( <span class="math inline">\(n^2\)</span> )
<ul>
<li>當「Input data」恰巧為大到小，<span class="math inline">\(Total = 1+2+ \ldots+n-1 \\=\frac{n(n-1)}{2} = O(n^2)\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541038370084.png" alt="1541038370084" /><figcaption aria-hidden="true">1541038370084</figcaption>
</figure>
<ul>
<li>Avg. case：O( <span class="math inline">\(n^2\)</span> )
<ul>
<li>利用遞迴時間函數，令第 n 筆資料之平均比較次數 (Time complexity) 為 O(n)</li>
<li><span class="math inline">\(T(n) = T(n-1) + \frac n2 \\ = T(n-2) + \frac{n-1}2 + \frac n2 \\ \vdots \\ = \frac{1+2+\ldots+n}{2} = \frac{n(n+1)}{4} = O(n^2)\)</span></li>
</ul></li>
<li>Space complexity ( 除了「Input data」之外所需空間 )
<ul>
<li>O( 1 )</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541092068950.png" alt="1541092068950" /><figcaption aria-hidden="true">1541092068950</figcaption>
</figure>
<ul>
<li>Stable
<ul>
<li>因為這行程式碼<code>while(r &lt; A[j]) do...</code>所以不會交換一樣大小的資料</li>
</ul></li>
</ul>
<h2 id="selection-sort">Selection sort</h2>
<ul>
<li>演算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// Iterate through array elements </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;   </span><br><span class="line">        <span class="keyword">int</span> min = i; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">            <span class="keyword">if</span> (a[min] &gt; a[j]) </span><br><span class="line">                min = j;</span><br><span class="line">        <span class="keyword">if</span>(min != i) <span class="built_in">swap</span>(a[i], a[min]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure>
<img src="\willywangkaa\images\1541092807581.png" alt="1541092807581" /><figcaption aria-hidden="true">1541092807581</figcaption>
</figure>
<ul>
<li>Time complexity
<ul>
<li>Best case：<span class="math inline">\(O(n^2)\)</span></li>
<li>Worst case：<span class="math inline">\(O(n^2)\)</span></li>
<li>Avg. case：<span class="math inline">\(O(n^2)\)</span></li>
</ul></li>
<li>Space complexity
<ul>
<li>O( 1 )</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541093304800.png" alt="1541093304800" /><figcaption aria-hidden="true">1541093304800</figcaption>
</figure>
<ul>
<li><p>Unstable</p></li>
<li><p>多用在大型紀錄( 由多欄位組成之資料 ) 之排序</p>
<ul>
<li><strong>每回合最多一次資料交換 ( Swap )</strong>，不會吃太多資料存取較有優勢</li>
</ul></li>
<li><p><code>if(min != i) do...</code> 如果省略，可以省下比較之次數但是會多增加一次資料交換，所以適用於大多資料皆未落在正確位置之上時</p></li>
</ul>
<h2 id="bubble-sort">☆Bubble sort</h2>
<h3 id="版本一">版本一</h3>
<p>由左而右，兩兩互相比較，<strong>若前者大於後者交換之</strong></p>
<blockquote>
<p>當某一回合在檢查時，未發生資料交換 ( Swap ) 則可以提早結束演算法</p>
</blockquote>
<blockquote>
<p>此演算法稱為「Bubble」是因為在每一回合檢查完，當時「Sublist」中最大值會往最高位置走，形同大泡泡往水上浮起一般</p>
</blockquote>
<ul>
<li>演算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(A[], n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j]&gt;A[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[j], A[j+<span class="number">1</span>]);</span><br><span class="line">                f = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="\willywangkaa\images\1541094481788.png" alt="1541094481788" /><figcaption aria-hidden="true">1541094481788</figcaption>
</figure>
<h3 id="版本二">版本二</h3>
<p>由左而右，<strong>兩兩互相比較如果後者小於前者交換之</strong></p>
<blockquote>
<p>此處之「Bubble」是將最小值往最小位置走</p>
</blockquote>
<ul>
<li>演算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(A[], n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[j], A[j<span class="number">-1</span>]);</span><br><span class="line">                f = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="\willywangkaa\images\1541094963273.png" alt="1541094963273" /><figcaption aria-hidden="true">1541094963273</figcaption>
</figure>
<ul>
<li>Time complexity
<ul>
<li>Best case：O( n )
<ul>
<li>在第一回合檢查時<strong>歷經 (n-1) 次比較</strong>，但無須作「Swap」即可將排序完成</li>
<li><span class="math inline">\(T(n) = 0 + (n-1), T(1) = 0\)</span> ( 第一回合之比較次數 + 剩下 n-1 筆資料之「Bubble sort」)</li>
</ul></li>
<li>Avg. case：O( <span class="math inline">\(n^2\)</span> )
<ul>
<li><span class="math inline">\(T(n) = O(n) + T(n-1)\)</span> ( 每回合之平均比較次數 + 剩下 n-1 筆資料之「Bubble sort」)</li>
<li><span class="math inline">\(T(n) = O(n) + T(n-1) \\ \vdots \\ = T(1) + c \cdot(2 + \ldots + n) = O(n^2)\)</span></li>
</ul></li>
<li>Worst case：O( <span class="math inline">\(n^2\)</span> )
<ul>
<li>在「Input data」恰巧為大至小之狀況 (見下圖)</li>
<li>處理 n 筆資料時則為 <span class="math inline">\(n + (n-1) + \ldots + 1 = O(n^2)\)</span></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541214129532.png" alt="1541214129532" /><figcaption aria-hidden="true">1541214129532</figcaption>
</figure>
<ul>
<li>Space complexity
<ul>
<li>O( 1 )</li>
</ul></li>
<li>Stable
<ul>
<li>因為 <code>if(A[j]&gt;A[j+1])</code> 必須要大於才會交換資料所以為穩定排序法</li>
</ul></li>
</ul>
<h2 id="weiss-版本-shell-sort">[Weiss 版本] Shell sort</h2>
<p>從 1 元素到 n-span 元素，比較 A[i] 與 A[i+span] ，若前者大於後者則交換；每一回合需持續到<strong>沒有交換</strong>為止，再進入下一回合</p>
<ul>
<li>Span 型式（將會決定總回合數）
<ul>
<li>( 一般型 ) <span class="math inline">\(\lceil \frac {n}{2^k}\rceil\)</span> 或 <span class="math inline">\([\frac{n}{2^k}]\)</span>
<ul>
<li>第一回合 span 等於 <span class="math inline">\(\frac n2\)</span></li>
<li>第二回合 span 等於 <span class="math inline">\(\frac n4\)</span></li>
<li>以此類推，<strong>最後一回合 span 為 1</strong></li>
</ul></li>
<li><span class="math inline">\(2^k-1\)</span>
<ul>
<li>第一回合 span 等於 15</li>
<li>第二回合 span 等於 7</li>
<li>以此類推，<strong>最後一回合 span 為 1</strong></li>
</ul></li>
<li>（自訂型）
<ul>
<li>第一回合 span 等於 7</li>
<li>第二回合 span 等於 5</li>
<li>第三回合 span 等於 2</li>
<li><strong>最後一回合 span 為 1</strong></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>最後一回合 span 必須為 1</p>
</blockquote>
<blockquote>
<p>當此回合的 span 值為 k 時，則表示有 k 條「Sublist」要排序，</p>
</blockquote>
<p>Example ( Span型：5、3、2、1 )</p>
<p>排序：9 8 7 2 3 5 1 4 6</p>
<figure>
<img src="\willywangkaa\images\1542454674621.png" alt="1542454674621" /><figcaption aria-hidden="true">1542454674621</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// span 型態 =&gt; n/(2^k)</span></span><br><span class="line"><span class="built_in">Shellsort</span>(A[], n) &#123;</span><br><span class="line">    span = n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(span &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            f = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n-span); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i] &gt; A[i+span]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(A[i], A[i+span]);</span><br><span class="line">                    f = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(f != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>Avg. case：<span class="math inline">\(O(n^2)\)</span></li>
<li>Worst case：<span class="math inline">\(O(n^2)\)</span></li>
<li>Best case：目前無定論，與「Span 型態」有關
<ul>
<li><span class="math inline">\(O(n^{\frac 32})、O(n^{\frac 54})、O(n^{\frac 76})\)</span></li>
</ul></li>
</ul></li>
<li>Space complexity
<ul>
<li>O(1)</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542455003562.png" alt="1542455003562" /><figcaption aria-hidden="true">1542455003562</figcaption>
</figure>
<ul>
<li>Unstable</li>
</ul>
<h1 id="高等排序">高等排序</h1>
<h2 id="comparesion-based-comparsion-and-swap-sort-研究與探討">Comparesion based ( Comparsion and swap ) sort 研究與探討</h2>
<p>使用比較大小的方式進行排序可以使用一個「Decision tree」來表達</p>
<p>Example</p>
<p>三筆資料 R1, R2, R3 不知其大小關係，在排序之後之所有可能</p>
<figure>
<img src="\willywangkaa\images\1541935896940.png" alt="1541935896940" /><figcaption aria-hidden="true">1541935896940</figcaption>
</figure>
<blockquote>
<p>根據上圖之「Decision tree」：</p>
<ol type="1">
<li>為一個「Binary tree」
<ul>
<li>非葉節點：「比較過程之節點」( Comparsion node )</li>
<li>葉節點：「某個排序的結果」</li>
</ul></li>
<li>假設排序 n 筆資料：會產生 n! 之排序可能結果，會有 n! 個葉節點
<ul>
<li><span class="math inline">\(\because 總節點數量 = 葉節點數量 + 非葉節點數量 = 2\times 非葉節點數量 + 1 \\有\; n! \;個葉節點 \Rightarrow n! -1 \;個非葉節點\)</span></li>
<li><span class="math inline">\(\because 有\; n! \;個葉節點，又為「Binary \;tree」 \\ Tree \;height (h) \Rightarrow 2^{h-1} \geq n! \\ \Rightarrow h-1 \geq \lceil \lg n! \rceil \\ \Rightarrow h \geq \lceil \lg n! \rceil +1 \Rightarrow \\ \therefore 總共的比較需要大於等於 \lceil n \lg n \rceil \approx n\lg n \\ 「Comparsion\;based \; sort」 最快之\; Time \;complexity= \Omega ( n\lg n )\)</span></li>
</ul></li>
</ol>
</blockquote>
<p><strong>Example</strong></p>
<p><strong>五筆資料排序之比較次數至少為何？</strong></p>
<p><del>5 × lg 5 =&gt; 10</del></p>
<p><span class="math inline">\(\lceil \lg n!\rceil = \lceil\lg 5!\rceil = \lceil \lg 120 \rceil \approx 7\)</span></p>
<blockquote>
<p>若非使用「Comparsion based」則可以不受到此限制，<strong>時間複雜度最快可達到線性時間</strong></p>
</blockquote>
<h2 id="quick-sort">Quick sort</h2>
<ul>
<li>Avg. case 在實際排序時間最快的方法</li>
<li>採用「Divide and conquer」作法</li>
</ul>
<p>令陣列最左資料 A[1] 作為「Pivot key」，經過「分割」( Partition ) 動作後，將「Pivot」置於大小關係"最正確"的位置上</p>
<figure>
<img src="\willywangkaa\images\1541215583779.png" alt="1541215583779" /><figcaption aria-hidden="true">1541215583779</figcaption>
</figure>
<blockquote>
<p>可用多線程電腦加速執行</p>
</blockquote>
<h3 id="quicksort1-hoare-partition">Quicksort1 ( Hoare partition )</h3>
<figure>
<img src="\willywangkaa\images\1541216603304.png" alt="1541216603304" /><figcaption aria-hidden="true">1541216603304</figcaption>
</figure>
<p>Example</p>
<p>排序：6, 8, 3, 7, 5, 9, 4, 1, 10, 2</p>
<figure>
<img src="\willywangkaa\images\1541217794632.png" alt="1541217794632" /><figcaption aria-hidden="true">1541217794632</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排序陣列 A[l] ~ A[u]</span></span><br><span class="line"><span class="built_in">Qsort</span>(A[], l, u) &#123;</span><br><span class="line">    <span class="comment">// Partition</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt; u) &#123;</span><br><span class="line">        i = l;</span><br><span class="line">        j = u+<span class="number">1</span>;</span><br><span class="line">        p = A[l];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">while</span>(A[i] &lt; p);</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">while</span>(A[j] &gt; p);</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>( i &lt;= j ) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[i], A[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(i &lt;= j);</span><br><span class="line">        <span class="built_in">swap</span>(A[l], A[j]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Qsort</span>(A[], l, j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">Qsort</span>(A[], j+<span class="number">1</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example</p>
<p>排序：<span class="math inline">\(5^＊, 5, 5, 5, 5\)</span></p>
<figure>
<img src="\willywangkaa\images\1541218724819.png" alt="1541218724819" /><figcaption aria-hidden="true">1541218724819</figcaption>
</figure>
<ul>
<li><p><strong>Unstable</strong></p></li>
<li><p><strong>Time complexity</strong></p>
<ul>
<li><strong>Best case：O( n log n ) (下圖一)</strong>
<ul>
<li>「Partition」恰將「Input data」分成兩等分</li>
<li><span class="math inline">\(T(n) = O(n) + T(\frac n2) + T(\frac n2)\)</span>：<strong>Partition time + 左右邊作「Quick sort」</strong></li>
<li><span class="math inline">\(T(n) = 2T(\frac n2) + cn\\ =nT(1) +c\cdot n\log n = O(n \log n)\)</span></li>
</ul></li>
<li><strong>Avg. case：O( n log n ) (下圖二)</strong>
<ul>
<li><span class="math inline">\(T(n) = c\cdot n + \frac 1n\cdot \sum_{s = 1}^n (T(s) + T(n-s))\)</span>
<ul>
<li><strong>Partition time + 全部狀況之平均</strong></li>
</ul></li>
<li><strong>（1）</strong>$nT(n) = c n^2 + _{s = 1}^n(T(s) + T(n-s))\ = [(T(1)+T(n-1)) + (T(2)+T(n-2)) + + (T(n)+ T(0))] + cn^2 \ = 2 [T(1)+T(2)++T(n-1)] + T(n) + cn^2 $</li>
<li><strong>以 (n-1) 代入式（1）成為式（2） </strong></li>
<li><strong>（2）</strong>$(n-1)T(n-1) = 2[T(1)+ T(2)++T(n-2)]+T(n-1)+c(n-1)^2 $</li>
<li><strong>式（1）— 式（2）</strong></li>
<li><span class="math inline">\(\Rightarrow nT(n) - (n-1)T(n-1) = 2T(n-1)+T(n)-T(n-1)+c(n^2 - (n-1)^2) \\ \Rightarrow nT(n) - nT(n-1) + T(n-1) = T(n-1) + T(n) + c(n^2-(n-1)^2) \\ \Rightarrow (n-1)T(n) = nT(n-1) + c(n^2- (n-1)^2) \\ \Rightarrow \frac{T(n)}{n} = \frac{T(n-1)}{n-1} + c (\frac{2n-1}{n(n-1)}) \Rightarrow \frac{T(n)}{n} = \frac{T(n-1)}{n-1} + c (\frac 1n + \frac{1}{n-1}) \\ \Rightarrow \frac{T(n)}{n} = c(\frac 1n+\frac 1{n-1} + \ldots+\frac 12) + c (\frac 1{n-1} + \frac 1{n-2} + \ldots + \frac 11) \\ \Rightarrow\frac{T(n)}{n} = c(H_n -1) + c(H_n + \frac 1n) \\ \Rightarrow T(n) = 2 c\cdot n \cdot H_n - cn -c \\ = 2\cdot c \cdot n \log n - cn -c = O(n\log n)\)</span></li>
<li>上述遞迴時間表示式<strong>忽略執行「Partition」後，右邊會多少一筆資料</strong>（下圖二）
<ul>
<li>完整表示應該為 <span class="math inline">\(T(n) = \frac 1n \sum_{s = 0}^{n-1}(T(s) + T(n-1-s)) + c\cdot n\)</span></li>
</ul></li>
</ul></li>
<li><strong>Worst case：O(</strong> <span class="math inline">\(n^2\)</span> <strong>) (下圖三)</strong>
<ul>
<li><strong>當 Pivot 恰為最小最大值時</strong>，作「Partition」不會使「Divide and conquer」的優點顯現
<ul>
<li><strong>整體資料為「由小到大」或「由大到小」時會發生「Worst case」</strong></li>
<li><span class="math inline">\(T(n) = O(n) + T(n-1) \\ = T(1) + (2 + 3 + \ldots + n) \cdot c \\ = c \cdot \frac{(n+2)(n-1)}{2} = O(n^2)\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541765950716.png" alt="1541765950716" /><figcaption aria-hidden="true">1541765950716</figcaption>
</figure>
<p>圖一</p>
<figure>
<img src="\willywangkaa\images\1541766239354.png" alt="1541766239354" /><figcaption aria-hidden="true">1541766239354</figcaption>
</figure>
<p>圖二</p>
<figure>
<img src="\willywangkaa\images\1541766394245.png" alt="1541766394245" /><figcaption aria-hidden="true">1541766394245</figcaption>
</figure>
<p>圖三</p>
<blockquote>
<p>如何避免「Worst case」發生？</p>
<p>避免 Pivot 為最小值或最大值</p>
<p><strong>Randomized quicksort</strong></p>
<ul>
<li>亂數挑一個數作為 Pivot</li>
<li><strong>仍有可能發生「Worst case」( 無法完全解決問題 )</strong></li>
</ul>
<p><strong>Middle of three</strong> （下圖）</p>
<ul>
<li>做法
<ol type="1">
<li><span class="math inline">\(M = \frac {L+U}{2}\)</span></li>
<li>比較 A[L], A[M], A[U] 找出三者中之中間值，以<strong>此中間值與 A[l] 交換</strong></li>
<li>選擇 A[L] 作為 Pivot（中間值），作「Quicksort partition」</li>
</ol></li>
<li>可以解決「Worst case」問題</li>
</ul>
<figure>
<img src="\willywangkaa\images\1541766823939.png" alt="1541766823939" /><figcaption aria-hidden="true">1541766823939</figcaption>
</figure>
<p><strong>Median of medians</strong></p>
<p><strong>＜下方細述＞</strong></p>
</blockquote>
<ul>
<li><strong>Space complexity（遞迴所需的「Stack space」）</strong>
<ul>
<li>Best case (下圖一)：O( log n )</li>
<li>Worst case (下圖二)：O( n )</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541816631365.png" alt="1541816631365" /><figcaption aria-hidden="true">1541816631365</figcaption>
</figure>
<p>圖一</p>
<figure>
<img src="\willywangkaa\images\1541816965630.png" alt="1541816965630" /><figcaption aria-hidden="true">1541816965630</figcaption>
</figure>
<p>圖二</p>
<h3 id="quicksort2-algorithm書中版本">Quicksort2 ( 「Algorithm」書中版本 )</h3>
<p>Example</p>
<p>2 8 7 1 3 5 6 4 之第一次「Partition」</p>
<figure>
<img src="\willywangkaa\images\1541818660118.png" alt="1541818660118" /><figcaption aria-hidden="true">1541818660118</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Quicksort</span>(A[], p, r) &#123;               <span class="comment">// 排序 A[p] ~ A[r]</span></span><br><span class="line">    <span class="keyword">if</span>(p &lt; r) &#123;</span><br><span class="line">        q = <span class="built_in">Partition</span>(A[], p, r);    <span class="comment">// 見下圖一</span></span><br><span class="line">        <span class="built_in">Quicksort</span>(A[], p, q<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">Quicksort</span>(A[], q+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Partition</span>(A[], p, r) &#123;</span><br><span class="line">    pivot = A[r];</span><br><span class="line">    i = p<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = p; i &lt;= r<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(A[i], A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(A[i+<span class="number">1</span>], A[r]);</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example</p>
<p>The output of quicksort pass1</p>
<ul>
<li>1 2 3 4 5</li>
</ul>
<figure>
<img src="\willywangkaa\images\1541927350444.png" alt="1541927350444" /><figcaption aria-hidden="true">1541927350444</figcaption>
</figure>
<ul>
<li>5 4 3 2 1</li>
</ul>
<figure>
<img src="\willywangkaa\images\1541927780299.png" alt="1541927780299" /><figcaption aria-hidden="true">1541927780299</figcaption>
</figure>
<ul>
<li><span class="math inline">\(5 \;5 \;5 \;5 \;5^＊\)</span>
<ul>
<li><strong>在「Quicksort 2」演算情況下會是「Worst case」</strong>（O(<strong><span class="math inline">\(n^2\)</span></strong>)）</li>
<li><strong>在「Quicksort 1」演算情況下會是「Best case」</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541928492844.png" alt="1541928492844" /><figcaption aria-hidden="true">1541928492844</figcaption>
</figure>
<blockquote>
<p><strong>改善上述問題</strong></p>
<ol type="1">
<li>在「Partition」執行前<strong>檢查該陣列中元素是否相同</strong>：O( n )</li>
<li>改採用「 Hoare partition」：「Best case」O( n log n )</li>
</ol>
</blockquote>
<h3 id="問題與討論selection-problem">問題與討論—Selection problem</h3>
<p>問題概要：想要在一個<strong>未排序的一維陣列</strong>中，找到其最大值與最小值</p>
<ul>
<li>Native solution
<ol type="1">
<li>歷經 n-1 次比較後找出最大值</li>
<li>剩下 n-1 筆資料中歷經 n-2 次比較找出最小值
<ul>
<li>總<strong>比較</strong>次數：(n-1) + (n-2) = <strong>2n-3 次比較</strong></li>
</ul></li>
</ol></li>
<li>改良解法
<ol type="1">
<li><strong>A[1] 與 A[2] 比較一次知道兩數大小</strong>
<ul>
<li>令兩者之大數為 m 、小數為 n</li>
</ul></li>
<li>針對<strong>後面 n-2 筆資料以遞迴找出最大值與最小值</strong>（A[3]、A[4]、A[n-4]）
<ul>
<li>令 n-2 筆資料的最大值為 x、最小值為 y</li>
</ul></li>
<li>『m 與 x <strong>比較一次</strong>找出最大值』、『n 與 y <strong>比較一次</strong>找出最小值』</li>
</ol>
<ul>
<li>初值
<ul>
<li>T(0) = T(1) = 0</li>
<li>T(2) = 1</li>
</ul></li>
<li>總<strong>比較</strong>次數
<ul>
<li>T(n) = T(n-2) +（<strong>A[i] 與 A[i+1] 比較一次</strong> + <strong>m 與 x 比較</strong> + <strong>n 與 y 比較一次</strong>）</li>
<li><span class="math inline">\(T(n) = T(n-2) + 3 \\ = T(n-4) + 6 \\= T(n-6) + 9 \\ \vdots \\= T(0) + 3 \cdot \frac n2 &lt; 2n-3\)</span></li>
</ul></li>
<li><strong>稍微減少比較次數</strong></li>
</ul></li>
</ul>
<h3 id="問題與討論select-i-th-item-among-n-unsorted-data-array">問題與討論—Select i-th item among n unsorted data array</h3>
<p><strong>在未排序的陣列中找到第 i 小的資料</strong></p>
<blockquote>
<p>學過的演算法中：</p>
<ul>
<li>不知道其值域
<ul>
<li>以「Quick sort」等算法求取資料各個大小的資訊</li>
<li><strong>O(n log n)</strong></li>
</ul></li>
<li>知道資料範圍
<ul>
<li>以「Radix sort」等算法求取資料的大小資訊</li>
<li><strong>O(n)</strong></li>
</ul></li>
</ul>
<p><strong>如果以「Comparison based」來解決這個問題有無更快的算法？</strong></p>
<ul>
<li><strong>利用「Quick sort」中的「Partition」為此算法基底</strong></li>
</ul>
</blockquote>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 A[p]~A[r] 中找到第 i 小的資料</span></span><br><span class="line"><span class="built_in">Select</span>(A[], p, r, i) &#123;</span><br><span class="line">    q = <span class="built_in">Partition</span>(A, p, r); <span class="comment">// 將 pivot 大小定位在 q 點</span></span><br><span class="line">    k = q-p+<span class="number">1</span>;              <span class="comment">// 算出 pivot 是第 k 小的資料</span></span><br><span class="line">    <span class="keyword">if</span>(i == k) &#123;            <span class="comment">// pivot 即為 A[p]~A[r] 中第 k 小的資料</span></span><br><span class="line">        <span class="keyword">return</span> A[q];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; k) &#123;</span><br><span class="line">        <span class="built_in">Select</span>(A, p, q<span class="number">-1</span>, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Select</span>(A, q+<span class="number">1</span>, r, i-q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Time complexity</strong></p>
<ul>
<li>Best case：<strong>Pivot 的定位恰將資料切為兩等分</strong>
<ul>
<li>對左半或是右半作「Selection」+ 「Partition」</li>
<li><span class="math inline">\(T(n) = T(\frac n2) + cn \\ = c(n + \frac n2 + \frac n4 + \ldots+1) = \Theta(n)\)</span></li>
</ul></li>
<li>Average case
<ul>
<li><span class="math inline">\(T(n) = \frac 1n\sum_{s = 0}^{n-1} T(s)+ cn = O(n)\)</span></li>
</ul></li>
<li>Worst case
<ul>
<li><strong>當 Pivot 恰為最大或是最小值</strong></li>
<li><span class="math inline">\(T(n) = T(n-1) + cn\\ = n + (n-1) + (n-2) + \dots + 1 = O(n^2)\)</span></li>
<li><strong>解決辦法</strong>
<ul>
<li><strong>採取「Median of medians」選擇 Pivot ，將 Worst case 弭平為 O(n)</strong></li>
</ul></li>
</ul></li>
</ul>
<h4 id="selection-with-median-of-medians">Selection with median of medians</h4>
<figure>
<img src="\willywangkaa\images\1542449916157.png" alt="1542449916157" /><figcaption aria-hidden="true">1542449916157</figcaption>
</figure>
<p>步驟</p>
<ol type="1">
<li><p>先將 n 筆資料分成 <span class="math inline">\(\lceil \frac n5 \rceil\)</span> 個群組，每個群組有<strong>五筆資料</strong>（可能有一群組不足 5 筆資料）</p>
<ul>
<li>時間複雜度
<ul>
<li>O(n)</li>
</ul></li>
</ul></li>
<li><p>針對每個群組各自排序（如：Insertion sort）</p>
<ul>
<li>時間複雜度
<ul>
<li>每個群組最多花費 O(25) 次比較</li>
<li>共有 <span class="math inline">\(\lceil \frac n5 \rceil\)</span> 個群組</li>
<li>總共需 O(n)</li>
</ul></li>
</ul></li>
<li><p>每個已排序群組中<strong>第三個資料為該群組之中間值</strong></p>
<ul>
<li>對 <span class="math inline">\(\lceil \frac n5 \rceil\)</span> 個群組的中間值作「Selection with median」
<ul>
<li><strong>這些中間值中的中間值即為「Median of medians」</strong></li>
</ul></li>
<li>時間複雜度
<ul>
<li>遞迴呼叫「Selection with median」函式</li>
<li>在中間值中找第 <span class="math inline">\(\frac{\lceil\frac{n}{5}\rceil}{2}\)</span> 小的中間值
<ul>
<li><span class="math inline">\(T(\lceil\frac n5\rceil)\)</span></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>以「Median of medians」作為「Pivot」進行「Partition」</p>
<ul>
<li>時間複雜度
<ul>
<li>O(n)</li>
</ul></li>
</ul></li>
<li><p>繼續尋找 i 大小的值</p>
<ul>
<li>時間複雜度
<ul>
<li><strong>取決於「Median of medians」作為「Pivot」將資料切割之程度</strong></li>
</ul></li>
</ul></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">k = q-p+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i == k) &#123;</span><br><span class="line">    <span class="keyword">return</span> A&#123;q];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">    <span class="built_in">Select</span>(A, p, q<span class="number">-1</span>, i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">Select</span>(A, q+<span class="number">1</span>, r, i-k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>扣除「Pivot」所在的群組以及不滿五筆資料之群組
<ul>
<li><p><strong>約有一半的群中組必有 3 筆資料</strong> ≧「Pivot」</p></li>
<li><p>比「Pivot」大的資料個數 $( n5)  =   $</p></li>
<li><p>相反的會有 <span class="math inline">\(\lceil \frac{7n}{10}\rceil +6\)</span> 筆資料 ≦「Pivot」</p></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542450245855.png" alt="1542450245855" /><figcaption aria-hidden="true">1542450245855</figcaption>
</figure>
</blockquote>
<ul>
<li>Time comlexity
<ul>
<li>（下圖）最糟糕的情況
<ul>
<li><strong>在資料比較多的地方作「Select」</strong></li>
<li>在 <span class="math inline">\(\lceil \frac{7n}{10}\rceil +6\)</span> 中遞迴找出目標值
<ul>
<li>第五步的遞迴最壞需要 <span class="math inline">\(T(\lceil \frac{7n}{10}\rceil + 6)\)</span></li>
</ul></li>
</ul></li>
<li><span class="math inline">\(T(n) = T(\lceil\frac n5\rceil) + T(\lceil \frac{7n}{10}\rceil+6)+O(n) \\ = T(\frac 15n)+ T(\frac 7{10}n) + cn = O(n)\)</span>（以樹狀結構解此遞迴）</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542451499380.png" alt="1542451499380" /><figcaption aria-hidden="true">1542451499380</figcaption>
</figure>
<blockquote>
<ul>
<li>（下圖）如果以<strong>七筆資料為一群組</strong>
<ul>
<li>至少有 <span class="math inline">\((\frac 12\cdot\lceil\frac n7\rceil -2)\cdot 4\)</span> 筆資料 ≧「Pivot」
<ul>
<li><span class="math inline">\(\frac{2n}{7}-8\)</span> 筆 ≧「Pivot」</li>
<li><span class="math inline">\(\lceil \frac {5n}{7}\rceil+8\)</span> 筆 ≦「Pivot」</li>
</ul></li>
<li><span class="math inline">\(T(n) = O(n) + O(n) + T(\lceil\frac n7\rceil) +O(n) + T(\lceil \frac{5n}{7}\rceil+8) \\ = T(\frac n7)+ T(\frac 57n)+cn = O(n)\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542450561714.png" alt="1542450561714" /><figcaption aria-hidden="true">1542450561714</figcaption>
</figure>
<ul>
<li>（下圖）如果以<strong>三筆資料為一群組</strong>
<ul>
<li>至少有 <span class="math inline">\((\frac 12\cdot\lceil\frac n3\rceil -2)\cdot 2\)</span> 筆資料 ≧ 「Pivot」
<ul>
<li><span class="math inline">\(\frac{n}{3}-4\)</span> 筆 ≧「Pivot」</li>
<li><span class="math inline">\(\lceil \frac {2n}{3}\rceil+4\)</span> 筆 ≦「Pivot」</li>
</ul></li>
<li><span class="math inline">\(T(n) = O(n) + O(n) + T(\lceil\frac n3\rceil) +O(n) + T(\lceil \frac{2n}{3}\rceil+4) \\ = T(\frac n3)+ T(\frac 23n)+cn = O(n\log n)\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542450928741.png" alt="1542450928741" /><figcaption aria-hidden="true">1542450928741</figcaption>
</figure>
</blockquote>
<h2 id="merge-sort">Merge sort</h2>
<p>適用於「External sort」，所以可以又稱為「External merge sort」；其特性可讀入一些能放在內存內的數據量，在內存中排序後輸出為一個順串（即是內部數據有序的臨時文件），處理完所有的數據後再進行歸併</p>
<p>(見<a href="https://zh.wikipedia.org/zh-tw/%E5%A4%96%E6%8E%92%E5%BA%8F">外排序- 維基百科，自由的百科全書 - Wikipedia</a>)</p>
<ul>
<li>名詞
<ul>
<li>「Run」：<strong>順串</strong>；排序好的片段資料</li>
<li>「Run」的長度：順串中的資料量</li>
</ul></li>
</ul>
<blockquote>
<p>計算機科學家 <a href="https://zh.wikipedia.org/w/index.php?title=%E5%90%89%E5%A7%86%C2%B7%E6%A0%BC%E9%9B%B7&amp;action=edit&amp;redlink=1">吉姆·格雷</a> 的 <a href="http://sortbenchmark.org/">Sort Benchmark</a> 網站用不同的硬體、軟體環境測試了實現方法不同的多種外排序算法的效率。效率較高的算法具有以下的特徵：</p>
<ul>
<li><strong>並行計算</strong>
<ul>
<li>用多個磁碟驅動器<strong>並行處理數據</strong>，可以加速順序磁碟讀寫</li>
<li>在<strong>計算機上使用多執行緒</strong>，可在多核心的計算機上得到優化</li>
<li>使用異步輸入輸出，可以<strong>同時排序和歸併，同時讀寫</strong></li>
<li>使用多台計算機用高速網絡連接，分擔計算任務</li>
</ul></li>
<li><strong>提高硬體速度</strong>
<ul>
<li><strong>增大內存，減小磁碟讀寫次數，減小歸併次數</strong></li>
<li>使用快速的外存設備，比如15000 RPM的硬碟或固態硬碟</li>
<li>使用性能更優良個各種設備，比如使用多核心 CPU 和延遲時間更短的內存</li>
</ul></li>
<li><strong>提高軟體速度</strong>
<ul>
<li>對於某些特殊數據，在第一階段的排序中使用<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基數排序</a></li>
<li>壓縮輸入輸出文件和臨時文件</li>
</ul></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>外歸併排序法並不是唯一的「External sort」，另外有<strong>「外分配排序」</strong>，其原理類似於內排序中的<a href="https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序（Bucket sort）</a></p></li>
<li><p>「Merge sort」和「Bucket sort」之間存在數學上的某種對偶性</p></li>
</ul>
<p>Example（106 清華大學資工基礎計算機科學第 6 題）</p>
<ul>
<li>簡述
<ul>
<li>比較兩個「External sort」分別的特性，並且個別適合什麼類型的資料型態
<ul>
<li>Merge sort</li>
<li>Bucket sort</li>
</ul></li>
</ul></li>
<li>Merge sort
<ul>
<li>因為其特性，適合大量資料的排序，可以將資料從「Second storage」中取得資料存於 RAM 中，再進行排序，歸併後再輸出至「Second storage」</li>
</ul></li>
<li>Bucket sort
<ul>
<li>與「Merge sort」一樣，經過調整的演算法可以作為「外分配排序」，同樣可以處理大量資料，但還有包含另一個性質，若資料位數很大時，或是基底很小時，也建議採用「MSD radix sort」</li>
</ul></li>
</ul>
</blockquote>
<h3 id="iterative-merge-sorttwo-way-merge">Iterative merge sort（Two way merge）</h3>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\1542088579919.png" alt="1542088579919" /><figcaption aria-hidden="true">1542088579919</figcaption>
</figure>
<ul>
<li>Algorithm（Merge 2 runs）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A[l....m]: 子陣列「順串一」</span></span><br><span class="line"><span class="comment">// A[m+1..n]: 子陣列「順串二」</span></span><br><span class="line"><span class="built_in">Merge</span>(A[], l, m, n) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = l, q = m+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tmp[n-l+<span class="number">1</span>];   <span class="comment">// 暫存陣列 [1..(n-l+1)]</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 當 run1 與 run2 皆未掃描完</span></span><br><span class="line">    <span class="keyword">while</span>(p &lt;= m &amp;&amp; q &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[p] &lt;= A[q]) &#123;</span><br><span class="line">            tmp[i++] = A[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[i++] = A[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// run1 未掃描完</span></span><br><span class="line">    <span class="keyword">while</span>(p &lt;= m) &#123;</span><br><span class="line">        tmp[i++] = A[p++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// run2 未掃描完</span></span><br><span class="line">    <span class="keyword">while</span>(q &lt;= n) &#123;</span><br><span class="line">        tmp[i++] = A[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(A[l..n], tmp[<span class="number">1.</span>.(n-l+<span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity：O( n log n )
<ul>
<li>「順串一」的長度為 m、「順串二」的長度為 n，合併兩順串：
<ul>
<li><span class="math inline">\(\left\{\begin{matrix}最少比較次數： &amp; m \;or \;n\\ 最多比較次數（有一方先掃描完）：&amp; m+n-1\end{matrix}\right.\)</span></li>
</ul></li>
<li>（下圖一）所以假設整體要排序的資料總量為 n ，合併一次所有的順串需 O(n)
<ul>
<li>n 筆資料作「2-way merge sort」</li>
<li>（下圖二）可以看成一棵「Completed binary search tree」</li>
<li>因為<strong>「Merge」回合數 = 樹高 - 1</strong>
<ul>
<li><span class="math inline">\(\Rightarrow 2^{k-1} = n \Rightarrow k = \lceil \lg n\rceil +1\)</span></li>
<li><span class="math inline">\(\Rightarrow 「Merge」回合數 = \lceil \lg n\rceil \\ \because 每個回合作「Merge」需\; O(n) \; \\ \therefore 總共的時間複雜度為\; O(n \log n)\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542088930143.png" alt="1542088930143" /><figcaption aria-hidden="true">1542088930143</figcaption>
</figure>
<p>圖一</p>
<figure>
<img src="\willywangkaa\images\1542089353231.png" alt="1542089353231" /><figcaption aria-hidden="true">1542089353231</figcaption>
</figure>
<p>圖二</p>
<h3 id="recursive-merge-sorttwo-way-merge">Recursive merge sort（Two way merge）</h3>
<p>採用「Devide and conquer」的技巧</p>
<p>步驟：</p>
<ol type="1">
<li><p>一律切割成兩等分之「子串列」（Sublist）</p>
<ul>
<li>O( 1 )</li>
</ul></li>
<li><p>左右子串列各自作「Merge sort」，算出左右之「順串」</p>
<ul>
<li><span class="math inline">\(2 \times T(\frac n2)\)</span></li>
</ul></li>
<li><p>對左右順串作「Merge」</p>
<ul>
<li>O( n )</li>
</ul></li>
</ol>
<blockquote>
<p>「Quicksort」相比</p>
<ul>
<li>「Mergesort」把時間（O(n)）<strong>花在合併的階段</strong></li>
<li>「Quicksort」把時間（O(n)）<strong>花在分割階段</strong></li>
</ul>
</blockquote>
<figure>
<img src="\willywangkaa\images\1542090860348.png" alt="1542090860348" /><figcaption aria-hidden="true">1542090860348</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A[l....m]: 子陣列「順串一」</span></span><br><span class="line"><span class="comment">// A[m+1..n]: 子陣列「順串二」</span></span><br><span class="line"><span class="built_in">Merge</span>(A[], l, m, n) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = l, q = m+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tmp[n-l+<span class="number">1</span>];   <span class="comment">// 暫存陣列 [1..(n-l+1)]</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 當 run1 與 run2 皆未掃描完</span></span><br><span class="line">    <span class="keyword">while</span>(p &lt;= m &amp;&amp; q &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[p] &lt;= A[q]) &#123;</span><br><span class="line">            tmp[i++] = A[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[i++] = A[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// run1 未掃描完</span></span><br><span class="line">    <span class="keyword">while</span>(p &lt;= m) &#123;</span><br><span class="line">        tmp[i++] = A[p++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// run2 未掃描完</span></span><br><span class="line">    <span class="keyword">while</span>(q &lt;= n) &#123;</span><br><span class="line">        tmp[i++] = A[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(A[l..n], tmp[<span class="number">1.</span>.(n-l+<span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 對 A[L]~A[R] 排序</span></span><br><span class="line"><span class="built_in">Mergesort</span>(A[], L, R) &#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt; R) &#123;</span><br><span class="line">        m = (l+u)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">Mergesort</span>(A, L  , m);</span><br><span class="line">        <span class="built_in">Mergesort</span>(A, m+<span class="number">1</span>, R);</span><br><span class="line">        <span class="built_in">Merge</span>(A, L, m, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>Best / Worst / Avg.：O( nlogn )
<ul>
<li><span class="math inline">\(\because T(n) = 2\times T(\frac n2) + cn \Rightarrow T(n) = O(n\log n)\)</span></li>
</ul></li>
</ul></li>
<li>Space complexity
<ul>
<li>O( n )
<ul>
<li>在作「Merge」的時候為了<strong>暫存合併的結果</strong>
<ul>
<li>空間占用大小等於資料量（n）</li>
<li>空間需求高</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Stable</strong>
<ul>
<li>因為在作「Merge」時，<code>if(A[p]&lt;=A[q])..</code> <strong>會讓左順串與右順串在有兩個同樣大小的值時，左順串優先進入新的順串之中</strong></li>
</ul></li>
</ul>
<h3 id="輔助結構-selection-tree">[輔助結構] Selection tree</h3>
<p>如果在「Mergesort」中一次合併多個順串（k 個順串），稱之為「K-way mergesort」</p>
<p>Example</p>
<p><strong>4-way merge</strong></p>
<figure>
<img src="\willywangkaa\images\1542091456582.png" alt="1542091456582" /><figcaption aria-hidden="true">1542091456582</figcaption>
</figure>
<ul>
<li>每次要對 k 個順串作合併時
<ul>
<li>資料總量為 n</li>
<li><strong>每次從 k 個順串中找到最小的值必須花 k-1 次比較</strong></li>
<li>最多要<strong>歷經 n-1 個回合</strong></li>
<li><strong>作一次「k-way merge」之時間複雜度為 O(n×k)</strong></li>
</ul></li>
</ul>
<blockquote>
<p>減少比較的次數</p>
<ul>
<li>以資料結構輔佐
<ul>
<li>「Winner tree」、「Loser tree」</li>
</ul></li>
<li>在實現上多採用「Loser tree」</li>
</ul>
</blockquote>
<h4 id="winner-tree">Winner tree</h4>
<p>Example</p>
<p><strong>8-way merge with winner tree</strong></p>
<figure>
<img src="\willywangkaa\images\1542091906501.png" alt="1542091906501" /><figcaption aria-hidden="true">1542091906501</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542092026110.png" alt="1542092026110" /><figcaption aria-hidden="true">1542092026110</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542092171261.png" alt="1542092171261" /><figcaption aria-hidden="true">1542092171261</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542092353259.png" alt="1542092353259" /><figcaption aria-hidden="true">1542092353259</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542092514867.png" alt="1542092514867" /><figcaption aria-hidden="true">1542092514867</figcaption>
</figure>
<p>（重複動作直到「新順串」建立完）</p>
<ul>
<li>Time complexity（假設為「k-way merge」、總資料數為 n）
<ul>
<li>建立「Winner tree」：O( k )
<ul>
<li>分別從 k 個順串中複製出<strong>最小值</strong>作為「Winner tree」的葉節點
<ul>
<li>O( k )</li>
</ul></li>
<li>在「Winner tree」中的葉節點，以 k-1 次的比較找出最小值節點作為「根節點」
<ul>
<li>O( k )</li>
</ul></li>
</ul></li>
<li>輸出「根節點」至「新順串」中，被輸出的順串之下一筆資料遞補，重複 n-1 回合：O( n×log k )
<ul>
<li>決定根節點（最小值）
<ul>
<li>假設 <span class="math inline">\(l\)</span> 為葉節點數量
<ul>
<li>「Winner tree」之葉節點為<span class="math inline">\(l = k = 8\)</span></li>
<li>「Winner tree」樹高 h 為 <span class="math inline">\(O(\lceil\log l\rceil+1)\)</span></li>
</ul></li>
<li>決定根節點需要歷經 <span class="math inline">\(O(h-1) \equiv O(\lceil\lg(l)\rceil+1-1)\)</span>
<ul>
<li><span class="math inline">\(O(\log k)\)</span></li>
</ul></li>
</ul></li>
<li>輸出根節點：O( 1 )</li>
<li>被輸出之順串下一筆資料遞補：O( 1 )</li>
</ul></li>
<li>總體時間複雜度
<ul>
<li>O(k) + O( nlogk ) = O( nlogk )</li>
</ul></li>
</ul></li>
</ul>
<h4 id="loser-tree">Loser tree</h4>
<p>Example</p>
<p>8-way merge with loser tree</p>
<figure>
<img src="\willywangkaa\images\1542093764103.png" alt="1542093764103" /><figcaption aria-hidden="true">1542093764103</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542093996385.png" alt="1542093996385" /><figcaption aria-hidden="true">1542093996385</figcaption>
</figure>
<p>（執行直到「新順串」建立完成）</p>
<p>Time complexity （假設為「k-way merge」、總資料數為 n）</p>
<ul>
<li>建立「Loser tree」：O( k )
<ul>
<li>分別從 k 個順串中複製出<strong>最小值</strong>作為「Loser tree」的「葉節點」：O( k )</li>
<li>在「Loser tree」中的葉節點，以 k-1 次的比較找出最小值節點作為「根節點」：O( k )</li>
</ul></li>
<li>輸出「根節點」至「新順串」中，被輸出的順串之下一筆資料遞補，重複 n-1 回合：O( n×log k )
<ul>
<li>決定根節點（最小值）
<ul>
<li>假設 <span class="math inline">\(l\)</span> 為葉節點數量
<ul>
<li>「Winner tree」之葉節點為<span class="math inline">\(l = k = 8\)</span></li>
<li>「Winner tree」樹高 h 為 <span class="math inline">\(O(\lceil\log l\rceil+1)\)</span></li>
</ul></li>
<li>決定根節點需要歷經 <span class="math inline">\(O(h-1) \equiv O(\lceil\lg(l)\rceil+1-1)\)</span>
<ul>
<li><span class="math inline">\(O(\log k)\)</span></li>
</ul></li>
</ul></li>
<li>輸出根節點：O( 1 )</li>
<li>被輸出之順串下一筆資料遞補：O( 1 )</li>
</ul></li>
<li>總體時間複雜度
<ul>
<li>O(k) + O( nlogk ) = O( nlogk )</li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>「External merge sort」
<ul>
<li>排序資料：n
<ul>
<li>「K-way merging on m runs」</li>
</ul></li>
<li>使用「Selection tree」其時間複雜度
<ul>
<li>O( n lg m )</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542095449837.png" alt="1542095449837" /><figcaption aria-hidden="true">1542095449837</figcaption>
</figure>
<ul>
<li>假設 m 個順串被 k-way 分成了<strong>兩堆</strong>
<ul>
<li>由「Selection tree」得知
<ul>
<li>作「k-way merge」之時間複雜度
<ul>
<li><span class="math inline">\(O( \frac n2 \times \lg k )\)</span></li>
</ul></li>
</ul></li>
<li>因為有兩堆所以「Merge」總共需要
<ul>
<li>O( n lg k )</li>
</ul></li>
<li>推廣後無論分幾堆作「Merge」之時間複雜度
<ul>
<li><strong>O( n lg k )</strong></li>
</ul></li>
</ul></li>
</ul>
<p><strong>因為『回合數 = 樹高 - 1』（見下圖），在「Sorting」時需要執行</strong> <span class="math inline">\(\lceil log_km \rceil\)</span> <strong>回合</strong></p>
<figure>
<img src="\willywangkaa\images\1542097917874.png" alt="1542097917874" /><figcaption aria-hidden="true">1542097917874</figcaption>
</figure>
<ul>
<li>Time complexity
<ul>
<li>以樹的觀點
<ul>
<li>Degree = k</li>
<li>Number of leaves = m
<ul>
<li><span class="math inline">\(\Rightarrow k^{h-1} = m \\ \Rightarrow h = \lceil\log_k m\rceil +1\\ 回合數 = h -1 = O(\log_k m)\)</span></li>
</ul></li>
</ul></li>
<li>總共時間複雜度
<ul>
<li><span class="math inline">\(O((n \cdot \lg k) \times \log_k m) \\ = O(n \cdot \frac{\log k}{\log 2}\cdot\frac{\log m}{\log k})\\ = O(n\cdot\lg m)\)</span></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h2 id="heap-sort">Heap sort</h2>
<p>步驟：</p>
<ol type="1">
<li>先將 n 筆資料建構成「Max heap」
<ul>
<li>Time complexity：O(n)</li>
</ul></li>
<li>執行「Del-max」並將取出資料放置於陣列最後端資料被移除處（見「Binary heap」之刪除節點）</li>
<li>動作（2）重複 n-1 回合</li>
</ol>
<p>Example</p>
<p>排序：5 3 8 2 6 9 1 4 10 7</p>
<figure>
<img src="\willywangkaa\images\1542105475686.png" alt="1542105475686" /><figcaption aria-hidden="true">1542105475686</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542105714121.png" alt="1542105714121" /><figcaption aria-hidden="true">1542105714121</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542105818821.png" alt="1542105818821" /><figcaption aria-hidden="true">1542105818821</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542105935299.png" alt="1542105935299" /><figcaption aria-hidden="true">1542105935299</figcaption>
</figure>
<p>（重複動作）</p>
<figure>
<img src="\willywangkaa\images\1542106039971.png" alt="1542106039971" /><figcaption aria-hidden="true">1542106039971</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tree: Array[1..n]</span></span><br><span class="line"><span class="comment">// n   : 元素個數</span></span><br><span class="line"><span class="comment">// i   : 節點編號 (調整以 i 為樹根之子樹)</span></span><br><span class="line"><span class="built_in">Heapify</span>(tree, i, n) &#123;</span><br><span class="line">    x = tree[i];</span><br><span class="line">    j = <span class="number">2</span> * i                     <span class="comment">//左子</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; n)                 <span class="comment">// 具有右子</span></span><br><span class="line">            <span class="keyword">if</span>(tree[j]&lt;tree[j+<span class="number">1</span>])</span><br><span class="line">                j = j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= tree[j])          <span class="comment">// 已經為 heap</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tree[j/<span class="number">2</span>] = tree[j];</span><br><span class="line">            j = <span class="number">2</span> * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[j/<span class="number">2</span>] = x;                <span class="comment">// 將資料 x 置於正確位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tree[]: 目標排序資料</span></span><br><span class="line"><span class="comment">// n: 排序資料數量</span></span><br><span class="line"><span class="built_in">Heapsort</span>(tree[], n) &#123;</span><br><span class="line">    <span class="comment">// Build heap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(tree, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 執行 n-1 回合之 heap sorting</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i&gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(tree[<span class="number">1</span>], tree[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">heapify</span>(tree, <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>Best case / Worst case / Avg. case = O(n log n)
<ol type="1">
<li>Build heap：O( n )</li>
<li>執行 n-1 回合「Del max」：O ( n log n )</li>
</ol></li>
</ul></li>
<li>Space complexity
<ul>
<li>O(1)</li>
</ul></li>
</ul>
<p>Example</p>
<p>排序： 5 5* 1</p>
<figure>
<img src="\willywangkaa\images\1542106445237.png" alt="1542106445237" /><figcaption aria-hidden="true">1542106445237</figcaption>
</figure>
<ul>
<li><strong>Unstable</strong></li>
</ul>
<h1 id="linear-time-sorting-method">Linear time sorting method</h1>
<p><strong>不採用「Comparison based」技巧之排序手法</strong></p>
<blockquote>
<p>在探討線性時間複雜度之排序技術前，要知道這類排序都要有一個前提，<strong>資料值域必須有範圍限制</strong>，才能將排序降低為線性時間</p>
<ul>
<li>Example：當排序資料只有 0 與 1 兩種類型資料時，最快的排序方法
<ul>
<li><strong>「Counting sort」、「Radix sort」</strong></li>
</ul></li>
<li>Example：當資料只有 -1、0、1 三種資料做排序，最快的排序方法
<ul>
<li><strong>「Counting sort」、「Radix sort」</strong></li>
</ul></li>
</ul>
</blockquote>
<h2 id="radix-sort-基數排序法-data-structure-書上版本">Radix sort 基數排序法 ( Data structure 書上版本 )</h2>
<p>又稱為「Bucket sort」，採取「Distribution and merge」之技巧</p>
<ul>
<li>書本名詞差異</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">[DS 版]（Radix = Bucket）</th>
<th style="text-align: center;">[Algorithm 版]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">LSD radix sort</td>
<td style="text-align: center;"><strong>Radix sort</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">MSD radix sort</td>
<td style="text-align: center;"><strong>Bucket sort</strong></td>
</tr>
</tbody>
</table>
<h3 id="lsd-radix-sortleast-significant-digital">LSD radix sort（Least significant digital）</h3>
<p>步驟：</p>
<ol type="1">
<li>令 r 為基底（Base）
<ul>
<li>準備 r 個「Bucket」編號為 0 ~ (r-1)</li>
</ul></li>
<li>令 d 為「Input data」<strong>中所有值以 r 為基底之最大位數個數</strong>：O( n )
<ul>
<li><strong>之後在執行排序時只需要 d 回合即可完成</strong></li>
</ul></li>
<li>由最低位元至最高位元執行：
<ol type="1">
<li>分派（Distribution）
<ul>
<li>依各個資料之該位元分派到對應的「Bucket」</li>
</ul></li>
<li>合併（Merge）
<ul>
<li>將所有「Bucket」由小到大（0 ~ (r-1)）合併</li>
</ul></li>
</ol></li>
</ol>
<p>Example（基底為 10；十進位）</p>
<p>排序：329、457、657、839、436、720、355</p>
<figure>
<img src="\willywangkaa\images\1542447949542.png" alt="1542447949542" /><figcaption aria-hidden="true">1542447949542</figcaption>
</figure>
<ul>
<li>Time complexity
<ul>
<li>作 d 回合 <span class="math inline">\(\left\{\begin{matrix} 分派：O(n) \\ 合併：O(r) \end{matrix}\right. \\ \Rightarrow 一回合需要\; O(n+r) \\ \Rightarrow 總共時間複雜度：O( d \times (n+r) )\)</span></li>
<li>為「Linear time」：r 可以視為常數 c1 ，而因為值域受到限制，所以 d 為固定值亦為常數 c2
<ul>
<li>O(c2 × (n+c1)) = O( c2 × n + c2 × c1 ) = O( n )</li>
</ul></li>
</ul></li>
<li>Space complexity
<ul>
<li>額外空間需求為「Bucket space」，而有 r 個大小為 n 的「Bucket」：O( r × n )</li>
</ul></li>
<li>Stable</li>
</ul>
<h3 id="msd-radix-sortmost-significant-digital">MSD radix sort（Most significant digital）</h3>
<p>步驟：</p>
<ol type="1">
<li>令 r 為基底（Base） ，準備 r 個「Bucket」編號為 0 ~ (r-1)</li>
<li>依照「最高位元」的數值分派資料至「Bucket」中</li>
<li>每個「Bucket」內各自排序</li>
<li>由小到大合併所有「Bucket」</li>
</ol>
<blockquote>
<p>「LSD radix sort」最大的區別</p>
<ul>
<li>「MSD radix sort」
<ul>
<li>作「分派」與「合併」各一次</li>
<li>若「資料位數很大」或「基底很小」時
<ul>
<li>建議採用「MSD radix sort」</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h4 id="bucket-sortalgorithm-書上版本">Bucket sort（Algorithm 書上版本）</h4>
<p>步驟：</p>
<ol type="1">
<li>將資料轉化成「純小數」</li>
<li>以各個純小數之小數後第一位值有序的插入「Bucket」中</li>
<li>由小到大合併所有「Bucket」</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pseudo code</span></span><br><span class="line">Array bucket-<span class="built_in">sort</span>(array, n) &#123;</span><br><span class="line">    Array buckets[n];</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> <span class="built_in">to</span> (<span class="built_in">length</span>(array)<span class="number">-1</span>) &#123;</span><br><span class="line">        buckets[<span class="built_in">msbits</span>(array[i], k)].<span class="built_in">insert</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span> </span><br><span class="line">        next-<span class="built_in">sort</span>(buckets[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">concatenation</span>(buckets[<span class="number">0</span>], ..., buckets[n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在實作裡，可用每個桶內部用連結串列表示，在資料入桶的同時<strong>插入排序</strong>，然後把各個桶中的資料合併</p>
</blockquote>
<p>Example</p>
<p>排序：179、208、306、93、859、984、55、9、271、33</p>
<figure>
<img src="\willywangkaa\images\1542448961965.png" alt="1542448961965" /><figcaption aria-hidden="true">1542448961965</figcaption>
</figure>
<h2 id="counting-sort">Counting sort</h2>
<p>假設 n 為欲排序資料之總數，且該資料範圍介於 1 ~ k 之間</p>
<p>步驟</p>
<ol type="1">
<li>統計各個鍵值出現次數，並記錄在 count[1...k] 之中</li>
<li>利用 count[1...k] 求出各個鍵值<strong>未來</strong>排序時之起始位置，紀錄在 start[1...k] 中</li>
<li>依據 start[1...k] 之指示，將「Input array」置入「Output array」中對應的位置</li>
</ol>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A: 欲排序陣列</span></span><br><span class="line"><span class="comment">// n: 資料個數</span></span><br><span class="line"><span class="comment">// k: 值域範圍</span></span><br><span class="line"><span class="built_in">Countingsort</span>(A[], n, k) &#123;</span><br><span class="line">    <span class="keyword">new</span> count[<span class="number">1.</span>..k];</span><br><span class="line">    <span class="keyword">new</span> start[<span class="number">1.</span>..k];</span><br><span class="line">    <span class="keyword">new</span> output[<span class="number">1.</span>..n];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;         <span class="comment">// Time complexity: O(k)</span></span><br><span class="line">        count[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步驟一：統計鍵值出現個數</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;         <span class="comment">// Time complexity: O(n)</span></span><br><span class="line">        count[A[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步驟二：計算每個鍵值排序時之起點位置</span></span><br><span class="line">    start[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; i++) &#123;         <span class="comment">// Time complexity: O(k)</span></span><br><span class="line">        start[i] = start[i<span class="number">-1</span>]+count[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步驟三：依照指示放置資料</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;         <span class="comment">// Time complexity: O(n)</span></span><br><span class="line">        <span class="comment">// 先使用 start[A[i]] 原本資料後，</span></span><br><span class="line">        <span class="comment">// 將 start[A[i]]+=1</span></span><br><span class="line">        output[start[A[i]]++] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>O(k) + O(n) +O(k) + O(n) = O(n+k)</li>
</ul></li>
</ul>
<blockquote>
<p>探討為何 <code>O(k)+O(n)+O(k)+O(n)</code> 為線性時間複雜度</p>
<ul>
<li>觀點一
<ul>
<li>若鍵值值域之範圍變化是 O(n)
<ul>
<li>此處的 O(n) 為資料範圍
<ul>
<li><strong>意旨「Input array」中每一個元素在資料範圍中均勻分布</strong></li>
</ul></li>
<li>此觀點來看時間複雜度為
<ul>
<li><strong>O(n+k) =&gt; O(n+O(n)) =&gt; O(n)</strong></li>
</ul></li>
</ul></li>
</ul></li>
<li>觀點二
<ul>
<li>若「Input array」之值域受到限制
<ul>
<li>k 可以視為一個常數
<ul>
<li>O(n+k) = O(n)</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>Space complexity
<ul>
<li><code>count[1...k]、start[1...k]、output[1...n]</code>，O(n+k)</li>
</ul></li>
<li>Stable</li>
</ul>
<h3 id="counting-sort-問題與探討">Counting sort 問題與探討</h3>
<p>延續上面探討時間複雜度之觀點一，已知「Counting sort」之時間複雜度為 O(n+k)，若<strong>資料範圍</strong> k 為線性等級 O(k) ，則整理排序時間複雜度為 O(n)</p>
<ul>
<li>倘若<strong>資料範圍</strong> k 為平方等級 O(<span class="math inline">\(n^2\)</span>)
<ul>
<li><strong>意旨「Input array」中的元素在資料範圍超出原本「Counting sort」可執行排序的資料範圍</strong></li>
</ul></li>
<li>必須探討其時間複雜度之變化 O(n + O(<span class="math inline">\(n^2\)</span>))</li>
</ul>
<p>Example（用例子解釋）</p>
<ul>
<li>一「Counting sort」只能對值域 0 ~ 9 的資料集合<strong>（O(n)）</strong>作排序
<ul>
<li>要如何對一個值域為 0 ~ 99 <strong>（O(</strong><span class="math inline">\(n^2\)</span><strong>)）</strong>的資料集合作排序？</li>
</ul></li>
</ul>
<p>以<strong>「基數排序法」的想法為基礎</strong>，則可以在兩回合中將排序完成</p>
<ol type="1">
<li><p>對每個鍵值作「mod n」</p>
<ul>
<li>n 為「Counting sort」能夠排序的範圍，亦可以視為「基底」</li>
<li>取其作為排序鍵值，對每個資料以新排序鍵值作「Counting sort」
<ul>
<li>將結果以類似<strong>「『Radix sort』每回合最後之合併動作」</strong>收尾</li>
</ul></li>
<li>因為值域介於 0 ~ (n-1) 之間
<ul>
<li>第一回合使用「Counting sort」的排序時間複雜度為 O(n)</li>
</ul></li>
</ul></li>
<li><p>以第一回合之「Output array」作為「Input array」</p>
<ul>
<li>對每個鍵值作「÷ n」再作「mod n」取其作為排序鍵值</li>
<li>對每個資料以新排序鍵值作「Counting sort」
<ul>
<li>將結果以類似「『Radix sort』每回合最後之合併動作」收尾</li>
</ul></li>
<li>採用「基數排序法」作為基礎
<ul>
<li>每回合的排序必須是「Stable」才能正確排序
<ul>
<li>「Counting sort」為「Stable」</li>
<li>排序執行成功，</li>
</ul></li>
<li>第二回合之時間複雜度為 O(n)</li>
</ul></li>
</ul></li>
</ol>
<ul>
<li><strong>總時間複雜度為 2 × O(n) = O(n) ，仍為線性時間複雜度</strong></li>
</ul>
<blockquote>
<p>若資料範圍為 O(<span class="math inline">\(n^3\)</span>) 則依照上述想法， 三回合即可排序完成</p>
<ol type="1">
<li>第一回合的排序鍵值為 $原本鍵值i ;％; n $ 作為「Counting sort」排序鍵值（時間複雜度為 O(n)）</li>
<li>第一回合的排序鍵值為 $;％; n $ 作為「Counting sort」排序鍵值（時間複雜度為 O(n)）</li>
<li>第一回合的排序鍵值為 <span class="math inline">\(\lceil\frac{原本鍵值i}{n^2}\rceil \;％ \;n ​\)</span> 作為「Counting sort」排序鍵值（時間複雜度為 O(n)）</li>
</ol>
<ul>
<li>當資料範圍為 <span class="math inline">\(O(n^4)、O(n^5)\)</span> 亦可以以此類推</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Search</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Data structure - Graph</title>
    <url>/willywangkaa/2018/12/02/Data-structure-graph/</url>
    <content><![CDATA[<h1 id="the-structure-of-graph">The structure of graph</h1>
<h2 id="note-adjacency-list">[Note] Adjacency list</h2>
<p>有一圖 G = (V, E), |V| = n, |E| = e，需要 n 條相鄰串列（vertex[1...n] : pointer）來表達，其中 vertex[i] 代表頂點 i 的相鄰串列，紀錄所有與頂點 i 相鄰的頂點編號</p>
<ul>
<li>以「相鄰串列」表示無向圖時，因為 邊(i,j) = 邊(j,i)（一條邊有兩個頂點），所以串列需要 2×e 個節點來儲存這張圖
<ul>
<li><strong>當圖的邊少時，可以取得優勢</strong></li>
</ul></li>
</ul>
<p>Example（無向圖）</p>
<p>求頂點 i 的「Degree」需要的時間複雜度為？</p>
<p>即為 vertex[i] 的串列長度，所以需要的時間複雜度為 O(<span class="math inline">\(V_i\)</span>串列長度) ≦ O(e)</p>
<p>Example（無向圖）</p>
<p>求圖上有多少邊的時間複雜度為？</p>
<p><span class="math inline">\(e = \frac 12\sum_{i = 1}^n (V_i \;Degree)\\ \therefore e = \frac 12 \sum_{i = 1}^n (V_i \;串列長度)\\ = O(n+e)\)</span></p>
<blockquote>
<p>無向圖上最多可以有 <span class="math inline">\(\binom {n}{2} = \frac{n(n-1)}{2} = \frac{n^2-n}{2}\)</span> 條邊，從上述又可以得知如果要追蹤以「相鄰串列」表示的無向圖上之邊，最多的時間複雜度為 <span class="math inline">\(O(n + \frac{n^2-n}{2}) = O(n^2)\)</span></p>
</blockquote>
<p>Example</p>
<p>若以「相鄰串列」表示有向圖，要求頂點的「Out-degree」與「In-degree」，分別需要的時間複雜度為？</p>
<p>「Out-degree」：vertex[i] 的串列長度，所以也為 O(e)</p>
<p>「In-degree」：因為必需追蹤所有點以找到指向 i 的頂點為何，所以全部的串列都要確認，時間複雜度為 <span class="math inline">\(O(n^2)\)</span></p>
<h2 id="相鄰串列與相鄰陣列比較表">相鄰串列與相鄰陣列比較表</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th>Adjacency matrix</th>
<th>Adjacency list</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>空間需求</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><strong>O(n+e)</strong></td>
</tr>
<tr class="even">
<td>表示頂點數多邊數少之圖</td>
<td>需要<span class="math inline">\(O(n^2)\)</span>且為<strong>稀疏矩陣</strong>，不適合</td>
<td>適合</td>
</tr>
<tr class="odd">
<td>表示邊數多（e=O<span class="math inline">\((n^2)\)</span>）之圖</td>
<td>適合</td>
<td>需要<span class="math inline">\(O(n+O(n^2))\)</span>，不適合</td>
</tr>
<tr class="even">
<td>判斷兩頂點間是否存在邊</td>
<td>時間複雜度 O(1)，適合</td>
<td>時間複雜度 O(e)，不適合</td>
</tr>
<tr class="odd">
<td>求圖上的邊數（判斷連通...）</td>
<td>時間複雜度 <span class="math inline">\(O(n^2)\)</span>，不適合</td>
<td>時間複雜度 O(n+e)，適合</td>
</tr>
</tbody>
</table>
<h2 id="adjacency-multilist相鄰多元串列">Adjacency multilist（相鄰多元串列）</h2>
<p>欲表示圖 G = (V,E), |V| = n, |E| = e</p>
<ul>
<li>每一條<strong>邊</strong>以一個<strong>節點</strong>表示</li>
</ul>
<figure>
<img src="\willywangkaa\images\1543649110616.png" alt="1543649110616" /><figcaption aria-hidden="true">1543649110616</figcaption>
</figure>
<ul>
<li>指標陣列（vertex[1...n] : pointer）
<ul>
<li>Vertex[i] <strong>指向第一個包含</strong> <span class="math inline">\(V_i\)</span> <strong>的邊節點</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1543649696312.png" alt="1543649696312" /><figcaption aria-hidden="true">1543649696312</figcaption>
</figure>
<ul>
<li>空間複雜度：O(n+e)</li>
</ul>
<h2 id="index-array">Index array</h2>
<p>欲表示圖 G = (V,E), |V| = n, |E| = e</p>
<ul>
<li><p>一個一維陣列（Array[1... 2×e]）<strong>紀錄所有點之相鄰頂點編號</strong></p></li>
<li><p>一個一維陣列為「Index」（Index[1...n]）表示頂點 i 在 Array 中紀錄的<strong>起始位置</strong></p></li>
</ul>
<figure>
<img src="\willywangkaa\images\1543650099846.png" alt="1543650099846" /><figcaption aria-hidden="true">1543650099846</figcaption>
</figure>
<ul>
<li>空間複雜度：O(n+e)</li>
</ul>
<h2 id="incident-matrix-離散數學">Incident matrix （離散數學）</h2>
<p>欲表示圖 G = (V,E), |V| = n, |E| = e</p>
<ul>
<li>一個二維陣列（A[1...n, 1...e] : boolean）
<ul>
<li>若圖中存在邊 <span class="math inline">\(e_k\)</span>=(i,j)，則 A[i, <span class="math inline">\(e_k\)</span>]=A[j, <span class="math inline">\(e_k\)</span>]=1，其餘為 0</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1543650560718.png" alt="1543650560718" /><figcaption aria-hidden="true">1543650560718</figcaption>
</figure>
<h1 id="圖的追蹤">圖的追蹤</h1>
<p>G = (V,E), |V| = n, |E| = e</p>
<ul>
<li>比較表
<ul>
<li>在演算法書籍中，使用「Adjacency list」作深度追蹤與廣度追蹤時，<strong>時間複雜度分析考慮了 visit[1...n] 陣列初值的設定</strong>，所以為 O(n+e)，而資料結構書籍則無考慮</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th></th>
<th>DFS</th>
<th>BFS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>佐結構</td>
<td>Stack</td>
<td>Queue</td>
</tr>
<tr class="even">
<td>Adjacency Matrix（時間複雜度）</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
<tr class="odd">
<td>Adjacency List（時間複雜度）[DS版]</td>
<td>O(e)</td>
<td>O(e)</td>
</tr>
<tr class="even">
<td>Adjacency List（時間複雜度）[Algorithm版]</td>
<td><strong>O(n+e)</strong></td>
<td><strong>O(n+e)</strong></td>
</tr>
</tbody>
</table>
<h2 id="ds-書籍版本">DS 書籍版本</h2>
<h3 id="depth-first-search">Depth first search</h3>
<blockquote>
<p>以無項圖為主，此演算法使用「相鄰矩陣」</p>
</blockquote>
<blockquote>
<p>深度優先追蹤法以「Stack」實作，所以使用遞迴法實現</p>
</blockquote>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Global variable:</span></span><br><span class="line"><span class="comment">//                    G: adjacency matrix</span></span><br><span class="line"><span class="comment">//          visit[1..n]: 頂點搜尋紀錄，且全部元素已經重設為 false</span></span><br><span class="line"><span class="comment">// Parameter:</span></span><br><span class="line"><span class="comment">//          v: 起始頂點</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(v)</span> </span>&#123;</span><br><span class="line">    visit[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt;= n; w++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[v,w])</span><br><span class="line">            <span class="keyword">if</span>(!visit[w])</span><br><span class="line">                <span class="built_in">DFS</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Depth first search 的路線並不唯一</li>
<li>通常頂點編號小者優先走訪，考試時路線才會唯一</li>
</ul>
</blockquote>
<h3 id="breath-first-search">Breath first search</h3>
<blockquote>
<p>廣度優先追蹤以「Queue」實作</p>
</blockquote>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Global variable:</span></span><br><span class="line"><span class="comment">//                    G: adjacency matrix</span></span><br><span class="line"><span class="comment">//          visit[1..n]: 頂點搜尋紀錄，且全部元素已經重設為 false</span></span><br><span class="line"><span class="comment">// Parameter:</span></span><br><span class="line"><span class="comment">//          v: 起始頂點</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(v)</span> </span>&#123;</span><br><span class="line">    visit[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">CreateQueue</span>(q);</span><br><span class="line">    <span class="built_in">Enqueue</span>(q, v);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        u = <span class="built_in">Dequeue</span>(q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt;= n; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(G[u,w])</span><br><span class="line">                <span class="keyword">if</span>(!visit[w])&#123;</span><br><span class="line">                    visit[w] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">Enqueue</span>(q, w);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="\willywangkaa\images\1543651440091.png" alt="1543651440091" /><figcaption aria-hidden="true">1543651440091</figcaption>
</figure>
<blockquote>
<p>無向圖二元樹</p>
<figure>
<img src="\willywangkaa\images\1543651513624.png" alt="1543651513624" /><figcaption aria-hidden="true">1543651513624</figcaption>
</figure>
<ul>
<li>(見上圖) 在圖中執行 DFS(1) 類似在二元樹中作「前序追蹤」</li>
<li>(見上圖) 在圖中執行 BFS(1) 類似在二元樹中作「層序追蹤」</li>
</ul>
</blockquote>
<p>Example （實現「Level-order」追蹤演算法）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v: 根節點</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Level_order</span><span class="params">(v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    <span class="built_in">Createqueue</span>(q);</span><br><span class="line">    <span class="built_in">Enqueue</span>(q, v);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        u = <span class="built_in">Dequeue</span>(q);</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;lchild != null) &#123;</span><br><span class="line">            <span class="built_in">print</span>(u-&gt;lchild);</span><br><span class="line">            <span class="built_in">Enqueue</span>(q, u-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;rchild != null) &#123;</span><br><span class="line">            <span class="built_in">print</span>(u-&gt;rchild);</span><br><span class="line">            <span class="built_in">Enqueue</span>(q, u-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="algorithm-書籍版本">Algorithm 書籍版本</h2>
<h3 id="depth-first-search-1">Depth first search</h3>
<ul>
<li>Algorithm
<ul>
<li>u.Color
<ul>
<li>White：尚未拜訪</li>
<li>Gray：已拜訪，但尚未拜訪完相鄰的頂點</li>
<li>Black：拜訪完相鄰的頂點</li>
</ul></li>
<li>u.d
<ul>
<li>從起點拜訪 u 點的時間</li>
</ul></li>
<li>u.f
<ul>
<li>u 點拜訪完所有相鄰頂點的時間</li>
</ul></li>
<li>u.parent
<ul>
<li>在 DFS 拜訪樹中，為 u 的父節點</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// time: Global variable 用來記錄追蹤的路徑</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS_visit</span><span class="params">(G, u)</span> </span>&#123;</span><br><span class="line">    time++;</span><br><span class="line">    u.color  = gray;</span><br><span class="line">    u.d      = time;</span><br><span class="line">    <span class="keyword">for</span> each w in G.adj[u] &#123;</span><br><span class="line">        <span class="keyword">if</span>(w==white) &#123;</span><br><span class="line">            w.parent = u;</span><br><span class="line">            <span class="built_in">DFS_visit</span>(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    time++;</span><br><span class="line">    u.color = black;</span><br><span class="line">    u.f     = time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(G)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// O(|V|)</span></span><br><span class="line">    <span class="comment">// Initialize</span></span><br><span class="line">    <span class="keyword">for</span> each u in G.V &#123;</span><br><span class="line">        u.color  = white;</span><br><span class="line">        u.parent = null;</span><br><span class="line">    &#125;</span><br><span class="line">    time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> each u in G.V &#123;</span><br><span class="line">        <span class="keyword">if</span>(u.color==white) &#123;</span><br><span class="line">            <span class="built_in">DFS_visit</span>(G, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有向圖">有向圖</h4>
<p>使用 DFS 追蹤時，會將圖分為四種邊（詳見演算法文章中的圖論）</p>
<ol type="1">
<li>Tree edge：DFS 拜訪經過的邊</li>
<li>Back edge：指向祖先的邊</li>
<li>Forward edge：指向後代的邊</li>
<li>Cross edge：<strong>跨不同子樹的邊</strong></li>
</ol>
<blockquote>
<p>在無向圖上，使用 DFS 追蹤只會將圖分成</p>
<ol type="1">
<li>Tree edge</li>
<li>Back edge</li>
</ol>
</blockquote>
<h3 id="breath-first-search-1">Breath first search</h3>
<ul>
<li>Algorithm
<ul>
<li>u.Color
<ul>
<li>White：尚未拜訪</li>
<li>Gray：已拜訪，但尚未拜訪完相鄰的頂點</li>
<li>Black：拜訪完相鄰的頂點</li>
</ul></li>
<li>u.d
<ul>
<li>從起點到 u 點路徑的邊數（深度）</li>
</ul></li>
<li>u.parent
<ul>
<li>在 BFS 拜訪樹中，為 u 的父節點</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// G: adjacency list</span></span><br><span class="line"><span class="comment">// s: 起始頂點</span></span><br><span class="line"><span class="built_in">BFS</span>(G, s) &#123;</span><br><span class="line">    <span class="comment">// Time complexity: O(|v|)</span></span><br><span class="line">    <span class="comment">// Initialize</span></span><br><span class="line">    <span class="comment">// G.V: Vertex set for G</span></span><br><span class="line">    <span class="keyword">for</span> each u in G.V-&#123;s&#125; &#123;</span><br><span class="line">        u.color  = white;</span><br><span class="line">        u.d      = oo;</span><br><span class="line">        u.parent = null;</span><br><span class="line">    &#125;</span><br><span class="line">    s.color  = gray;</span><br><span class="line">    s.d      = <span class="number">0</span>;</span><br><span class="line">    s.parent = null;</span><br><span class="line">    <span class="built_in">CreateQueue</span>(q);</span><br><span class="line">    <span class="built_in">Enqueue</span>(q, s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        u = <span class="built_in">Dequeue</span>(q);                    <span class="comment">// Line A</span></span><br><span class="line">        <span class="comment">// G.adj[u]: Adjacency list for G</span></span><br><span class="line">        <span class="keyword">for</span> each w in G.adj[u] &#123;           <span class="comment">// ↑</span></span><br><span class="line">            <span class="keyword">if</span>(w.color==<span class="keyword">while</span>) &#123;           <span class="comment">// ︳ Loop A</span></span><br><span class="line">                w.color  = gray;           <span class="comment">// ︳</span></span><br><span class="line">                w.d      = u.d+<span class="number">1</span>;          <span class="comment">// ︳</span></span><br><span class="line">                w.parent = u;              <span class="comment">// ︳</span></span><br><span class="line">                <span class="built_in">Enqueue</span>(q, w);             <span class="comment">// ︳</span></span><br><span class="line">            &#125;                              <span class="comment">// ↓</span></span><br><span class="line">        &#125;</span><br><span class="line">        u.color = black;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>Line A：作「Dequeue」需要 O(1)，共有 |V| 個頂點
<ul>
<li>O(1)×|V| = O(|V|)</li>
</ul></li>
<li>Loop A ：找到每個頂點的相鄰頂點
<ul>
<li>O(2|E|)</li>
</ul></li>
<li>總時間複雜度
<ul>
<li>O(|V|+|E|)</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>無向圖若邊上無權重</strong>，求某起點到各頂點之<strong>「最短路徑」</strong>可以使用<strong>廣度優先追蹤之生成樹</strong>即可</p>
</blockquote>
<h2 id="追蹤的應用">追蹤的應用</h2>
<p>Example</p>
<p><strong>無向圖 G</strong>，判斷是否有<strong>連通</strong>？</p>
<ul>
<li><p>Algorithm</p>
<ol type="1">
<li><p>使用 DFS（[DS 版]） 或 BFS 追蹤 G</p></li>
<li><p>若 visit 陣列中<strong>有頂點尚未被拜訪</strong>即為<strong>不連通</strong></p></li>
</ol></li>
<li><p>Time complexity</p>
<ul>
<li>相鄰矩陣：<span class="math inline">\(O(|V|^2) + O(|V|) = O(|V|^2)\)</span></li>
<li>相鄰串列：O(|V|+|E|) + O(V) = O(|V|+|E|)</li>
</ul></li>
</ul>
<p>Example</p>
<p><strong>有向圖 G</strong>，判斷是否有<strong>環路</strong>？</p>
<ul>
<li>Algorithm
<ul>
<li>用 DFS，若存在「Back edge」即存在環路</li>
</ul></li>
<li>Time complexity
<ul>
<li>相鄰矩陣：<span class="math inline">\(O(|V|^2)\)</span></li>
<li>相鄰串列：O(|V|+|E|) （當圖上存在「Hamilton cycle」，為最好的情況，因為只要搜尋過所有點即可找到）</li>
</ul></li>
</ul>
<p><strong>Example</strong></p>
<p><strong>無向圖 G</strong>，判斷是否有環路？（找「Back edge」即可）</p>
<blockquote>
<p><strong>如何判斷「Back edge」？</strong></p>
<ul>
<li>修改程式（因為無項圖的邊可來回，<strong>為了防止同一邊追蹤兩次</strong>須加上 <code>w.parent != u</code>）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="keyword">for</span> each w in G.adj[u] &#123;</span><br><span class="line">    <span class="keyword">if</span>(w.color==gray &amp;&amp; w.parent!=u) <span class="comment">// 為「Back edge」</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="spanning-tree">Spanning tree</h1>
<blockquote>
<p>針對無向圖</p>
</blockquote>
<ul>
<li>若 G 為非連通圖，則無「Spanning tree」</li>
<li>若 G 為連通圖，則「Spanning tree」≧ 1</li>
</ul>
<p><strong>Example （True or False）</strong></p>
<p>一個連通無向圖 G，則 G 上任意的「Spanning tree」，必定包含 ≧ 1 條「共同的邊」？</p>
<p><strong>False（見下圖）</strong></p>
<figure>
<img src="\willywangkaa\images\1543652365094.png" alt="1543652365094" /><figcaption aria-hidden="true">1543652365094</figcaption>
</figure>
<h2 id="minimum-spanning-tree">Minimum spanning tree</h2>
<ul>
<li><p>若圖中有多條邊具有相同的值，則「Minimum spanning tree」≧ 1</p></li>
<li><p>若每條邊權重皆不同則「Minimum spanning tree」唯一</p></li>
<li><p>應用</p>
<ul>
<li>電路布局成本最小化</li>
<li>連結 n 城市之最少建設成本</li>
</ul></li>
</ul>
<h3 id="kruskals-algorithm-algorithm-書上版本">Kruskal's algorithm [Algorithm 書上版本]</h3>
<p>G = (V,E), |V| = n, |E| = e</p>
<ul>
<li>最多作 |E| 回合，而每一回合主要有兩個工作
<ol type="1">
<li>挑選最小成本的邊 (u, v)
<ul>
<li>邊的權重集合若使用「Heap」維護，則時間複雜度則為「Delete min」的成本（O(log |E|)）</li>
</ul></li>
<li>判斷邊 (u, v) 加入到 s 之中是否形成環路（O(1)）
<ul>
<li>使用一個「Disjoint set」維護「Minimum spanning tree」上的點，在加入新的邊時，使用邊上兩頂點在「Disjoint set」中尋找（<code>Find(u)==Find(v)?</code>），如果兩點都存在於<strong>同一個集合</strong>中，則形成環路，不加入該邊，反之將該邊加入（<code>Union(u,v)</code>）「Minimum spanning tree」中</li>
<li>若「Disjoint set」採用「Union by height」與「Find with path compression」，則 <code>Union(u,v)</code> <code>Find(u)</code> <code>Find(v)</code> 需要的時間複雜度為 O(1)</li>
</ul></li>
</ol></li>
<li>Time complexity
<ul>
<li><strong>O( |E|×log|E|)</strong></li>
</ul></li>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Mst_kruskal</span>(G, W) &#123;</span><br><span class="line">    S = ∅; <span class="comment">// MST邊集合</span></span><br><span class="line">    D = ∅; <span class="comment">// Disjoint set for vertex</span></span><br><span class="line">    <span class="keyword">for</span> each vertex x in G.V &#123;           <span class="comment">//  ↑</span></span><br><span class="line">        D.<span class="built_in">Make_set</span>(x);                   <span class="comment">//  | O(|V|)</span></span><br><span class="line">    &#125;                                    <span class="comment">//  ↓</span></span><br><span class="line">    <span class="built_in">Sort</span>(G.E); <span class="comment">// 針對權重由小到大作排序           O(|E|log|E|)</span></span><br><span class="line">    <span class="comment">// 由小到大取邊</span></span><br><span class="line">    <span class="function"><span class="keyword">for</span> <span class="title">each</span> <span class="params">(u,v)</span> in G.E </span>&#123;              <span class="comment">//  ↑</span></span><br><span class="line">        <span class="keyword">if</span>(D.<span class="built_in">Find</span>(u)!=<span class="built_in">Find</span>(v)) &#123;         <span class="comment">//  |</span></span><br><span class="line">            S = S ∪ &#123;(u,v)&#125;;             <span class="comment">//  | O(|E|)</span></span><br><span class="line">            D.<span class="built_in">Union</span>(u,v);                <span class="comment">//  |</span></span><br><span class="line">        &#125;                                <span class="comment">//  |</span></span><br><span class="line">    &#125;                                    <span class="comment">//  ↓</span></span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>O(|V|) + O(|E|log|E|)+O(|E|) = O(|E|log|E|)</li>
<li>因為 |E| ≦ |V|×|V|，所以 <strong>O(|E|log|E|) = O(|E|log|</strong><span class="math inline">\(V^2\)</span><strong>|) = O(|E|log|V|)</strong></li>
</ul></li>
</ul>
<blockquote>
<p>Example（102 交通大學資料結構與演算法）</p>
<ul>
<li>The running time of Kruskal's algorithm for a connected undirected weighted graph G = (V, E) is ＿＿＿.</li>
</ul>
<p>O(∣E∣log∣V∣)</p>
<ul>
<li>Suppose that all edge weights in a graph G are integers <strong>in the range from 1 to ∣V∣</strong>. How fast can you make Kruskal's algorithm run?</li>
</ul>
<p>O(∣E∣ α(∣V∣))，α 為「<a href="https://en.wikipedia.org/wiki/Ackermann_function">Ackermann function</a>」反函數</p>
</blockquote>
<h3 id="prims-algorithm-ds-書上版本">Prim's algorithm [DS 書上版本]</h3>
<ul>
<li>Time complexity
<ul>
<li>O(||)</li>
</ul></li>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// G: graph</span></span><br><span class="line"><span class="comment">// W: weight of G.E</span></span><br><span class="line"><span class="comment">// r: 起點</span></span><br><span class="line"><span class="built_in">Mst_prim</span>(G, W, r) &#123;</span><br><span class="line">    <span class="keyword">for</span> each u in G.V &#123;             <span class="comment">//   ↑</span></span><br><span class="line">        u.key = ∞;                  <span class="comment">//   ︳  Initialize</span></span><br><span class="line">        u.parent = null;            <span class="comment">//   ︳  O(|v|)</span></span><br><span class="line">    &#125;                               <span class="comment">//   ↓</span></span><br><span class="line"></span><br><span class="line">    r.key = <span class="number">0</span>;</span><br><span class="line">    q = <span class="built_in">Build_priorityqueue</span>(G.V);   <span class="comment">// 可以使用「Binary heap」或「Fib. heap」，</span></span><br><span class="line">                                    <span class="comment">// O(|V|)</span></span><br><span class="line">    <span class="keyword">while</span>(q != ∅) &#123;</span><br><span class="line">        u = <span class="built_in">Extract_min</span>(q);         <span class="comment">//   ↑  LineA:O(log|V|)</span></span><br><span class="line">        <span class="keyword">for</span> each v in G.adj[u] &#123;    <span class="comment">//   ︳</span></span><br><span class="line">            <span class="keyword">if</span>(v.key &gt; W[u,v]) &#123;    <span class="comment">//   ︳ LoopA</span></span><br><span class="line">                v.parient = u;      <span class="comment">//   ︳</span></span><br><span class="line">                v.key     = W[u,v]; <span class="comment">//   ︳ LineB:不斷更新「Prioryty queue」的鍵值</span></span><br><span class="line">            &#125;                       <span class="comment">//   ︳</span></span><br><span class="line">        &#125;                           <span class="comment">//   ︳</span></span><br><span class="line">    &#125;                               <span class="comment">//   ↓</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Time complexity （用「Binary heap」作為「Priority queue」）</p>
<ol type="1">
<li><p>初值建立 O(|V|)</p></li>
<li><p>建立「Priority queue」 O(|V|)</p></li>
<li><p>Line A：<code>Extract_min(q)</code> 作一次需要 O(log|V|)</p>
<ul>
<li>共作 |V| 次，需要 <strong>O(|V|log|V|)</strong></li>
</ul></li>
<li><p>Loop A：總共會檢視 2 ×|E| 個頂點</p>
<ul>
<li><p>Line B：<code>v.key = W[u,v]</code> 相當於是作「Decrease key of node in heap」</p></li>
<li><p>因為為「Binary heap」，所以需要 O(log|V|) 的時間複雜度</p></li>
<li><p>迴圈總共的時間複雜度為 <strong>O(|E|log|V|)</strong></p></li>
</ul></li>
</ol></li>
</ul>
<p>總共需要 O(|V|) + O(|V|) + <strong>O(|V|log|V|) + O(|E|log|V|)</strong> ，<strong>因為 |E|≧ |V|-1 ，所以時間複雜度為 O(|E|log|V|)</strong></p>
<blockquote>
<ul>
<li>與「Kruskal」的複雜度一致</li>
<li>可以使用「Fibonacci heap」再進行加速</li>
</ul>
</blockquote>
<figure>
<img src="\willywangkaa\images\1543730410752.png" alt="1543730410752" /><figcaption aria-hidden="true">1543730410752</figcaption>
</figure>
<ul>
<li><p>Time complexity （用「Fibonacci heap」作為「Priority queue」）</p>
<ol type="1">
<li><p>初值建立 O(|V|)</p></li>
<li><p>建立「Priority queue」 O(|V|)</p></li>
<li><p>Line A：<code>Extract_min(q)</code> 作一次需要 O(log|V|)</p>
<ul>
<li>共作 |V| 次，需要 **O(|V|log|V|)</li>
</ul></li>
<li><p>Loop A：總共會檢視 2 ×|E| 個頂點</p>
<ul>
<li><p>Line B：<code>v.key = W[u,v]</code> 相當於是作「Decrease key of node in heap」</p></li>
<li><p>因為為「Fibonacci heap」，所以需要 O(1) 的時間複雜度</p></li>
<li><p>迴圈總共的時間複雜度為 O(|E|)</p></li>
</ul></li>
</ol></li>
</ul>
<p>總共需要 O(|V|) + O(|V|) + O(|V|log|V|) + <strong>O(|E|)</strong> ，<strong>因為 |E|≧ |V|-1 ，所以時間複雜度為 O(|V|log|V|+|E|)</strong></p>
<h3 id="sollins-algorithm">Sollin's algorithm</h3>
<p>步驟：（開始時先將每個頂點視為獨立的數根）</p>
<ol type="1">
<li>針對每棵樹，各自挑出「Minimum cost tree edge」</li>
<li>刪除重複挑出的邊</li>
<li>重複第一步與第二步直到成為「最小生成樹」</li>
</ol>
<blockquote>
<ul>
<li>在循環迭代中
<ul>
<li>每棵樹都會合併成一棵較大的子樹
<ul>
<li>每次<strong>會使子樹的數量至少減少一半</strong>
<ul>
<li>所以循環迭代的總次數為O( log|V| )</li>
</ul></li>
</ul></li>
</ul></li>
<li>第一步會檢查所有邊以<strong>更新每個連通分量的最小弧</strong>
<ul>
<li>O( |E| )</li>
</ul></li>
<li><strong>時間複雜度</strong>
<ul>
<li><strong>O( log|V|×|E| )</strong></li>
</ul></li>
</ul>
</blockquote>
<h1 id="shortest-path-problem">Shortest path problem</h1>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 46%" />
<col style="width: 26%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Dijkstra's algorithm</th>
<th>Bellman-ford algorithm</th>
<th>Folyed-warshall algorihm</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>欲解問題</td>
<td>Single source</td>
<td>Single source</td>
<td>All pair shortest</td>
</tr>
<tr class="even">
<td>策略</td>
<td>Greedy</td>
<td>Dynamic programming</td>
<td>Dynamic programming</td>
</tr>
<tr class="odd">
<td>允許負邊？</td>
<td>NO</td>
<td><strong>YES</strong></td>
<td><strong>YES</strong></td>
</tr>
<tr class="even">
<td>允許負環？</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr class="odd">
<td>時間複雜度</td>
<td>Adjacency matrix: O(<span class="math inline">\(V^2\)</span>)</td>
<td>Adjacency matrix: O(<span class="math inline">\(V^3\)</span>)</td>
<td>O( <span class="math inline">\(V^3\)</span> )</td>
</tr>
<tr class="even">
<td></td>
<td>Adjacency list<br />Heap：O(|E|log|V|)<br />Fib. heap：O(|V|log|V|+|E|)</td>
<td>Adjacency list<br />O(|V|×|E|)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="dijkstras-algorithm-ds-書上版本">Dijkstra's algorithm [DS 書上版本]</h2>
<p>適用於有向圖或無向圖皆可以</p>
<p>Data structure</p>
<ul>
<li>Cost matrix：為一 n × n 的矩陣，n = |V|</li>
</ul>
<p><span class="math inline">\(cost[i, j] = \left\{\begin{matrix} 邊成本值 &amp; ,if \;＜i,j＞ \in E \\ 0 &amp; ,if \; i=j \\ \infty &amp; ,if \;＜i,j＞ \notin E\end{matrix}\right.\)</span></p>
<ul>
<li>S[1...n]：Boolean</li>
</ul>
<p><span class="math inline">\(S[i] = \left\{\begin{matrix}False &amp; , 起點到 \;i \;點的最短距離尚未決定 \\True &amp; , 起點到 \;i \;點的最短距離已決定\end{matrix}\right.\)</span></p>
<ul>
<li>Dist[1...n]：Integer</li>
</ul>
<p>Dist[i] ： 起點到 i 點的最短路徑長（初值為「Cost matrix」起點到該點值）</p>
<ul>
<li>概念</li>
</ul>
<figure>
<img src="\willywangkaa\images\1543730847726.png" alt="1543730847726" /><figcaption aria-hidden="true">1543730847726</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Dist[i]&gt;Dist[u]+Cost[u,i]) &#123;</span><br><span class="line">    Dist[i] = Dist[u] + Cost[u,i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>圖中不可有負邊，否則無法求初正確的最短路徑</p>
<figure>
<img src="\willywangkaa\images\1543731055463.png" alt="1543731055463" /><figcaption aria-hidden="true">1543731055463</figcaption>
</figure>
<p>以（1）作為起點，使用「Dijkstra's algorithm」則 <code>Dist[2] = 5</code>，但其實應為 <code>Dist[2] = 2</code></p>
<p>不得對所有邊以加權種方式使得負邊為正，因為若有一路徑經過點越多，則該路徑權重也倍數成長，如下：</p>
<figure>
<img src="\willywangkaa\images\1543731311974.png" alt="1543731311974" /><figcaption aria-hidden="true">1543731311974</figcaption>
</figure>
<p>在路徑＜1,2＞路徑上只有增加權重 6 ，但是在路徑＜1,3,2＞上路徑增加權重為 12</p>
</blockquote>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\1543736203059.png" alt="1543736203059" /><figcaption aria-hidden="true">1543736203059</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s: 起點</span></span><br><span class="line"><span class="built_in">Initialize</span>(G, s) &#123;              <span class="comment">//  ↑</span></span><br><span class="line">    <span class="keyword">for</span> each vertex v in G.V &#123;  <span class="comment">//  ︳</span></span><br><span class="line">        v.d = ∞;                <span class="comment">//  ︳</span></span><br><span class="line">        v.parent = null;        <span class="comment">//  ︳  O(|V|)</span></span><br><span class="line">    &#125;                           <span class="comment">//  ︳</span></span><br><span class="line">    s.d = <span class="number">0</span>;                    <span class="comment">//  ︳</span></span><br><span class="line">&#125;                               <span class="comment">//  ↓</span></span><br><span class="line"><span class="built_in">Relax</span>(u,v,W) &#123;</span><br><span class="line">    <span class="keyword">if</span>(v.d &gt; u.d+W[u,v]) &#123;</span><br><span class="line">        v.d = u.d + w[u,v];   <span class="comment">// 不斷更新「Fib. heap」的鍵值:O(1)</span></span><br><span class="line">        v.parent = u;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// W[]: 邊權重集合</span></span><br><span class="line"><span class="built_in">Dijkstra</span>(G, W, x) &#123;</span><br><span class="line">    <span class="built_in">Initialize</span>(G, x);</span><br><span class="line">    S = ∅; <span class="comment">// 已確定為最短路徑之點集合</span></span><br><span class="line">    <span class="comment">// 以點的d值建立「Priority queue」（Fib. heap）: O(|V|)</span></span><br><span class="line">    q = <span class="built_in">Build_priorityqueue</span>(G.V); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q != ∅) &#123;</span><br><span class="line">        u = <span class="built_in">extract_min</span>(q);              <span class="comment">// O(log|V|)×|V| = O(|V|log|V|)</span></span><br><span class="line">        S = S ∪ &#123;(u)&#125;;</span><br><span class="line">        <span class="keyword">for</span> each vertex v in G.adj[u] &#123;  <span class="comment">//  ↑</span></span><br><span class="line">            <span class="built_in">Relax</span>(u, v, W);              <span class="comment">//  ︳O(|E|)</span></span><br><span class="line">        &#125;                                <span class="comment">//  ↓</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>Binary heap：O(|V|) + O(|V|) + O(|V|log|V|) + <strong>O(|E|log|V|)</strong> = <strong>O(|E|log|V|)</strong></li>
<li>Fibonacci heap：O(|V|) + O(|V|) + O(|V|log|V|) + <strong>O(|E|)</strong> = <strong>O(|V|log|V|+|E|)</strong>
<ul>
<li>等同於「Prim's algorithm」</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<ol type="1">
<li>與「Prim's algorithm」的時間複雜度相同</li>
<li>「Prim's algorithm」與「Dijkstra's algorithm」都採用「廣度優先搜尋法」</li>
</ol>
</blockquote>
<h2 id="bellman-ford-algorithm">Bellman-Ford algorithm</h2>
<p>Data structure</p>
<ul>
<li><span class="math inline">\(Dist^k[1...n]\)</span>：起點到 i 點的最短路徑長且<strong>經過邊數 ≦ k</strong>
<ul>
<li><span class="math inline">\(Dist^1\)</span> ：初值，「Cost matrix」之起點到各點的權重值</li>
<li>依序求出 <span class="math inline">\(Dist^2、Dist^3、\ldots、Dist^{n-1}\)</span>，且 <span class="math inline">\(Dist^{n-1}\)</span> 即為最後結果</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1543736615438.png" alt="1543736615438" /><figcaption aria-hidden="true">1543736615438</figcaption>
</figure>
<p><span class="math inline">\(Dist^k[i] = min_{\forall u}｛Dist^{k-1}[i], min｛Dist^{k-1}[u]+Cost[u, i]｝｝\)</span>，<strong>u 為有邊指向 i 的頂點</strong></p>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\1543737721578.png" alt="1543737721578" /><figcaption aria-hidden="true">1543737721578</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cost: cost matrix</span></span><br><span class="line"><span class="comment">// n:    |V|</span></span><br><span class="line"><span class="comment">// s:    起點</span></span><br><span class="line"><span class="built_in">BellmanFord</span>(Cost, n, s) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        Dist[i] = Cost[s,i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= n<span class="number">-1</span>; k++) &#123;                   <span class="comment">//       ↑</span></span><br><span class="line">        tmp_Dist[<span class="number">1.</span>..n];                              <span class="comment">//       ︳</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;                 <span class="comment">//  ↑    ︳</span></span><br><span class="line">            <span class="function"><span class="keyword">for</span> each u that has <span class="title">edge</span><span class="params">(u,i)</span> </span>&#123;           <span class="comment">//  ︳   O(|V|)</span></span><br><span class="line">                <span class="keyword">if</span>(Dist[i]&gt;Dist[u]+Cost[u,i]) &#123;       <span class="comment">//  ︳   ︳</span></span><br><span class="line">                    tmp_Dist[i] = Dist[u]+Cost[u,i];  <span class="comment">//  ︳   ︳</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// O(|E|) </span></span><br><span class="line">                    tmp_Dist[i] = Dist[i];            <span class="comment">//  ︳   ︳</span></span><br><span class="line">                &#125;                                     <span class="comment">//  ︳   ︳</span></span><br><span class="line">            &#125;                                         <span class="comment">//  ↓    ︳</span></span><br><span class="line">        &#125;                                             <span class="comment">//       ↓</span></span><br><span class="line">        <span class="built_in">copy</span>(Dist[<span class="number">1.</span>..n], tmp_Dist[<span class="number">1.</span>.n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>採用「Adjacency list」時間複雜度為 O(|V|×|E|) = O(|V|×|<span class="math inline">\(V^2\)</span>|)</p>
</blockquote>
<p>Example</p>
<p>如何利用「Bellman Ford algorithm」判斷圖上是否有負環？</p>
<ol type="1">
<li>先執行完一次正常的「Bellman Ford」（求到 <span class="math inline">\(Dist^{n-1}\)</span> 為止）</li>
<li>再求 <span class="math inline">\(Dist^n\)</span>，若有值比 <span class="math inline">\(Dist^{n-1}\)</span> 還小，則必存在負環</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    tmp_Dist[<span class="number">1.</span>..n];</span><br><span class="line">    <span class="function"><span class="keyword">for</span> each u that has <span class="title">edge</span><span class="params">(u,i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dist[i] &gt; Dist[u]+Cost[u,i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;存在負環&quot;</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            tmp_Dist[i] = Dist[u]+Cost[u,i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp_Dist[i] = Dist[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(Dist[<span class="number">1.</span>..n], tmp_Dist[<span class="number">1.</span>.n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example（102交通大學資料結構與演算法 - <strong>差分約束系統</strong>（System of Difference Constraints））</p>
<ul>
<li>Consider the problem of finding a vector <span class="math inline">\((x_1, x_2, x_3, x_4, x_5)\)</span> satisfying the following constrains such that <span class="math inline">\(x_1+x_2+x_3+x_4+x_5\)</span> is maximized, where <span class="math inline">\(x_i \leq 0\)</span> for i = 1, ..., 5. What are <strong>the maximum value</strong> and the corresponding vector?</li>
</ul>
<p><span class="math inline">\(x_1 - x_2 \leq 1 \\x_1 - x_5 \leq -1 \\ x_2 - x_5 \leq 1 \\ x_3 - x_1 \leq 15 \\ x_4 - x_1 \leq 4 \\ x_4 - x_3 \leq -1 \\ x_5 - x_3 \leq -3 \\ x_5 - x_4 \leq 0\)</span></p>
<p><strong>在此條件下求最大解</strong>可以轉換成「Single source all shortest path problem」</p>
<ul>
<li>觀察 <span class="math inline">\(x_j - x_i \leq b_k\)</span>
<ul>
<li>圖論中， d[v] ≦ d[u]+w[u,v]
<ul>
<li>d[v]：為 s 至 v 的最短路徑長</li>
<li>d[u]：為 s 至 u 的最短路徑長</li>
<li>w[u,v]：邊(u,v) 的權重</li>
<li>所以此式意旨「s 至 v 的最短路徑長」≦「s 至 u 的最短路徑長」+「邊(u,v) 的權重」</li>
</ul></li>
<li>將 <span class="math inline">\(x_j - x_i \leq b_k\)</span> 視為 d[v] - d[u] ≦ w[u,v]
<ul>
<li>其中 s 為額外增加的節點</li>
</ul></li>
</ul></li>
<li>如果 s 點無法到達 <span class="math inline">\(x_i\)</span>
<ul>
<li>則其路徑為無窮大</li>
<li>因為不斷作「Relaxation」會使得路徑不斷變小，直到滿足所有條件時其為最大可能</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1549622277405.png" alt="1549622277405" /><figcaption aria-hidden="true">1549622277405</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1549627232982.png" alt="1549627232982" /><figcaption aria-hidden="true">1549627232982</figcaption>
</figure>
<ul>
<li>對 s 頂點使用「Bellman-Ford algorithm」
<ul>
<li>解出 <span class="math inline">\((x_1, x_2, x_3, x_4, x_5) = (-4, -2, 0, -1, -3)\)</span></li>
<li>總和：-10</li>
</ul></li>
</ul>
<blockquote>
<p><del><strong>在此條件下求最大解</strong>可以轉換成「Single source all <strong>longest path problem</strong>」</del></p>
<ul>
<li>觀察 <span class="math inline">\(-(x_j - x_i) \geq -b_k\)</span>
<ul>
<li>圖論中， d[v] ≧ d[u]+w[u,v]
<ul>
<li>d[v]：為 s 至 v 的最長路徑長</li>
<li>d[u]：為 s 至 u 的最長路徑長</li>
<li>w[u,v]：邊(u,v) 的權重</li>
<li>所以此式意旨「s 至 v 的最長路徑長」≧「s 至 u 的最長路徑長」+「邊(u,v) 的權重」</li>
</ul></li>
<li>將 <span class="math inline">\(x_i - x_j \geq -b_k\)</span> 視為 d[v] - d[u] ≧ w[u,v]
<ul>
<li>其中 s 為額外增加的節點</li>
</ul></li>
</ul></li>
<li>如果 s 點無法到達 <span class="math inline">\(x_i\)</span>
<ul>
<li>則其路徑為無窮小</li>
<li>因為不斷作「Relaxation」會使得路徑不斷變大，直到滿足所有條件時其為最小可能</li>
</ul></li>
</ul>
<p><span class="math inline">\(x_2 - x_1 \geq -1 \\x_5 - x_1 \geq 1 \\ x_5 - x_2 \geq -1 \\ x_1 - x_3 \geq -15 \\ x_1 - x_4 \geq -4 \\ x_3 - x_4 \geq 1 \\ x_3 - x_5 \geq 3 \\ x_4 - x_5 \geq 0\)</span></p>
<figure>
<img src="\willywangkaa\images\1549628472201.png" alt="1549628472201" /><figcaption aria-hidden="true">1549628472201</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1549628610514.png" alt="1549628610514" /><figcaption aria-hidden="true">1549628610514</figcaption>
</figure>
<ul>
<li><del>對 s 頂點使用「Bellman-Ford algorithm」（Single source all <strong>longest path</strong>）</del></li>
</ul>
</blockquote>
<h2 id="floyd-warshell-algorithm">Floyd-Warshell algorithm</h2>
<p>假設 G = ＜V, E＞</p>
<p>Data structure</p>
<ul>
<li><span class="math inline">\(A^k\)</span> ：n × n 矩陣，n = |V|
<ul>
<li><span class="math inline">\(A^k[i, j]\)</span>：i 到 j 之最短路徑且<strong>途中經過頂點的編號必須 ≦ k</strong></li>
<li><span class="math inline">\(A^0\)</span>：原始的「Cost matrix」，依序求出 <span class="math inline">\(A^1, A^2, \ldots, A^n\)</span></li>
</ul></li>
</ul>
<p>概念</p>
<p><span class="math inline">\(A^k[i,j]= min｛A^{k-1}[i,j], A^{k-1}[i,k]+A^{k-1}[k,j]｝\)</span>，針對點（k）作討論，如果使用此頂點作為中介點路徑是否可以縮短</p>
<figure>
<img src="\willywangkaa\images\1543738191981.png" alt="1543738191981" /><figcaption aria-hidden="true">1543738191981</figcaption>
</figure>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\1543739868201.png" alt="1543739868201" /><figcaption aria-hidden="true">1543739868201</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cost[1..n, 1..n]: 邊的權重集合</span></span><br><span class="line"><span class="comment">// n: 頂點數</span></span><br><span class="line"><span class="comment">// A[1..n,1..n]: A^k[1..n,1..n]</span></span><br><span class="line"><span class="built_in">FloydWarshell</span>(Cost, n, A) &#123;</span><br><span class="line">    <span class="comment">// Initialization</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">            A[i,j] = Cost[i,j];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求取 A^1, A^2, A^3, ..., A^n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;              <span class="comment">// ↑</span></span><br><span class="line">        tmpA[<span class="number">1.</span>.n,<span class="number">1.</span>.n];                       <span class="comment">// ︳</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)            <span class="comment">// ︳</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)        <span class="comment">//  O(|V|^3)</span></span><br><span class="line">                <span class="keyword">if</span>(A[i,j]&gt;A[i,k]+A[k,j])       <span class="comment">// ︳</span></span><br><span class="line">                    tmpA[i,j] = A[i,k]+A[k,j]; <span class="comment">// ︳</span></span><br><span class="line">        <span class="built_in">copy</span>(tmpA, A);                         <span class="comment">// ︳</span></span><br><span class="line">    &#125;                                          <span class="comment">// ↓</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="johnsons-algorithm">Johnson's algorithm</h2>
<p>All pair shortest path problem for <strong>sparse graph</strong></p>
<blockquote>
<ol type="1">
<li>一個 n 個頂點的<strong>無負邊有向圖</strong>上，可以在每個點上做一次「Dijkstra's algorithm」以求出「All pair shortest path」
<ul>
<li>時間複雜度（All pair shortest path）
<ul>
<li>[DS 版本：鄰接矩陣] |V| × O(<span class="math inline">\(|V|^2\)</span>) = O(<span class="math inline">\(|V|^3\)</span>)</li>
<li>[Algorithm 版本：鄰接串列] |V|×O(|E|log|V|)（Binary heap）；<strong>|V|×O(|V|log|V|+|E|)（Fibonacci heap）</strong></li>
</ul></li>
</ul></li>
<li>一個 n 個頂點的<strong>有負邊有向圖</strong>上，可以在每個點上做一次「Bellman-Ford's algorithm」以求出「All pair shortest path」
<ul>
<li>時間複雜度（All pair shortest path）
<ul>
<li><strong>|V|×O(|V|×|E|)</strong> = |V|×O(|<span class="math inline">\(V^3\)</span>|) = O(|<span class="math inline">\(V^4\)</span>|)</li>
</ul></li>
</ul></li>
</ol>
<p>「Johnson's algorithm」藉由融合「Bellman-Ford's algorithm」可以<strong>對負邊進行運算的優點</strong>，與「Dijkstra's algorithm」在<strong>邊數很少時可以讓複雜度降低的優點</strong>，所以在「Sparse graph」計算「All pair shortest path」時，可以因為邊數少而降低時間複雜度，又不因負邊而無法計算正確的數值</p>
<ul>
<li>演算法概念
<ul>
<li><strong>以「Bellman-Ford's algorithm」解決負邊問題</strong></li>
<li><strong>使用「Dijkstra's algorithm」計算無負邊圖的「Shortest path」</strong></li>
</ul></li>
</ul>
</blockquote>
<p>給定一圖 G = ＜V,E＞</p>
<p>步驟：</p>
<ol type="1">
<li>加入一個新的頂點 s 與 G 上的每個點連接成為新的圖 G' = ＜V', E'＞，且每條新增的邊之權重為 0</li>
<li>對 s 頂點執行「Bellman-ford's algorithm」（Single source shortest path）
<ul>
<li><strong>令 s 到其他 G 上的頂點 v 之「Shortest path」為 h(v)</strong></li>
</ul></li>
<li>對 G' 上每個邊進行「重設權重」（Reweight）
<ul>
<li><span class="math inline">\(\hat{w}(u,v) = w(u,v) + h(u)-h(v)\)</span></li>
</ul></li>
<li>將 G' 上 s 點與連接的邊移除，保留「重設權重」的邊，對剩下的每個頂點做「Dijkstra's algorithm」</li>
</ol>
<p>時間複雜度：（等價於對每個頂點做「Dijkstra's algorithm」，只是需要前置處理）</p>
<ul>
<li>$O(|V|) + O(|V||E|) + O(|E|) + |V|O(|V| |V|+|E|) = O(|V|^2 |V|+|V||E|) $</li>
<li>（新增|V|條邊）+（修正負邊）+（重設權重）+（對每個頂點做「Dijkstra's algorithm」）</li>
</ul>
<p><strong>Example（證明「Johnson's algorithm」對邊的修正必不會產生負邊）</strong></p>
<ul>
<li><p>考慮一個「強連通有向圖」G = ＜V,E＞，並且圖上<strong>存在負邊</strong>但無負環路</p></li>
<li><p>假設 c(u,v) 表示 u 到 v 頂點的權重</p></li>
<li><p>假設 d(u,v) 表示 u 到 v 頂點的最小權重</p></li>
<li><p>證明 c(w,v) + d(u,w) - d(u,v) ≧ 0，對於圖上任意三個相異頂點</p></li>
</ul>
<p>令 u 到 v 頂點的「Shortest path」為 d(u,v) ，所以<strong>任何其他從 u 到 v 頂點的路徑必 ≧ d(u,v)</strong>，且 d(u,w)+c(w,v) 亦為一個從 u 到 v 頂點的路徑，所以：</p>
<p><span class="math inline">\(d(u,w) + c(w,v) \geq d(u,v) \Rightarrow c(w,v) + d(u,w) - d(u,v) \geq 0\)</span></p>
<figure>
<img src="\willywangkaa\images\johnsonalgorithm_1.png" alt="johnsonalgorithm_1" /><figcaption aria-hidden="true">johnsonalgorithm_1</figcaption>
</figure>
<p><strong>Example（證明「重設權重」的圖 G'，其計算的「All pair shortest path」與圖 G 計算相等）</strong></p>
<ul>
<li><p>考慮一個「強連通有向圖」G = ＜V,E＞，並且圖上<strong>存在負邊</strong>但無負環路</p></li>
<li><p>假設 c(u,v) 表示 u 到 v 頂點的權重</p></li>
<li><p>假設 d(u,v) 表示 u 到 v 頂點的最小權重</p></li>
<li><p>新增一頂點 s 並對各個頂點連接且權重為 0，將每個邊以 c(u,v) + d(s,u) - d(s,v)（c(u,v)+h(u)-h(v)）的數值重設權重後成為 G'，證明其「Shortest path」在 G 上亦成立</p></li>
</ul>
<p>考慮 P = ＜<span class="math inline">\(u = v_0, v_1, \ldots, v = v_k\)</span>＞ 為一條從 u 到 v 的一條路徑</p>
<p>令 <span class="math inline">\(\hat{w}(u,v) = c(u, v)+d(s,u) - d(s,v)\)</span>，則該路徑的權重總和為：</p>
<p><span class="math inline">\(\hat{w}(P) = \sum_{i = 1}^k \hat{w}(v_{i-1}, v_i)\)</span></p>
<p>將重設的權重值代入：</p>
<p><span class="math inline">\(\Rightarrow \sum_{i = 1}^k [c(v_{i-1},v_i)+d(s,v_{i-1}) - d(s, v_i)] = \sum_{i = 1}^k [c(v_{i-1},v_i)+h(v_{i-1}) - h(v_i)]\)</span></p>
<p>展開相消：</p>
<p><span class="math inline">\(\Rightarrow (\sum_{i=1}^kc(v_{i-1}, v_i)) + h(v_0) - h(v_k) = w(P)+h(v_0)-h(v_k)\\ \Rightarrow \hat{w}(P) = w(P)+h(v_0)-h(v_k)\)</span></p>
<p>因為 <span class="math inline">\(h(v_0)\)</span> 與 h(<span class="math inline">\(v_1\)</span>) 為<strong>固定值</strong>，所以當 <span class="math inline">\(\hat{w}(P)\)</span> 愈小時，<strong>等價於</strong> <span class="math inline">\(w(P)\)</span> 也隨之愈小，且不會因為路徑長短而讓修正的邊影響答案（見下例）</p>
<p><strong>Example（失敗的「Reweight」方法）</strong></p>
<ol type="1">
<li>給定一圖 G = ＜V,E＞，而 P 為一條從 s 到 t 頂點的「Shortest path」，假設將 G 上的<strong>每條邊的權重減一</strong>成為 G'，請問是否 P 路徑仍為 s 到 t 在 G' 中的「Shortest path」？</li>
<li>給定一圖 G = ＜V,E＞，而 P 為一條從 s 到 t 頂點的「Shortest path」，假設將 G 上的<strong>每條邊的權重改為</strong> <span class="math inline">\(\hat{w}(u,v) = w(u, v) - w^＊\)</span> 成為 G'，請問是否 P 路徑仍為 s 到 t 在 G' 中的「Shortest path」？
<ul>
<li><span class="math inline">\(w^＊ = min_{(u,v)\in G.E}｛w(u, v)｝\)</span></li>
</ul></li>
</ol>
<p>（1）否，因為<strong>若路徑越長，權重扣除的越多</strong>：</p>
<p>從 u 到 v 頂點的原始「Shortest path」為 ＜u, v＞</p>
<figure>
<img src="\willywangkaa\images\johnsonalgorithm_2.png" alt="johnsonalgorithm_2" /><figcaption aria-hidden="true">johnsonalgorithm_2</figcaption>
</figure>
<p>因為路徑 ＜u,x,y,v＞ 比路徑 ＜u,v＞ 還要長，所以扣除的權重也越多（每條邊的權重扣 1），所以使 ＜u,x,y,v＞ 成為 u 到 v 的新「Shortest path」</p>
<figure>
<img src="\willywangkaa\images\johnsonalgorithm_3.png" alt="johnsonalgorithm_3" /><figcaption aria-hidden="true">johnsonalgorithm_3</figcaption>
</figure>
<p>（2）否，概念與上題一致：</p>
<p>從 u 到 v 頂點的原始「Shortest path」為 ＜u, x, y, v＞</p>
<figure>
<img src="\willywangkaa\images\johnsonalgorithm_4.png" alt="johnsonalgorithm_4" /><figcaption aria-hidden="true">johnsonalgorithm_4</figcaption>
</figure>
<p>因為路徑 ＜u,x,y,v＞ 比路徑 ＜u,v＞ 還要長，所以扣除的權重也越多（每條邊的權重扣 -5；應該說增加權重），所以使 ＜u,v＞ 成為 u 到 v 的新「Shortest path」</p>
<figure>
<img src="\willywangkaa\images\johnsonalgorithm_5.png" alt="johnsonalgorithm_5" /><figcaption aria-hidden="true">johnsonalgorithm_5</figcaption>
</figure>
<h1 id="activity-on-vertex-network-and-topological-sort">Activity on vertex network and topological sort</h1>
<p>令 G = ＜V,E＞ 為有向圖，若為一個「Activity on vertex network」，則：</p>
<ol type="1">
<li>Vertex：代表「工作」（Activity）</li>
<li>Edge：工作之間的<strong>「先後次序關係」</strong>
<ul>
<li>若（頂點 i）→（頂點 j），代表<strong>「工作（i）必須要在工作（j）之前作完」</strong></li>
</ul></li>
</ol>
<ul>
<li>應用
<ul>
<li>判斷<strong>計畫工作先後的執行是否合理</strong>，即至少要有 ≧ 1 組合理的工作順序（使用拓樸排序來判斷）</li>
</ul></li>
<li>Topological sort（Order）
<ul>
<li>給一個<strong>不具有環路（使用 DFS 檢查是否有「Back edge」）</strong>的「AOV network」，則至少可產生 ≧ 1 組「頂點的拜訪順序」，且若「AOV network 中（i）→（j）」，則最後輸出的拜訪順序中，（i）必定出現在（j）之前</li>
</ul></li>
</ul>
<p>步驟：</p>
<ol type="1">
<li>找出「In-degree」等於 0 的頂點（i）</li>
<li>輸出該點，並將（i）點指出去的邊從圖中移除</li>
<li>重複第一、第二步直到所有頂點皆已輸出，或是圖上無「In-degree」等於 0 的頂點</li>
<li>確認是否所有頂點皆輸出，若否表示該圖上無法建立一個「Topological sort」（因為該圖上有環路）</li>
</ol>
<blockquote>
<p>若該圖不含有環路，則「Topological sort」 ≧ 1 組；反之，則無法建立「Topological sort」</p>
</blockquote>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\1543740383474.png" alt="1543740383474" /><figcaption aria-hidden="true">1543740383474</figcaption>
</figure>
<ul>
<li>Algorithm [Algorithm 書上版本]</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS_visit</span><span class="params">(G, u, p)</span> </span>&#123;</span><br><span class="line">    time++;</span><br><span class="line">    u.color  = gray;</span><br><span class="line">    u.d      = time;</span><br><span class="line">    <span class="keyword">for</span> each w in G.adj[u] &#123;</span><br><span class="line">        <span class="keyword">if</span>(w==white) &#123;</span><br><span class="line">            w.parent = u;</span><br><span class="line">            <span class="built_in">DFS_visit</span>(G, w, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    time++;</span><br><span class="line">    u.color = black;</span><br><span class="line">    u.f     = time;</span><br><span class="line">    <span class="built_in">insertFront</span>(u, p);           <span class="comment">// 當一個頂點完成了 DFS 的搜尋，將該頂點插入連結串列的前面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(G, p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// O(|V|)</span></span><br><span class="line">    <span class="comment">// Initialize</span></span><br><span class="line">    <span class="keyword">for</span> each u in G.V &#123;</span><br><span class="line">        u.color  = white;</span><br><span class="line">        u.parent = null;</span><br><span class="line">    &#125;</span><br><span class="line">    time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> each u in G.V &#123;         <span class="comment">//  ↑</span></span><br><span class="line">        <span class="keyword">if</span>(u.color==white) &#123;    <span class="comment">//  |</span></span><br><span class="line">            <span class="built_in">DFS_visit</span>(G, u, p); <span class="comment">//  | O(|V|+|E|)</span></span><br><span class="line">        &#125;                       <span class="comment">//  |</span></span><br><span class="line">    &#125;                           <span class="comment">//  ↓</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ptr <span class="title">Topologicalsort</span><span class="params">(G)</span> </span>&#123;</span><br><span class="line">    ptr p = null;</span><br><span class="line">    <span class="built_in">DFS</span>(G, p);</span><br><span class="line">    <span class="keyword">return</span> p;                   <span class="comment">// 回傳建立好的「Topological sort」的鍊結串列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\1543740792975.png" alt="1543740792975" /><figcaption aria-hidden="true">1543740792975</figcaption>
</figure>
<ul>
<li>Time complexity
<ul>
<li>（等同於 DFS 的時間複雜度）O(|V|+|E|)</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Topological sort（DFS 應用）</strong></p>
<p>在「有向圖」上找出「Strongly connected component」</p>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS_visit</span><span class="params">(G, u, p)</span> </span>&#123;</span><br><span class="line">    time++;</span><br><span class="line">    u.color  = gray;</span><br><span class="line">    u.d      = time;</span><br><span class="line">    <span class="keyword">for</span> each w in G.adj[u] &#123;</span><br><span class="line">        <span class="keyword">if</span>(w==white) &#123;</span><br><span class="line">            w.parent = u;</span><br><span class="line">            <span class="built_in">DFS_visit</span>(G, w, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    time++;</span><br><span class="line">    u.color = black;</span><br><span class="line">    u.f     = time;</span><br><span class="line">    <span class="built_in">insertFront</span>(u, p);           <span class="comment">// 當一個頂點完成了 DFS 的搜尋，</span></span><br><span class="line">                                 <span class="comment">// 將該頂點插入連結串列的前面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS_visit</span><span class="params">(G, u)</span> </span>&#123;</span><br><span class="line">    time++;</span><br><span class="line">    u.color  = gray;</span><br><span class="line">    u.d      = time;</span><br><span class="line">    <span class="keyword">for</span> each w in G.adj[u] &#123;</span><br><span class="line">        <span class="keyword">if</span>(w==white) &#123;</span><br><span class="line">            w.parent = u;</span><br><span class="line">            <span class="built_in">DFS_visit</span>(G, w, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    time++;</span><br><span class="line">    u.color = black;</span><br><span class="line">    u.f     = time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(G, p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// O(|V|)</span></span><br><span class="line">    <span class="comment">// Initialize</span></span><br><span class="line">    <span class="keyword">for</span> each u in G.V &#123;</span><br><span class="line">        u.color  = white;</span><br><span class="line">        u.parent = null;</span><br><span class="line">    &#125;</span><br><span class="line">    time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> each u in G.V &#123;         <span class="comment">//  ↑</span></span><br><span class="line">        <span class="keyword">if</span>(u.color==white) &#123;    <span class="comment">//  |</span></span><br><span class="line">            <span class="built_in">DFS_visit</span>(G, u, p); <span class="comment">//  | O(|V|+|E|)</span></span><br><span class="line">        &#125;                       <span class="comment">//  |</span></span><br><span class="line">    &#125;                           <span class="comment">//  ↓</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">graph <span class="title">Stronglyconnectedcomponent</span><span class="params">(G)</span> </span>&#123;</span><br><span class="line">    ptr p = null;</span><br><span class="line">    <span class="built_in">reverse</span>(G_T, G);                        <span class="comment">// 將原本 G 上的邊＜u,v＞，改為邊＜v,u＞</span></span><br><span class="line">    <span class="built_in">DFS</span>(G, p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initialize，要對 G_T 作 DFS 的事前準備</span></span><br><span class="line">    <span class="keyword">for</span> each u in G_T.V &#123;</span><br><span class="line">        u.color  = white;</span><br><span class="line">        u.parent = null;</span><br><span class="line">    &#125;</span><br><span class="line">    time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ptr i = p; i-&gt;link != null; i = i-&gt;link) &#123;  </span><br><span class="line">                                            <span class="comment">// 沿用「Topological sort」的鍊結串列，</span></span><br><span class="line">        <span class="built_in">DFS_visit</span>(G_T, i);                  <span class="comment">// 因為此順序恰巧是「Finish time」由大到</span></span><br><span class="line">    &#125;                                       <span class="comment">// 小排序下來，依照此順序對 G_T 作 DFS</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> G_T;                             <span class="comment">// 在 G_T 上的 DFS forest 即為各個</span></span><br><span class="line">                                            <span class="comment">// 「Strongly connected component」</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\1543741711989.png" alt="1543741711989" /><figcaption aria-hidden="true">1543741711989</figcaption>
</figure>
</blockquote>
<blockquote>
<p><strong>Topological sort + Strongly connected component</strong></p>
<p><strong>（判斷「Semi-connected graph」）</strong></p>
<p>Example（106 成功大學程式設計）</p>
<ul>
<li>A directed graph G=(V,E) is semi-connected if, for all pairs of vertices u,v ∈ V, u is reachable from v through a directed path, or v is reachable from u through a directed path. Given a linear-time algorithm to determine whether or not G is semi-connected.</li>
</ul>
<ol type="1">
<li><p>用「Topological sort」找出 G 的所有「Strongly connected component」（SCC）</p>
<ul>
<li>將每個 SCC 視為一頂點組成集合 V'
<ul>
<li>假設共有 k 個 SCC</li>
</ul></li>
<li>各個 SCC 在 G 相連的邊組成集合 E'
<ul>
<li><span class="math inline">\(E&#39;=｛(V_1,V_2) ∣ \exist v_1 \in V_1 , v_2 \in V_2 \ni (v1,v2) \in E)｝\)</span></li>
</ul></li>
</ul></li>
<li><p>令 G'=(V',E')</p>
<ul>
<li>必為「Directed acyclic graph」（DAG）
<ul>
<li>若兩點存在環路
<ul>
<li>則該兩點必成為一個 SCC</li>
</ul></li>
</ul></li>
<li>對 G' 執行「Topological sort」
<ul>
<li>找出序列 <span class="math inline">\(T=(v_1,\ldots,v_k )\)</span></li>
<li>若 <span class="math inline">\((V_i, V_{i+1}) \in E&#39; ,i = 1,\ldots,k-1\)</span> 成立
<ul>
<li>G 為「Semi-connected graph」</li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<p><strong>正確性證明</strong></p>
<p>假設 G=(V,E) 為「Semi-connected graph」</p>
<ul>
<li>對所有 <span class="math inline">\(v_1, v_2\in V\)</span> 存在路徑
<ul>
<li>不失一般性假設為 <span class="math inline">\((v_1\rightarrow \ldots\rightarrow v_2)\)</span></li>
</ul></li>
<li>假設 <span class="math inline">\(v_1 \in V_1, v_2 \in V_2\)</span>
<ul>
<li><span class="math inline">\(V_1, V_2\)</span> 為 G 的兩個 SCC</li>
<li>若 <span class="math inline">\((V_1, V_2)\in E&#39;\)</span>
<ul>
<li><span class="math inline">\(v_1, v_2\)</span> 必有路徑</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<blockquote>
<p><strong>有向無環路圖（Direct acyclic graph）</strong>上求「Single source all shortest paths」</p>
<p>可以利用「Topological sort」（O(|V|+|E|)）來減少維護「Fibonacci heap」需要的時間複雜度（每回合的Delete-min：O(|V|log|V|)）</p>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s: 起點</span></span><br><span class="line"><span class="built_in">Initialize</span>(G, s) &#123;              <span class="comment">//  ↑</span></span><br><span class="line">    <span class="keyword">for</span> each vertex v in G.V &#123;  <span class="comment">//  ︳</span></span><br><span class="line">        v.d = ∞;                <span class="comment">//  ︳</span></span><br><span class="line">        v.parent = null;        <span class="comment">//  ︳  O(|V|)</span></span><br><span class="line">    &#125;                           <span class="comment">//  ︳</span></span><br><span class="line">    s.d = <span class="number">0</span>;                    <span class="comment">//  ︳</span></span><br><span class="line">&#125;                               <span class="comment">//  ↓</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Relax</span>(u,v,W) &#123;</span><br><span class="line">    <span class="keyword">if</span>(v.d &gt; u.d+W[u,v]) &#123;</span><br><span class="line">        v.d = u.d + w[u,v];</span><br><span class="line">        v.parent = u;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// W[1..n,1..n]: 邊權重集合</span></span><br><span class="line"><span class="comment">// s: 起點</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DAG_shorestpath</span><span class="params">(G,W,s)</span> </span>&#123;</span><br><span class="line">    ptr p = <span class="built_in">Topologicalsort</span>(G);</span><br><span class="line">    <span class="comment">// Dijkstra&#x27;s algorithm</span></span><br><span class="line">    <span class="built_in">Initialize</span>(G, s);</span><br><span class="line">    <span class="keyword">for</span>(ptr u = p; u-&gt;link != null; u = u-&gt;link) &#123;</span><br><span class="line">        <span class="keyword">for</span> each vertex v in G.adj[u] &#123;</span><br><span class="line">            <span class="built_in">Relax</span>(u,v,W)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\1543742596379.png" alt="1543742596379" /><figcaption aria-hidden="true">1543742596379</figcaption>
</figure>
<ul>
<li>Time complexity
<ul>
<li>O(|V|+|E|) + O(|V|) + O(|V|) + O(|E|) = O(|V|+|E|)</li>
<li>「Topological sort」+「Initialization」+「Trace adjacency list」</li>
</ul></li>
</ul>
</blockquote>
<h1 id="activity-on-edge-network-critical-path-and-critical-task">Activity on edge network, critical path and critical task</h1>
<p>應用於「計畫的專案管理」、CPM（Critical path management）</p>
<p>G = ＜V,E＞ 為有向圖且為「AOE network」，則：</p>
<ol type="1">
<li>Vertex：<strong>代表「事件」（Event）</strong>、「里程碑」（Milestone）、「查核點」</li>
<li>Edge：<strong>代表「工作」（Activity）</strong>
<ul>
<li>權重：<strong>代表該「工作」需要完成的工作時數</strong></li>
</ul></li>
</ol>
<ul>
<li><p>所有指向某「事件頂點」的工作全部完成時，該事件才會發生</p></li>
<li><p>「事件頂點」一旦觸發後，從此頂點指出的「工作邊」才可以開工</p></li>
</ul>
<figure>
<img src="\willywangkaa\images\1543742794508.png" alt="1543742794508" /><figcaption aria-hidden="true">1543742794508</figcaption>
</figure>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\1543743405702.png" alt="1543743405702" /><figcaption aria-hidden="true">1543743405702</figcaption>
</figure>
<ol type="1">
<li>完成計畫<strong>最快</strong>需要幾天？
<ul>
<li>求 s 至 e 之最常路徑，也就為「Critical path」的長度（24天）</li>
</ul></li>
</ol>
<figure>
<img src="\willywangkaa\images\1543743598858.png" alt="1543743598858" /><figcaption aria-hidden="true">1543743598858</figcaption>
</figure>
<ol start="2" type="1">
<li>列出所有「Critical path」
<ul>
<li>＜s,e＞路徑長為 24 的皆為「Critical path」</li>
</ul></li>
</ol>
<figure>
<img src="\willywangkaa\images\1543744208911.png" alt="1543744208911" /><figcaption aria-hidden="true">1543744208911</figcaption>
</figure>
<ol start="3" type="1">
<li>列出所有「Critical task」（不可延遲的工作）
<ul>
<li>在「Critical path」上的<strong>工作邊</strong>｛<span class="math inline">\(a_1, a_6, a_7, a_8, a_{10}, a_{12}\)</span>｝</li>
</ul></li>
<li>那些工作（瓶頸）的時數縮短後，可有效的縮短整體計畫之工作時數？
<ul>
<li>所有「Critical path」上的「共同工作」（交集邊）｛<span class="math inline">\(a_1, a_6, a_{12}\)</span>｝</li>
</ul></li>
</ol>
<figure>
<img src="\willywangkaa\images\1543744339082.png" alt="1543744339082" /><figcaption aria-hidden="true">1543744339082</figcaption>
</figure>
<ol start="5" type="1">
<li>那些工作可以延遲？可以延遲多久不影響進度？
<ul>
<li>不在「Critical path」上的工作邊可以有延遲</li>
</ul></li>
</ol>
<blockquote>
<ol type="1">
<li>求各個<strong>事件頂點</strong>點之「最早觸發時間」（起點至各點的「最長路徑長」）</li>
</ol>
<table>
<thead>
<tr class="header">
<th>事件頂點</th>
<th>s</th>
<th>t</th>
<th>u</th>
<th>v</th>
<th>w</th>
<th>x</th>
<th>e</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>最早觸發時間點</td>
<td>0</td>
<td>8</td>
<td>13</td>
<td>16</td>
<td>19</td>
<td>12</td>
<td>24</td>
</tr>
<tr class="even">
<td>最晚觸發時間點</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>求各個<strong>事件頂點</strong>點之「最晚觸發時間」（終點回推各點的最小值）</li>
</ol>
<figure>
<img src="\willywangkaa\images\1543745099778.png" alt="1543745099778" /><figcaption aria-hidden="true">1543745099778</figcaption>
</figure>
<p>綜合以上可以發現事件頂點 x 必定要在第 7 天觸發</p>
<p>查看指向自己的頂點以確認最晚觸發的時間，也可以確認<strong>該工作邊</strong>是否可以延遲</p>
<figure>
<img src="\willywangkaa\images\1543747954832.png" alt="1543747954832" /><figcaption aria-hidden="true">1543747954832</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th>事件頂點</th>
<th>s</th>
<th>t</th>
<th>u</th>
<th>v</th>
<th>w</th>
<th>x</th>
<th>e</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>最早觸發時間點</td>
<td>0</td>
<td>8</td>
<td>13</td>
<td>16</td>
<td>19</td>
<td><strong>12</strong></td>
<td>24</td>
</tr>
<tr class="even">
<td>最晚觸發時間點</td>
<td>0</td>
<td>8</td>
<td>13</td>
<td>16</td>
<td>19</td>
<td><strong>14</strong></td>
<td>24</td>
</tr>
</tbody>
</table>
<p><strong>事件頂點 x 的觸發</strong>可以延遲</p>
<ol start="3" type="1">
<li>求各個工作之「最早開工」與「最晚開工」時間點
<ul>
<li>最早開工等價於<strong>「需觸發之事件點」</strong>之「最早觸發」時間點</li>
<li>最晚開工等價於<strong>「欲觸發之事件點」</strong>之「最晚觸發」時間點</li>
</ul></li>
</ol>
<figure>
<img src="\willywangkaa\images\1543748398923.png" alt="1543748398923" /><figcaption aria-hidden="true">1543748398923</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th>工作邊</th>
<th>a1</th>
<th>a2</th>
<th>a3</th>
<th>a4</th>
<th>a5</th>
<th>a6</th>
<th>a7</th>
<th>a8</th>
<th>a9</th>
<th>a10</th>
<th>a11</th>
<th>a12</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>最早開工時間點</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>13</td>
<td>13</td>
<td>12</td>
<td>16</td>
<td>12</td>
<td>19</td>
</tr>
<tr class="even">
<td>最晚開工時間點</td>
<td>0</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>9</td>
<td>8</td>
<td>13</td>
<td>13</td>
<td>14</td>
<td>16</td>
<td>19</td>
<td>19</td>
</tr>
</tbody>
</table>
<p>在「Critical path」上的<strong>工作邊</strong>｛<span class="math inline">\(a_1, a_6, a_7, a_8, a_{10}, a_{12}\)</span>｝</p>
</blockquote>
<h1 id="articulation-point">Articulation point</h1>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\1543748935456.png" alt="1543748935456" /><figcaption aria-hidden="true">1543748935456</figcaption>
</figure>
<p>橘色即為「Articulation point」</p>
<h2 id="biconnected-graph">Biconnected graph</h2>
<p>一個連通無向圖，且無「Articulation point」，則稱為「Biconnected graph」</p>
<ul>
<li>應用
<ul>
<li>網路節點設置</li>
</ul></li>
<li>Biconnected component
<ul>
<li>子圖</li>
<li>連通</li>
<li>為極大的「Biconnected」子圖</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1543749321235.png" alt="1543749321235" /><figcaption aria-hidden="true">1543749321235</figcaption>
</figure>
<ul>
<li>求出「Articulation point」（以上圖為例）</li>
</ul>
<ol type="1">
<li>從任意頂點作「深度優先查找」（這裡作DFS(3)），求出各點的「DFN」（DFS拜訪順序）</li>
</ol>
<table>
<thead>
<tr class="header">
<th>頂點</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DFN</td>
<td>3</td>
<td>2</td>
<td>4</td>
<td>1</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
<tr class="even">
<td>LOW</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>畫出「DFS spanning tree」並標出「Back edge」</p>
<figure>
<img src="\willywangkaa\images\1543749964256.png" alt="1543749964256" /><figcaption aria-hidden="true">1543749964256</figcaption>
</figure>
<ol start="2" type="1">
<li>求個頂點的「low」值
<ul>
<li><span class="math inline">\(low(x) = min｛dfn(x), ｛dfn(y)|為x的後代頂點最多經過一條「Back\;edge」所到之頂點｝｝\)</span></li>
</ul></li>
</ol>
<table>
<thead>
<tr class="header">
<th>頂點</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DFN</td>
<td>3</td>
<td>2</td>
<td>4</td>
<td>1</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
<tr class="even">
<td>LOW</td>
<td>3</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>9</td>
<td>10</td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li>判斷「Articulation point」
<ul>
<li>針對<strong>樹根頂點</strong>：若有 ≧ 2 個子頂點，則必為「Articulation point」
<ul>
<li>（3）有 ≧ 2 個子頂點，所以為「Articulation point」</li>
</ul></li>
<li>針對<strong>非樹根頂點</strong>：任意一個 x 之<strong>子頂點 y（非所有後代頂點）</strong>只要符合<code>low(y) &gt;= dfn(x)</code>，則為「Articulation point」
<ul>
<li>（1）之子頂點（0）：<code>dfn(1)&lt;=low(0)</code>，為「Articulation point」</li>
<li>（2）之子頂點（4）：<code>dfn(4)&gt;low(2)</code>，非「Articulation point」</li>
<li>（5）之子頂點（6）：<code>dfn(5)&gt;low(6)</code>，非「Articulation point」</li>
<li>（6）之子頂點（7）：<code>dfn(6)&gt;low(7)</code>，非「Articulation point」</li>
<li>（7）之子頂點（8）、（9）：<code>dfn(7)&gt;low(8)&amp;&amp;dfn(7)&gt;low(9)</code>，非「Articulation point」</li>
</ul></li>
<li>針對<strong>葉頂點</strong>：皆非「Articulation point」
<ul>
<li>（0）、（4）、（8）、（9）</li>
</ul></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System - Virtual memory</title>
    <url>/willywangkaa/2018/09/10/Operating-system-Virtual-memory/</url>
    <content><![CDATA[<h1 id="virtual-memory">Virtual memory</h1>
<ul>
<li>Pros
<ul>
<li><strong>允許 Process 大小超過實體記憶體可用空間大小時，Process 仍可以正確執行</strong>，主要是作業系統要解決之議題，開發者無須擔心。</li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>Additional pros
<ul>
<li>RAM 的利用度 ( Utilization ) 高</li>
<li>儘可能地提高系統的多工度 ( Multiprogramming degree )，亦也提高 CPU 的利用度( Utilization )
<ul>
<li><strong>＜Note＞ Thrashing 除外</strong></li>
</ul></li>
<li><strong>I/O Transfer time</strong> ( I/O 傳輸時間 )<strong>較小</strong> (Response)：每次程式要執行時從原本要抓取該程式全部頁面( page )，變成只需要抓取足夠頁面即可
<ul>
<li>傳輸時間 <span class="math inline">\(\propto\)</span> 傳輸量</li>
<li><strong>＜Note＞ 但是整個 Process 在執行的時間作 I/O 傳輸的次數上升(還是要將方才剩餘的頁面抓進頁框之中)，導致整體作 I/O 傳輸的時間是上升的</strong></li>
</ul></li>
<li>開發者只需專注於程式的開發，無須將心思置於程式過大而無法執行之問題，因為虛擬記憶體是作頁系統管理的一環。( 開發者不需要使用「Overlay」的技術 )</li>
</ul></li>
</ul>
</blockquote>
<h2 id="實現虛擬記憶體">實現虛擬記憶體</h2>
<h3 id="demand-paging-需求分頁技術">Demand paging ( 需求分頁技術 )</h3>
<figure>
<img src="\willywangkaa\images\demandpaging.png" alt="demandpaging" /><figcaption aria-hidden="true">demandpaging</figcaption>
</figure>
<ul>
<li><p>架構於 Page memory management 的基礎之上</p>
<ul>
<li><strong>＜Note＞ 但在虛擬記憶體之中，與傳統 Page memory management 最大的差異在於以前的 Process 必須等到所有程式載入到頁框之中才可執行；但是在虛擬記憶體裡採用「Lazy swapper」，意指在程式開始時，無須載入所有與該 Process 相關之頁面也可正確的執行 Process，等到該 Process 需要該頁面時才載入至頁框。</strong>(若初始時，若該 Process 在記憶體無任何頁面，則稱之為「Pure demand paging」 )</li>
<li>當 Process 於執行階段企圖存取不在頁框( RAM frame )中的頁面時，則稱為發生了「Page fault」並對作業系統發出該錯誤中斷，接著作業系統會將 Process 所需的「Lost page」從硬碟載入至 RAM 中，Process 方可執行。</li>
</ul></li>
<li><p>在分頁中，需要一個欄位：「Valid/ Invalid bit」，用來區分此分頁是否存在於 RAM 中。</p>
<ul>
<li><p><span class="math inline">\(\left\{\begin{matrix} 1 &amp; ： &amp; 在 \; RAM 中 \\ 0 &amp; ： &amp; 不存在於 RAM 中 \end{matrix}\right.\)</span></p></li>
<li><table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Valid bit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作業系統</td>
<td>設定、修改 ( 作業系統在建立分頁表時會決定哪些頁面的進出，所以會設定該 Valid bit 的狀態，另外作業系統在處理「Page fault」時會將頁面抓入 RAM 中並修改該 Valid bit )</td>
</tr>
<tr class="even">
<td>記憶體管理單元</td>
<td>讀取 Valid bit</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>
<h3 id="處理-page-fault">處理 Page fault</h3>
<figure>
<img src="\willywangkaa\images\handlingpagefault.png" alt="handlingpagefault" /><figcaption aria-hidden="true">handlingpagefault</figcaption>
</figure>
<ul>
<li><strong>處理時間長</strong></li>
</ul>
<ol type="1">
<li>MMU 會遇到「Address error」並對作業系統傳出「interrupt」。</li>
<li>作業系統收到中斷後，必須暫停該 Process 的執行且保存其狀態資訊於 PCB 中。</li>
<li>作業系統檢查 Process 之存取位址是否合法。若為非法，則終止該 Process；<strong>若合法，則作業系統判定為「Page fault」所導致。</strong></li>
<li>作業系統吸到 RAM 中檢查有無空閒頁框
<ul>
<li>若無，則必須執行「Page replacement」工作，以空出一個頁框，以便將頁面移入記憶體之中。</li>
</ul></li>
<li>作業系統再到硬碟中找出「Lost page」所在的位址，啟動 I/O 運作，將 Lost page 載入到 free frame 中。</li>
<li><strong>最後作業系統修改分頁表</strong>，紀錄該分頁位於何頁框碼中，<strong>另外將 Invalid 改為 Valid。</strong></li>
<li><strong>作業系統恢復中斷之前 Process 的執行。</strong></li>
</ol>
<blockquote>
<p>Ref P8.7 步驟六 ...作業系統<strong>可</strong>將 CPU 分給...</p>
</blockquote>
<h3 id="計算-effective-memory-access-time-virtual-memory">計算 Effective memory access time ( Virtual memory )</h3>
<p>當 P 是「Page fault ratio」時，有效的記憶體存取時間為： <span class="math display">\[
(1-p) \times Memory \;access \;time + p \times ( Page\; fault \;process \;time+Memory\;access\;time)
\]</span></p>
<ul>
<li><p>Ex</p>
<ul>
<li>Memory access time：200 ns</li>
<li>page fault process time：5ms</li>
</ul>
<p>若 page fault ratio = 10 %，求出 Effective memory access time。</p></li>
</ul>
<p><span class="math display">\[
Memory \;access \;time + p \times Page\; fault \;process \;time = 200\;ns + 0.1 \times 5ms = 500180 \;ns
\]</span></p>
<p>若希望 Effective memory access time 不超過 2ms 則 page fault reatio 為？</p>
<p><span class="math display">\[
\begin{matrix}
&amp;Memory \;access \;time + p \times Page\; fault \;process \;time &amp;\leq&amp; 2 \;ms \\
\Rightarrow&amp; 200 \;ns + p\times5 \;ms &amp;\leq&amp; 2 \;ms \\
\Rightarrow&amp; p\times5 \;ms &amp;\leq&amp; 1.9998 \;ms \\
\Rightarrow&amp; p &amp;\leq&amp; 0.39996
\end{matrix}
\]</span></p>
<blockquote>
<p>令 P 代表 TLB hit ratio，q 代表 page fault ratio <span class="math display">\[
p \times (TLB \;time + Memory \;access \;time) + (1-p) \times (TLB \;time + \\ Memory\;access\;time_{查Page table} + Memory\;access\;time_{存取資料} + \\q \times Page\; fault \;process \;time)
\]</span></p>
</blockquote>
<ul>
<li>欲降低有效記憶體存取時間降低，提升虛擬記憶體的效能，關鍵在於<strong>降低「Page fault ratio」。</strong></li>
</ul>
<h3 id="影響-page-fault-ratio-因素">影響 Page fault ratio 因素</h3>
<h4 id="page-replacement-頁面替換">Page replacement (頁面替換)</h4>
<p>當 <strong>Page fault 發生</strong>且 <strong>RAM 無空閒之頁框</strong>，作業系統必須執行此工作，<strong>即要選擇一「Victim page」( 或 replaced page )</strong> 將它搬出 <strong>( swap out ) 至硬碟保存</strong>，以騰出一個空閒的頁框，所以<strong>遇到需要「Page replacement 」的情況時，會額外多出一個硬碟的 I/O 運作 ( Page fault process time 更久 )。</strong></p>
<ul>
<li>如何<strong>降低</strong>「Swap out」此一額外的「I/O運作」？
<ul>
<li>在分頁表中多一個欄位<strong>「Modification bit」(Dirty bit)</strong>，用以表示上次分頁載入後到現在，內容是否被修改過。<br><span class="math inline">\(\left\{\begin{matrix} 1 &amp; ： &amp; 曾經修改過 \\ 0 &amp; ： &amp; 不曾修改過 \end{matrix}\right.\)</span> <br><strong>所以作業系統可以檢查 Victim page 的 Dirty bit。若為 0 ，則無需將該分頁「swap out」</strong>以降低 I/O 次數；<strong>反之，則要將該分頁「Swap out」至硬碟之中。</strong></li>
</ul></li>
</ul>
<blockquote>
<table>
<thead>
<tr class="header">
<th></th>
<th>Dirty bit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Memory management unit</td>
<td>set <span class="math inline">\((0 \rightarrow 1)\)</span></td>
</tr>
<tr class="even">
<td>Operating system</td>
<td>Reference and reset<span class="math inline">\((1 \rightarrow 0)\)</span></td>
</tr>
</tbody>
</table>
</blockquote>
<ul>
<li><p>Ex</p>
<ul>
<li>Page fault process time：8 ms ( 有可用頁框或是該犧牲頁框不用「swap back」至硬碟中 )</li>
<li>Page fault process time：20 ms ( 該犧牲頁框<strong>需</strong>「swap back」至硬碟中 )</li>
<li>Memory access time：100 ns</li>
<li>選定已修改過犧牲頁框之機率：70 %</li>
</ul>
<p>若要使有效記憶體存取時間<span class="math inline">\(\leq 200 \;ns\)</span> ，求 page fault ratio <span class="math inline">\(\leq ？\)</span></p></li>
</ul>
<p><span class="math display">\[
100 \;ns + p\times page\;fault\;process\;time \leq 200 \;ns \\
\Rightarrow 100 \;ns + p\times (0.3 \times 8\;ms+0.7\times20\;ms) \leq 200 \;ns \\
\Rightarrow 100 \;ns + p\times 16.4 \;ms \leq 200 \;ns \\
\Rightarrow p \leq \frac{1}{164000}
\]</span></p>
<ul>
<li><p>Ex</p>
<ul>
<li>1 次 I/O time：10 ms</li>
<li>Page fault ratio：10 %</li>
<li>Victim page is modified ratio：60 %</li>
<li>Memory access time：200 ns</li>
</ul>
<p>求有效記憶體存取時間為何？</p></li>
</ul>
<p><span class="math display">\[
200 \;ns + 0.1 \times page\;fault\;process\;time \\
 = 200 \;ns + 0.1 \times ( 0.4\times 10\;ms+0.6\times(10 \;ms \times 2) )......*需要兩次I/O運作
\]</span></p>
<h4 id="replacement-policy">Replacement policy</h4>
<ul>
<li><strong>Local</strong> replacement policy ( 多數使用 )
<ul>
<li>作業系統只能從發生「Page fault」的 Process 之所有分頁 ( in frame ) 之中挑選一個<strong>犧牲頁面</strong>，<strong>不可在其他 Process 之所有分頁 ( in frame ) 裡挑選犧牲頁面。</strong></li>
<li><strong>Cons</strong>
<ul>
<li>無法從其他<strong>不活躍的 Process</strong> 之所有分頁中挑選一個犧牲頁面，<strong>導致記憶體的利用度差。</strong></li>
</ul></li>
<li><strong>Pros</strong>
<ul>
<li>若該 Process 發生「Page fault」的頻率極高，但也不會搶奪其它 Process 的頁框，<strong>所以可限縮「Thrashing」的範圍。</strong></li>
</ul></li>
</ul></li>
<li>Global replacement policy
<ul>
<li>作業系統可從其他 Process 挑選犧牲頁面。</li>
<li><strong>Cons</strong>
<ul>
<li>若該 Process 發生「Page fault」的頻率極高，因為可以搶奪其它 Process 的頁框，<strong>所以「Thrashing」的範圍會一直擴散。</strong></li>
</ul></li>
<li><strong>Pros</strong>
<ul>
<li>可從其他<strong>不活躍的 Process</strong> 之所有分頁中挑選一個犧牲頁面，<strong>記憶體的利用度佳。</strong></li>
</ul></li>
</ul></li>
</ul>
<h4 id="page-replacement-schema-法則">Page replacement schema ( 法則 )</h4>
<h6 id="belady-anomaly">Belady anomaly</h6>
<blockquote>
<p><strong>Process 分配到的頁框數增加</strong>，其「Page fault ratio」卻<strong>不減反增</strong>之異常現象。</p>
<ul>
<li>Ex ( *FIFO法則 )</li>
</ul>
<p><span class="math display">\[
1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
\]</span></p>
<p>配置<strong>三個</strong>頁框：</p>
<figure>
<img src="\willywangkaa\images\FIFO3frame.png" alt="FIFO3frame" /><figcaption aria-hidden="true">FIFO3frame</figcaption>
</figure>
<p>9 次「Page fault」</p>
<p>配置<strong>四個</strong>頁框：</p>
<figure>
<img src="\willywangkaa\images\FIFO4frame.png" alt="FIFO4frame" /><figcaption aria-hidden="true">FIFO4frame</figcaption>
</figure>
<p><strong>10 次「Page fault」</strong></p>
<ul>
<li><strong>Stack property</strong>
<ul>
<li><strong>n 個頁框所包含的「Page set」保證是 n+1 個頁框所包含的「Page set」之子集合</strong>。</li>
<li><strong>若具有「Stack property」保證不會有「Belady anomaly」。</strong>
<ul>
<li>若在 n 個頁框的「Page set」不會發生「Page fault」，那在 n+1 個頁框自然也不會發生「Page fault」；而如果在 n 個頁框的「Page set」<strong>會發生</strong>「Page fault」，那在 n+1 個頁框可能不會發生「Page fault」，這樣之下至少 n+1 個頁框會比 n 個頁框<strong>少一次「Page fault」。</strong></li>
</ul></li>
<li>具有 Stack property 的法則 ( 不會發生「Belady anomaly」 )
<ul>
<li>Optimal 法則</li>
<li>Least recently used 法則</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\stackproperty.png" alt="stackproperty" /><figcaption aria-hidden="true">stackproperty</figcaption>
</figure>
</blockquote>
<h5 id="fifo-法則">FIFO 法則</h5>
<p>最早載入的頁面<strong>( Loading time 最小 )</strong>，作為犧牲頁面。</p>
<ul>
<li>Pros
<ul>
<li>簡單、容易實作。</li>
</ul></li>
<li>Cons
<ul>
<li>可能有「Belady anomaly」現象。</li>
<li>效能不是很好，Page fault ratio 相當高。</li>
<li><strong>＜Note＞ Page replacement 法則之中，只有最佳沒有最差 <br>( 在任何情況之下都要使 FIFO 的「Page fault」最高才能稱為最差 )。</strong></li>
</ul></li>
<li>Ex
<ul>
<li>給予 3 個頁框並且初始時全部皆為空 ( 又稱為「Pure demand paging」)，以下是「<strong>Page reference string</strong>」，請求取「Page fault」次數。</li>
</ul></li>
</ul>
<p><span class="math display">\[
7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0 ,1
\]</span></p>
<blockquote>
<p>或是以頁框大小為 100 kB，目前有三個空頁框，存取下列位址： <span class="math display">\[
731, 008, 117, 258, 039, 331, 047 ...
\]</span> 或是「Logical address」為 12 bits，「Page no.」佔有 3 bits，存取位址如下： <span class="math display">\[
FAF, 1DC, 21E, 147, 747, 0AF, 5D7... 
\]</span></p>
</blockquote>
<figure>
<img src="\willywangkaa\images\FIFOpagereplace.png" alt="FIFOpagereplace" /><figcaption aria-hidden="true">FIFOpagereplace</figcaption>
</figure>
<p><strong>總共 15 次。</strong></p>
<h5 id="optimal-法則-opt">Optimal 法則 ( OPT )</h5>
<p>選擇<strong>將來長期不會使用到的分頁</strong>作為犧牲頁面。</p>
<ul>
<li>Pros
<ul>
<li><strong>「Page fault ratio」最低，所以稱之為「Optimal」。</strong></li>
<li><strong>不會有「Belady anomaly」現象。</strong></li>
</ul></li>
<li>Cons
<ul>
<li>因為需要未來的資訊，<strong>所以無法被實作出來。</strong>
<ul>
<li>通常做為理論研究時當作比較對象來使用。</li>
</ul></li>
</ul></li>
<li>Ex
<ul>
<li>給予 3 個頁框並且初始時全部皆為空 ( 又稱為「Pure demand paging」)，以下是「<strong>Page reference string</strong>」，請求取「Page fault」次數。</li>
</ul></li>
</ul>
<p><span class="math display">\[
7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0 ,1
\]</span></p>
<figure>
<img src="\willywangkaa\images\pagereplacement_opt.png" alt="pagereplacement_opt" /><figcaption aria-hidden="true">pagereplacement_opt</figcaption>
</figure>
<p><strong>總共 9 次。</strong></p>
<h5 id="least-recently-used-lru-法則">Least recently used ( LRU ) 法則</h5>
<p><strong>選擇過去不常使用的分頁作為犧牲頁面</strong>，即挑選<strong>最後一次存取時間點最小的分頁</strong>，也就相當於是「反向 Optimal 法則」( 依照歷史資訊而作出決定的 OPT 法則 )。</p>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>「Page fault ratio」可以被接受。</strong></li>
<li><strong>不會發生「Belady anemaly」現象。</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>LRU 的製作需要大量硬體支持，所以成本很高。</strong>
<ul>
<li>進而衍生出「LRU 近似法則」，以降低成本。</li>
</ul></li>
</ul></li>
</ul>
<h6 id="lru-的製作方法">LRU 的製作方法</h6>
<blockquote>
<ul>
<li><p>以 Counter 製作</p>
<ul>
<li><p>程序</p>
<ol type="1">
<li><p>每次發生存取該頁面時，累進 Counter 的值。</p></li>
<li><p>將 Counter 的值複製至該存取頁面之「last reference time」欄位之中。</p></li>
<li><p>作業系統在挑選 LRU 分頁時，就挑選「last reference time」最小的分頁。</p></li>
</ol></li>
</ul></li>
<li><p>以 Stack 製作</p>
<ul>
<li>最後一次存取之分頁必定置於 Stack <strong>頂端</strong>。</li>
<li>Stack 之<strong>底端即為 LRU 分頁。</strong></li>
<li><strong>Stack 大小 = 頁框數量。</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\LRU_stack.png" alt="LRU_stack" /><figcaption aria-hidden="true">LRU_stack</figcaption>
</figure>
<ul>
<li>3 個頁框有 10 次「Page fault」</li>
<li><strong>注意：此時「FIFO」法加上三個頁框才 9 次「Page fault」</strong></li>
<li>4 個頁框有 8 次「Page fault」</li>
</ul>
</blockquote>
<ul>
<li><p>Ex</p>
<ul>
<li>給予 3 個頁框並且初始時全部皆為空 ( 又稱為「Pure demand paging」)，以下是「<strong>Page reference string</strong>」，請求取「Page fault」次數。</li>
</ul></li>
</ul>
<p><span class="math display">\[
7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0 ,1
\]</span></p>
<figure>
<img src="\willywangkaa\images\pagereplacement_LRU.png" alt="pagereplacement_LRU" /><figcaption aria-hidden="true">pagereplacement_LRU</figcaption>
</figure>
<p><strong>總共 12 次。</strong></p>
<h5 id="least-recently-used-近似法則">Least recently used 近似法則</h5>
<p>主要以「Reference bit」為基礎 <span class="math inline">\(\left\{\begin{matrix} 0 &amp; ： &amp; 此分頁未曾被修改過 \\ 1 &amp; ： &amp; 此分頁曾經被修改過 \end{matrix}\right.\)</span>，但不確定何時被存取( 與 LRU 的差異 )。</p>
<h6 id="additional-reference-bit">Additional reference bit</h6>
<blockquote>
<p><strong>每個分頁有一個欄位 ( 或暫存器； 8 bit ... )，當發生記憶體存取時，該分頁之「Reference bit」會被設置為 1，系統每隔一段時間會將各分頁的暫存器值「右移」一位 ( 空出最高位元並將最右側位元捨去 )，並將各分頁之「Reference bit」值複製到暫存器之「最高」位元並重設各個分頁的「Reference bit」。</strong></p>
<p>將來要挑選犧牲頁面時，<strong>挑選「暫存器最小值」之分頁</strong>，若多個分頁具有相同的值，則以「FIFO 法則」加以篩選。</p>
<ul>
<li>Ex
<ul>
<li>給予 3 個頁框並且初始時全部皆為空</li>
</ul></li>
</ul>
<p><span class="math display">\[
1, 2, 1, 1 ,1 ,1, 3, 1, 3, 3, 3, 3, 5
\]</span></p>
<figure>
<img src="\willywangkaa\images\pagereplacement_addbit.png" alt="pagereplacement_addbit" /><figcaption aria-hidden="true">pagereplacement_addbit</figcaption>
</figure>
<p>遇到「Page 5」時，因為<strong>「Page 2」</strong>的暫存器值最小所以選擇該分頁為犧牲分頁。</p>
</blockquote>
<h6 id="second-chance-法則">Second chance 法則</h6>
<p>以 FIFO 為基礎，搭配「Reference bit」以挑選犧牲頁面。</p>
<ul>
<li>步驟
<ol type="1">
<li><strong>先以 FIFO 順序挑出一個分頁。</strong></li>
<li><strong>檢查此分頁的「Reference bit」值，</strong><br><span class="math inline">\(\left\{\begin{matrix} case \;1： &amp; 0 &amp; 則該分頁即為犧牲者處理完後回到第一步。 \\ case\;2： &amp; 1 &amp; 跳至第三步。 \end{matrix}\right.\)</span></li>
<li><strong>給予該分頁機會 ( 不挑選該分頁作為犧牲者 )</strong></li>
<li><strong>重設該分頁之「Reference bit」為 0。</strong></li>
<li><strong>☆將該分頁之「載入時間」設置成現在時間 ( FIFO 性質 )。</strong><br>( 載入時間有兩個地方會被更改，<span class="math inline">\(\left\{\begin{matrix} 1. &amp; 該分頁真的被載入至記憶體之中。 \\ 2. &amp; 給予該分頁機會不挑選為犧牲者時。\end{matrix}\right.\)</span> )</li>
<li>回到第一步。</li>
</ol></li>
<li>☆Ex ( 四個頁框中，依目前狀態挑一頁框為犧牲頁框 )</li>
</ul>
<figure>
<img src="\willywangkaa\images\pagereplacement_secondchance.png" alt="pagereplacement_secondchance" /><figcaption aria-hidden="true">pagereplacement_secondchance</figcaption>
</figure>
<p>挑「Page 3」為犧牲頁框。</p>
<ul>
<li>Ex ( 三個頁框 )</li>
</ul>
<p><span class="math display">\[
1, 2, 3, 4, 2, 5, 2, 6, 1, 2
\]</span></p>
<figure>
<img src="\willywangkaa\images\pagereplecement_secondchoice_2.png" alt="pagereplecement_secondchoice_2" /><figcaption aria-hidden="true">pagereplecement_secondchoice_2</figcaption>
</figure>
<p><strong>8 次「Page fault」。</strong></p>
<blockquote>
<ul>
<li>當所有分頁之「Reference bit」皆相同時，則退化成 FIFO。</li>
<li><strong>也稱為「Clock algorithm」。</strong></li>
</ul>
</blockquote>
<h6 id="enhanced-second-chance-法則">Enhanced second chance 法則</h6>
<p>以 ＜Reference bit, Modification bit＞ 配對值作為挑選犧牲頁面的依據，值最小者之分頁作為犧牲頁面。若多個分頁具有相同的值，則以 FIFO 為準。</p>
<ul>
<li>Modificaion bit
<ul>
<li>該分頁曾經被修改過，若該分頁為犧牲品，要將該分頁寫回硬碟保存 ( Swap out )。</li>
</ul></li>
<li>大小依據 ( 大小由上到下 )</li>
</ul>
<p><span class="math display">\[
＜Reference bit, Modification bit＞\\
＜0, 0＞\\
＜0, 1＞\\
＜1, 0＞\\
＜1, 1＞
\]</span></p>
<h5 id="lfu-與-mfu-法則-無計算題">LFU 與 MFU 法則 ( 無計算題 )</h5>
<p>以分頁的<strong>累計總參考次數</strong>為挑犧牲頁面的依據。</p>
<ul>
<li><strong>Cons</strong>
<ul>
<li><strong>「Page fault reatio」相當高。</strong></li>
<li><strong>有「Belady anomaly」。</strong></li>
<li><strong>製作需大量硬體支持，所以成本非常高。</strong></li>
</ul></li>
</ul>
<h6 id="least-frequently-used">Least frequently used</h6>
<p>挑選參考次數最小的分頁為犧牲品。</p>
<ul>
<li>若多個分頁具有相同值，也是以 FIFO 為準。</li>
</ul>
<h6 id="most-frequently-used">Most frequently used</h6>
<p>挑選參考次數最多的分頁為犧牲品。</p>
<ul>
<li>若多個分頁具有相同值，也是以 FIFO 為準。</li>
</ul>
<h5 id="問題與討論">問題與討論</h5>
<ul>
<li>Ex</li>
</ul>
<table>
<thead>
<tr class="header">
<th>Page</th>
<th>Loading time</th>
<th>Last reference time</th>
<th>Reference bit</th>
<th>Modification bit</th>
<th>參考次數</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Page 1</td>
<td>493</td>
<td>800</td>
<td>0</td>
<td>0</td>
<td>410</td>
</tr>
<tr class="even">
<td>Page 2</td>
<td>172</td>
<td>700</td>
<td>1</td>
<td>1</td>
<td>235</td>
</tr>
<tr class="odd">
<td>Page 3</td>
<td>333</td>
<td>430</td>
<td>0</td>
<td>1</td>
<td>147</td>
</tr>
<tr class="even">
<td>Page 4</td>
<td>584</td>
<td>621</td>
<td>1</td>
<td>0</td>
<td>875</td>
</tr>
<tr class="odd">
<td>Page 5</td>
<td>256</td>
<td>564</td>
<td>0</td>
<td>1</td>
<td>432</td>
</tr>
</tbody>
</table>
<p>則下面各法則之犧牲頁面為何？</p>
<ul>
<li>FIFO：Page 2</li>
<li>LRU：Page 3</li>
<li>Second chance：<del>Page 1</del> Page 5
<ul>
<li><strong>要從最早載入( FIFO )的開始檢查。</strong></li>
</ul></li>
<li>Enhanced second chance：<del>Page 1</del> Page 1
<ul>
<li><strong>以 ＜Reference bit, Modification bit＞ 配對值作為挑選犧牲頁面的依據。</strong></li>
</ul></li>
<li>LFU：Page 3</li>
<li>MFU：Page 4</li>
</ul>
<h4 id="page-buffering-機制">Page buffering 機制</h4>
<p>挑選出犧牲頁面後，如果該分頁被<strong>修改</strong>過，則會</p>
<ol type="1">
<li><strong>將犧牲頁面 Swap out 至硬碟之中。</strong></li>
<li><strong>載入「Lost page」。</strong></li>
<li><strong>讓 Process 恢復執行。</strong></li>
</ol>
<p>而以上處理的時間過於冗長，導致 Process 要恢復執行所需的時間拖太久而欲趕改善。</p>
<h5 id="free-frame-pool">Free frame pool</h5>
<p>( 作業系統的預留頁框，平常不配置給 Process 所用 )</p>
<ul>
<li><strong>主要由作業系統維護。</strong></li>
<li>當作業系統挑到<strong>曾修改過之分頁</strong>之後：
<ol type="1">
<li><strong>作業系統從「Free frame pool」中取出一個 Free frame，提供 Lost page 載入。</strong></li>
<li><strong>載入完成之後，Process 即可恢復執行。</strong></li>
<li>作業系統稍後將犧牲頁面寫回硬碟，空出之頁框<strong>再還給作業系統，加入「Free frame pool」之中</strong></li>
</ol></li>
</ul>
<figure>
<img src="\willywangkaa\images\freefreampool.png" alt="freefreampool" /><figcaption aria-hidden="true">freefreampool</figcaption>
</figure>
<h5 id="modification-list">Modification list</h5>
<ul>
<li>作業系統維護一條<strong>「Modification list」，記錄所有曾被修改過的分頁資訊 ( 即為Modification bit 值 = 1 )</strong>
<ul>
<li>作業系統等到「Paging I/O device」利用度低時 ( 裝置閒置；有空 )，將此串列中某些分頁寫回硬碟之中，<strong>同時自此串列移除這些分頁，接著重設該「Modification bit」為 0。</strong></li>
<li>可以使選擇犧牲分頁時，<strong>會有較小的機率選到曾被修改過的分頁</strong>，也就能讓 Process 有較高的機會可以快速的恢復執行。</li>
</ul></li>
</ul>
<h5 id="強化-free-frame-pool">☆ 強化 Free frame pool</h5>
<p><strong>以「Free frame pool」為基礎，針對 Pool 中每一個頁框記錄放的是哪個 Process 的哪個分頁</strong> ( ＜Process ID, Page No.＞ )，因為這些分頁內容必定為最新值 ( 該值與存於硬碟中的值目前<strong>同調</strong> )。</p>
<ul>
<li>流程
<ol type="1">
<li>作業系統選擇完犧牲頁面之後 ( 該頁面曾被修改過 )。</li>
<li><strong>作業系統在「Free frame pool」中尋找有無該需要的「Lost page」存在，</strong><br><strong>（a）若存在</strong>則直接將該頁框加入至「Resident frame pool」之中，Process 即可恢復執行 ( <strong>不需任何一次的硬碟的 I/O 傳輸</strong> )。<br><strong>（b）若不存在</strong>則再<strong>從硬碟取出該分頁寫入至「Free frame pool」</strong>並將該頁框加入至「Resident frame pool」中(<strong>需一次的硬碟的 I/O 傳輸</strong>)。</li>
<li>當作業系統將犧牲分頁寫回 ( Swap back ) 至硬碟之後，再將該頁框加入至「Free frame pool」中。</li>
</ol></li>
</ul>
<h5 id="問題與討論-1">問題與討論</h5>
<ul>
<li><p>Ex (P. 8-90 ex89)</p></li>
<li><p>舉例說明 LFU 之「Page fault」次數<strong>少於</strong> LRU 的可能。</p>
<ul>
<li>給三個頁框一開始為空。</li>
</ul></li>
<li><p>舉例說明 LFU 之「Page fault」次數<strong>多於</strong> LRU 的可能。</p>
<ul>
<li>給三個頁框一開始為空。</li>
</ul></li>
</ul>
<h4 id="頁框數量分配多寡之影響">頁框數量分配多寡之影響</h4>
<ul>
<li><p>一般而言，Process 分配到的頁框數增加，<em>其「Page fault ratio」理應下降</em>。</p></li>
<li><p><strong>作業系統分配 Process 頁框數量時，必須滿足最少及最多數量限制</strong>。( 由硬體限制，作業系統無權 )</p>
<ul>
<li><p><strong>最大數量限制</strong></p>
<ul>
<li>實際頁框多寡( 實體記憶體大小 )</li>
</ul></li>
<li><p><strong>最少數量限制</strong></p>
<ul>
<li><strong>CPU 在「完成機器指令執行過程中」，可能最多對 RAM 讀寫的次數。</strong>( 否則 CPU 在讀取機器指令階段可能永遠無法完成。若讀寫需 3 次，則配給所有 Process 至少要 3 個頁框 )</li>
<li>Ex</li>
</ul>
<p><strong>假設指令的存取不需跨頁面。</strong></p>
<p><strong>存在於記憶體的運算元採用直接定址模式</strong></p>
<p>則最多可能需要幾次的記憶體存取？ 3 次，<strong>則作業系統至少要給 Process 頁框數量大於等於三</strong>。</p>
<ul>
<li>Ex</li>
</ul>
<p><strong>假設指令的存取需跨頁面。</strong></p>
<p><strong>存在於記憶體的運算元採用間接定址模式</strong></p>
<p>則最多可能需要幾次的記憶體存取？ 6 次，<strong>則作業系統至少要給 Process 頁框數量大於等於六</strong>。</p></li>
</ul></li>
</ul>
<h3 id="thrashing-現象">Thrashing 現象</h3>
<figure>
<img src="\willywangkaa\images\thrashing.png" alt="thrashing" /><figcaption aria-hidden="true">thrashing</figcaption>
</figure>
<p><strong>若 Process 分配到的頁框不足時，</strong>則此 Process 會經常「Page fault」，所以作業系統要作 Page replacement，若作業系統採用「Global replacement policy」，可能會挑選到其他 Process 所把持的頁框當作犧牲頁面，而如此一來也會造成其他 Process page fault 使得其他 Process 也發生 Page fault，最後又去搶奪其他 Process 的頁框來使用，導致所有 Process 皆發生 Page fault 且<strong>等待 Paging I/O 裝置運作完成 ( Swap out / Swap in )，此時 CPU 利用度下降，作業系統會企圖調高「Multiprogramming degree」</strong>，將導入更多 Process 進入執行，<strong>但是記憶體原本就不夠，</strong>所以這些 Process 也立刻發生「Page fault」，而作業系統又在調高「Multiprogramming degree」，<strong>不斷循環下去</strong>，此時系統呈現：</p>
<ul>
<li><strong>CPU 利用度急速下降。</strong></li>
<li><strong>Paging I/O 設備異常忙碌。</strong></li>
<li><strong>Processes 花在 Page fault process time ( Blocked state )遠大於正常執行時間 ( Running state )。</strong></li>
</ul>
<h4 id="解決與預防-thrashing">解決與預防 Thrashing</h4>
<h5 id="decrease-multiprogramming-degree---解決">Decrease multiprogramming degree - 解決</h5>
<p>當 Thrashing 發生時，作業系統必須將「Multiprogramming degree」降低。</p>
<ul>
<li>選擇低優先權或完成度低的 Process 作 Swap out。</li>
</ul>
<h5 id="使用-page-fault-frequency-control-機制---預防">使用 Page fault frequency control 機制 - 預防</h5>
<figure>
<img src="\willywangkaa\images\pagefaultfrequencycontrol.png" alt="pagefaultfrequencycontrol" /><figcaption aria-hidden="true">pagefaultfrequencycontrol</figcaption>
</figure>
<p>使用 <strong>Page fault frequency contro</strong>l 機制，來防止 Thrashing 發生。</p>
<ul>
<li><strong>作業系統會制定合理的「Process page fault ratio 上限與下限」</strong>
<ul>
<li>作業系統如果發現 Process 的「Page fault ratio」
<ul>
<li><strong>高於「上限值」</strong>：作業系統應該多<strong>分配一些額外的頁框給該 Process，降低其「Page fault ratio」回到合理的區間。</strong></li>
<li><strong>低於「下限值」</strong>：作業系統應該<strong>收回一些該 Process 的頁框，分配給其他有需要之 Process 。</strong></li>
</ul></li>
<li><strong>若作業系統能夠控制所有 Process 之「Page fault ratio」在合理的區間，則理當不會發生「Thrashing」。</strong></li>
</ul></li>
</ul>
<h5 id="working-set-model-技術">☆Working set model 技術</h5>
<p>運用 Working set model 技術預估 Process 在不同時間執行時，所需之頁框數量，作業系統根據此資訊，分配 Process 足夠的數量，以防止 Thrashing。</p>
<p>此技術是基於「Locality model」( 集中模型 )之理論基礎之上。</p>
<figure>
<img src="\willywangkaa\images\workingsetwindow.png" alt="workingsetwindow" /><figcaption aria-hidden="true">workingsetwindow</figcaption>
</figure>
<ul>
<li><p>相關名詞解釋</p>
<ul>
<li>Working set window：<span class="math inline">\(\Delta\)</span>
<ul>
<li>表示以「<span class="math inline">\(\Delta\)</span> 次的 Page reference」作為依據參考。</li>
</ul></li>
<li>Working set
<ul>
<li>在「<span class="math inline">\(\Delta\)</span> 次的 Page Reference 」中<strong>所「Reference」到不同分頁之集合。</strong></li>
</ul></li>
<li>Working set size ( WSS )
<ul>
<li>Working set 之「元素個數」。</li>
<li><strong>代表 Process 此時所需要頁框數量。</strong></li>
</ul></li>
</ul></li>
<li><p><strong>☆☆ 作業系統應用的方法</strong></p>
<ul>
<li>假設 <em>n</em> 為 Processes 個數。</li>
<li><span class="math inline">\(WSS_i\)</span><strong>：</strong><span class="math inline">\(Process_i\)</span> <strong>在此時期的「Working set size」。</strong></li>
<li><strong>求</strong> <span class="math inline">\(D = \sum_{i = 1}^n WSS_i = 頁框的總需求量\)</span> ( Demand )。<br><strong>令 M = 實際記憶體頁框的總數</strong>
<ul>
<li><strong>若</strong><span class="math inline">\(D \leq M\)</span><strong>：則作業系統可以依照</strong> <span class="math inline">\(WSS_i\)</span> <strong>之值分配給</strong> <span class="math inline">\(P_i\)</span> <strong>足夠的頁框數量，也不會造成 Thrashing。</strong></li>
<li><strong>若</strong><span class="math inline">\(D &gt; M\)</span><strong>：則作業系統會選擇一些 Process 並對他們作「Swap out」，以降低 D 直到</strong> <span class="math inline">\(D \leq M\)</span> <strong>為止</strong>，作業系統再進行分配頁框。</li>
</ul></li>
</ul></li>
<li><p>Pros</p>
<ul>
<li>可以防止「Thrashing」。</li>
<li>對於「Prepaging」有助益：<strong>事先猜測哪些資源 Process 會使用到哪些分頁，並預先載入至記憶體之中，如果猜測精準，則可以避免初期之大量「Page fault」</strong>。</li>
</ul></li>
<li><p>Cons</p>
<ul>
<li>不易制定精確的「Working set」。</li>
<li>若前後期的「Working sey」內容分頁差異很大，則 I/O 次數會上升。</li>
</ul></li>
<li><p><strong>Ex (P.8-58 39)</strong></p>
<ul>
<li>下列狀況增加「Multiprogramming degree」是否有助於提高「CPU utilization」？
<ul>
<li>（1）CPU 利用度：13%、硬碟利用度：97%</li>
<li>（2）CPU 利用度：87%、硬碟利用度：3%</li>
<li><strong>（3）</strong>CPU 利用度：13%、硬碟利用度：3%</li>
</ul></li>
</ul></li>
</ul>
<p>（1）<strong>(thrashing)</strong>、（2）維持現狀；</p>
<ul>
<li><strong>Ex (P.8-63 49)</strong>
<ul>
<li>CPU 利用度：20 %</li>
<li>Paging disk：97 %</li>
<li>下列哪些措施<strong>必 ( will )、可能 ( is likely to )、絕不 ( never ) 增進 CPU 的利用度？</strong>
<ul>
<li>（1）Increase multiprogramming degree</li>
<li>（2）Decrease multiprogramming degree</li>
<li>（3）Install <em>faster CPU</em></li>
<li>（4）Install more main memory</li>
<li>（5）Install bigger disk</li>
<li>（6）Install faster disk</li>
<li>（7）Local replacement policy used</li>
<li>（8）Prepaging used</li>
<li>（9）Use bigger page size</li>
<li>（10）Use smaller page size</li>
</ul></li>
</ul></li>
</ul>
<p>目前正在「Thrashing」：</p>
<p><strong>(will)</strong></p>
<p>(2)；(4)；(9)</p>
<p><strong>(is likely to)</strong></p>
<p>(6)：<strong>因為 Page fault process time 可以降低</strong>；<strong>(7)</strong>；<strong>(8)</strong></p>
<p><strong>(never)</strong></p>
<p>(1)；(3)；(5)；<strong>(10)：更差</strong></p>
<ul>
<li>Example（106清華大學資工計算機系統）
<ul>
<li>Is it possible for a process to have two working sets, one representing data and another representing code? Explain your answer.</li>
</ul></li>
</ul>
<p>「Working set」是由多個<strong>正在執行的</strong>「Virtual memory page」組成，<strong>且並不包含不用執行的「Page」</strong>，所以不可能有兩個「Working set」分別記錄「Data」與「Code」</p>
<h6 id="locality-model">☆Locality model</h6>
<blockquote>
<figure>
<img src="\willywangkaa\images\localittmodel.png" alt="localittmodel" /><figcaption aria-hidden="true">localittmodel</figcaption>
</figure>
<p>Process 執行時，對於所存取之「記憶體區塊」，<strong>並非是均勻的，而是具有某種 局部/集中 區域存取之特性。</strong></p>
<ul>
<li>Temporal locality ( 時間局部性 )
<ul>
<li>目前所存取的區域<strong>不久後</strong>又會再度被存取。( <strong>或者是此區域在最近經常被存取</strong>，如上圖所示 )</li>
<li>可能導致的因素
<ul>
<li><strong>Loop 敘述</strong></li>
<li><strong>Subroutine ( function, pure code... )：常被使用的一段程式碼片段。</strong></li>
<li><strong>Counter ：經常存取之變數。</strong></li>
<li><strong>Stack</strong>：頂端之元素。</li>
</ul></li>
</ul></li>
<li>Spatial locality ( 空間區域性 )
<ul>
<li>目前所存取區域<strong>之鄰近區域</strong>也極有可能被再次存取。</li>
<li><strong>可能導致的因素</strong>
<ul>
<li><strong>陣列</strong></li>
<li><strong>Sequential code execution ( 鄰近程式碼 )</strong></li>
<li><strong>Common data area ( 集中的共享變數 )</strong></li>
<li>Linear search</li>
<li><strong>Vector 的運算</strong> ( 早期將向量視為陣列 )</li>
</ul></li>
</ul></li>
</ul>
<p>只要 Program 中用到的指令、資料結構、演算法符合「Locality model」，<strong>則此程式對於記憶體是友善的 ( Page fault ratio 應下降 )</strong>；若不符合則對記憶體不友善。</p>
<ul>
<li><strong>不友善的因素</strong>
<ul>
<li><strong>Hashing：希望資料不要靠太近，會發生碰撞。</strong></li>
<li><strong>Binary search：會在記憶體跳來跳去。</strong></li>
<li><strong>Link list</strong></li>
<li><strong>goto , jump 指令</strong></li>
<li><strong>間接定址模式：會容易跨頁面存取。</strong></li>
</ul></li>
<li>Ex (p.8-55 ex32)</li>
</ul>
</blockquote>
<h6 id="page-size-的影響">Page size 的影響</h6>
<blockquote>
<ul>
<li>若 Page size <strong>愈小</strong>，則
<ul>
<li>Pros
<ul>
<li><strong>Page fault ratio ( 效能的關鍵，一旦發生「Page fault」必須要執行「Swap」 )</strong>：越大<br>(因為跨不同分頁的機率增加)</li>
<li>Page table size：愈大</li>
<li>I/O 次數 ( Total time )：<strong>增加</strong> ( 因為會有更多頁面需要載入 )</li>
</ul></li>
<li>Cons
<ul>
<li>內部碎裂：<strong>輕微</strong></li>
<li>I/O Transfer time ：越小 ( 因為單一頁面小，I/O的<strong>傳輸量</strong>就可以降低 )</li>
<li><strong>Locality：越佳</strong></li>
</ul></li>
</ul></li>
</ul>
<p><strong>＜主流趨勢＞</strong> 朝向大的 Page size 設計。</p>
</blockquote>
<h3 id="program-structure-對於記憶體存取之影響">Program structure 對於記憶體存取之影響</h3>
<figure>
<img src="\willywangkaa\images\workingset.png" alt="workingset" /><figcaption aria-hidden="true">workingset</figcaption>
</figure>
<ul>
<li><p>若 Program 中使用的指令、資料結構、演算法符合「Locality model」，則有助於降低「Page fault ratio」。</p>
<ul>
<li>反之，則無助於降低「Page fault ratio」。</li>
</ul></li>
<li><p><strong>程式中對於陣列元素的處理程序最好與陣列元素在記憶體中的儲存方式 ( Row-major 或 Column-major )對應，有助於降低「Page fault ratio」</strong></p></li>
<li><p>Ex</p>
<ul>
<li><p>A：array [1... 128, 1 ... 128] of int</p></li>
<li><p>每個 int 佔有 1 B</p></li>
<li><p>A 以 Row-major 方式存於記憶體中</p></li>
<li><p>Page size = 128 B</p></li>
<li><p>給該 Process 三個頁框，且程式已經在記憶體之中，採用 FIFO replacement policy 求下列程式碼的「Page fault」次數。</p></li>
<li><p>（1）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (i = 1 to 128) &#123;</span><br><span class="line">    for (j = 1 to 128) &#123;</span><br><span class="line">        A[i, j] = 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>每一列發生 1 次「Page fault」，共 128 列，所以總共發生 128 次「Page fault」。</p>
<ul>
<li><p>（2）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (j = 1 to 128) &#123;</span><br><span class="line">    for (i = 1 to 128) &#123;</span><br><span class="line">        A[i, j] = 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>每一行發生 128 次「Page fault」，共 128 行，所以總共發生 128 <span class="math inline">\(\times\)</span> 128 次「Page fault」。</p></li>
<li><p>Ex</p>
<ul>
<li><p>A：array [1... 100, 1 ... 100] of int</p></li>
<li><p>每個 int 佔有 1 B</p></li>
<li><p>A 以 Row-major 方式存於記憶體中</p></li>
<li><p>Page size = 200 B</p></li>
<li><p>給該 Process 三個頁框，且程式已經在記憶體之中，採用 <strong>LRU</strong> replacement policy 求下列程式碼的「Page fault」次數。</p></li>
<li><p>（1）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (i = 1 to 100) &#123;</span><br><span class="line">    for (j = 1 to 100) &#123;</span><br><span class="line">        A[i, j] = 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>每兩列發生 1 次「Page fault」，共 100 列，所以總共發生 100 / 2 次「Page fault」。</p>
<ul>
<li><p>（2）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (j = 1 to 100) &#123;</span><br><span class="line">    for (i = 1 to 100) &#123;</span><br><span class="line">        A[i, j] = 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>每一行發生 100 / 2 次「Page fault」，共 100 行，所以總共發生 50 <span class="math inline">\(\times\)</span> 100 次「Page fault」。</p></li>
</ul>
<h3 id="copy-on-write">Copy-on-write</h3>
<p>主要談論到三種 <code>fork()</code> 的差異。</p>
<figure>
<img src="\willywangkaa\images\copyonwrite.png" alt="copyonwrite" /><figcaption aria-hidden="true">copyonwrite</figcaption>
</figure>
<ul>
<li><code>fork()</code> without「copy-on-write」
<ul>
<li>Parent process 使用 <code>fork()</code> 建立 child process，<strong>作業系統會配置新頁框給予 Child process</strong>。( Child 與 parent 占用不同的記憶體空間 )</li>
<li><strong>同時，作業系統會複製 Parent process 內容( Code section, data section )給 Child process。</strong></li>
<li>Cons
<ul>
<li><strong>記憶體頁框需求量大增。( 與 Parent process 頁框一致 )</strong></li>
<li><strong>建立 Child process 的時間慢。</strong>( 需複製 Parent process 資料 )</li>
<li>☆ <strong>在 Child 生出之後立即執行</strong> <code>execkp()</code> <strong>作其他的工作時，更加顯得不必要作上面兩件事。</strong></li>
</ul></li>
</ul></li>
<li><code>fork()</code> with「copy-on-write」
<ul>
<li>當 Parent process 建立 Child process 時，<strong>作業系統讓 Child 一開始共享 Parent process 之記憶體頁框空間，所以不需要配置給 Child process 新的頁框與複製 Parent 的內容給 Child process。</strong></li>
<li><strong>若 Child process 想要更改某分頁的內容，則作業系統會配置一個新的分頁給 Child ，且複製該分頁內容到新頁框中( 並修改 Child 的分頁表指向新頁框 )，供 Child 使用與修改，</strong>就不會影響 Parent process 的資料。</li>
<li>有可能會修改 ( modified ) 的 分頁需標示「copy-on-write bit」為 1。<br>( Read-only code / data 無須標示 )</li>
<li>Pros
<ul>
<li><strong>可降低頁框需求量</strong><br />
</li>
<li><strong>加速 Process 的建立。</strong></li>
</ul></li>
</ul></li>
<li><code>vfork()</code> ( Virtual memory <code>fork()</code> )
<ul>
<li>Parent process 建立 Child process 時，<strong>Child process 會共享 Parent process 相同的頁框，但是並無提供「Copy-on-write 技術」，所以任何一方改變了某分頁內容會使另一方受到影響。( 須小心使用 )</strong></li>
<li><strong>特別適合用於 Child process 的建立是要立刻執行</strong> <code>execlp()</code> <strong>要去作其他工作時</strong>，只需要將 Child process 的分頁表指向新頁框的位址即可讓效率提升。</li>
<li>通常用於
<ul>
<li>Command interpreter 的製作。( UNIX shell )</li>
</ul></li>
</ul></li>
</ul>
<h3 id="tlb-reach">TLB reach</h3>
<p>經由 TLB 的對應，所能存取到的「記憶體空間」大小，則「TLB reach」愈大愈好。 <span class="math display">\[
TLB \; reach = TLB \;entry \;數量 \times Page \;size
\]</span></p>
<ul>
<li>Ex
<ul>
<li>TLB 有 8 個 entry</li>
<li>Page size = 16 kB</li>
</ul></li>
</ul>
<p>TLB reach = 128 kB</p>
<ul>
<li>增加「TLB reach」的方式
<ul>
<li>提高 TLB entry 數量
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>TLB reach 增加</strong></li>
<li><strong>TLB hit ratio 提高</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>價格成本高</strong></li>
<li>有時候 TLB entry 的提升仍不足以涵蓋 Process 的「Working set」</li>
</ul></li>
</ul></li>
<li>增加「Page size」
<ul>
<li>Pros
<ul>
<li><strong>TLB reach 增加</strong></li>
<li><strong>成本可以接受</strong></li>
</ul></li>
<li>Cons
<ul>
<li><strong>內部碎裂愈嚴重</strong> <br>解決方法：現代的硬體均會<strong>提供不同大小的分頁( multiple page size )</strong>來使用；<br>E.g. 提供 2 組不同大小的「Page size」 - 4 kB、2 kB<br>所以 TLB 的紀錄項目就會增加一個「Page/Frame size」的欄位紀錄；<br>此外，目前 TLB 的管理從<strong>硬體</strong>改成<strong>作業系統管理</strong>，雖然會因為<strong>中斷使效能降低，但獲得的好處可以抵消。</strong></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Virtual Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System - Process Synchronization 1</title>
    <url>/willywangkaa/2018/07/10/Operating-System-Process-Synchronization/</url>
    <content><![CDATA[<h1 id="process-synchronization-process-communication-inter-process-communication">Process Synchronization ( Process Communication, Inter Process Communication )</h1>
<hr />
<ul>
<li>Synchronization
<ul>
<li>Process 因為「某件事情」的已發生或是未發生( 有多個 process 相互合作的時候 )，導致必須等待該事件完成或發生才得以繼續進行。</li>
</ul></li>
</ul>
<h2 id="process-communication">Process Communication</h2>
<h3 id="shared-memory">Shared memory</h3>
<figure>
<img src="\willywangkaa\images\1530175318032.png" alt="1530175318032" /><figcaption aria-hidden="true">1530175318032</figcaption>
</figure>
<p>Process 透過對共享變數 ( Shared variables ) 之存 ( Write )、取 ( Read )，達到構通 ( Infomation exchange ) 的目的。</p>
<ul>
<li><strong>分析</strong>
<ol type="1">
<li>適用於<strong>大量資料( Data, Message )</strong>傳輸的狀況。</li>
<li>因為<strong>不須 Kernel 的介入干涉</strong>，因此傳輸速度<strong>較快</strong>。</li>
<li>不適用在分散式系統( distributed system )。</li>
<li>Kernel 不須提供額外的支援( 最多就只供應共享的記憶體空間 Shared memory space )，<strong>而所有的控制都交付給 Programmer 自行負擔，必須撰寫額外的控制碼防止 Race condition 發生。</strong></li>
</ol></li>
</ul>
<h3 id="message-passing">Message passing</h3>
<p>Process 雙方要溝通必須要遵循以下步驟</p>
<ol type="1">
<li><strong>建立 Communication link。</strong></li>
<li><strong>訊息可雙向傳輸。</strong></li>
<li><strong>傳輸完畢，釋放 Communication link。</strong></li>
</ol>
<ul>
<li><strong>分析</strong>
<ol type="1">
<li>適用於<strong>少量資料( Data, Message )</strong>傳輸的狀況。</li>
<li>因為<strong>須要 Kernel 的介入干涉</strong>，因此傳輸速度<strong>較慢</strong>。</li>
<li><strong>適用在分散式系統( Distributed system )。</strong></li>
<li>Kernel 必須提供額外的支援( <strong>如：System call of send/receive, Management of communication link, Detection of message lost, 例外狀況的處理</strong> )，而所有的通訊控制都交付給作業系統。</li>
</ol></li>
</ul>
<h2 id="race-condition-problem-in-memory-communication">Race Condition Problem in Memory Communication</h2>
<p>在利用共享記憶體作為通訊橋梁時，若未對共享變數存取提供<strong>任何互斥存取控制之同步( Synchronization )機制，會因為 Processes 之間的交錯執行而導致前後順序不同，進而造成共享變數的最終結果有所不同，</strong>這種<strong>資料不一致( Data inconsistency )的情型</strong>，稱為 Race condition。</p>
<ul>
<li><span class="math inline">\(Ex .\)</span>
<ul>
<li>C 為共享變數且初值為 5。</li>
<li>兩個 Processes <span class="math inline">\(P_i, P_j\)</span>，分別程式碼如下。</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P_i</span></span><br><span class="line">...</span><br><span class="line">C = C + <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P_j</span></span><br><span class="line">...</span><br><span class="line">C = C - <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(P_i, P_j\)</span> 個執行一次則 <strong>C 的最終值可能是 5 或 4 或 6。</strong></p>
<ul>
<li>正常結束( No race condition ) ：5</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// processing flow</span></span><br><span class="line">c = c + <span class="number">1</span> <span class="comment">// P_i</span></span><br><span class="line">c = c - <span class="number">1</span> <span class="comment">// P_j</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//processing flow</span></span><br><span class="line">c = c - <span class="number">1</span> <span class="comment">// P_j</span></span><br><span class="line">c = c + <span class="number">1</span> <span class="comment">// P_i</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Race condition：4</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// assembly processing flow</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">load c; <span class="comment">// c == 5</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">load c; <span class="comment">// c == 5</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">process c = c + <span class="number">1</span>; <span class="comment">// c == 6</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">process c = c - <span class="number">1</span>; <span class="comment">// c == 4</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">restore to c; <span class="comment">// c == 6</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">restore to c; <span class="comment">// c == 4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Race condition：6</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// assembly processing flow</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">load c; <span class="comment">// c == 5</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">load c; <span class="comment">// c == 5</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">process c = c + <span class="number">1</span>; <span class="comment">// c == 6</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">process c = c - <span class="number">1</span>; <span class="comment">// c == 4</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">restore to c; <span class="comment">// c == 4</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">restore to c; <span class="comment">// c == 6</span></span><br></pre></td></tr></table></figure>
<ul>
<li><span class="math inline">\(Ex 1.\)</span> x、y 是共享變數，初值各別為 5, 7 ，有兩個 process <span class="math inline">\(P_i, P_j\)</span> 分別程式碼如下。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P_i</span></span><br><span class="line">...</span><br><span class="line">x = x + y;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P_j</span></span><br><span class="line">...</span><br><span class="line">y = x * y;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(P_i, P_j\)</span> 各作一次，求 (x, y) 可能的值？</p>
<ul>
<li>(12, 84)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// processing flow</span></span><br><span class="line">x = x + y;</span><br><span class="line">y = x * y;</span><br></pre></td></tr></table></figure>
<ul>
<li>(40, 35)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// processing flow</span></span><br><span class="line">y = x * y;</span><br><span class="line">x = x + y;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>★ (12, 35)</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// assembly processing flow</span></span><br><span class="line"><span class="comment">// P_1</span></span><br><span class="line">load x, y; <span class="comment">// x = 5, y = 7</span></span><br><span class="line"><span class="comment">// P_2</span></span><br><span class="line">load x, y; <span class="comment">// x = 5, y = 7</span></span><br><span class="line"><span class="comment">// P_1</span></span><br><span class="line">process x = x + y;</span><br><span class="line">restore to x;</span><br><span class="line"><span class="comment">// P_2</span></span><br><span class="line">process y = x * y;</span><br><span class="line">restore to y;</span><br></pre></td></tr></table></figure>
<ul>
<li><span class="math inline">\(Ex 2.\)</span> x 是共享變數<strong>初值等於零</strong> ， i 為<em>區域變數</em>，另外有兩個 process <span class="math inline">\(P_i, P_j\)</span> 分別程式碼如下。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P_i</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ )</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P_j</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ )</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(P_i, P_j\)</span> 各作一次，求 x 可能的值( <strong>可能的最小值、可能的最大值</strong> )？</p>
<ul>
<li>先拆解 for loop</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析若為最小值的狀況：3。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// assembly processing flow</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">load x; <span class="comment">// x = 0</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">load x; <span class="comment">// x = 0</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">restore x; <span class="comment">// x = 1</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">restore x; <span class="comment">// x = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">load x; <span class="comment">// x = 1</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">load x; <span class="comment">// x = 1</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">restore x; <span class="comment">// x = 2</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">restore x; <span class="comment">// x = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">load x; <span class="comment">// x = 2</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">load x; <span class="comment">// x = 2</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">restore x; <span class="comment">// x = 3</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">restore x; <span class="comment">// x = 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>正常結束：6</p></li>
<li><p>所以 x 的值會介於在 3 ～ 6 之間，都是有可能會出現的狀況。</p></li>
<li><p><span class="math inline">\(Ex 3.\)</span> x 是共享變數<strong>初值等於零</strong> ， i 為<em>區域變數</em>，另外有兩個 process <span class="math inline">\(P_i, P_j\)</span> 分別程式碼如下。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P_i</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ )</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P_j</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ )</span><br><span class="line">    x = x - <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(P_i, P_j\)</span> 各作一次，求 x 可能的值( <strong>可能的最小值、可能的最大值</strong> )？</p>
<ul>
<li>先拆解 for loop</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">x = x - <span class="number">1</span>;</span><br><span class="line">x = x - <span class="number">1</span>;</span><br><span class="line">x = x - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析若為最小值的狀況：-3。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// assembly processing flow</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">load x; <span class="comment">// x = 0</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">load x; <span class="comment">// x = 0</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">restore x; <span class="comment">// x = 1</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">x = x - <span class="number">1</span>;</span><br><span class="line">restore x; <span class="comment">// x = -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">load x; <span class="comment">// x = -1</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">load x; <span class="comment">// x = -1</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">restore x; <span class="comment">// x = 0</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">x = x - <span class="number">1</span>;</span><br><span class="line">restore x; <span class="comment">// x = -2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">load x; <span class="comment">// x = -2</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">load x; <span class="comment">// x = -2</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">restore x; <span class="comment">// x = -1</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">restore x; <span class="comment">// x = -3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>最大值的狀況：3。</li>
</ul>
<h3 id="解決-race-condition">解決 Race Condition</h3>
<h4 id="disable-inrerrput-針對cpu">Disable inrerrput ( 針對CPU )</h4>
<p>Process 在對共享變數存取之前，<strong>先 Disable interrupt</strong>，等到完成共享變數的存取後，<strong>才 Enable interrupt，</strong>如此一來可以保證 Process 在存取共享變數的期間 <strong>CPU 不會被搶走( Preempted )</strong>，所以這種存取的方法稱為「<strong>Atomically executed (不可分割之執行)</strong>」，所以可以防止 Race condition。</p>
<ul>
<li><span class="math inline">\(Ex.\)</span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P_i</span></span><br><span class="line">...</span><br><span class="line">disable interrupt</span><br><span class="line">C = C + <span class="number">1</span>;</span><br><span class="line">enable interrupt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P_j</span></span><br><span class="line">...</span><br><span class="line">disable interrupt</span><br><span class="line">C = C - <span class="number">1</span>;</span><br><span class="line">enable interrupt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>Pros
<ul>
<li>Simple, easy to implementation</li>
<li><strong>適用於 Uniprocessor system。(單一CPU)</strong></li>
</ul></li>
<li>Cons</li>
<li><strong>不適合用在 Multiprocessors system 中。因為只 Disable 一顆 CPU 的 Interrupt 功能無法防止 race condition ( 其他的 CPUs 上執行之 Processes 仍可以存取該共享變數 )；但若 Disable 所有 CPU 的 Interrupt 功能，雖然可以防止 Race condition，但是會導致 Multiprocessor 的效能低落( low performance，因為無法「平行執行」 )變得和 Single-processor 的環境差不多。</strong></li>
<li><strong>風險很高：因為 Disable interrupt 指應為特權指令(風險高，可能阻擋 Kernel 的插斷)，</strong>所以必須信任使用者程式在 Disable interrupt 後，在短時間內會再 Enable interrupt <strong>，不然 CPU 從此再也不會回到 Kernel 管理的狀態 ( 高風險!! )。</strong></li>
</ul>
<blockquote>
<p><strong>通常「 Disable interrupt 解決方法」不會下放給 User process，通常只存在於作業系統 Kernel 的實踐之中。</strong>( 只有作業系統開發者可以使用 )</p>
</blockquote>
<figure>
<img src="\willywangkaa\images\1530176275538.png" alt="1530176275538" /><figcaption aria-hidden="true">1530176275538</figcaption>
</figure>
<h4 id="critical-section-design-針對共享資料製作臨界區塊">Critical section design( 針對共享資料製作臨界區塊 )</h4>
<p>針對「共享變數」的存取進行管制，當 P_i 取得共享變數存取管制，在該 Process 尚未完成之期間，任何其餘 Processes 即便已取得 CPU 的使用權之下，<strong>仍無法存取共享變數</strong>。</p>
<figure>
<img src="\willywangkaa\images\1530176581925.png" alt="1530176581925" /><figcaption aria-hidden="true">1530176581925</figcaption>
</figure>
<blockquote>
<ul>
<li>Atomic operation
<ul>
<li>在多程序環境下，此指令運算時不得被中斷其運算，或者共用同一個資料區域</li>
</ul></li>
<li>Atomic transaction
<ul>
<li>由一系列資料（資料庫）活動構成，包括資料讀取與資料寫入的動作，通常這類的活動都是不可分割的（Atomic）
<ul>
<li>「Transaction」所包含的一連串活動，若無法一次全部執行完畢，則都不執行（All-or-nothing）</li>
<li>交易過程中發生錯誤造成系統當機時，這筆交易最後不會執行（Commit），以確保資料正確性</li>
</ul></li>
<li>除錯（包含「Client」與「Server」的處理）
<ul>
<li>「Server」
<ul>
<li>當程序（Process）出現<strong>錯誤終止</strong>，「Server」會分配另外一個行程來接手，但是原本程序處理的「未完成交易」會被取消，然後<strong>將數值恢復成「交易前的狀態」</strong></li>
</ul></li>
<li>「Client」
<ul>
<li>「Server」會給予「Client」每一筆交易一個時間區段，如果在時限內交易未完成，則會取消該筆交易，以預防客戶端無預警當機，造成交易一直無法完成</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li><strong>Critical section</strong>
<ul>
<li>Process 中對於共享變數進行存取的敘述集合。</li>
</ul></li>
<li><strong>Remainder section</strong>
<ul>
<li>Process 中除了 C. S. 之外的區間統稱為 Remainder section。</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Process</span><br><span class="line">repeat</span><br><span class="line">	entery section</span><br><span class="line">		</span><br><span class="line">		critical section</span><br><span class="line">		</span><br><span class="line">	exit section</span><br><span class="line">    </span><br><span class="line">		remainder section</span><br><span class="line">    	</span><br><span class="line">until false</span><br></pre></td></tr></table></figure>
<p>Critical section 的主要設計，是設計每個 Critical section 的前後 Programmer 需增加的控制碼( <strong>Entery section、Exit section</strong> )。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P_i</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Enter section</span></span><br><span class="line">...</span><br><span class="line">C = C + <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Exit section</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Remainder section</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P_j</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Enter section</span></span><br><span class="line">...</span><br><span class="line">C = C - <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Exit section</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Remainder section</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="critical-section-spinlock-busy-wiating-vs.-disable-interrupt">Critical Section ( Spinlock, Busy-wiating ) VS. Disable interrupt</h4>
<ul>
<li>Critical Section (Pros)
<ul>
<li><strong>適用於多處理器系統( Multiprocessor system )。</strong></li>
</ul></li>
<li>Critical Section (Cons)
<ul>
<li><strong>設計較為複雜。</strong></li>
<li><strong>較不適合用在單處理器系統( Uniprocessor system )。</strong></li>
</ul></li>
</ul>
<h3 id="busy-waiting-spinlock-技巧">Busy waiting ( Spinlock ) 技巧</h3>
<p>透過使用迴圈相關敘述達到<strong>讓 Process 暫時等待該共享變數。</strong></p>
<ul>
<li>Cons
<ul>
<li><strong>在 Spinlock 等待中的 Porcess 會與其他 Processes 競爭 CPU ，將得到的 CPU time 用在於空轉 ( spinlock ) 中</strong>，因此若 Process 要等待很長的時間才能離開迴圈，則這種方式較為浪費 CPU time。</li>
</ul></li>
<li>Pros
<ul>
<li><strong>若 Process 在迴圈等待的時間短( 小於「Context switching time」 )，則 Spinlock 非常有用。</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1531041864596.png" alt="1531041864596" /><figcaption aria-hidden="true">1531041864596</figcaption>
</figure>
<blockquote>
<p>恐龍課本<strong>的錯誤</strong>：因為 Critical Section 設計當中，「Entery section」中經常使用 Busy-waiting ( spinlock ) 技巧，而課本將 Busy-waiting ( Spinlock ) 與 Critical Section 視為相同，<strong>進而與 Disable interrupt 比較( 應是 Busy waiting 與 Non-busy waiting 來比較 )</strong>。</p>
</blockquote>
<h3 id="non-busy-waiting-技巧">Non-busy waiting 技巧</h3>
<p>當 Process 因為同步事件( Synchronization event )被長時間卡住，<strong>則可以使用 Block system call 將該 Process 送入 Blocked state，所以不會與其他 Process 競爭 CPU ，直到該事件觸動了，才會喚醒 ( Wake up system call ) 該 Process 移至 Ready state</strong>。</p>
<ul>
<li><strong>Pros</strong>
<ul>
<li><strong>等待中的 Process 不會與其他 Process 不會浪費 CPU time。</strong></li>
</ul></li>
<li><strong>Cons</strong>
<ul>
<li><strong>需額外付出「Context switching time」。</strong></li>
</ul></li>
</ul>
<h3 id="critical-section-design">Critical Section Design</h3>
<ul>
<li><strong>關鍵性質</strong>
<ul>
<li><strong>Mutual exclution：在任何時間點最多只允許一個 Process 進入它的 C.S. ，不可以有多個 Processes 分別進入各自的 C.S.。</strong></li>
<li><strong>Progress：不想進入 C.S. 的 Process ( 在 R.S. 中活動的 Process )，不可阻礙( 不參與「 進入C.S.」的決策 )其他 Processes 進入 C.S.。</strong><br>「安排欲進入 C.S 的 Process」之決策，要在<strong>有限的時間中完成 ( Non-deadlock：不可以無窮等待，使得全部之 Process 皆無法進入 C.S. )。</strong>---全部 Process 都無法進入</li>
<li><strong>Bounded waiting：</strong>當有 Process 提出「進入 C.S.」之申請，等待核准的時間是有限的( 防止該 Process 出現 Starvation 的情形 )。---單一 Process 一直無法進入<br><strong>若有 n 個 Process 欲進入 C.S. 則每個 Process 最多等待 n-1 次後即可進入 C.S.。</strong></li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 39%" />
<col style="width: 14%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th></th>
<th><strong>著重於</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>高階( 位於函式庫中 )</td>
<td><strong>Monitor</strong></td>
<td>同步問題之解決</td>
<td></td>
</tr>
<tr class="even">
<td>中階( 通常於 System call )</td>
<td><strong>Semaphore</strong></td>
<td>同步問題之解決</td>
<td></td>
</tr>
<tr class="odd">
<td>基礎建設( 作業系統核心製作 )</td>
<td><strong>Software solutions、Hardware instrustions support</strong></td>
<td>C.S. 設計的正確與否</td>
<td><strong>Disable interrupt </strong> 也在基礎建設</td>
</tr>
</tbody>
</table>
<h4 id="software-solutions">Software Solutions</h4>
<h5 id="兩個-processes-之-critical-section-design">兩個 Processes 之 critical section design</h5>
<p>有兩個 Process <span class="math inline">\(P_i, P_j\)</span>。</p>
<h6 id="algorithm-1-fall-權力層面">Algorithm 1 ( Fall )：權力層面</h6>
<ul>
<li>共享變數：<strong>Turn：int，值恰為 i 或是 j 值。</strong>
<ul>
<li><strong>視為一種權力的象徵，當 turn 值為 i 時 <span class="math inline">\(P_i\)</span> 始得 進入 C.S. 的權力，且只能讓 <span class="math inline">\(P_i\)</span> 下一個進入 C.S. ，反之亦然。</strong></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line"><span class="function">Repeat</span></span><br><span class="line"><span class="function">	<span class="title">while</span> <span class="params">( turn != i )</span></span>; <span class="comment">// enter</span></span><br><span class="line">	C.S.</span><br><span class="line">	turn = j; <span class="comment">// leave</span></span><br><span class="line">	R.S.</span><br><span class="line">Until False</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line"><span class="function">Repeat</span></span><br><span class="line"><span class="function">	<span class="title">while</span> <span class="params">( turn != j )</span></span>; <span class="comment">//enter</span></span><br><span class="line">	C.S.</span><br><span class="line">    turn = i; <span class="comment">//leave</span></span><br><span class="line">	R.S.</span><br><span class="line">Until False</span><br></pre></td></tr></table></figure>
<p><strong>＜分析＞</strong>：</p>
<ol type="1">
<li>Mutual exclution ( OK ) ：<strong>因為 turn 值不會同時為 i 且為 j ，只會為 i 或 j 之其中一個值，所以只有 </strong><span class="math inline">\(P_i\)</span> 或 <span class="math inline">\(P_j\)</span> <strong>一個可進入 C.S. 而不會兩個同時進入。</strong></li>
<li>Progress ( FALL ) ：假設目前 <span class="math inline">\(P_i\)</span> <strong>在 R.S. ( 且</strong> <span class="math inline">\(P_i\)</span> <strong>不想進入 C.S. )，而目前的 turn = i 且 </strong><span class="math inline">\(P_j\)</span> <strong>欲進入 C.S，但是因為</strong> <span class="math inline">\(P_i\)</span> <strong>仍在 R.S. 無法交付 turn ，所以被</strong> <span class="math inline">\(P_i\)</span> <strong>阻礙進入。</strong></li>
<li>Bounded waiting ( OK ) ：<strong>證明 <span class="math inline">\(P_i\)</span> 無法連續兩次進入 C.S 之中。</strong>假設目前 turn = i，且<span class="math inline">\(P_i\)</span> 已先早於 <span class="math inline">\(P_j\)</span> 進入 C.S. 使 <span class="math inline">\(P_j\)</span> 開始等待，若 <span class="math inline">\(P_i\)</span> 離開後又想立刻想再次進入，但因為 <span class="math inline">\(P_i\)</span> 離開時會將 turn = j，使得 <span class="math inline">\(P_i\)</span> 無法再度比 <span class="math inline">\(P_j\)</span> 早進入 C.S.，這一次 <span class="math inline">\(P_j\)</span> 必定先進入之 ，<strong>所以 </strong><span class="math inline">\(P_j\)</span> <strong>最多等一次後即可進入。</strong></li>
</ol>
<h6 id="algorithm-2-fall-意願層面">Algorithm 2 ( Fall )：意願層面</h6>
<ul>
<li>共享變數：flag[ i ... j ] of Boolean。( 初值皆為 False )
<ul>
<li><span class="math inline">\(flag[i] = \left\{\begin{matrix}True \quad P_i \; 有意願進入 \; C.S.\\ False \quad P_i \; 無意願進入\; C.S. \end{matrix}\right.\)</span></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">Repeat</span><br><span class="line">	flag[i] = <span class="literal">true</span>;  <span class="comment">// 表達意願</span></span><br><span class="line">	<span class="keyword">while</span> (flag[j]); <span class="comment">// enter</span></span><br><span class="line">	C.S.</span><br><span class="line">	flag[i] = <span class="literal">false</span>; <span class="comment">// leave</span></span><br><span class="line">Until <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">Repeat</span><br><span class="line">	flag[j] = <span class="literal">true</span>;  <span class="comment">// 表達意願</span></span><br><span class="line">	<span class="keyword">while</span> (flag[i]); <span class="comment">// enter</span></span><br><span class="line">	C.S.</span><br><span class="line">	flag[i] = <span class="literal">false</span>; <span class="comment">// leave</span></span><br><span class="line">Until <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>＜Note＞</strong></p>
<ol type="1">
<li>Progress ( 造成死結 -&gt; Fall )</li>
<li>Mutual exclusion ( OK )</li>
<li>Bounded waiting ( OK )</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">flag[i] = <span class="literal">true</span>; <span class="comment">// P_i 表達意願</span></span><br><span class="line">flag[j] = <span class="literal">true</span>; <span class="comment">// P_j表達意願</span></span><br><span class="line">	<span class="keyword">while</span> (flag[j]); <span class="comment">// P_i can&#x27;t enter</span></span><br><span class="line">	<span class="keyword">while</span> (flag[j]); <span class="comment">// P_j can&#x27;t enter</span></span><br><span class="line">... <span class="comment">// Progress fall ( Deadlock )</span></span><br></pre></td></tr></table></figure>
<h6 id="algorithm-3---petersons-algorithm-ok-權力意願層面">Algorithm 3 - Peterson's Algorithm ( OK )：權力、意願層面</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"><span class="comment">// Name        : Softwaresolution.cpp</span></span><br><span class="line"><span class="comment">// Author      : willywangkaa</span></span><br><span class="line"><span class="comment">// Description : Hello World in C++, Ansi-style</span></span><br><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sharedvar = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> turn;</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> condition[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">int</span> tid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(condition[tid]) &#123;</span><br><span class="line">        <span class="keyword">double</span> delaySum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++ i )</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; ++ j )</span><br><span class="line">                delaySum += i*j;</span><br><span class="line"></span><br><span class="line">        flag[tid] = <span class="literal">true</span>;</span><br><span class="line">        turn = (tid^<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(flag[tid^<span class="number">1</span>] &amp;&amp; turn == (tid^<span class="number">1</span>)) ;</span><br><span class="line">        turn = tid;</span><br><span class="line"></span><br><span class="line">        this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">        sharedvar = tid;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Shared variable is edit by &quot;</span>&lt;&lt; sharedvar &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        flag[tid] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;thread&gt; ths;</span><br><span class="line">    turn = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        condition[i] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        ths.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(worker, i));</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    condition[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line">    condition[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (thread &amp; th : ths) &#123;</span><br><span class="line">		<span class="keyword">if</span> (th.<span class="built_in">joinable</span>())</span><br><span class="line">			th.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sharedvar &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>共享變數：flag[ i ... j ] of Boolean。( 初值皆為 False )
<ul>
<li><span class="math inline">\(flag[i] = \left\{\begin{matrix}True \quad P_i \; 有意願進入 \; C.S.\\ False \quad P_i \; 無意願進入\; C.S. \end{matrix}\right.\)</span></li>
</ul></li>
<li>共享變數：<strong>Turn：int，值恰為 i 或是 j 值。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">Repeat</span><br><span class="line">	flag[i] = <span class="literal">true</span>;                 <span class="comment">// 表達意願</span></span><br><span class="line">	turn = j;                       <span class="comment">// * enter ( 權力先給對方 )</span></span><br><span class="line">	<span class="keyword">while</span> ( flag[j] &amp;&amp; turn == j ); <span class="comment">//   enter</span></span><br><span class="line"><span class="comment">//  turn = i;                       //   enter</span></span><br><span class="line">	C.S.</span><br><span class="line"><span class="comment">//  turn = j;                       // enter ( fall )</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;                <span class="comment">// leave</span></span><br><span class="line">Until <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">Repeat</span><br><span class="line">	flag[j] = <span class="literal">true</span>;                 <span class="comment">// 表達意願</span></span><br><span class="line">	turn = i;                       <span class="comment">// *enter</span></span><br><span class="line">	<span class="keyword">while</span> ( flag[i] &amp;&amp; turn == i ); <span class="comment">//  enter</span></span><br><span class="line"><span class="comment">//  turn = i;                       //  enter</span></span><br><span class="line">	C.S.</span><br><span class="line"><span class="comment">//  turn = j;                       // enter ( fall )</span></span><br><span class="line">    flag[j] = <span class="literal">false</span>;                <span class="comment">// leave</span></span><br><span class="line">Until <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Mutual exclusion (OK)：<strong>若 </strong><span class="math inline">\(P_i, P_j\)</span> <strong>皆欲進入 C.S. 代表 </strong><code>flag[i]</code> <strong>與</strong> <code>flag[j]</code> <strong>皆為 True，當雙方皆作到</strong><code>while</code><strong>測試的時候，代表雙方已分別執行過</strong> <code>turn = i</code> <strong>以及</strong> <code>turn = j</code> <strong>的設定，差異點在於可能會交錯執行，但是</strong> <code>turn</code> <strong>必為兩值之其中一者，所以只有P_i, P_j 一個可以進入 C.S。</strong></li>
<li>Progress (OK)：
<ul>
<li>假設 turn 值目前為 i ，且 P_i 不想進入 C.S.，<strong>帶表 flag[i] = false</strong> 若此時 P_j 欲進入 C.S. ，則 P_j 必可通過 while 的關卡進入 C.S. ，所以<strong>P_i 不會阻礙 P_j 進入 C.S.。</strong></li>
<li><strong>若 P_i, P_j 皆欲進入 C.S 則在有限的時間內必可決定出</strong> <code>turn</code> <strong>值為</strong> <code>i</code> <strong>或為</strong> <code>j</code> <strong>使得 P_i, P_j 可以進入，兩者不會永遠互相等待造成死結。</strong></li>
</ul></li>
<li><strong>Bound waiting (OK)：假設 turn 為 i ， P_i 已早於 P_j 進入 C.S. 而 P_j 等待進入中，所以 flag[i] = flag[j] = true，若 P_i 離開 C.S. 後，又想再進入 C.S. ，則 P_i 必定會將</strong> <del>flag[i]=false</del> <strong>turn = j ，使得 P_i 無法再度先早於 P_j 進入 C.S. ，一定是 P_j 進入 C.S. ，所以 P_j 至多等待一次後即可進入 C.S.。</strong></li>
</ul>
<ol type="1">
<li>今有一程式如下，請問該程式是否可以正確執行，或是違反 Cirtial section 中的關鍵性值？</li>
</ol>
<p><strong>可以正確執行，只是 flag 互相對調而已。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">Repeat</span><br><span class="line">	flag[j] = <span class="literal">true</span>;                 <span class="comment">// 表達意願</span></span><br><span class="line">	turn = j;                       <span class="comment">// * enter ( 權力先給對方 )</span></span><br><span class="line">	<span class="keyword">while</span> ( flag[i] &amp;&amp; turn == j ); <span class="comment">//   enter</span></span><br><span class="line">	C.S.</span><br><span class="line">	flag[j] = <span class="literal">false</span>;                <span class="comment">// leave</span></span><br><span class="line">Until <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">Repeat</span><br><span class="line">	flag[i] = <span class="literal">true</span>;                 <span class="comment">// 表達意願</span></span><br><span class="line">	turn = i;                       <span class="comment">// *enter</span></span><br><span class="line">	<span class="keyword">while</span> ( flag[j] &amp;&amp; turn == i ); <span class="comment">//  enter</span></span><br><span class="line">	C.S.</span><br><span class="line">	flag[i] = <span class="literal">false</span>;                <span class="comment">// leave</span></span><br><span class="line">Until <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>今有一程式如下，請問該程式是否可以正確執行，或是違反 Cirtial section 中的關鍵性值？</li>
</ol>
<p><strong>可以正確執行，只是 turn 互相對調而已。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">Repeat</span><br><span class="line">	flag[i] = <span class="literal">true</span>;                 <span class="comment">// 表達意願</span></span><br><span class="line">	turn = i;                       <span class="comment">// * enter ( 權力先給對方 )</span></span><br><span class="line">	<span class="keyword">while</span> ( flag[j] &amp;&amp; turn == i ); <span class="comment">//   enter</span></span><br><span class="line">	C.S.</span><br><span class="line">	flag[i] = <span class="literal">false</span>;                <span class="comment">// leave</span></span><br><span class="line">Until <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">Repeat</span><br><span class="line">	flag[j] = <span class="literal">true</span>;                 <span class="comment">// 表達意願</span></span><br><span class="line">	turn = j;                       <span class="comment">// *enter</span></span><br><span class="line">	<span class="keyword">while</span> ( flag[i] &amp;&amp; turn == j ); <span class="comment">//  enter</span></span><br><span class="line">	C.S.</span><br><span class="line">	flag[j] = <span class="literal">false</span>;                <span class="comment">// leave</span></span><br><span class="line">Until <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>今有一程式如下，請問該程式是否可以正確執行，或是違反 Cirtial section 中的關鍵性值？</li>
</ol>
<p><strong>可以正確執行，只是 turn 與 flag 皆互相對調而已。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">Repeat</span><br><span class="line">	flag[j] = <span class="literal">true</span>;                 <span class="comment">// 表達意願</span></span><br><span class="line">	turn = i;                       <span class="comment">// * enter ( 權力先給對方 )</span></span><br><span class="line">	<span class="keyword">while</span> ( flag[i] &amp;&amp; turn == i ); <span class="comment">//   enter</span></span><br><span class="line">	C.S.</span><br><span class="line">	flag[j] = <span class="literal">false</span>;                <span class="comment">// leave</span></span><br><span class="line">Until <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">Repeat</span><br><span class="line">	flag[i] = <span class="literal">true</span>;                 <span class="comment">// 表達意願</span></span><br><span class="line">	turn = j;                       <span class="comment">// *enter</span></span><br><span class="line">	<span class="keyword">while</span> ( flag[j] &amp;&amp; turn == j ); <span class="comment">//  enter</span></span><br><span class="line">	C.S.</span><br><span class="line">	flag[i] = <span class="literal">false</span>;                <span class="comment">// leave</span></span><br><span class="line">Until <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h5 id="n-個-process-之-critical-section-design">N 個 Process 之 Critical Section design</h5>
<h6 id="bakerys-algorithm-麵包店號碼牌演算法">Bakery's Algorithm ( 麵包店號碼牌演算法 )</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"><span class="comment">// Name        : Softwaresolution.cpp</span></span><br><span class="line"><span class="comment">// Author      : willywangkaa</span></span><br><span class="line"><span class="comment">// Description : Hello World in C++, Ansi-style</span></span><br><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sharedvar = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> choosing[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> number[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">int</span> tid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> delaySum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++ i )</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; ++ j )</span><br><span class="line">			delaySum += i*j;</span><br><span class="line"></span><br><span class="line">    choosing[tid] = <span class="literal">true</span>;</span><br><span class="line">    number[tid] = *<span class="built_in">max_element</span>(number, number+<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">    choosing[tid] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(choosing[i]) (<span class="keyword">void</span>)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(number[i]&gt;<span class="number">0</span> &amp;&amp; (</span><br><span class="line">				(number[i] &lt; number[tid])</span><br><span class="line">					|| (number[i] == number[tid] &amp;&amp; i &lt; tid)</span><br><span class="line">								))</span><br><span class="line">				(<span class="keyword">void</span>)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">    sharedvar = tid;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Shared variable is edit by &quot;</span>&lt;&lt; sharedvar &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	number[tid] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;thread&gt; tharr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        choosing[i] = <span class="literal">false</span>;</span><br><span class="line">        number[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        choosing[i] = <span class="literal">false</span>;</span><br><span class="line">        tharr.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(worker, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (thread &amp; th : tharr) &#123;</span><br><span class="line">		<span class="keyword">if</span> (th.<span class="built_in">joinable</span>())</span><br><span class="line">			th.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; sharedvar &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>核心觀念：
<ol type="1">
<li>客人要先取得號碼牌才可以入店內。</li>
<li>店內一次只能有一個客人進入。</li>
<li><strong>「號碼牌最小的客人」或「號碼牌相同最小之 ID 最小的客人」，得以優先入內。</strong></li>
</ol></li>
<li>共享變數
<ul>
<li><strong>choosing: [0 ... n-1] fo boolean：初值皆為 false。</strong><br><span class="math inline">\(choose[i] = \left\{\begin{matrix}True &amp; P_i \; 正在取得號碼牌中，但尚未取得\\ False &amp; P_i \; 已取得號碼牌(init) \end{matrix}\right.\)</span></li>
<li><strong>number: [0 ... n-1] of int：初值為 0。</strong><br><span class="math inline">\(number[i] = \left\{\begin{matrix}=0 &amp; 代表 \; P_i \;無意願進入\\ &gt;0 &amp; P_i \; 有意願進入 \end{matrix}\right.\)</span></li>
</ul></li>
<li>MAX(i ... j)：從 i ... j 挑最大值。</li>
<li>(a, b) &lt; (c, d)：<strong>代表</strong><br>1. a &lt; c<br>or 2. a==c and b &lt; d</li>
<li>P_i 之程式碼</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Repeat</span><br><span class="line">	choosing[i] = <span class="literal">true</span>;</span><br><span class="line">	number[i] = <span class="built_in">Max</span>(number[<span class="number">0</span>], ... , number[n<span class="number">-1</span>]) + <span class="number">1</span> </span><br><span class="line">	choosing[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; n; j++ ) &#123;</span><br><span class="line">        <span class="keyword">while</span> (choosing[j]) <span class="keyword">do</span> no-op;  <span class="comment">// 等待P_j 取得號碼牌。</span></span><br><span class="line">        <span class="comment">//比較號碼牌與 Process ID。</span></span><br><span class="line">        <span class="keyword">while</span>(number[j]&gt;<span class="number">0</span> &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) <span class="keyword">do</span> no-op; </span><br><span class="line">    &#125;</span><br><span class="line">    C.S.</span><br><span class="line">    Number[i] = <span class="number">0</span> <span class="comment">// P_i 已無意願</span></span><br><span class="line">    R.S.</span><br><span class="line">util <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Ex1. 為何號碼牌( number[i] )會有<strong>兩個以上相同</strong>的問題？
<ul>
<li>因為在 <code>number[i] = Max(number[0], ... , number[n-1]) + 1</code> 的執行階段時，有可能會被其他 Process 搶斷。</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// number[max] = 0</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line"><span class="comment">// Processiing &quot; choosing[i] = true; &quot;</span></span><br><span class="line">Load max number[max];         <span class="comment">// number[max] = 0</span></span><br><span class="line">Process max++;</span><br><span class="line"><span class="comment">// P_j preempting</span></span><br><span class="line"><span class="comment">// Processiing &quot; choosing[j] = true; &quot;</span></span><br><span class="line">Load max number[max];         <span class="comment">// number[max] = 0</span></span><br><span class="line">Process max++;</span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">Store to number[i];           <span class="comment">// number[i] = 1</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">Store to number[i];           <span class="comment">// number[i] = 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Ex2. 證明 Critical section <strong>關鍵性值</strong>。
<ul>
<li>Mutual exclusion (OK) ：
<ul>
<li>Case1. <strong>假設號碼牌值皆不同且大於零，則具有最小號碼牌值之 Process 可以優先進入 Critical section，因為最小值必唯一，所以除了該 Process 可以進入其餘等待。</strong></li>
<li>Case2. 有多個 Processes 有相同的最小號碼牌，以 Process ID 最小者優先進入 Critical section，因為 Process ID 必唯一最小值也必定唯一，所以除了該 Process 可以進入其餘等待。<br>唯一性確保，互斥確保。</li>
</ul></li>
<li>Process (OK)：
<ol type="1">
<li>( 不想進入但不會控制其他人 )<strong>假設 P_j 不想進入 C.S. 代表 number[j] 為 0 ，若此時 P_i 欲進入 C.S.</strong> 則 <code>while(number[j]&gt;0 &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) do no-op;</code> 不會被 P_j 阻擋住。</li>
<li>( 不會造成 deadlock ) 若 P_0 ~ P_n-1 n 個 Processes 皆欲進入 C.S. 會在<strong>有限時間內必決定有一個 Process (號碼牌最小加上 ProcessID 最小)可以順利結束 for loop 進入 C.S.</strong></li>
</ol></li>
<li>Bounded waiting (OK)：<strong>假設 P_0~P_n-1 processes 皆欲進入 C.S. 令 P_i 具有最大的號碼牌等於 K ( nuber[i] = K ) 因此，其他 n-1 Process：P_j ( j!=i )，必定先早於 P_i 進入 C.S.，</strong>若 P_j 離開 C.S 後，又立刻欲進入 C.S，<strong>則 P_j 的再取得號碼牌必定大於 K，所以 P_j 不會再早於 P_i 進入 C.S. 進而可以知道 P_i 最多等待 n-1 次即可進入 C.S.。</strong></li>
</ul></li>
<li>Ex3.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Repeat</span><br><span class="line">	choosing[i] = <span class="literal">true</span>;</span><br><span class="line">	number[i] = <span class="built_in">Max</span>(number[<span class="number">0</span>], ... , number[n<span class="number">-1</span>]) + <span class="number">1</span> </span><br><span class="line">	choosing[i] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; n; j++ ) &#123;</span><br><span class="line">		~~<span class="keyword">while</span> (choosing[j]) <span class="keyword">do</span> no-op;~~  <span class="comment">// 移除這行程式碼是否還正確？請解釋。</span></span><br><span class="line">		<span class="keyword">while</span>(number[j]&gt;<span class="number">0</span> &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) <span class="keyword">do</span> no-op; </span><br><span class="line">	&#125;</span><br><span class="line">	C.S.</span><br><span class="line">	Number[i] = <span class="number">0</span>;</span><br><span class="line">	R.S.</span><br><span class="line">util <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不正確，違反「Mutual exclusion」</li>
<li>令目前 number[0 ... n-1] 所有的值皆為 0 ，今有兩 Process <span class="math inline">\(P_i, P_j \quad where \; i \neq j\)</span> 欲進入 C.S. ，並且假設 Process ID 為 <span class="math inline">\(P_i &lt; P_j\)</span></li>
<li><strong>小結論</strong>
<ul>
<li>此行程式碼存在的目的，是為了讓<strong>所有可能會同一時間拿到號碼牌的 Processes 能公平的取得該號碼牌，不會有的早拿到或是晚拿到該「同一號碼」之號碼牌。</strong></li>
</ul></li>
</ul>
<h4 id="hardware-cpu-intructions-support">Hardware (CPU) Intructions Support</h4>
<p><strong>程式開發者可以使用硬體預先定義之指立於設計 Critical Section。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"><span class="comment">// Name        : Hardware solution</span></span><br><span class="line"><span class="comment">// Author      : willywangkaa</span></span><br><span class="line"><span class="comment">// Version     :</span></span><br><span class="line"><span class="comment">// Copyright   :</span></span><br><span class="line"><span class="comment">// Description : Hello World in C++, Ansi-style</span></span><br><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> condition;</span><br><span class="line"><span class="keyword">int</span> sharedvar = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> waiting[<span class="number">10</span>];</span><br><span class="line">atomic_flag LOCK = ATOMIC_FLAG_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">int</span> tid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( condition ) &#123;</span><br><span class="line">        <span class="keyword">double</span> delaySum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++ i )</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; ++ j )</span><br><span class="line">                delaySum += i*j;</span><br><span class="line"></span><br><span class="line">        waiting[tid] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(waiting[tid] &amp;&amp; LOCK.<span class="built_in">test_and_set</span>()) ;</span><br><span class="line"></span><br><span class="line">        this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">        sharedvar = tid;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Shared variable is edit by &quot;</span>&lt;&lt; sharedvar &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        waiting[tid] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">-1</span>, curr = (tid + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr != tid) &#123;</span><br><span class="line">            <span class="keyword">if</span>(waiting[curr]) &#123;</span><br><span class="line">                next = curr;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = (curr + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next != <span class="number">-1</span>) &#123;</span><br><span class="line">            waiting[curr] = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOCK.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;thread&gt; ths;</span><br><span class="line">    condition = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        waiting[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ths.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(worker, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        condition = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">Sleep</span>(i*<span class="number">20</span>);</span><br><span class="line">        condition = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (thread &amp; th : ths) &#123;</span><br><span class="line">		<span class="keyword">if</span> (th.<span class="built_in">joinable</span>())</span><br><span class="line">			th.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; sharedvar &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="test_and_setbool-lock機器指令">「test_and_set(bool *lock)」機器指令</h5>
<ul>
<li>功能：<strong>回傳 Lock 參數值並將 Lock 參數設為 True，且 CPU 保證此指令是不可中斷地執行( Atomically executed )。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test_and_set</span><span class="params">(<span class="keyword">bool</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> return_value = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> return_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="algorithm-1-fall">Algorithm 1 ( Fall )</h6>
<ul>
<li>共享變數：
<ul>
<li><strong>Lock：bool = False</strong>( Initial value )</li>
</ul></li>
<li><span class="math inline">\(P_i\)</span> 之程式碼：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">test_and_set</span>(&amp;Lock)); <span class="comment">// do nothing</span></span><br><span class="line">    <span class="comment">/* critical section */</span></span><br><span class="line">    Lock = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/* remainder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition == <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>分析
<ul>
<li>Mutual exclusion：OK</li>
<li>Progress：OK</li>
<li>Bounded waiting：Fall<br>假設 <span class="math inline">\(P_i\)</span> 以早於 <span class="math inline">\(P_j\)</span> 進入 C.S. ，所以 <span class="math inline">\(P_j\)</span> 進行等待，<strong>當 </strong><span class="math inline">\(P_i\)</span> <strong>離開 C.S. 後又想立即進入 C.S.，而以上述寫法可能會導致 </strong><span class="math inline">\(P_i\)</span> <strong>有可能可以再次早於</strong> <span class="math inline">\(P_j\)</span> <strong>執行 test_and_set 進入 C.S.</strong>，所以 <span class="math inline">\(P_j\)</span> 有可能會面臨「Starvation」。</li>
</ul></li>
</ul>
<h6 id="algorithm-2-pass---fifo">★★Algorithm 2 ( Pass ) - FIFO</h6>
<ul>
<li>共享變數
<ul>
<li><strong>Lock：bool = False</strong> ( Initial value )</li>
<li><strong>Waiting：[0 ... n-1] of bool 初值皆為 False</strong><br><span class="math inline">\(waiting[i] = \left\{\begin{matrix}True \quad P_i \; 有意願進入 \; C.S. ，且正在等待\\ False \quad 初值。P_i \; 不用等待，可以直接進入\; C.S. \end{matrix}\right.\)</span></li>
</ul></li>
<li><span class="math inline">\(P_i\)</span> 之程式碼：</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">區域變數：key:<span class="keyword">bool</span>;</span><br><span class="line">         j  :<span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    waiting[i] = <span class="literal">true</span>;</span><br><span class="line">    key = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 假設目前無人在 C.S. 所以第一個執行此指令的 Process 可以直接進入下一步。</span></span><br><span class="line">    <span class="keyword">while</span> (waiting[i] &amp;&amp; key) key = <span class="built_in">test_and_set</span>(&amp;Lock); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// **表明 P_i 不用繼續等待，可以進入 C.S.。</span></span><br><span class="line">    waiting[i] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* critical section */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出下一個欲進入 C.S. 之 P_j Process</span></span><br><span class="line">    j = (i + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="comment">// j != i -&gt; 尚未繞完一圈 &amp;&amp; !waiting[j] -&gt; P_j 不想進入 C.S.</span></span><br><span class="line">    <span class="keyword">while</span> ((j != i) &amp;&amp; !waiting[j])</span><br><span class="line">    	j = (j + <span class="number">1</span>) % n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (j == i)</span><br><span class="line">    	lock = <span class="literal">false</span>;         <span class="comment">// 無 Process 欲進入 C.S.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	waiting[j] = <span class="literal">false</span>;   <span class="comment">// 讓 P_j 進入 C.S.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* remainder section */</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">while</span> (condition == <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>證明 Critical section 關鍵性值存在：
<ul>
<li>Mutual exclusion：OK<br><span class="math inline">\(P_i\)</span> <strong>可進入 C.S. 之條件有兩種可能：</strong><br>Case1：<strong>Key 為 False，代表</strong> P_i 是第一個執行 test_and_set 的 Process ，如此才能將 Key 賦予 False ，<strong>唯一性。</strong><br>Case2：<strong>Waiting[i] = False，因為一開始會先執行</strong> <code>waiting[i] = true;</code> <strong>代表 P_i 在離開</strong> <code>while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock);</code> 前不會將 Waiting[i] 賦予 False ，<strong>只有在 C.S. 的 Process 欲離開 C.S. 後才能將其他 Processes 其中一個 Process 的 Waiting 賦予 False 值，</strong>但是能在 C.S. 之中執行的 Process 唯一，所以也只會讓一個 Process 的 waiting 賦予 False 值，<strong>唯一性( Mutex 成立 )</strong>。</li>
<li>Progress：OK<br>(1) 若 P_i 不想進入 C.S. 其 Waiting[i] 為 False ，且 P_i 不會與其他 Process 競爭執行 <code>while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock);</code> ，另外，從 C.S. 離開之 Process 不會改變 Waiting[i]，<strong>所以 P_i 不會參與進入 C.S 之決策。</strong><br>(2) 若 n 個 Process 皆想進入 C.S. ，則在有限的時間內( 無死結 )必定會決定出第一個執行 <code>while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock);</code> 者。之後，該選中 Process 從 C.S. 離開後，也會在有限的時間內，讓下一個欲進入 C.S. 的 Process 進入 C.S 。</li>
<li><strong>Bounded waiting：OK</strong><br>n 個 Process 皆欲進入 C.S. ，<strong>表示 Waiting[0] ~ Waiting[n-1] 皆為 true。</strong><br>令 P_i 是第一個執行 <code>while (waiting[i] &amp;&amp; key) key = test_and_set(&amp;Lock);</code> <strong>者，率先進入 C.S.，當 P_i 離開 C.S. 後會將</strong> <span class="math inline">\(P_{(i+1) \mod n}\)</span> <strong>的 Waiting 賦予 False 值，使</strong> <span class="math inline">\(P_{(i+1) \mod n}\)</span> <strong>進入 C.S.，依此類推 Process 會以</strong> <span class="math inline">\(＜P_i, P_{(i+1) \mod n}, \ldots, P_{(i-1) \mod n}＞\)</span> <strong>的序列 ( FIFO ) 進入 C.S.，所以沒有「Starvation」。</strong></li>
</ul></li>
</ul>
<h5 id="compare_and_swapint-value-int-expected-int-new_value-指令">「compare_and_swap(int *value, int expected, int new_value) 」指令</h5>
<ul>
<li><strong>功能：將 value 與 new_value 兩值互換，且 CPU 保證為不可分割之執行( Atomically executed )。</strong></li>
<li><strong>實現作法 ( 硬體寫死，無法使用高階程式語言實現 )</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *value, <span class="keyword">int</span> expected, <span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *value;</span><br><span class="line">    <span class="keyword">if</span> (*value == expected)</span><br><span class="line">    	*value = new_value;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="algorithm-1-fall-1">Algorithm 1 (Fall)</h6>
<ul>
<li>共享變數
<ul>
<li>Lock：bool = False ( Initial value )</li>
</ul></li>
<li><span class="math inline">\(P_i\)</span> 之程式碼：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">區域變數: key:<span class="keyword">bool</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">compare_and_swap</span>(&amp;lock, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ; <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="comment">/* critical section */</span></span><br><span class="line">    lock = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* remainder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition == <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>分析
<ul>
<li>Mutual exclusion：OK</li>
<li>Progress：OK</li>
<li>Bounded waiting：Fall<br>假設 <span class="math inline">\(P_i\)</span> 以早於 <span class="math inline">\(P_j\)</span> 進入 C.S. ，所以 <span class="math inline">\(P_j\)</span> 進行等待，<strong>當 </strong><span class="math inline">\(P_i\)</span> <strong>離開 C.S. 後又想立即進入 C.S.，而以上述寫法可能會導致 </strong><span class="math inline">\(P_i\)</span> <strong>有可能可以再次早於</strong> <span class="math inline">\(P_j\)</span> <strong>執行 compare_and_swap 進入 C.S.</strong>，所以 <span class="math inline">\(P_j\)</span> 有可能會面臨「Starvation」。</li>
</ul></li>
</ul>
<h6 id="algorithm-2-pass---fifo-1">★★Algorithm 2 ( Pass ) - FIFO</h6>
<ul>
<li>共享變數
<ul>
<li><strong>Lock：bool = False</strong> ( Initial value )</li>
<li><strong>Waiting：[0 ... n-1] of bool 初值皆為 False</strong><br><span class="math inline">\(waiting[i] = \left\{\begin{matrix}True \quad P_i \; 有意願進入 \; C.S. ，且正在等待\\ False \quad 初值。P_i \; 不用等待，可以直接進入\; C.S. \end{matrix}\right.\)</span></li>
</ul></li>
<li><span class="math inline">\(P_i\)</span> 之程式碼：</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">區域變數：key:<span class="keyword">bool</span>;</span><br><span class="line">         j  :<span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    waiting[i] = <span class="literal">true</span>;</span><br><span class="line">    key = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 假設目前無人在 C.S. 所以第一個執行此指令的 Process 可以直接進入下一步。</span></span><br><span class="line">    <span class="keyword">while</span> (waiting[i] &amp;&amp; key) key = <span class="built_in">compare_and_swap</span>(&amp;Lock); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// **表明 P_i 不用繼續等待，可以進入 C.S.。</span></span><br><span class="line">    waiting[i] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* critical section */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出下一個欲進入 C.S. 之 P_j Process</span></span><br><span class="line">    j = (i + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="comment">// j != i -&gt; 尚未繞完一圈 &amp;&amp; !waiting[j] -&gt; P_j 不想進入 C.S.</span></span><br><span class="line">    <span class="keyword">while</span> ((j != i) &amp;&amp; !waiting[j])</span><br><span class="line">    	j = (j + <span class="number">1</span>) % n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (j == i)</span><br><span class="line">    	lock = <span class="literal">false</span>;         <span class="comment">// 無 Process 欲進入 C.S.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	waiting[j] = <span class="literal">false</span>;   <span class="comment">// 讓 P_j 進入 C.S.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* remainder section */</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">while</span> (condition == <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="問題探討">問題探討</h5>
<ul>
<li>Ex</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    waiting[i] = <span class="literal">true</span>;</span><br><span class="line">    key = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (waiting[i] &amp;&amp; key) key = <span class="built_in">test_and_set</span>(&amp;Lock);</span><br><span class="line">    </span><br><span class="line">    ~~waiting[i] = <span class="literal">false</span>;~~ <span class="comment">// 若此行刪除將導致什麼後果？</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* critical section */</span></span><br><span class="line">    </span><br><span class="line">    j = (i + <span class="number">1</span>) % n;</span><br><span class="line">	<span class="keyword">while</span> ((j != i) &amp;&amp; !waiting[j])</span><br><span class="line">    	j = (j + <span class="number">1</span>) % n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (j == i)</span><br><span class="line">    	lock = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	waiting[j] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* remainder section */</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">while</span> (condition == <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>違反 Progress 性質 ( 造成死結 )。</p>
<h3 id="semaphore-號誌">Semaphore ( 號誌 )</h3>
<p>令 S 為 <code>Semaphore type</code> 變數，架構在 <code>Integer type</code>。針對 S ，提供兩個「Atomic 運算元」</p>
<p><strong>wait(S) ( 或 P(S) ) 與 signal(S) ( 或 V(S) )</strong>。( 因為是「Atomic 運算元」，所以不會有 Race condition。 )</p>
<ul>
<li><strong>wait(S)</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(S &lt;= <span class="number">0</span>) ;</span><br><span class="line">S = S - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>signal(S)</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">S = S + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>主要功能：「設計 C.S. 」與「解決同步問題」</li>
<li>使用範例
<ul>
<li>共享變數<br><strong>mutex：semaphore = 1 (Initial value)</strong></li>
<li>程式結構</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">repeat</span></span><br><span class="line"><span class="function">	<span class="title">wait</span><span class="params">(mutex)</span></span>;</span><br><span class="line">	C.S.</span><br><span class="line">	<span class="built_in">signal</span>(mutex);</span><br><span class="line">	R.S.</span><br><span class="line">until False</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>＜Note＞：semaphore 的初值，有某些意義。</strong><span class="math inline">\(\left\{\begin{matrix}1 \Rightarrow 互斥控制之用途。\\ 0 \Rightarrow 強迫等待之用途。 \end{matrix}\right.\)</span></p>
</blockquote>
<h4 id="解決簡單的同步問題-synchronization-problem">解決簡單的同步問題 ( synchronization problem )</h4>
<p>Synchronization</p>
<ul>
<li>Process 因為「某件事情」的已發生或是未發生( 有多個 process 相互合作的時候 )，導致必須等待該事件完成或發生才得以繼續進行。</li>
</ul>
<h5 id="ex.-a-必須要在-b-之前執行"><span class="math inline">\(Ex.\)</span> <span class="math inline">\(A;\)</span> 必須要在 <span class="math inline">\(B;\)</span> 之前執行。</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">...</span><br><span class="line">A;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">...</span><br><span class="line">B;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>宣告共享變數 <span class="math inline">\(s\)</span>：semaphore = 0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">...</span><br><span class="line">A;</span><br><span class="line"><span class="built_in">signal</span>(s);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">wait</span>(s);</span><br><span class="line">B;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h5 id="ex.-執行順序為-acb"><span class="math inline">\(Ex.\)</span> 執行順序為 <span class="math inline">\(A、C、B\)</span>。</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">...</span><br><span class="line">A;</span><br><span class="line"><span class="built_in">signal</span>(s_1);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">wait</span>(s_2);</span><br><span class="line">B;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_k</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">wait</span>(s_1);</span><br><span class="line">C;</span><br><span class="line"><span class="built_in">signal</span>(s_2);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>宣告共享變數 s_1：semaphore = 0、s_2：semaphore = 0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">...</span><br><span class="line">A;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">...</span><br><span class="line">B;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_k</span></span><br><span class="line">...</span><br><span class="line">C;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h5 id="ex.-一直重複執行依照-abc-的順序"><span class="math inline">\(Ex.\)</span> 一直重複執行依照 「<span class="math inline">\(A、B、C\)</span> 」的順序。</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	A;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	B;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_k</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	C;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>宣告共享變數 s_1：semaphore = 0、s_2：semaphore = 0、<strong>s_3：semaphore：semaphore = 0</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    A;</span><br><span class="line">    <span class="built_in">signal</span>(s_1);</span><br><span class="line">    <span class="built_in">wait</span>(s_3);   <span class="comment">// 注意!</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">wait</span>(s_1);</span><br><span class="line">    B;</span><br><span class="line">    <span class="built_in">signal</span>(s_2);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_k</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">wait</span>(s_2);</span><br><span class="line">    C;</span><br><span class="line">    <span class="built_in">signal</span>(s_3);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>當我們令 s_1：semaphore = 0、s_2：semaphore = 0、<strong>s_3：semaphore = 1</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">wait</span>(s_3);   <span class="comment">// 注意!</span></span><br><span class="line">    A;</span><br><span class="line">    <span class="built_in">signal</span>(s_1);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">wait</span>(s_1);</span><br><span class="line">    B;</span><br><span class="line">    <span class="built_in">signal</span>(s_2);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_k</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">wait</span>(s_2);</span><br><span class="line">    C;</span><br><span class="line">    <span class="built_in">signal</span>(s_3);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ex.-c-為共享變數且初值為-3追蹤下列程式判斷可能的結果值"><span class="math inline">\(Ex.\)</span> <span class="math inline">\(C\)</span> 為共享變數且初值為 3，追蹤下列程式判斷可能的結果值。</h5>
<ol type="1">
<li></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">    ...</span><br><span class="line">	C = C * <span class="number">2</span>;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">    ...</span><br><span class="line">    C = C + <span class="number">1</span>;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>可能的結果值為<code>6</code>、<code>4</code>、<code>8</code>、<code>7</code>。</p>
<ol start="2" type="1">
<li>s：semaphore = 1</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">wait</span>(s);</span><br><span class="line">	C = C * <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">signal</span>(s);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">wait</span>(s);</span><br><span class="line">    C = C + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">signal</span>(s);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>可能的結果值為<code>8</code>、<code>7</code>。</p>
<ol start="3" type="1">
<li>s：semaphore = 0</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">    ...</span><br><span class="line">	C = C * <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">signal</span>(s);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">wait</span>(s);</span><br><span class="line">    C = C + <span class="number">1</span>;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>結果值為<code>7</code>。</p>
<h5 id="ex.-求-abc-可能的執行順序"><span class="math inline">\(Ex.\)</span> 求 <span class="math inline">\(A、B、C\)</span> 可能的執行順序。</h5>
<ul>
<li>s_1：semaphore = 1、s_2：semaphore = 0。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">wait</span>(s_1);</span><br><span class="line">A;</span><br><span class="line"><span class="built_in">signal</span>(s_2);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">wait</span>(s_2);</span><br><span class="line">B;</span><br><span class="line"><span class="built_in">signal</span>(s_1);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_k</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">wait</span>(s_1);</span><br><span class="line">C;</span><br><span class="line"><span class="built_in">signal</span>(s_1);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可能的執行順序為<code>A-&gt;B-&gt;C</code> 或 <code>C-&gt;A-&gt;B</code>。</p>
<h4 id="semaphore-誤用">Semaphore 誤用</h4>
<h5 id="違反互斥">違反「互斥」</h5>
<ul>
<li>s：semaphore = 1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line"><span class="built_in">signal</span>(s);</span><br><span class="line">	<span class="comment">// C.S.</span></span><br><span class="line"><span class="built_in">wait</span>(s);</span><br><span class="line"><span class="comment">// R.S.</span></span><br></pre></td></tr></table></figure>
<h5 id="形成死結">☆形成死結</h5>
<ul>
<li>s：semaphore = 1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line"><span class="built_in">wait</span>(s);</span><br><span class="line">	<span class="comment">// C.S.</span></span><br><span class="line"><span class="built_in">wait</span>(s);</span><br><span class="line"><span class="comment">// R.S.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>☆ s_1：semaphore = 1、s_2：semaphore = 1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_i</span></span><br><span class="line"><span class="built_in">wait</span>(s_1);</span><br><span class="line">	<span class="built_in">wait</span>(s_2);</span><br><span class="line">		...</span><br><span class="line"><span class="built_in">signal</span>(s_1);</span><br><span class="line">	<span class="built_in">signal</span>(s_2);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P_j</span></span><br><span class="line"><span class="built_in">wait</span>(s_2);</span><br><span class="line">	<span class="built_in">wait</span>(s_1);</span><br><span class="line">		...</span><br><span class="line"><span class="built_in">signal</span>(s_2);</span><br><span class="line">	<span class="built_in">signal</span>(s_1);</span><br></pre></td></tr></table></figure>
<p><strong>可能會造成「死結」。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flow code</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">	<span class="built_in">wait</span>(s_1); <span class="comment">// pass</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">	<span class="built_in">wait</span>(s_2); <span class="comment">// pass</span></span><br><span class="line"><span class="comment">// P_i</span></span><br><span class="line">	<span class="built_in">wait</span>(s_2); <span class="comment">// block</span></span><br><span class="line"><span class="comment">// P_j</span></span><br><span class="line">	<span class="built_in">wait</span>(s_1); <span class="comment">// block</span></span><br><span class="line"><span class="comment">// Deadlock</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>重要的同步問題 ( Synchronization Problem )</p>
<ul>
<li>解決要點
<ul>
<li><strong>以 Semaphore 變數實作同步處理條件。</strong></li>
<li><strong>以 Semaphore 實作互斥控制防止「Race condition」。</strong></li>
<li>先同步、再互斥。</li>
</ul></li>
</ul>
</blockquote>
<h4 id="producer-consumer-problem-生產者消費者問題">Producer Consumer Problem ( 生產者消費者問題 )</h4>
<figure>
<img src="\willywangkaa\images\producercomsumerproblem.png" alt="producercomsumerproblem" /><figcaption aria-hidden="true">producercomsumerproblem</figcaption>
</figure>
<ul>
<li>Producer：這種 Processes 專門產生資料，以供其他 Processes 使用。</li>
<li>Consumer：這種 Processes 專門處理資料給使用者。</li>
<li>Shared memory 狀態下討論。</li>
</ul>
<h5 id="bounded-buffer-producer-consumer-有限緩衝區">☆Bounded Buffer Producer-Consumer ( 有限緩衝區 )</h5>
<ul>
<li>當緩衝區<strong>滿</strong>的時候，<strong>生產者必須等待。</strong></li>
<li>當緩衝區<strong>空</strong>的時候，<strong>消費者必須等待。</strong></li>
</ul>
<h6 id="algorithm1-未使用semaphore">Algorithm1 ( 未使用「Semaphore」 )</h6>
<ul>
<li>共享變數
<ul>
<li><span class="math inline">\(Buffer：[0 \ldots n-1] \; of \; items\)</span></li>
<li><span class="math inline">\(in, out：int = 0\)</span></li>
</ul></li>
<li>Producer Process</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// producer</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	create a <span class="keyword">new</span> item <span class="string">&quot;t&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>((in+<span class="number">1</span>)%n == out) ;</span><br><span class="line">	Buffer[in] = t;</span><br><span class="line">	in = (in + <span class="number">1</span>) % n;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Consumer Process</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// consumer</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">while</span>(in == out) ;</span><br><span class="line">	assign Buffer[out] to <span class="string">&quot;I&quot;</span>;</span><br><span class="line">	out = (out + <span class="number">1</span>) % n;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// using &quot;I&quot; item</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="algorithm2-fall">Algorithm2( Fall )</h6>
<figure>
<img src="\willywangkaa\images\circulerqueue.png" alt="circulerqueue" /><figcaption aria-hidden="true">circulerqueue</figcaption>
</figure>
<p>若使用「Algorithm1」的算法，在上圖所表示的狀態中，算法會判斷為 Buffer 已滿 (<code>(in + 1) % n == out</code>)，無法再加入，所以導致最多只能用 n-1 個 Buffer。</p>
<ul>
<li>共享變數
<ul>
<li><span class="math inline">\(Buffer：[0 \ldots n-1] \; of \; items\)</span></li>
<li><span class="math inline">\(in, out：int = 0\)</span></li>
<li><strong>Count：int = 0</strong></li>
</ul></li>
<li>Producer Process</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// producer</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	creat a <span class="keyword">new</span> item <span class="string">&quot;t&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(count == n) ;</span><br><span class="line">	buffer[in] = t;</span><br><span class="line">	in = (in + <span class="number">1</span>) % n;</span><br><span class="line">	count++;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Consumer Process</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// consumer</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">while</span>(count == <span class="number">0</span>) ;</span><br><span class="line">	assign buffer[out] value to <span class="string">&quot;I&quot;</span>;</span><br><span class="line">	out = (out + <span class="number">1</span>) % n;</span><br><span class="line">	count--;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// using tiem &quot;I&quot;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="algorithm3-用-semaphore-解決-algorithm2">Algorithm3 ( 用 Semaphore 解決 Algorithm2 )</h6>
<ul>
<li>共享變數
<ul>
<li><strong>empty：semaphore = n</strong><br>代表緩衝區內的<strong>「空閒容量」</strong>，若為 0 則代表緩衝區已<strong>滿</strong>。</li>
<li><strong>full：semaphore = 0</strong><br>代表緩衝區中<strong>「已使用容量」</strong>，若為 0 則代表緩衝區目前為<strong>空</strong>。</li>
<li>mutex：semaphore = 1<br>對緩衝區、in、out 與 Count 做互斥控制，<strong>防止「Race condition」。</strong></li>
</ul></li>
<li>Producer Process</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// producer</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	create a <span class="keyword">new</span> item <span class="string">&quot;t&quot;</span>;</span><br><span class="line">	<span class="built_in">wait</span>(empty);               <span class="comment">// 確認當前「空格數」是否足夠使用。</span></span><br><span class="line">		<span class="built_in">wait</span>(mutex);</span><br><span class="line">			buffer[in] = t;</span><br><span class="line">			in = (in + <span class="number">1</span>) % n;</span><br><span class="line">			count++;</span><br><span class="line">		<span class="built_in">signal</span>(mutex);</span><br><span class="line">		<span class="built_in">signal</span>(full);         <span class="comment">// 將「滿格數」添上一筆。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Consumer Process</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// consumer</span></span><br><span class="line"><span class="keyword">while</span>(condition == <span class="literal">true</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">wait</span>(full);                        <span class="comment">// 確認當前「滿格數」是否足夠使用。</span></span><br><span class="line">		<span class="built_in">wait</span>(mutex);</span><br><span class="line">			assign buffer[out] to <span class="string">&quot;I&quot;</span>;</span><br><span class="line">			out = (out + <span class="number">1</span>) % n;</span><br><span class="line">			count--;</span><br><span class="line">		<span class="built_in">signal</span>(mutex);</span><br><span class="line">		<span class="built_in">signal</span>(empty);                 <span class="comment">// 將「空格數」添上一筆。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="unbunded-buffer-producer-consumer-無限緩衝區">Unbunded Buffer Producer-Consumer ( 無限緩衝區 )</h5>
<ul>
<li>當緩衝區<strong>空</strong>的時候，<strong>消費者必須等待。</strong></li>
<li>不予討論</li>
</ul>
<h4 id="reader-writer-problem">Reader Writer Problem</h4>
<figure>
<img src="\willywangkaa\images\readerwiterproblem.png" alt="readerwiterproblem" /><figcaption aria-hidden="true">readerwiterproblem</figcaption>
</figure>
<ul>
<li>☆<strong>問題重點</strong>
<ul>
<li><strong>Reader、Writer 須對該資料進行互斥處理。</strong></li>
<li><strong>Writer、Writer 須對該資料進行互斥處理。</strong></li>
</ul></li>
</ul>
<h5 id="first-reader-writer-problem">First reader writer problem</h5>
<figure>
<img src="\willywangkaa\images\firstreaderwiterproblem.png" alt="firstreaderwiterproblem" /><figcaption aria-hidden="true">firstreaderwiterproblem</figcaption>
</figure>
<p>對於 Reader 有利，而對於 Writer 不利所以可能導致 Writer 「Starvation」。</p>
<ul>
<li>共享變數
<ul>
<li>wrt：semaphore = 1 提供 Read/Write 與 Write/Write 的互斥控制，<strong>這種控制將會不利於 Writer 的寫入</strong>。</li>
<li>readcnt：int = 0 <strong>紀錄目前的 Reader 個數。</strong> <span class="math inline">\(\left\{\begin{matrix}多一位 \; Reader \Rightarrow readcnt = readcnt + 1。\\少一位 \; Reader \Rightarrow readcnt = readcnt -1。 \end{matrix}\right. \Rightarrow 需使用互斥控制。\)</span></li>
<li><strong>mutex：semaphore = 1</strong> 對 readcnt 作「互斥控制」，防止 Race condition。</li>
</ul></li>
<li>Reader 程式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reader</span></span><br><span class="line">    <span class="built_in">wait</span>(mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="keyword">if</span>(readcnt == <span class="number">1</span>) <span class="built_in">wait</span>(wrt);</span><br><span class="line">    <span class="built_in">signal</span>(mutex);</span><br><span class="line">    <span class="comment">// Reading</span></span><br><span class="line">    <span class="built_in">wait</span>(mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="keyword">if</span>(readcnt == <span class="number">0</span>) <span class="built_in">signal</span>(wrt); <span class="comment">// 目前沒有 Reader 要使用此檔案了。</span></span><br><span class="line">    <span class="built_in">signal</span>(mutex);</span><br></pre></td></tr></table></figure>
<ul>
<li>Writer</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Writer</span></span><br><span class="line">    <span class="built_in">wait</span>(wrt);</span><br><span class="line">    <span class="comment">// Writing</span></span><br><span class="line">    <span class="built_in">signal</span>(wrt);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>當 <code>if(readcnt == 1)</code> 符合條件代表目前是第一個<strong>想要</strong>使用此檔案的 Reader。</p>
<ul>
<li>需要執行 <code>wait(wrt);</code> <strong>以檢查目前是否有其他的 Writer 正在使用此檔案。</strong><br>1. 若有，則不繼續執行。<br>2. 若無，則通過且將 Writer 阻擋住。</li>
</ul></li>
<li><p>EX：根據上方程式，假設目前 <span class="math inline">\(W_1\)</span> 已在寫入之中。</p>
<ol type="1">
<li>若 <span class="math inline">\(R_1\)</span> 接上面之後開始執行，則 <span class="math inline">\(R_1\)</span> 會卡在程式碼何處？而此時的 readcnt 又為何？<br><code>wait(wrt);</code>，readcnt = 1。</li>
<li>若 <span class="math inline">\(R_2\)</span> 接上面之後開始執行，則 <span class="math inline">\(R_2\)</span> 會卡在程式碼何處？而此時的 readcnt 又為何？<br><code>wait(mutex);</code>，readcnt = 1。</li>
<li>若 <span class="math inline">\(R_3\)</span> 接上面之後開始執行，則 <span class="math inline">\(R_3\)</span> 會卡在程式碼何處？而此時的 readcnt 又為何？<br><code>wait(mutex);</code>，readcnt = 1。</li>
</ol></li>
</ul>
<h5 id="second-reader-writer-problem">Second reader writer problem</h5>
<figure>
<img src="\willywangkaa\images\secondreaderwriterproblem.png" alt="secondreaderwriterproblem" /><figcaption aria-hidden="true">secondreaderwriterproblem</figcaption>
</figure>
<p>對於 Writer 有利，而對於 Reader 不利所以可能導致 Reader 「Starvation」。</p>
<p><strong>只要 Writer 離開，發現尚有 Writers 也在等待佇列，則優先讓 Writer 對資料進行寫入，所以可能會導致 Reader Starvation。</strong></p>
<ul>
<li>共享變數
<ul>
<li>readcnt：int = 0<br>紀錄目前 Readers 正在讀取的個數。</li>
<li>wrtcnt：int = 0<br>紀錄目前還有多少 Writer 在等待寫入資料。</li>
<li>x：semaphore = 1<br>對 readcnt 作互斥控制，防止 race condition。</li>
<li>y：semaphore = 1<br>對 wrtcnt 作互斥控制，防止 race condition。</li>
<li>z：semaphore = 1<br><strong>因為要對 Writer 有利，所以使用 mutex 作為 Reader 要對資料進行讀取時的障礙，不會急於對資料讀取。(讓 rsem 的效果更明顯)</strong></li>
<li><strong>rsem：semaphore = 1</strong><br><strong>作為不利 Reader 之控制。</strong></li>
<li><strong>wsem：semaphore = 1</strong><br><strong>提供 Read/Write 與 Write/Write 的互斥控制。</strong></li>
</ul></li>
<li>Reader 程式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reader</span></span><br><span class="line"><span class="built_in">wait</span>(z);</span><br><span class="line">	<span class="built_in">wait</span>(rsem);</span><br><span class="line">		<span class="built_in">wait</span>(x);</span><br><span class="line">			readcnt++;</span><br><span class="line">			<span class="keyword">if</span>(readcnt == <span class="number">1</span>) <span class="built_in">wait</span>(wsem);</span><br><span class="line">		<span class="built_in">signal</span>(x);</span><br><span class="line">	<span class="built_in">signal</span>(rsem);</span><br><span class="line"><span class="built_in">signal</span>(z);</span><br><span class="line"><span class="comment">// Reading</span></span><br><span class="line"><span class="built_in">wait</span>(x);</span><br><span class="line">	readcnt--;</span><br><span class="line">	<span class="keyword">if</span>(readcnt == <span class="number">0</span>) <span class="built_in">signal</span>(wsem);</span><br><span class="line"><span class="built_in">signal</span>(x);</span><br></pre></td></tr></table></figure>
<ul>
<li>Writer 程式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Writer</span></span><br><span class="line"><span class="built_in">wait</span>(y);</span><br><span class="line">	wrtcnt++;</span><br><span class="line">	<span class="keyword">if</span>(wrtcnt == <span class="number">1</span>) <span class="built_in">wait</span>(rsem);   <span class="comment">// 目前第一個 Writer，會迫使 Reader 多一層等待</span></span><br><span class="line"><span class="built_in">signal</span>(y);</span><br><span class="line"><span class="built_in">wait</span>(wsem);                       <span class="comment">// 開始等待寫入</span></span><br><span class="line">	<span class="comment">// Writing</span></span><br><span class="line"><span class="built_in">wait</span>(y);</span><br><span class="line">	wrtcnt--;</span><br><span class="line">	<span class="keyword">if</span>(wrtcnt == <span class="number">0</span>) <span class="built_in">signal</span>(rsem); <span class="comment">// 最後一個 Writer，將擋住 Reader 的閘門解除。</span></span><br><span class="line">	<span class="built_in">signal</span>(wsem);                 <span class="comment">// Writer 離開時，交付讀寫權。</span></span><br><span class="line"><span class="built_in">signal</span>(y);</span><br></pre></td></tr></table></figure>
<h4 id="the-sleeping-barber-problem-理髮師睡覺問題">The sleeping Barber Problem ( 理髮師睡覺問題 )</h4>
<p>一個理髮師，一張美髮座椅( 理髮師一次服務一個客人 )，與 n 個等待座位。</p>
<ul>
<li>客人
<ul>
<li><strong>若等待座位坐滿，就不會進入理髮廳。</strong></li>
<li><strong>若尚未坐滿：</strong>
<ul>
<li><strong>進入理髮廳等待。</strong></li>
<li><strong>通知 / 喚醒理髮師。</strong></li>
<li><strong>若理髮師正在忙碌，客人進行睡覺( waiting )，</strong>直到理髮師喚醒客人剪髮，剪完後離開。</li>
</ul></li>
</ul></li>
<li>理髮師
<ul>
<li><strong>若目前無客人，睡覺( waiting )直到有客人喚醒理髮師。</strong></li>
<li>若目前理髮師醒著且目前有客人正在等待，會去喚醒客人理髮，重複動作直到沒有客人為止最後睡覺(wait)。</li>
</ul></li>
<li>共享變數：
<ul>
<li><strong>customer：semaphore = 0</strong><br><strong>用來處理客人與理髮師的同步問題。有客人才被喚醒工作，若無則繼續睡覺。</strong></li>
<li><strong>barber：semaphore = 0</strong><br><strong>用來處理客人與理髮師的同步問題。若理髮師忙碌等待並睡覺，反之進行理髮。</strong></li>
<li>waiting：int = 0 目前座在等待區的人數。 <span class="math inline">\(\left\{\begin{matrix}客人入店 \; \Rightarrow waiting++ \\理髮師開始處理下一為客人 \Rightarrow waiting-- \end{matrix}\right.\)</span></li>
<li>mutex：semaphore = 1<br><strong>對 waiting 變數做互斥處理，以免 Race condition。</strong></li>
</ul></li>
<li>Barber 程式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// barber</span></span><br><span class="line"><span class="keyword">while</span>(conditon == <span class="literal">false</span>) &#123;</span><br><span class="line">	<span class="built_in">wait</span>(customer);          <span class="comment">// 目前沒有客人，Barber 睡覺去。</span></span><br><span class="line">		<span class="built_in">wait</span>(mutex);</span><br><span class="line">			waiting--;</span><br><span class="line">			<span class="built_in">signal</span>(barber); <span class="comment">// 叫醒客人。</span></span><br><span class="line">		<span class="built_in">signal</span>(mutex);</span><br><span class="line">		<span class="comment">// processing cutting hair</span></span><br><span class="line">		<span class="comment">// signal(barber);  // worng code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Costomer 程式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// customer: 注意! customer 並沒有需要 loop 剪髮的需求。</span></span><br><span class="line"><span class="built_in">wait</span>(mutex);</span><br><span class="line">	<span class="keyword">if</span>(waiting &lt; n) &#123;</span><br><span class="line">		waiting++;</span><br><span class="line">		<span class="built_in">signal</span>(customer); <span class="comment">// 叫醒/通知 Barber。</span></span><br><span class="line"><span class="built_in">signal</span>(mutex);</span><br><span class="line">		<span class="built_in">wait</span>(barber);		</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">signal</span>(mutex);    </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="\willywangkaa\images\secondreaderwriterproblem_2.png" alt="secondreaderwriterproblem_2" /><figcaption aria-hidden="true">secondreaderwriterproblem_2</figcaption>
</figure>
<h4 id="the-dining-philosophers-problem-哲學家用餐問題">The Dining-philosophers Problem (哲學家用餐問題)</h4>
<figure>
<img src="\willywangkaa\images\dining_philosophersproblem.png" alt="dining_philosophersproblem" /><figcaption aria-hidden="true">dining_philosophersproblem</figcaption>
</figure>
<p><strong>倆倆之間有一隻筷子，哲學家若感到飢餓，必須要能夠同時取得左右兩根筷子才能用餐。用完餐後放下左右兩根筷子，進行思考模式。</strong></p>
<p><strong>＜Note＞</strong></p>
<ol type="1">
<li>中餐，奇數或是偶數位哲學家皆可以，因為左右邊都可以是<strong>一根筷子</strong>。</li>
<li>西餐，一定為偶數個哲學家，因為為吃飯需要<strong>一副刀叉</strong>。</li>
</ol>
<figure>
<img src="\willywangkaa\images\thedinningphilosopherproblem2.png" alt="thedinningphilosopherproblem2" /><figcaption aria-hidden="true">thedinningphilosopherproblem2</figcaption>
</figure>
<ul>
<li>共享變數
<ul>
<li>chopstick[0...4] of semaphore = {1 ... 1}<br><strong>對 5 根筷子進行互斥控制。</strong></li>
<li>i (i：0...4) 哲學家：<span class="math inline">\(Process \; P_i\)</span></li>
</ul></li>
<li>Philosopher 程式 (fall)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// philosopher</span></span><br><span class="line"><span class="keyword">while</span>(condition==<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// need processing...</span></span><br><span class="line">    <span class="built_in">wait</span>(chopstick[i]);</span><br><span class="line">        <span class="built_in">wait</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        	<span class="comment">// processing</span></span><br><span class="line">    <span class="built_in">signal</span>(chopstick[i]);</span><br><span class="line">    	<span class="built_in">signal</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    <span class="comment">// thinking</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程式碼中，若每位哲學家都依序先取得左筷，之後每位哲學家在取得右筷時，會直接形成「Circular waiting」，所以這程式很有可能會造成「Deadlock」。</p>
<figure>
<img src="\willywangkaa\images\thedinningpholosopherproblem3.png" alt="thedinningpholosopherproblem3" /><figcaption aria-hidden="true">thedinningpholosopherproblem3</figcaption>
</figure>
<h5 id="解法一">解法一</h5>
<ul>
<li><strong>最多只允許 4 位哲學家上桌用餐。</strong>
<ul>
<li>根據產生死結的<strong>定理</strong>：m = 5、<span class="math inline">\(Max_i = 2 \; where \; 1 \leq i \leq 5\)</span>。
<ul>
<li><span class="math inline">\(1 \leq Max_i \leq m\)</span>，OK。</li>
<li><span class="math inline">\(\sum_{i = 1}^n Max_i &lt; n+m \Rightarrow 2n &lt; n+ 5 \Rightarrow n &lt; 5\)</span>。</li>
</ul></li>
<li><strong>保證 「Deadlock free」。</strong></li>
<li>可以利用一個號誌來實現這個做法 <strong>s：semaphore = 4。</strong></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// philosopher</span></span><br><span class="line"><span class="keyword">while</span>(condition==<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// need processing...</span></span><br><span class="line">    <span class="built_in">wait</span>(s);</span><br><span class="line">        <span class="built_in">wait</span>(chopstick[i]);</span><br><span class="line">            <span class="built_in">wait</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">            <span class="comment">// processing</span></span><br><span class="line">        <span class="built_in">signal</span>(chopstick[i]);</span><br><span class="line">        	<span class="built_in">signal</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">signal</span>(s);</span><br><span class="line">    <span class="comment">// thinking</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法二">解法二</h5>
<ul>
<li><strong>增加限制「除非哲學家可以同時取得左右邊兩隻筷子，才允許取得筷子，否則不得持有該筷子」。</strong>
<ul>
<li><strong>要解決「Hold and wait」的問題。</strong></li>
</ul></li>
</ul>
<h5 id="解法三">解法三</h5>
<ul>
<li><strong>增加一個限制「相鄰的哲學家取筷的順序必須不同」。</strong>
<ul>
<li><strong>創造「Asymmtric」，則必不可能形成迴路，亦不能造成「Circular waiting」。</strong></li>
<li>Ex. <span class="math inline">\(\left\{\begin{matrix} 偶數號 \quad 先取左再取右。\\ 奇數號 \quad 先取右再取左。\end{matrix}\right.\)</span></li>
<li>這種做法亦等同於在西餐時，規定每個人必須先取刀再取叉一致。</li>
</ul></li>
</ul>
<h3 id="semaphore-種類">Semaphore 種類</h3>
<h4 id="分類一---區分號誌值域">分類一 - 區分號誌值域</h4>
<ul>
<li>Binary semaphore (二元)
<ul>
<li>semaphore 的值指介於 0 或 1。</li>
<li>不可為負。</li>
<li>無法紀錄有多少個 Process 正在 wait semaphore。</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">S: Binary semaphore = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span>(S):</span><br><span class="line"><span class="comment">// Entry section</span></span><br><span class="line"><span class="comment">// Critical section</span></span><br><span class="line">	<span class="keyword">while</span>(s&lt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// Leave section</span></span><br><span class="line">		no-op</span><br><span class="line"><span class="comment">// Entry section</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">// Critical section</span></span><br><span class="line">	s--;</span><br><span class="line"><span class="comment">// Leave section</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">signal</span>(S):</span><br><span class="line"><span class="comment">// Entry section</span></span><br><span class="line"><span class="comment">// Critical section</span></span><br><span class="line">	s++;</span><br><span class="line"><span class="comment">// Leave section</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用途</span></span><br><span class="line"><span class="built_in">wait</span>(s);</span><br><span class="line">	<span class="comment">// Critical section</span></span><br><span class="line"><span class="built_in">signal</span>(s);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> choosing[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> number[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">b_Semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125; BSEM;</span><br><span class="line">BSEM bsem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">( BSEM &amp;s, <span class="keyword">int</span> tid )</span> </span>&#123;</span><br><span class="line"><span class="comment">// Entry section</span></span><br><span class="line">    choosing[tid] = <span class="literal">true</span>;</span><br><span class="line">    number[tid] = *<span class="built_in">max_element</span>(number, number+<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">    choosing[tid] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(choosing[i]) _mm_pause();</span><br><span class="line">        <span class="keyword">while</span>(number[i]&gt;<span class="number">0</span> &amp;&amp;</span><br><span class="line">                (number[i]&lt;number[tid] ||</span><br><span class="line">                  (number[i]==number[tid] &amp;&amp; i&lt;tid)</span><br><span class="line">                 )) _mm_pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(s.v&lt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// Leave section</span></span><br><span class="line">        number[tid] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Critical section</span></span><br><span class="line">        _mm_pause();</span><br><span class="line"><span class="comment">// Entry section</span></span><br><span class="line">        choosing[tid] = <span class="literal">true</span>;</span><br><span class="line">        number[tid] = *<span class="built_in">max_element</span>(number, number+<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">        choosing[tid] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(choosing[i]) _mm_pause();</span><br><span class="line">            <span class="keyword">while</span>(number[i]&gt;<span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (number[i]&lt;number[tid] ||</span><br><span class="line">                      (number[i]==number[tid] &amp;&amp; i&lt;tid)</span><br><span class="line">                     )) _mm_pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Critical section</span></span><br><span class="line">    s.v--;</span><br><span class="line"><span class="comment">// Leave section</span></span><br><span class="line">    number[tid] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(BSEM &amp;s, <span class="keyword">int</span> tid)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Entry section</span></span><br><span class="line">    choosing[tid] = <span class="literal">true</span>;</span><br><span class="line">    number[tid] = *<span class="built_in">max_element</span>(number, number+<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">    choosing[tid] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(choosing[i]) _mm_pause();</span><br><span class="line">        <span class="keyword">while</span>(number[i]&gt;<span class="number">0</span> &amp;&amp;</span><br><span class="line">                (number[i]&lt;number[tid] ||</span><br><span class="line">                  (number[i]==number[tid] &amp;&amp; i&lt;tid)</span><br><span class="line">                 )) _mm_pause();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Critical section</span></span><br><span class="line">    s.v++;</span><br><span class="line">    <span class="keyword">if</span>(s.v&gt;<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// Leave section</span></span><br><span class="line">    number[tid] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> tid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(bsem, tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> rawtime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">timeinfo</span>;</span></span><br><span class="line">    <span class="built_in">time</span> (&amp;rawtime);</span><br><span class="line">    timeinfo = <span class="built_in">localtime</span> (&amp;rawtime);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; tid &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Current local time and date: %s&quot;</span>, <span class="built_in">asctime</span>(timeinfo));</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">V</span>(bsem, tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bsem.v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;thread&gt; ths;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        choosing[i] = <span class="literal">false</span>;</span><br><span class="line">        number[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ths.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(Worker, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (thread &amp; th : ths) &#123;</span><br><span class="line">		<span class="keyword">if</span> (th.<span class="built_in">joinable</span>())</span><br><span class="line">			th.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Counting semaphore (計數)
<ul>
<li>semaphore 值域在整數之上(可為負)</li>
<li><strong>可以利用負值知道目前有多少 Process 正在等待 semaphore，ex. s = -n。</strong></li>
</ul></li>
<li>使用 Binary semaphore 實現 Counting semaphore。
<ul>
<li>共享變數
<ul>
<li>C：int<br>代表 Counting semaphore 號誌值。</li>
<li><strong>S1：binary semaphore = 1。</strong><br><strong>對 C 作互斥控制，防止 race condition。</strong></li>
<li><strong>S2：Binary semaphore = 0</strong>。<br><strong>當 C &lt; 0 的時候，讓 process 暫停。</strong></li>
</ul></li>
<li>程式</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wait</span>(C):</span><br><span class="line">	<span class="built_in">wait</span>(S1);</span><br><span class="line">	C--;</span><br><span class="line">	<span class="keyword">if</span>(C &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">signal</span>(S1);</span><br><span class="line">		<span class="built_in">wait</span>(S2);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">signal</span>(S1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">signal</span>(C):</span><br><span class="line">	<span class="built_in">wait</span>(S1);</span><br><span class="line">	c++;</span><br><span class="line">	<span class="keyword">if</span>(c&lt;=<span class="number">0</span>) </span><br><span class="line">		<span class="built_in">signal</span>(S2);</span><br><span class="line">	<span class="built_in">signal</span>(S1);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C: counting semaphore = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span>(c);</span><br><span class="line">	<span class="comment">// Critical section</span></span><br><span class="line"><span class="built_in">signal</span>(c);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> choosing[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> number[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">b_Semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125; BSEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">c_Semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    BSEM s1;</span><br><span class="line">    BSEM s2;</span><br><span class="line">&#125; CSEM;</span><br><span class="line">CSEM csem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">( BSEM &amp;s, <span class="keyword">int</span> tid )</span> </span>&#123;</span><br><span class="line"><span class="comment">// Entry section</span></span><br><span class="line">    choosing[tid] = <span class="literal">true</span>;</span><br><span class="line">    number[tid] = *<span class="built_in">max_element</span>(number, number+<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">    choosing[tid] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(choosing[i]) (<span class="keyword">void</span>)<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(number[i]&gt;<span class="number">0</span> &amp;&amp;</span><br><span class="line">                (number[i]&lt;number[tid] ||</span><br><span class="line">                  (number[i]==number[tid] &amp;&amp; i&lt;tid)</span><br><span class="line">                 )) (<span class="keyword">void</span>)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(s.v&lt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// Leave section</span></span><br><span class="line">        number[tid] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Critical section</span></span><br><span class="line">        (<span class="keyword">void</span>)<span class="number">0</span>;</span><br><span class="line"><span class="comment">// Entry section</span></span><br><span class="line">        choosing[tid] = <span class="literal">true</span>;</span><br><span class="line">        number[tid] = *<span class="built_in">max_element</span>(number, number+<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">        choosing[tid] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(choosing[i]) (<span class="keyword">void</span>)<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(number[i]&gt;<span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (number[i]&lt;number[tid] ||</span><br><span class="line">                      (number[i]==number[tid] &amp;&amp; i&lt;tid)</span><br><span class="line">                     )) (<span class="keyword">void</span>)<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Critical section</span></span><br><span class="line">    s.v--;</span><br><span class="line"><span class="comment">// Leave section</span></span><br><span class="line">    number[tid] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(BSEM &amp;s, <span class="keyword">int</span> tid)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Entry section</span></span><br><span class="line">    choosing[tid] = <span class="literal">true</span>;</span><br><span class="line">    number[tid] = *<span class="built_in">max_element</span>(number, number+<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">    choosing[tid] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(choosing[i]) (<span class="keyword">void</span>)<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(number[i]&gt;<span class="number">0</span> &amp;&amp;</span><br><span class="line">                (number[i]&lt;number[tid] ||</span><br><span class="line">                  (number[i]==number[tid] &amp;&amp; i&lt;tid)</span><br><span class="line">                 )) (<span class="keyword">void</span>)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Critical section</span></span><br><span class="line">    s.v++;</span><br><span class="line">    <span class="keyword">if</span>(s.v&gt;<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// Leave section</span></span><br><span class="line">    number[tid] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(CSEM&amp; s, <span class="keyword">int</span> tid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(s.s1, tid);</span><br><span class="line">    s.c--;</span><br><span class="line">    <span class="keyword">if</span>(s.c&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">V</span>(s.s1, tid);</span><br><span class="line">        <span class="built_in">P</span>(s.s2, tid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">V</span>(s.s1, tid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(CSEM&amp; s, <span class="keyword">int</span> tid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(s.s1, tid);</span><br><span class="line">    s.c++;</span><br><span class="line">    <span class="keyword">if</span>(s.c&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">V</span>(s.s2, tid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">V</span>(s.s1, tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> tid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(csem, tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> rawtime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">timeinfo</span>;</span></span><br><span class="line">    <span class="built_in">time</span> (&amp;rawtime);</span><br><span class="line">    timeinfo = <span class="built_in">localtime</span> (&amp;rawtime);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; tid &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Current local time and date: %s&quot;</span>, <span class="built_in">asctime</span>(timeinfo));</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">V</span>(csem, tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    csem.c = <span class="number">3</span>;</span><br><span class="line">    csem.s1.v = <span class="number">1</span>;</span><br><span class="line">    csem.s2.v = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;thread&gt; ths;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        choosing[i] = <span class="literal">false</span>;</span><br><span class="line">        number[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ths.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(Worker, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (thread &amp; th : ths) &#123;</span><br><span class="line">		<span class="keyword">if</span> (th.<span class="built_in">joinable</span>())</span><br><span class="line">			th.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分類二---是否-busy-waiting">分類二 - 是否 Busy-waiting</h4>
<h5 id="spinlock">Spinlock</h5>
<p>令 S 為 semaphore 變數。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wait</span>(s):</span><br><span class="line">	<span class="keyword">while</span>(s&lt;=<span class="number">0</span>);</span><br><span class="line">	s--;</span><br><span class="line"></span><br><span class="line"><span class="built_in">signal</span>(s):</span><br><span class="line">	s++;</span><br></pre></td></tr></table></figure>
<p>Pros and Cons：與 busy waiting 優缺一致。</p>
<h5 id="non-busy-waiting-semaphore">Non-Busy-waiting semaphore</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Queue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s:<span class="function">semaphore</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">wait</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="function">	s.value--;</span></span><br><span class="line">    <span class="keyword">if</span>(s.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		add process P into s.q;</span><br><span class="line">		<span class="built_in">block</span>(P);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">signal</span>(s):</span><br><span class="line">	s.value++;</span><br><span class="line">    <span class="keyword">if</span>(s.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		remove a process P from s.q;</span><br><span class="line">		<span class="built_in">wakeup</span>(P);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>＜Note＞這種實現的方法也算是 counting semaphore。</strong></p>
<h4 id="實現-counting-semaphore">實現 Counting semaphore</h4>
<p>要如何保證 semaphore 避免 Race condition，也要確保 wait 與 signal 等指令是不可分割的。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th><strong>Non-busy waiting semaphore</strong></th>
<th><strong>Spinlock semaphore</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Disable interrupt</strong></td>
<td>☆ Alogorithm1</td>
<td>☆ Alogorithm3</td>
</tr>
<tr class="even">
<td><strong>C.S. Design：Software sol.、Hardware sol.</strong></td>
<td>Alogorithm2</td>
<td>Alogorithm4</td>
</tr>
</tbody>
</table>
<h5 id="alogrithm1">Alogrithm1</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// alogoithm1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Queue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s:<span class="function">semaphore</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">wait</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="function">	// disable interrupt</span></span><br><span class="line"><span class="function">	s.value--;</span></span><br><span class="line">    <span class="keyword">if</span>(s.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		add process P into s.q;</span><br><span class="line">        <span class="comment">// enable interrupt</span></span><br><span class="line">		<span class="built_in">block</span>(P);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// enable interrupt</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">signal</span>(s):</span><br><span class="line">	<span class="comment">// disable interrupt</span></span><br><span class="line">	s.value++;</span><br><span class="line">    <span class="keyword">if</span>(s.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		remove a process P from s.q;</span><br><span class="line">		<span class="built_in">wakeup</span>(P);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// enable interrupt</span></span><br></pre></td></tr></table></figure>
<h5 id="algorithm2">Algorithm2</h5>
<ul>
<li>將「Algorithm1」中的<code>disable interrupt</code>換成是<code>entry section</code>。</li>
<li>將「Algorithm1」中的<code>enable interrupt</code>換成是<code>exit section</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// algorithm2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	Queue u;</span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span>(s):</span><br><span class="line">	<span class="comment">// entry section</span></span><br><span class="line">	s.value--;</span><br><span class="line">	<span class="keyword">if</span>(s.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		add process P into s.q;</span><br><span class="line">		<span class="comment">// exit section</span></span><br><span class="line">		<span class="built_in">block</span>();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// exit section</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="built_in">signal</span>(s):</span><br><span class="line">	<span class="comment">// entry section</span></span><br><span class="line">	s.value++;</span><br><span class="line">	<span class="keyword">if</span>(s.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        remove process P from s.q;</span><br><span class="line">        <span class="built_in">wakeup</span>(P);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// exit section</span></span><br></pre></td></tr></table></figure>
<h6 id="hardware-solution">Hardware solution</h6>
<ul>
<li>使用<code>test_and_set()</code>實踐「entry section」與「exit section」。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry section</span></span><br><span class="line"><span class="comment">// global waiting: boolean[] = false</span></span><br><span class="line"><span class="comment">// global lock: boolean = false</span></span><br><span class="line"></span><br><span class="line">    waiting[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">test_and_set</span>(lock) &amp;&amp; waiting[i]) ;</span><br><span class="line">    waiting[i] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exit section</span></span><br><span class="line">    tmp = (i + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">while</span>(tmp != i) &#123;</span><br><span class="line">        tmp = (tmp + <span class="number">1</span>) % n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tmp == i) &#123;</span><br><span class="line">        lock = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        waiting[tmp] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="software-solution">software solution</h6>
<ul>
<li>使用「Bakery's solution」。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entery section</span></span><br><span class="line"><span class="comment">// global chooseing: boolean[] = false</span></span><br><span class="line"><span class="comment">// global number:int[] = false</span></span><br><span class="line">	choosing[i] = <span class="literal">true</span>;</span><br><span class="line">	number[i] = <span class="built_in">Max</span>(number[<span class="number">0</span>], ... , number[n<span class="number">-1</span>]) + <span class="number">1</span> </span><br><span class="line">	choosing[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; n; j++ ) &#123;</span><br><span class="line">        <span class="keyword">while</span> (choosing[j]) <span class="keyword">do</span> no-op;  <span class="comment">// 等待P_j 取得號碼牌。</span></span><br><span class="line">        <span class="comment">//比較號碼牌與 Process ID。</span></span><br><span class="line">        <span class="keyword">while</span>(number[j]&gt;<span class="number">0</span> &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) <span class="keyword">do</span> no-op; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exit section</span></span><br><span class="line">	number[i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h5 id="algorithm3">Algorithm3</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// algorithm3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line">semaphore s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span>(s):</span><br><span class="line">	<span class="comment">// disable interrupt</span></span><br><span class="line">	s.value--;</span><br><span class="line">    <span class="keyword">while</span>(s.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// enable interrupt</span></span><br><span class="line">		<span class="built_in">sleep</span>(random);</span><br><span class="line">		<span class="comment">// disable interrupt</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// enable interrupt</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">signal</span>(s):</span><br><span class="line">	<span class="comment">// disable interrupt</span></span><br><span class="line">	s.value++;</span><br><span class="line">	<span class="comment">// enable interrupt</span></span><br></pre></td></tr></table></figure>
<h5 id="alogorithm4">Alogorithm4</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// algorithm4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line">semaphore s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span>(s):</span><br><span class="line">	<span class="comment">// entery section</span></span><br><span class="line">	s.value--;</span><br><span class="line">    <span class="keyword">while</span>(s.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// exit section</span></span><br><span class="line">        <span class="built_in">sleep</span>(random);</span><br><span class="line">        <span class="comment">// entery section</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// exit section</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">signal</span>(s):</span><br><span class="line">	<span class="comment">// entery section</span></span><br><span class="line">	s.value++;</span><br><span class="line">	<span class="comment">// exit section</span></span><br></pre></td></tr></table></figure>
<h6 id="hardware-solution-1">Hardware solution</h6>
<ul>
<li>使用<code>test_and_set()</code>實踐「entry section」與「exit section」。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry section</span></span><br><span class="line"><span class="comment">// global waiting: boolean[] = false</span></span><br><span class="line"><span class="comment">// global lock: boolean = false</span></span><br><span class="line"></span><br><span class="line">    waiting[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">test_and_set</span>(lock) &amp;&amp; waiting[i]) ;</span><br><span class="line">    waiting[i] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exit section</span></span><br><span class="line">    tmp = (i + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">while</span>(tmp != i) &#123;</span><br><span class="line">        tmp = (tmp + <span class="number">1</span>) % n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tmp == i) &#123;</span><br><span class="line">        lock = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        waiting[tmp] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="software-solution-1">software solution</h6>
<ul>
<li>使用「Bakery's solution」。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entery section</span></span><br><span class="line"><span class="comment">// global chooseing: boolean[] = false</span></span><br><span class="line"><span class="comment">// global number:int[] = false</span></span><br><span class="line">	choosing[i] = <span class="literal">true</span>;</span><br><span class="line">	number[i] = <span class="built_in">Max</span>(number[<span class="number">0</span>], ... , number[n<span class="number">-1</span>]) + <span class="number">1</span> </span><br><span class="line">	choosing[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; n; j++ ) &#123;</span><br><span class="line">        <span class="keyword">while</span> (choosing[j]) <span class="keyword">do</span> no-op;  <span class="comment">// 等待P_j 取得號碼牌。</span></span><br><span class="line">        <span class="comment">//比較號碼牌與 Process ID。</span></span><br><span class="line">        <span class="keyword">while</span>(number[j]&gt;<span class="number">0</span> &amp;&amp; (numbeer[j], j) &lt; (number[i], i)) <span class="keyword">do</span> no-op; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exit section</span></span><br><span class="line">	number[i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="無法完全避免的-busy-waiting">無法完全避免的 Busy-waiting</h4>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 38%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>定義</th>
<th>製作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>semaphore</td>
<td>Busy waiting <span class="math inline">\(\Rightarrow\)</span> Non-busy waiting</td>
<td>在實踐「Entry section」時，就必須使用「Busy-waiting」。</td>
</tr>
<tr class="even">
<td>semaphore</td>
<td>Busy waiting <span class="math inline">\(\Rightarrow\)</span> Non-busy waiting</td>
<td>若使用「Disable interrupt」，<strong>風險實在太高，且不適合用在多處理器( Multiprocessor )之上。</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><blockquote>
<p><strong>在 Semaphore 之下的 Busy waiting 是短暫的，不避太在意會浪費效能。</strong></p>
</blockquote></li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Process Synchronization</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System - Process Management and Thread Management</title>
    <url>/willywangkaa/2018/07/10/Operating-System-Process-Management-and-Thread-Management/</url>
    <content><![CDATA[<h1 id="process">Process</h1>
<ul>
<li><p>定義：A program in execution.</p>
<ul>
<li>Process 建立後，主要組成有：<span class="math inline">\(^{[1]}\)</span>Process NO.(ID), <span class="math inline">\(^{[2]}\)</span>Process state, <span class="math inline">\(^{[3]}\)</span>Process menory space：Code section, Data section。</li>
<li>Programming Counter (PC)：下一條指令的位址。</li>
<li>Stack</li>
<li>Cpu registers value</li>
<li><strong>是 OS 分配資源(CPU, I/O - Devce, Memory)的基本單位。</strong></li>
</ul></li>
<li><p>與Program (程式) 的差異</p>
<table>
<thead>
<tr class="header">
<th>Process</th>
<th>Program</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>執行中的程式</strong></td>
<td>只是一個在硬碟的檔案</td>
</tr>
<tr class="even">
<td>"執行中"的單位</td>
<td>"被動的"單位</td>
</tr>
</tbody>
</table></li>
</ul>
<h2 id="procress-control-block">Procress Control Block</h2>
<ul>
<li><p>定義：作業系統為了管裡所有的 process ，會在 kernel memory 中，替每個 process 各自準備一個 block 紀錄 process 之所有相關的資訊。</p></li>
<li><p>內容：</p>
<ul>
<li>Process No. (ID)：是唯一( unique )的。</li>
<li>Process state：有 「ready」、「running」、「wait」...。</li>
<li>Programming Counter ( PC )</li>
<li>CPU registers：有accmulatorm, psw, stack top...</li>
<li>CPU schedualing infomation：優先權值、process arrival time (FIFO)。</li>
<li>Memory management infomation：隨作業系統記憶體管理方式不同記錄不同的資訊。如：Base/limit register, page table 或 segememt table。</li>
<li>Accounting infomation：Pocess 已使用了多少 CPU time ，那些資源還剩多少資源、還剩 CPU time 可用，<strong>系統管理員依據此資訊用以調校效能</strong>。</li>
<li>I/O status infomation：Process 已發出多少 I/O-request，完成狀態如何，目前占用哪些 <strong>I/O 資源</strong>。</li>
</ul></li>
<li><p><span class="math inline">\(Ex29.\)</span> (Ref P.4-75)：以下哪些項目是<strong>不包含</strong>在正常的 PCB 當中？</p>
<ul>
<li>Process number</li>
<li>CPU register</li>
<li><strong>I/O device queue</strong>：為作業系統管理，不屬於每個 process。</li>
</ul></li>
<li><p><span class="math inline">\(Ex34.\)</span> (Ref P.4-78)：以下哪些項目是<strong>不包含</strong>在正常的 PCB 當中？</p>
<ul>
<li>Process state</li>
<li>The <strong>bitmap of this process</strong>：用於磁碟可用空間的管理方法。</li>
<li>Register</li>
</ul></li>
</ul>
<h2 id="state-trasition-diagram-s.t.d.">State trasition diagram (S.T.D.)</h2>
<p>用於描述 Process 的 Lifecycle。</p>
<h3 id="五個狀態">五個狀態</h3>
<ul>
<li>狀態
<ul>
<li>New (Create)：Process 被建立，已分得 PCB 空間，<strong>尚未載入 memory( 尚未取得 memory 資源 )</strong>。</li>
<li>Ready：Process 已在 memory 中，<strong>且在 ready queue 內，具有資格爭奪 CPU</strong>。</li>
<li>Running：Process 取得 CPU 並執行中。</li>
<li>Wait( Blocked )：Process 在 waitting queue 中，等待 I/O completed 或 事件發生。( <strong>不會爭奪CPU</strong> )</li>
<li>Exit( Terminate, Zombie, <em>abort</em> )：Process 完成工作正常結束或異常終止，<strong>此時可能其 PCB 尚未回收，因為要等其父親 (paraent-process)得到孩子(child-process)的成果之後</strong>，才會回收 PCB space。( 其他資源如memory, cpu, I/O-Device 等已回收 )</li>
</ul></li>
<li>轉換
<ul>
<li>Admited：當記憶體空間足夠時，可由 <strong>long-term scheduler</strong>依優先權決定此工作載入與否。( in Batch system, not in Time sharing, not in Interactive system )</li>
<li>Dispatch：由 <strong>short-term scheduler</strong> 決定，讓高優先權的process 取得 CPU。</li>
<li>Interrupt (Time-out)：<strong>執行中的 process 會因為某些事件發生而被迫放棄CPU，回到 ready queue。</strong><br>例如：<strong>Time-out, interrupt 發生</strong>，高優先權的 process 到達而被插隊。</li>
<li>Exit：Process 完成工作或異常終止。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1526880431737.png" alt="1526880431737" /><figcaption aria-hidden="true">1526880431737</figcaption>
</figure>
<h3 id="七個狀態">*七個狀態</h3>
<ul>
<li><p>狀態</p>
<ul>
<li>Block/Suspend：Process 被 swapout 到磁碟中暫存。(Blocked/Sleep in Disk)</li>
<li>Ready/Suspend：事件完成或 I/O-completed。(Ready in Disk)</li>
</ul></li>
<li><p>轉換</p>
<ul>
<li>Admit (實線)：記憶體足夠時。</li>
<li>Admit (虛線)：記憶體不足時。</li>
<li>Block-Suspend ( Swap-out )：當 memory 空間不足且有其他高優先權 process 需要更多 memory space 時，會由 <strong>medium-term scheduler 決定將 blocked process swap-out 至磁碟以空出 memory space</strong>。</li>
<li>Block-Ready ( Swap-in )：<em>這是一個不好的設計，但仍可以支持</em>主要是因為若所有的「Blocked-suspend state」process 優先權皆高於「Ready-suspend state」process，且作業系統相信後者會比較早進入<strong>等待狀態</strong>時。</li>
<li>Ready-Suspend( Swap-out )：支持此行為( trainsition )的理由：<br><span class="math inline">\(^{[1]}\)</span> 所有 blocked process 皆 swap-out 後 memory 仍不足時。<br><span class="math inline">\(^{[2]}\)</span> <strong>所有 blocked state process 之優先權皆高於 ready state process 時。</strong></li>
<li>Ready-Active ( Swap-in )：當 memory 有空時，<strong>medium-term scheduler 可將process swap-in memory 之中(Ready)準備被執行。</strong></li>
<li>Running-Suspend( Swap-out )：<em>這是一個不好的設計，但仍可以支持</em>主要是因為若有一個高優先權process 從 「Blocked/suspend」變為「Ready/suspend」時，則作業系統可以強迫<strong>低優先權的process放掉 CPU 及 memory，供高優先權的 process 使用。</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1526883114200.png" alt="1526883114200" /><figcaption aria-hidden="true">1526883114200</figcaption>
</figure>
<blockquote>
<p>Queuing diagram</p>
<figure>
<img src="\willywangkaa\images\queuingdiagramforprocessmodel.png" alt="Queuingdiagram" /><figcaption aria-hidden="true">Queuingdiagram</figcaption>
</figure>
</blockquote>
<h3 id="unix-std">UNIX STD</h3>
<figure>
<img src="\willywangkaa\images\1526885420905.png" alt="1526885420905" /><figcaption aria-hidden="true">1526885420905</figcaption>
</figure>
<h1 id="scheduler">Scheduler</h1>
<h2 id="io-bound-cpu-bound">I/O-bound &amp; CPU-bound</h2>
<figure>
<img src="\willywangkaa\images\1526887552589.png" alt="1526887552589" /><figcaption aria-hidden="true">1526887552589</figcaption>
</figure>
<ul>
<li>I/O-bound Job
<ul>
<li>定義：此類型的工作大都是需要<em>大量的 I/O operation( Resourse )但對於 CPU time( Computation )需求很少</em>，<strong>所以其工作效能會受限於 I/O-device 之速度。</strong></li>
<li>例如：資料庫管理、財報列印...。</li>
</ul></li>
<li>CPU-bound Job
<ul>
<li>定義：此類型的工作大都是需要<em>大量的 CPU time( Computation ) 但對於 I/O operation( Resourse )需求很少</em>，<strong>所以其工作效能會受限於 CPU 之速度。</strong></li>
<li>氣象預估的大氣模型、科學模擬...。</li>
</ul></li>
</ul>
<h2 id="long-term-schduler">Long-term schduler</h2>
<ul>
<li>定義：又稱為 Job schduler，目的是為了從 Job-queue 中挑選一些工作載入到記憶體中。</li>
<li><strong>特點：</strong>
<ul>
<li>執行頻率最低。</li>
<li>可以調控 Multiprogramming degree。</li>
<li>可以調控 I/O-bound Job 與 CPU-bound Job 之混和比例。</li>
<li>由 Batch system 採用，但是 Real-time system 及 Time-sharing system 皆不會採用。</li>
</ul></li>
</ul>
<h2 id="short-term-schduler">Short-term schduler</h2>
<ul>
<li>定義：又叫做<strong>CPU schduler 或 process schduler，</strong>目的是從「Ready queue」中<strong>挑出一個高優先權的 process，分派 CPU 給予執行。</strong></li>
<li><strong>特點：</strong>
<ul>
<li>執行頻率<strong>最高</strong>。</li>
<li><strong>無法</strong>調控 Multiprogramming degree。</li>
<li><strong>無法</strong>調控 I/O-bound Job 與 CPU-bound Job 之混和比例。</li>
<li>所有的 system 皆採用。</li>
</ul></li>
</ul>
<h2 id="midium-term-scheduler">★Midium-term scheduler</h2>
<ul>
<li><strong>定義：為 Time-sharing system</strong> 所採用。( 不為 Real-time system 所採用，因為該系統不支援 Swap-out - 虛擬記憶體 )</li>
<li>目的：當記憶體空間不足時，且又有其他高優先權的 process 需要記憶體時，此 scheduler <strong>會挑選一些process ( 例：Blocked process、低優先權 procss ) 將其 swap-out 到磁碟中保存，以空出記憶體空間，翁其他 process 使用，將來等到有足夠的記憶體空間被釋放時，此 sechduler可再將 Swap-outed process Swap-in 至記憶體等待執行( Ready for execution )。</strong></li>
<li><strong>特點：</strong>
<ul>
<li>執行頻率<strong>居中</strong>。</li>
<li><strong>可以</strong>調控 Multiprogramming degree。</li>
<li><strong>可以</strong>調控 I/O-bound Job 與 CPU-bound Job 之混和比例。</li>
<li>為 Time sharing system 採用，但 real-time system 與 batch system 不採用。</li>
</ul></li>
</ul>
<h1 id="context-switching">Context switching</h1>
<p>當 CPU 要從 running process 切給另一個 process 使用之前，kernel 執行 <strong>context-switching</strong> 包含：</p>
<ul>
<li><strong>保存</strong> running process 之目前狀態的資訊( PCB )。如：PC、stack、CPU register...。</li>
<li>要載入( Restore )另一個 Process 之狀態資訊( PCB )。</li>
</ul>
<p><strong>Context switching 是一額外負擔</strong>，其時間長短大都取決於硬體的因素。如：暫存器之數量、記憶體存取速度。</p>
<h2 id="如何降低-context-switching-的負擔">如何降低 Context switching 的負擔？</h2>
<ul>
<li>方法一：<strong>若暫存器很多，則可以</strong>
<ul>
<li>讓每個 process 皆有私有的( private )「Register set」，則作業系統只要切換指標指向另一個 process 的「Register set」即可完成 context swiching，而不用記憶體的存取( store and restore )。</li>
<li>此種方法速度最快。</li>
</ul></li>
<li>方法二：<strong>使用「Multithreading」機制。</strong></li>
<li>方法三：讓 <strong>system process</strong> 以及<strong>user process</strong>各自有自己的 register set，如此一來兩者之間的切換只要改變指向register set 的 pointer 即可。</li>
</ul>
<h1 id="dispatcher-and-dispatch-latency-分派器與分派延時">Dispatcher and dispatch latency （分派器與分派延時）</h1>
<ul>
<li>定義：Dispatcher 為一<em>模組</em>用來<strong>將 CPU 控制權授予「經由 CPU scheduler」所選出之 process (user process)。</strong></li>
<li>主要工作
<ul>
<li><strong>Context switching</strong> ( 費時最久 )</li>
<li><strong>Change mode from kernel mode to user mode</strong></li>
<li><strong>Jump to the execution entry of that selected process</strong></li>
</ul></li>
<li>在做上述這些工作的時間的總和就稱為「Dispatch Latency」。</li>
<li>Dispatch Latency 越小越好。</li>
</ul>
<h1 id="process-control-operations">Process control operations</h1>
<p>也就是 process 的建立、終止、暫停、回復執行、設定、修改、讀取 process attributes ...，<strong>而這些都應是作業系統提供的服務(system call)</strong></p>
<ul>
<li>Process 可以建立自己的 child process，<strong>目的是要 child process 工作。</strong></li>
<li><strong>Child process 的工作可分為兩類：</strong>
<ul>
<li><strong>與 parent 相同的工作。</strong>(word編輯器)</li>
<li><strong>特定工作 。</strong>(與 parent 不同)</li>
</ul></li>
<li><strong>Parent 與 child 之互動關係</strong>
<ul>
<li>Concurrent execution</li>
<li>Parent waits for child until child terminated</li>
</ul></li>
<li>Child process 的資源取得
<ul>
<li>方法一：<strong>作業系統供應</strong></li>
<li>方法二：<strong>Parente供應</strong></li>
</ul></li>
<li><em>Parent 若終止</em>，則 child process 會：
<ul>
<li>方法一 - Cascading termination：<strong>一併終止。</strong></li>
<li>方法二：存活資源向<span class="math inline">\(^{[1]}\)</span>作業系統取得，或向<span class="math inline">\(^{[2]}\)</span>祖先 process 取得。</li>
</ul></li>
</ul>
<h2 id="unix-system-call">UNIX system call</h2>
<figure>
<img src="\willywangkaa\images\1527077415190.png" alt="1527077415190" /><figcaption aria-hidden="true">1527077415190</figcaption>
</figure>
<ul>
<li><strong>fork()：</strong>用以建立 child process ，而 fork() 之回傳結果如下：
<ul>
<li>失敗，因為資源不足無法建立 process ，<strong>回傳 -1 給作業系統，在傳給 parent process。</strong></li>
<li><em>成功</em>，作業系統會回傳 <br><span class="math inline">\(^{[1]}\)</span> <strong>0，給 child process。 </strong><br><span class="math inline">\(^{[2]}\)</span> <strong>大於 0 的正整數，給 parent process，且此值為 child process ID (PID)。</strong></li>
</ul></li>
<li><strong>wait()：</strong>用以暫停 process 的執行直到某個事件發生。例如：parent 等到 child 直到 child 終止。</li>
<li><strong>exit()：</strong>用以終止 process 的執行且回收期資源 ( 不包含PCB )，通常 <br><span class="math inline">\(^{[1]}\)</span> exit(0) 表示正常終止。 <br><span class="math inline">\(^{[2]}\)</span> exit(-1) 表示異常終止。</li>
<li><strong>execlp() 或 exec() 或 execve()：</strong>用以載入特定的 Binary code( 可執行檔 ) 執行。 <br><strong>例：execlp("目錄名稱", "檔名", 個數)</strong></li>
<li>getpid()：用以取得 process 的 ID。</li>
</ul>
<figure>
<img src="\willywangkaa\images\1527077382823.png" alt="1527077382823" /><figcaption aria-hidden="true">1527077382823</figcaption>
</figure>
<p><strong>＜Note＞：</strong></p>
<ol type="1">
<li>呼叫 fork() 後作業系統會配置 child process memory space，此空間與 parent 是佔用不同的記憶體空間，且 child 的資料區塊及程式碼區塊內容均來自 parent 的一份副本。</li>
<li>若 child 所做的工作與 parent 相同( 平行處理 )，則只要使用 fork() 便可達到此目的。</li>
<li><strong>若 child 要做特定的工作(與 parent 不同)，則 child 必須執行 execlp() 以載入特定工作的執行檔。</strong></li>
</ol>
<figure>
<img src="\willywangkaa\images\1527077442901.png" alt="1527077442901" /><figcaption aria-hidden="true">1527077442901</figcaption>
</figure>
<h2 id="程式實際操作">程式實際操作</h2>
<hr />
<h3 id="ex1."><span class="math inline">\(Ex1.\)</span></h3>
<p>建立 child process 執行 ls 命定檔且 parent 等到 child 完成之後 parent 才輸出「child complete」。</p>
<p>Creating a separate process using the UNIX fork() system call.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();                        <span class="comment">//fork a child process</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;                       <span class="comment">// error occurred</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Fork Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                        <span class="comment">//exit(-1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;                 <span class="comment">// child process</span></span><br><span class="line">    	<span class="built_in">execlp</span>(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);     <span class="comment">// 程式區塊指標轉換，下方不做，見上圖。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                               <span class="comment">// parent process</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);                      <span class="comment">// parent will wait for the child to complete</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Complete\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ex2.-ref-p.-4-52"><span class="math inline">\(Ex2.\)</span> (Ref p. 4-52)</h3>
<p>Identify the values of pid at lines A, B, C, and D. ( Assume that the actual pids of the <strong>parent and child are 2600 and 2603</strong>, respectively. )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, pid1;</span><br><span class="line">    pid = fork();                          <span class="comment">// fork a child process</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;                         <span class="comment">// error occurred</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Fork Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;                   <span class="comment">// child process</span></span><br><span class="line">        pid1 = <span class="built_in">getpid</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A: Child: pid = %d\n&quot;</span>,pid);     <span class="comment">// A -&gt; 0</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B: Child: pid1 = %d\n&quot;</span>,pid1);   <span class="comment">// B -&gt; 2603</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                 <span class="comment">// parent process</span></span><br><span class="line">        pid1 = <span class="built_in">getpid</span>();                   <span class="comment">// child process ID</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C: Parent: pid = %d\n&quot;</span>,pid);    <span class="comment">// C -&gt; 2603</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;D: Parent: pid1 = %d\n&quot;</span>,pid1);  <span class="comment">// D -&gt; 2600</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ex3.-ref-p.-4-53"><span class="math inline">\(Ex3.\)</span> (Ref p. 4-53)</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;                                <span class="comment">// global varible</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;                           <span class="comment">// child process</span></span><br><span class="line">        value += <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;                       <span class="comment">// parent process</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PARENT: value = %d\n&quot;</span>,value); <span class="comment">// LINE A value -&gt; 5</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ex4.-程序的並行">★<span class="math inline">\(Ex4.\)</span> 程序的並行</h3>
<ol type="1">
<li>求輸出結果？ ( Tip: <strong>父與子是並行的。</strong> )</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;                         <span class="comment">// child process</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;A\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;                     <span class="comment">// parent process</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ans：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>
<p>OR</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<p>都有可能。</p>
<ol start="2" type="1">
<li>求輸出結果？ ( Tip: <strong>父與子是並行的。</strong> )</li>
</ol>
<p>考慮：</p>
<figure>
<img src="\willywangkaa\images\1527080836257.png" alt="1527080836257" /><figcaption aria-hidden="true">1527080836257</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;                         <span class="comment">// child process</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;A\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;                     <span class="comment">// parent process</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B\n&quot;</span>);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;C\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ans：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<p>OR</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<p>OR</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B</span><br><span class="line">A</span><br><span class="line">C</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<h3 id="ex5.-共享變數">★<span class="math inline">\(Ex5.\)</span> 共享變數</h3>
<ol type="1">
<li><strong>假設 Count 是 parent 與 child process 的共享變數，且初值為 5。</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;                         <span class="comment">// child process</span></span><br><span class="line">		count++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;                     <span class="comment">// parent process</span></span><br><span class="line">		<span class="built_in">wait</span>();</span><br><span class="line">		count--;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ans：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>＜Note＞：</strong>共享變數可用以下方式達成。</p>
<ol type="1">
<li>檔案共享。</li>
<li>UNIX 的 pipe。</li>
<li>共享記憶體區間。( Windows / Linux )</li>
</ol>
</blockquote>
<ol start="2" type="1">
<li><strong>假設 Count 是 parent 與 child process 的共享變數，且初值為 5。</strong></li>
</ol>
<p>考慮：</p>
<figure>
<img src="\willywangkaa\images\1527081997770.png" alt="1527081997770" /><figcaption aria-hidden="true">1527081997770</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* count;</span><br><span class="line">	count = (<span class="keyword">int</span>*) <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (count == MAP_FAILED) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mmap failed...&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*count = <span class="number">5</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;	</span><br><span class="line">        (*count)++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		(*count)--;</span><br><span class="line">	&#125;</span><br><span class="line"> 	cout &lt;&lt; (*count) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ans：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>OR</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>OR</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>OR ( <strong>當指令不是 atomic 時</strong> )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>OR ( <strong>當指令不是 atomic 時</strong> )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>★OR ( <strong>當指令不是 atomic 時</strong> )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>★OR ( <strong>當指令不是 atomic 時</strong> )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="ex6.-有幾個-process-被建立了-including-main-ref-p.-4-54-text-book-p.-150"><span class="math inline">\(Ex6.\)</span> 有幾個 process 被建立了？ including main() (Ref p. 4-54, Text book p. 150)</h3>
<ol type="1">
<li></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* fork a child process */</span></span><br><span class="line">    fork();</span><br><span class="line">    <span class="comment">/* fork another child process */</span></span><br><span class="line">    fork();</span><br><span class="line">    <span class="comment">/* and fork another */</span></span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ans：8 個。</p>
<ol start="2" type="1">
<li></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123; <span class="comment">// child process</span></span><br><span class="line">        fork();</span><br><span class="line">        fork();</span><br><span class="line">    &#125;</span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ans：10 個。</p>
<figure>
<img src="\willywangkaa\images\1531135436305.png" alt="1531135436305" /><figcaption aria-hidden="true">1531135436305</figcaption>
</figure>
<ol start="3" type="1">
<li>★</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">if</span>(fork()&gt;<span class="number">0</span>) &#123;       <span class="comment">// parent process</span></span><br><span class="line">        fork();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(fork()==<span class="number">0</span>) &#123; <span class="comment">// child process</span></span><br><span class="line">        fork();</span><br><span class="line">        fork();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ans： 14 個。(<del>30個</del>)</p>
<figure>
<img src="\willywangkaa\images\1531136821130.png" alt="1531136821130" /><figcaption aria-hidden="true">1531136821130</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1531137337724.png" alt="1531137337724" /><figcaption aria-hidden="true">1531137337724</figcaption>
</figure>
<ol start="4" type="1">
<li>★★</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fork()==<span class="number">0</span>) &#123;</span><br><span class="line">            fork();</span><br><span class="line">            fork();</span><br><span class="line">            fork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ans：729 個。</p>
<figure>
<img src="\willywangkaa\images\1531138419381.png" alt="1531138419381" /><figcaption aria-hidden="true">1531138419381</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1531139238689.png" alt="1531139238689" /><figcaption aria-hidden="true">1531139238689</figcaption>
</figure>
<p><span class="math inline">\(i == 2\)</span>, 會再多新生 <span class="math inline">\(8 \times 81 = 648\)</span> 加上原本的 81 個等於 729 個 Processes。</p>
<ol start="5" type="1">
<li></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fork()==<span class="number">0</span>) &#123;</span><br><span class="line">            fork();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fork()==<span class="number">0</span>) &#123;</span><br><span class="line">                fork();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ans：216 個。(<del>1728 個</del>)</p>
<figure>
<img src="\willywangkaa\images\1531139971022.png" alt="1531139971022" /><figcaption aria-hidden="true">1531139971022</figcaption>
</figure>
<p><span class="math inline">\(i == 1\)</span>，上面六個 Processes 會再各自生成 5 個行程，所以會再多生產 <span class="math inline">\(5 \times 6 = 30\)</span> 個 Processes ，加上原本的 Processes 等於 36 個。<br><span class="math inline">\(i == 2\)</span>，36 個 Processes 會再各自生成 5 個行程，所以會再多生產 <span class="math inline">\(5 \times 36 = 180\)</span> 個 Processes ，加上原本的 Processes 等於 216 個。</p>
<ol start="6" type="1">
<li><ol type="1">
<li><code>printf("%d\n;", a);</code>共做幾次？</li>
<li>印出<code>0</code>幾次？</li>
<li>印出<code>1</code>幾次？</li>
<li>印出<code>2</code>幾次？</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    fork();</span><br><span class="line">    a--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>) &#123;</span><br><span class="line">        a--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">        fork();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        a++;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ans：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<figure>
<img src="\willywangkaa\images\1531141578065.png" alt="1531141578065" /><figcaption aria-hidden="true">1531141578065</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\ 錯誤答案</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h1 id="cpu-排程">CPU 排程</h1>
<h2 id="評估-cpu-scheduking-效能之五個準則criteria">評估 CPU scheduking 效能之五個準則(criteria)</h2>
<ul>
<li>CPU utilization - CPU 利用度(率)
<ul>
<li><span class="math inline">\(\frac{CPU \; Process \; execution \; time}{CPU \; total \; time}\)</span></li>
<li><span class="math inline">\(CPU \; total \; time = process \; execution \; time + comtext \; switch \; time + idle \; time \dots\)</span></li>
<li>$Ex. $ Process 平均花 5 ms 在 execution 上，花 1 ms 在 comtext switching，則 <span class="math inline">\(CPU \; utilization = \frac{5}{5+1}\)</span></li>
</ul></li>
<li>Throughput - 產能
<ul>
<li>單位時間完成的工作數目。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1527426695265.png" alt="1527426695265" /><figcaption aria-hidden="true">1527426695265</figcaption>
</figure>
<ul>
<li><strong>★ Waiting time - 等待時間</strong>
<ul>
<li>Process 在 Ready Queue 中等待獲得 CPU 之等待<strong>時間的加總</strong>。</li>
<li><span class="math inline">\(Ex.\)</span>上圖的等待時間為 <span class="math inline">\((8-2)+(19-15) = 10\)</span>。</li>
</ul></li>
<li><strong>★ Turnaruond time - 完成時間</strong>
<ul>
<li>自 process <strong>進入(到達)</strong> 到工作完成的這段時間差值。</li>
<li>$Ex. $上圖的等待時間為 <span class="math inline">\(26-2 = 24\)</span>。</li>
</ul></li>
<li><em>Response time - 回應時間</em>
<ul>
<li>自使用者 (user process) 輸入命令(或資料)給系統後，到系統產生第一個回應的時間差。(<strong>Time-shaeing system, user-interactive application 特別重視。</strong>)</li>
</ul></li>
</ul>
<p>由上述可知，CPU utilization、throughput 愈高愈好；waiting time、turnaround time、response time 愈低愈好。</p>
<h2 id="排班法則">排班法則</h2>
<h3 id="starvation">Starvation</h3>
<ul>
<li>Process 因為<strong>長期無法取得完工所需之各項資源，導致遲遲無法完工，形成「Indefinite blocking - 未知期停滯」現象。</strong></li>
<li>容易發生在<em>不公平對待的環境之中</em>，若又有「Preemptive - 可搶奪機制」，<strong>則更容易發生。</strong></li>
<li>解決方案：使用「Aging」技術。隨著 process 待在 system 內的時間逐漸增加，<strong>我們也逐步調高此process 的優先權</strong>，經過一段有限的時間後，此 process 會有最高優先權，故可取得需要的資源(resourses)完工。
<ul>
<li><strong>＜Note＞：soft real-time system 不採用 「Aging」。</strong></li>
</ul></li>
</ul>
<h3 id="non-preemptive-與-premptive-法則">Non-preemptive 與 premptive 法則</h3>
<h4 id="觀點一">觀點一</h4>
<ul>
<li>Non-premptive 法則
<ul>
<li>除非執行中的 process <strong>自願放掉 CPU</strong>，其他的 process 才有機會取得 CPU，否則就只能 wait ，不可逕自搶奪 CPU。</li>
<li><span class="math inline">\(Ex.\)</span> 自願放棄使用 CPU 的情況：<strong>完成工作、wait for I/O-completed after issue I/O-request ...。</strong></li>
<li>Pros
<ol type="1">
<li>Comtext switching 次數<strong>較少</strong> ( 時間節省 )。</li>
<li><strong>Process 之完工時間點較可以預期 ( preditable )。</strong></li>
<li>比較不會有「Race condition problem - 資源競爭問題」。</li>
</ol></li>
<li>Cons
<ol type="1">
<li><strong>排班效能較差，因為可能會有 「Convoy effect」</strong>。</li>
<li><strong>不適合用在 Time-sharing system 與 Real-time system。</strong></li>
</ol></li>
</ul></li>
<li>Preemptive 法則
<ul>
<li>執中的 Provess 有可能<strong>被迫放棄 CPU ，</strong>回到 Ready queue ，再將 CPU 指派給別的 Process 使用。</li>
<li><span class="math inline">\(Ex.\)</span> <strong>Time-out ( 用在分時系統 )、interrupt ...。</strong></li>
<li>Pros
<ol type="1">
<li>排班效益較佳，平均 waiting / turnaround time 較小。</li>
<li>適用於 Real time system 與 Time sharing system。</li>
</ol></li>
<li>Cons
<ol type="1">
<li>完工時間較不可預期。</li>
<li>Context switching 次數較多，負擔重。</li>
<li><strong>須注意 Race condition 的發生。</strong></li>
</ol></li>
</ul></li>
</ul>
<h4 id="觀點二">★觀點二</h4>
<p><strong>從 CPU 排班決策(啟動)的時機點區分。</strong></p>
<ul>
<li>Running <span class="math inline">\(\rightarrow\)</span> Block
<ul>
<li>Ex. Wait for I/O-completed (<strong>自願</strong>)</li>
</ul></li>
<li>Running <span class="math inline">\(\rightarrow\)</span> Ready
<ul>
<li>Ex. Time out (<strong>被迫</strong>)</li>
</ul></li>
<li>Wait <span class="math inline">\(\rightarrow\)</span> Ready
<ul>
<li>Ex. I/O-completed (<strong>高優先權的 Process 開始需要 CPU，作業系統啟動排班器</strong>，低優先權的 process 被迫放棄 CPU )</li>
</ul></li>
<li>Running <span class="math inline">\(\rightarrow\)</span> Exit (terminate)
<ul>
<li>Ex. Task completed (<strong>自願</strong>)</li>
</ul></li>
</ul>
<p><strong>所以若排班決策之啟動點只包含</strong> Running <span class="math inline">\(\rightarrow\)</span> Block 與 Running <span class="math inline">\(\rightarrow\)</span> Exit (terminate) <strong>未包含</strong> Running <span class="math inline">\(\rightarrow\)</span> Ready 或 Wait <span class="math inline">\(\rightarrow\)</span> Ready <strong>則為 Non-preemptive，否則為 Preempt。</strong></p>
<p><strong>＜Note＞：凡是 </strong><span class="math inline">\(\ldots \rightarrow\)</span> <strong>Ready 皆列入 Preemptive 元素，所以 Ready/suspend </strong> <span class="math inline">\(\rightarrow_{Swap\; in}\)</span> <strong>Ready、New</strong> <span class="math inline">\(\rightarrow\)</span> <strong>Ready ... 也列入。</strong></p>
<h3 id="預估-process-next-cpu-burst-time">預估 Process Next CPU Burst Time</h3>
<ul>
<li>公式</li>
</ul>
<p><span class="math display">\[
\tau_{n+1} = \alpha \cdot t_n + (1-\alpha) \cdot \tau_n
\]</span></p>
<ul>
<li><span class="math inline">\(\tau_{n+1}\)</span>：下次預估值。</li>
<li><span class="math inline">\(t_n\)</span>：本次實際值。</li>
<li><span class="math inline">\(\tau_n\)</span>：本次預估值。</li>
<li><span class="math inline">\(\alpha\)</span>：加權值。(<span class="math inline">\(0 \leq \alpha \leq 1\)</span>)</li>
<li><span class="math inline">\(Ex.\)</span> 當<span class="math inline">\(\alpha = 0.5\)</span></li>
</ul>
<figure>
<img src="\willywangkaa\images\1527475744485.png" alt="1527475744485" /><figcaption aria-hidden="true">1527475744485</figcaption>
</figure>
<p><strong>＜Note＞：</strong><span class="math inline">\(\alpha\)</span> 的值用於條整與<strong>歷史紀錄的相依性高低。</strong></p>
<h3 id="fifo">FIFO</h3>
<p><strong>到達時間最小的 process 取得 CPU，也就是說先來先做。</strong></p>
<figure>
<img src="\willywangkaa\images\1527427440948.png" alt="1527427440948" /><figcaption aria-hidden="true">1527427440948</figcaption>
</figure>
<ul>
<li>到達時間皆為 0。</li>
<li>到達順序為：P1、P2、P3。</li>
<li>Gantt chart。</li>
</ul>
<figure>
<img src="\willywangkaa\images\FIFO.png" alt="FIFO" /><figcaption aria-hidden="true">FIFO</figcaption>
</figure>
<ul>
<li>Avg. waitting time</li>
</ul>
<p><span class="math display">\[
\frac{(0-0)+(24-1)+(27-0)}{3}=17
\]</span></p>
<ul>
<li>Avg. turnaround time</li>
</ul>
<p><span class="math display">\[
\frac{(24-0)+(27-0)+(30-0)}{3}=27
\]</span></p>
<ul>
<li><strong>分析</strong>
<ul>
<li>易於製作。</li>
<li>排班效能最差，<strong>即 Avg. waiting time &amp; Avg. turnaround time 最長</strong> (<em>其他準則不看</em>)。</li>
<li>可能有「Convoy effect - 護衛效應」，許多 processes 均等待一個需要很長 CPU time 之 process 完成工作，才能取得 CPU，<strong>導致 Avg. waiting time 太長</strong>。</li>
<li>非常公平。</li>
<li>沒有 starvation 現象。</li>
<li><strong>Non-premptive</strong>，不可搶奪、插隊。</li>
</ul></li>
</ul>
<h3 id="sjf-shortest-job-first">SJF ( Shortest Job First )</h3>
<p><strong>具有最小 CPU time 的 process，</strong>優先取得 CPU。</p>
<figure>
<img src="\willywangkaa\images\1527472805224.png" alt="1527472805224" /><figcaption aria-hidden="true">1527472805224</figcaption>
</figure>
<ul>
<li>到達時間皆為 0。</li>
<li>Gantt chart。</li>
</ul>
<figure>
<img src="\willywangkaa\images\1527472898945.png" alt="1527472898945" /><figcaption aria-hidden="true">1527472898945</figcaption>
</figure>
<ul>
<li>Avg. waiting time</li>
</ul>
<p><span class="math display">\[
\frac{(0-0+(3-0)+(9-0)+(16-0)}{4}=7
\]</span></p>
<ul>
<li><p><strong>分析</strong></p>
<ul>
<li><strong>排班效益最佳( Optimal ) 即 Avg. waiting/turnaround time 最小。</strong><br>Proof：</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1527473571408.png" alt="1527473571408" /><figcaption aria-hidden="true">1527473571408</figcaption>
</figure>
<ul>
<li>由上圖可知<br>Waiting time for long job：<span class="math inline">\(0 \rightarrow CPU \; execution \; time_{short \; job}\)</span><br>Waiting time for short job：<span class="math inline">\(CPU \; execution \; time_{long \; job} \rightarrow 0\)</span><br>Avg. waiting ime：<span class="math inline">\(\frac{(CPU \; execution \; time_{short \; job}-0)+(0-0)}{2} &lt; \frac{(0-0)+(CPU \; execution \; time_{long \; job}-0)}{2}\)</span></li>
<li>以這種方式 <strong>Short job 所減少的等待時間必定大於等於</strong> Long job 所增加的等待時間，所以<strong>會使平均等待時間變小，最後可歸納到必為最佳的排班法則。</strong></li>
<li><strong>不公平，偏好 short job。</strong></li>
<li><strong>可能會 Starvation (for long job)。</strong></li>
<li>又可以分為：
<ol type="1">
<li>Non-preemptive <strong>( SJF )</strong></li>
<li>Preemptive <strong>( SRTF or SRJF )</strong></li>
</ol></li>
<li><strong>較不適合用在 shortest-trem scheduler，</strong>因為 short-term schduler 執行頻率太高，所以<strong>很難在極短時間內預估出精確每個process 的 CPU burst time 又要挑出最小值，</strong>不易真正呈現出 SJF 之行為；<strong>但比較適合 long-term schduler。</strong></li>
</ul>
<h3 id="srtf-shorest-remaining-time-job-first">SRTF ( Shorest Remaining-time Job First )</h3>
<p>又稱為 SRJF 或 SRTN ( Shorest Remaining-time Job Next )，<strong>即為「Preemptive - SJF」</strong>，將剩餘 CPU burst time 最小的 Process 取得 CPU，若「新到達的 process」 的 CPU burst time 目前執行中 process 剩下的 CPU time ，則新到達的 Process 可以<strong>插隊( Preemption )目前執行中的 Process。</strong></p>
<figure>
<img src="\willywangkaa\images\SRTF.png" alt="SRTF" /><figcaption aria-hidden="true">SRTF</figcaption>
</figure>
<ul>
<li><p>Avg. waiting time for</p>
<ul>
<li>*<strong>SRTF</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1527477828916.png" alt="1527477828916" /><figcaption aria-hidden="true">1527477828916</figcaption>
</figure>
<p><span class="math display">\[
  \frac{ ((0-0)+(10-1)) + (1-1) + (17-2) + (5-3) }{ 4 } = 6.5
\]</span></p>
<ul>
<li><strong>SJF</strong></li>
</ul>
<p><img src="\willywangkaa\images\SJF_correct.png" alt="SJF" />  </p>
<p><span class="math display">\[
  \frac{ (0-0)+(8-1)+(12-3)+(17-2) }{4} = 7.75
\]</span></p>
<ul>
<li>FIFO</li>
</ul>
<figure>
<img src="\willywangkaa\images\SJF.png" alt="FIFO" /><figcaption aria-hidden="true">FIFO</figcaption>
</figure>
<p><span class="math display">\[
\frac{ (0-0) + (8-1) + (12-2) + (21 -3) }{4} = 8.75
\]</span></p>
<ul>
<li><strong>分析</strong>
<ul>
<li><strong>與 SJF 相比 SRTF 的平均 waiting / turnaround time 會比較小，但是付出較大的 Context switching 負擔。</strong></li>
<li>不公平，偏好 Short remaining time job。</li>
<li>可能會有 Starvation。</li>
<li>屬於 Preemptive。</li>
</ul></li>
</ul>
<h3 id="priority-method">Priority Method</h3>
<p><strong>具有最高優先權的 Process</strong> 取得 CPU ，若多個 Process 權值相同，則以 <strong>FIFO</strong> 為準。</p>
<figure>
<img src="\willywangkaa\images\1527479225080.png" alt="1527479225080" /><figcaption aria-hidden="true">1527479225080</figcaption>
</figure>
<ul>
<li>到達時間皆為 0。</li>
<li>Non-preemptive priority method 且 <strong>Priority number 愈小優先權愈大</strong>。</li>
<li>Avg. waiting time</li>
</ul>
<figure>
<img src="\willywangkaa\images\1527479387651.png" alt="1527479387651" /><figcaption aria-hidden="true">1527479387651</figcaption>
</figure>
<p><span class="math display">\[
\frac{ (6-0)+(1-0)+(16-0)+(18-0)+(1-0) }{5}=8.2
\]</span></p>
<ul>
<li><span class="math inline">\(Ex2.\)</span></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Process</th>
<th style="text-align: center;">Arrvial time</th>
<th style="text-align: center;">Priority</th>
<th style="text-align: center;">Burst time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="even">
<td style="text-align: center;">P2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="even">
<td style="text-align: center;">P4</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P5</td>
<td style="text-align: center;">13</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">6</td>
</tr>
</tbody>
</table>
<ul>
<li>Preemptive priority method。</li>
<li><strong>Priority number 愈小優先權愈大</strong>。</li>
<li>Avg. waiting time</li>
</ul>
<figure>
<img src="\willywangkaa\images\1527486332570.png" alt="1527486332570" /><figcaption aria-hidden="true">1527486332570</figcaption>
</figure>
<p><span class="math display">\[
\frac{ ((0-0)+(23-2)) + (2-2) + ((5-5)+(20-10)) + ((10-10)+(19-13)) + (13-13) }{5} = \frac{37}{5}
\]</span></p>
<ul>
<li>分析
<ul>
<li>不公平。</li>
<li>可能會有 Starvation ，但可以用「Aging」解決。</li>
<li><strong>分為 Non-preemptive 與 Preemptive。</strong></li>
<li>是一個具有參數化的方法，<strong>給予高低不同的優先權值</strong>，可展現出不同的排班行為。</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th>Priority 的定義</th>
<th>行為</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Arrival time 愈小，優先權愈大。</td>
<td>FIFO</td>
</tr>
<tr class="even">
<td>CPU time 愈小，優先權愈大。</td>
<td>SJF</td>
</tr>
<tr class="odd">
<td>剩餘時間愈小，優先權愈大。</td>
<td>SRTF</td>
</tr>
</tbody>
</table>
<h3 id="round-robin">★Round Robin</h3>
<ul>
<li><strong>為「Time sharing system」的實踐手段</strong></li>
<li>作業系統規定一個「CPU time quantum」（Slice）
<ul>
<li>若 Process 未能在此 Quantum 以 CPU 完成工作
<ul>
<li>原文：「The time quantum of the process has expired」</li>
<li>則「Timer」產生一個「Time-out interrupt」通知作業系統強迫回收 CPU</li>
<li>將此 Process 送回「Ready queue」中等待下一輪再取得 CPU 執行</li>
</ul></li>
<li><strong>每一回合皆採 FIFO 排班法則規劃</strong></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Timer</strong>（參考自：<a href="https://www.cs.umd.edu/~hollings/cs412/s96/project/proj3/proj3.html">CMSC 412 Project 3: Multiprogramming, Part II</a>）</p>
<ul>
<li><strong>D</strong>isk <strong>O</strong>perating <strong>S</strong>ystem（DOS；磁碟作業系統）
<ul>
<li>為了處理器中的「倒錶器」（Timer）硬體
<ul>
<li>提供各個程序「倒錶中斷服務程序」（Timer ISR）<strong>個別使用</strong></li>
<li>各個程序其私有的「倒錶中斷服務程序」會記錄「Time quantum」
<ul>
<li>取得 CPU 的新程序會重設「Time quantum」</li>
</ul></li>
</ul></li>
</ul></li>
<li>「新程序」要使用 CPU 時
<ul>
<li>替換「目前程序」與「新程序」的「倒錶中斷服務程序」
<ul>
<li>將作業系統裡「倒錶器」的中斷向量替換「目前程序」為「新程序」的「倒錶中斷服務程序」之記憶體位址</li>
</ul></li>
</ul></li>
<li><strong>當「倒錶器」硬體觸發中斷時</strong>，有三種情形發生：
<ul>
<li><strong>若「Time quantum」尚有值存在</strong>
<ul>
<li>「Time quantum」 ≠ 0
<ul>
<li>代表此程序還有權力可用 CPU</li>
</ul></li>
<li>對此程序的「倒錶中斷服務程序」紀錄的「Time quantum」遞減</li>
</ul></li>
<li><strong>若為「USER mode」程序且「Time quantum」耗盡</strong>
<ul>
<li>「Time quantum」 = 0
<ul>
<li>代表此程序無權限使用 CPU</li>
</ul></li>
<li>將此程序移至「Ready queue」以搶斷 CPU 的使用權</li>
<li>執行排程程序以找到下個執行的「新程序」</li>
</ul></li>
<li><strong>若為「KERNEL mode」程序且「Time quantum」耗盡</strong>
<ul>
<li>「Time quantum」 = 0
<ul>
<li>代表此程序無權限使用 CPU</li>
</ul></li>
<li>設定 <code>preempt</code> 變數為 1
<ul>
<li>在 <code>System_service</code> 結束後此變數會被系統檢查</li>
</ul></li>
<li>將此程序移至「Ready queue」以搶斷 CPU 的使用權</li>
<li>執行排程程序以找到下個執行的「新程序」</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Process</th>
<th style="text-align: center;">CPU time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P1</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="even">
<td style="text-align: center;">P2</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P3</td>
<td style="text-align: center;">9</td>
</tr>
<tr class="even">
<td style="text-align: center;">P4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<ul>
<li>到達時間為 0</li>
<li>順序為：P1～P4</li>
<li>Quantum = 4</li>
<li>Avg. waiting time</li>
</ul>
<figure>
<img src="\willywangkaa\images\1527829801602.png" alt="1527829801602" /><figcaption aria-hidden="true">1527829801602</figcaption>
</figure>
<p><span class="math display">\[
\frac{((0-0)+(16-4))+((4-0))+((8-0)+(20-12)+(25-24))+((12-0)+(24-16))}{4} = \frac{53}{4}
\]</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Process</th>
<th style="text-align: center;">*Arrival time</th>
<th style="text-align: center;">CPU time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">20</td>
</tr>
<tr class="even">
<td style="text-align: center;">P2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P3</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">P4</td>
<td style="text-align: center;">13</td>
<td style="text-align: center;">8</td>
</tr>
</tbody>
</table>
<ul>
<li>Quantum = 4</li>
<li>Avg. waiting time</li>
</ul>
<figure>
<img src="\willywangkaa\images\1527831109693.png" alt="1527831109693" /><figcaption aria-hidden="true">1527831109693</figcaption>
</figure>
<p><span class="math display">\[
\frac{((0-0)+(8-4)+(16-12))+((4-2)+(15-8))+((12-7))+((18-13))}{4} = \frac{27}{4}
\]</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Processs</th>
<th style="text-align: center;">★Arrival time</th>
<th style="text-align: center;">★★行程行為</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">5 CPU + 6 I/O + 4 CPU</td>
</tr>
<tr class="even">
<td style="text-align: center;">P2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">15 CPU</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P3</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">3 CPU + 10 I/O + 9 CPU</td>
</tr>
<tr class="even">
<td style="text-align: center;">P4</td>
<td style="text-align: center;">14</td>
<td style="text-align: center;">8 CPU</td>
</tr>
</tbody>
</table>
<ul>
<li>Quantum = 5 <strong>(Ref p.4-111)</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\1528097302440.png" alt="1528097302440" /><figcaption aria-hidden="true">1528097302440</figcaption>
</figure>
<ul>
<li>Turnaround time。
<ul>
<li>P1 = 22 - 0。</li>
<li>P2 = 32 - 3。</li>
<li>P3 = 44 - 8。</li>
<li>P4 = 40 - 14。</li>
</ul></li>
<li>Avg. waiting time。</li>
</ul>
<p><span class="math display">\[
\frac{((0-0)+(18-11))+((5-3)+(13-10)+(27-18))+((10-8)+(32-23)+(40-37))+((22-14)+(37-27))}{4} = \frac{113}{4}
\]</span></p>
<p><strong>＜Note＞：有爭議的題目。</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Process</th>
<th style="text-align: center;">Arrival time</th>
<th style="text-align: center;">CPu time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">10</td>
</tr>
<tr class="even">
<td style="text-align: center;">P2</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">9</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P3</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">6</td>
</tr>
</tbody>
</table>
<ul>
<li>Quantum = 4。</li>
</ul>
<figure>
<img src="\willywangkaa\images\1527833536050.png" alt="1527833536050" /><figcaption aria-hidden="true">1527833536050</figcaption>
</figure>
<ul>
<li>不知道為 P2 還是 P1 先進入 Waiting queue。</li>
<li><strong>分析</strong>
<ul>
<li><strong>Time sharing system 採用此方法。</strong></li>
<li>也為一種可<strong>參數化 (ex. Quantum)</strong>的法則。</li>
<li><strong>公平。</strong></li>
<li>沒有 starvation。</li>
<li><strong>★Preemptive。</strong></li>
<li>Round robin 排班效益取決於 Time quantum 大小決定。<br> <span class="math inline">\(Ex1. \; Quantum = \infty\)</span> 則 RR 會變成 <strong>FIFO</strong>，也可以說排班的效能很差。<br><span class="math inline">\(Ex2. \; Quantum \rightarrow 0\)</span> 則 Context switching 太頻繁，<strong>CPU utilization 會變得非常差</strong> (<span class="math inline">\(\approx 0\)</span>)。<br>$Ex3. $ 根據經驗法則，若 Quantum 能讓 80% 的工作量在該時間完成，效能最佳。</li>
</ul></li>
</ul>
<p><strong>＜Note＞：</strong> RR 雖然是公平，但<strong>可支持差異化 ( 優先權差異 ) 的實現，</strong>請問該如何達成？<br>Ans：</p>
<ul>
<li><strong>方法一</strong>
<ul>
<li><strong>針對高優先權的 Process 在 Ready queue 中置入多個 PCB pointer 指向此 Process ，使得每一輪當中可以多次取的 CPU 的機會。</strong></li>
</ul></li>
<li><strong>方法二</strong>
<ul>
<li><strong>針對高優先權 Process 給予較大的 Quantum。</strong></li>
</ul></li>
</ul>
<h4 id="round-robin-with-priority">Round robin with priority</h4>
<p>如果想在不改變 Round robin 排程演算法的情況下，欲使某寫 Process 有更多的 CPU 使用優先權</p>
<ul>
<li>「Ready queue」的<strong>內容</strong>（協助 Round robin 演算法的排程）
<ul>
<li>指向各個 Process 之「Process control block」（PCB）的指標</li>
</ul></li>
</ul>
<p>所以，直覺的想法就是讓「高優先權」的 Process，在「Ready queue」中能插入更多指向自己 PCB 的指標</p>
<ul>
<li>可以讓該 Process 有更多次的 CPU 使用權</li>
<li>優點
<ol type="1">
<li>可以讓使用者給予某寫 Process 更高的優先權</li>
<li>因為 Round robin 排程演算法原本的性質（FCFS；無法被中斷），所以可以<strong>防止某些低優先權的 Process 發生「Starvation」</strong></li>
<li>不必改變原始演算法的結構</li>
</ol></li>
<li>缺點
<ol type="1">
<li>因為每當「Time quantum」時間結束後，「Time interrupt」會隨之觸發，無論前後的 Process 是否相通<strong>皆需要做「Context switch」</strong>，而隨之而來的「Overhead」也會增加</li>
<li>當一個 Process 結束時，其<strong>原本位於「Ready queue」的其餘指標也要隨之刪除</strong>，但是由於「Queue」結構的特性，必須要將全部的元素都比對後才能確保將剩餘的指標完全移除</li>
</ol></li>
</ul>
<h3 id="multilevel-queues">Multilevel Queues</h3>
<ul>
<li>將原本單一一條 Ready queue 變成多條 Ready queue ，且高低優先權不同。</li>
<li>Queue 之間也有以排班的方式管理，通常採取<strong>「Preemptive priority」管理</strong>。</li>
<li>每個 Queue 可以有自己的排班法則。</li>
<li>Process 一旦被置入於某個 Queue 中，<strong>就不可(不允許)在不同 Ready queue 之間移動。</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\1527835326994.png" alt="1527835326994" /><figcaption aria-hidden="true">1527835326994</figcaption>
</figure>
<ul>
<li>$Ex. $ I/O - Bound 與 CPU - Bound Job 各自要置入哪種等級的 Queue 比較好？
<ul>
<li>Ans：I/O - Bound Job <span class="math inline">\(\Rightarrow\)</span> 高優先 Queue ( 使用 CPU 不多 )；CPU - Bound Job <span class="math inline">\(\Rightarrow\)</span> 低優先 Queue ( 會使用大量 CPU )</li>
</ul></li>
<li>分析
<ul>
<li><strong>可參數化 ( Queue 數目、Queue之間的排班法則、每個 Queue自己的排班法則、Process被放入哪個 Queue 之準則---Critera ) 的項目眾多，</strong>有助於排班設計及效能調校之彈性 ( flexibility )。</li>
<li>不公平。</li>
<li>*<strong>有 Starcation。</strong></li>
<li>Preemptive。</li>
</ul></li>
</ul>
<h3 id="multilevel-feedback-queues">Multilevel Feedback Queues</h3>
<p>與 Multilevel queue 相似，<strong>差別在於「允許」Process 在不同 Queue 之間移動。( 可以採取類似「Aging」的技術或是可以搭配「降級」的方式來避免「Starvation」 )</strong></p>
<ul>
<li>分析
<ul>
<li><strong>可參數化 ( Queue 數目、Queue之間的排班法則、每個 Queue自己的排班法則、Process被放入哪個 Queue 之準則---Critera ) 的項目眾多，</strong>有助於排班設計及效能調校之彈性 ( flexibility )。</li>
<li>不公平。</li>
<li><strong>可解決 Starcation。</strong></li>
<li>Preemptive。</li>
</ul></li>
</ul>
<h3 id="結論">結論</h3>
<ul>
<li>哪些是 Non-preemptive。
<ul>
<li>FIFO</li>
<li>SJF</li>
<li><strong>Non-preemptive priority</strong></li>
</ul></li>
<li>哪些是 Preemptive。
<ul>
<li>SRJF</li>
<li>RR</li>
<li>Preemptive priority</li>
<li>Multilevel (Feedback) queue</li>
</ul></li>
<li>哪些沒有 Starvation。
<ul>
<li>FIFO</li>
<li>RR</li>
<li>Multilevel feedback queue</li>
</ul></li>
<li><strong>那些包含於( <span class="math inline">\(\subset\)</span> )關係是錯的？</strong>
<ul>
<li>FIFO <span class="math inline">\(\subset\)</span> Priority</li>
<li>SJF <span class="math inline">\(\subset\)</span> Priority</li>
<li>FIFO <span class="math inline">\(\subset\)</span> RR</li>
<li><strong>SJF </strong><span class="math inline">\(\subset\)</span> <strong>RR</strong></li>
<li><em>RR</em> <span class="math inline">\(\subset\)</span> <em>MFQs</em></li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>Consider a <strong>preemptive priority scheduling algorithm</strong> based on dynamically changing priorities
<ul>
<li><strong>Larger priority numbers imply higher priority</strong></li>
<li>When a process is waiting for the CPU (<strong>In the ready queue, but not running</strong>), its priority changes <strong>at a rate α</strong></li>
<li><strong>When it is running</strong>, its priority changes <strong>at a rate β</strong></li>
<li>All processes are given a priority of 0 when they enter the ready queue</li>
</ul></li>
</ul>
<p><strong>What is the algorithm that results from β &gt; α &gt; 0 ?</strong></p>
<p>因為 β 的值比 α 還高，所以隨著該程序不斷在 CPU 執行，其<strong>優先權提升的變化度</strong>會比在「Ready queue」的程序還高，這使得「Ready queue」中的程序其優先權不可能大到可以插斷 CPU 正在執行的程序，所以為「FCFS排班演算法」</p>
<p><strong>What is the algorithm that results from α &lt; β &lt; 0?</strong></p>
<p>因為「Ready queue」的程序，其<strong>遞減變化度</strong> α 會比在 CPU 執行的程序的<strong>遞減變化度</strong> β 還高，新加入的優先權為零，而<strong>「Ready queue」的程序</strong>與<strong>正在 CPU 執行的程序</strong>優先權總是隨著時間遞減，所以新加入的程序永遠可以插斷目前執行的程序，且因為在 CPU 執行的程序遞減程度較緩，所已不可能被「Ready queue」中的程序插斷，所以為「LIFO排班演算法」</p>
</blockquote>
<h3 id="補充-cpu-utilization-計算">(補充) CPU utilization 計算</h3>
<ul>
<li><p>Modern 版</p>
<ul>
<li>假設採 RR 排班，令 Time quantum 為 Q、Context switching time 為 S，<br>Process 平均執行每隔 T 時間會發出 I/O-request，求下列狀況的 CPU utilization。</li>
</ul></li>
<li><p>0 &lt; S &lt; T &lt;&lt; Q</p></li>
</ul>
<figure>
<img src="\willywangkaa\images\1527838126019.png" alt="1527838126019" /><figcaption aria-hidden="true">1527838126019</figcaption>
</figure>
<p>所以 <span class="math inline">\(\frac{T}{T+S}\)</span></p>
<ul>
<li>0 &lt; S &lt; Q &lt;&lt; T</li>
</ul>
<figure>
<img src="\willywangkaa\images\1527838656554.png" alt="1527838656554" /><figcaption aria-hidden="true">1527838656554</figcaption>
</figure>
<p>所以 <span class="math inline">\(\frac{Q}{Q+S}\)</span></p>
<ul>
<li><p>0 &lt; S = Q &lt;&lt; T</p>
<p>由上圖可知 <span class="math inline">\(\frac{Q}{Q+S} = \frac{Q}{Q+Q} = 50 \%\)</span></p>
<ol start="4" type="1">
<li>Q 趨近於 0。</li>
</ol>
<p><span class="math inline">\(\frac{Q}{Q+S} \approx \frac{0}{0+S} = 0\)</span>，<strong>CPU utilization 趨近於 0。</strong></p></li>
<li><p>恐龍版 ( Ref p. 4-86 Ex.50 )</p>
<ul>
<li><p>10 個 I/O-Bound tasks、1 個 CPU-Bound task，I/O-Bound task 執行每隔 1ms 發出 I/O-request ，<em>每個 I/O 運作花 10 ms</em> ( 此例子有 CPU-Bound task 所以不會因此 Idle )。Context switching time: 0.1 ms，所有process 永遠不會結束，求 CPU utilization ，採 RR 法則。</p>
<ol type="1">
<li><p>Quantum = 1ms。<br>針對 I/O-Bound task，在 Time-out 的同時也發出了 I/O-request，接著花 0.1 ms 在 Context switching，所以一個 I/O-Bound task 共花了 <span class="math inline">\(1 + 0.1 = 1.1\)</span> (ms)。<br>針對 CPU-Bound task，會將所有 CPU time 用完後 Time-out ，接著花 0.1 ms 在 Context switching，所以一個 CPU-Bound task 共花了 <span class="math inline">\(1 + 0.1 = 1.1\)</span> (ms)。<br><span class="math inline">\(CPU utilization = \frac{CPU \; time_{execution}}{CPU \; time_{total}} = \frac{10 \times 1 + 1 \times 1 }{10 \times 1.1 + 1 \times 1.1} = \frac{1}{1.1} \approx 91\%\)</span></p></li>
<li><p>Quantum = 10 ms。<br>針對 I/O-Bound task，CPU time 用不完，隔 1 ms 後直接發出 I/O-request ，並也花 0.1 ms 在 Comtext switching 上，所以一個 I/O-Bound task 共花了 <span class="math inline">\(1 + 0.1 = 1.1\)</span> (ms)。<br>針對 CPU-Bound task ， 會將所有的 CPU-time 用完後 Time-out 接著花 0.1 ms 在 Context switching ，所以一個 CPU-Bound task 共花了 <span class="math inline">\(10 + 0.1 = 10.1\)</span> (ms)。<br><span class="math inline">\(CPU utilization = \frac{CPU \; time_{execution}}{CPU \; time_{total}} = \frac{10 \times 1 + 1 \times 10 }{10 \times 1.1 + 1 \times 10.1} = \frac{20}{21.1} \approx 94\%\)</span></p></li>
</ol></li>
</ul></li>
</ul>
<h2 id="特殊系統之排班設計考量">特殊系統之排班設計考量</h2>
<h3 id="multiprocessor-system">Multiprocessor system</h3>
<ul>
<li>ASMP (Master-Slave 架構)：因為都是以 Master-processor 來排班，類似於過去單顆 CPU，所以沒有特殊的排班設計。</li>
<li><strong>SMP</strong>：主要有兩個排班的機制。
<ul>
<li><strong>方法一</strong>： 每個CPU 共享同一個 Ready queue ，當一個 CPU 完程某 Process 後，<strong>就去存取 Ready queue</strong>。<br>設計重點：</li>
<li><ol type="1">
<li>必須提供上述 Ready queue 的<strong>互斥存取之機制</strong>，若未提供，則可能發生 <strong>Process 重複執行，或有 Process 被忽略的錯誤</strong>。<br>例：CPU 去取 Process 之工作如下：<br>第一步，取得(read) Queue Front 端 Process 之 PCB pointer；第二步，從 Queue 中刪除此 Process pointer 。</li>
<li>不須考慮附載平衡 (load balance)，因為每個 CPU 在工作都做完時會再繼續從 Ready queue 中挑選工作，不會讓自己閒置(idle)。</li>
</ol></li>
<li><strong>方法二</strong>：每個 CPU 都有自己的 Ready queue ，每個 CPU 只會檢查自己的 Ready queue ，不會去檢查其他 CPU 的 Ready queue ，<strong>有工作就執行，無工作就閒置 (idle)</strong>。<br><strong>設計重點：</strong><br>
<ol type="1">
<li><strong>不須有互斥存取的考量。</strong></li>
<li><strong>需考慮附載平衡 ( Load balanceing )，避免 CPU 之勞務不均 (有人忙、有人閒)。</strong><br>通常使用 2 種機制來調整 CPU 的附載 ( loading )：
<ol type="1">
<li>Push migration ( 移轉 ) --- 像是領班、工頭</li>
<li>Pull migration --- 好同事</li>
</ol></li>
</ol></li>
</ul></li>
</ul>
<h3 id="process-affinity">Process affinity</h3>
<ul>
<li>在 multiprocesors system 中，當 Process 已決定某 CPU 上執行，則在他執行過程之中，盡量<strong>不要將之移轉到其他 CPUs 上執行，</strong>除非有其必要。( 如：Processor bad、Load balancing... )<strong>避免 CPU 之 Cache、暫存器的內容要複製且又要刪除該工作，而影響效能。</strong></li>
<li>有兩種 Affinity：
<ul>
<li>Hard-affinity：該 Process 不可移轉。</li>
<li>Soft-affinity：盡可能不移轉。( 若有需要，仍可移轉。)</li>
</ul></li>
</ul>
<h2 id="real-time-system-排班設計考量">Real-time system 排班設計考量</h2>
<h3 id="hard-read-time-system">Hard read-time system</h3>
<figure>
<img src="\willywangkaa\images\1528098291707.png" alt="1528098291707" /><figcaption aria-hidden="true">1528098291707</figcaption>
</figure>
<ul>
<li><strong>排班設計考量</strong>
<ul>
<li><strong>確認這些工作是否可排程 ( schedulable )？也就是 CPU 可否負荷？</strong><br>判斷公式：若 <span class="math inline">\(\sum_{i = 1}^n \frac{C_i}{P_i} \leq 1\)</span> <strong>則為可排程，反之為不可排程。</strong><br>其中：<span class="math inline">\(n\)</span> 表示 Real-time event (Process)之數目、 $C_i$1表示 <span class="math inline">\(Event_i\)</span> (Process)之所需 CPU time、P_i 表示 <span class="math inline">\(Event_i\)</span> (Process)之發生週期( Period time )。<br>例：有下列四個 Real-time event ，其 CPU burst time 分別是：20 ms、50 ms、30 ms、X ms。其 period time 分別是 80ms、100ms、300ms、1ms。則在可排程的要求情況下，X 不可超過多少？<br>Ans：<span class="math inline">\(\frac{20}{80}+\frac{50}{100}+\frac{30}{300}+\frac{X}{1000} \leq 1 \Rightarrow \frac{X}{1000} \leq 0.15 \Rightarrow X \leq 150\)</span> (ms)。</li>
<li><strong>再考慮是否可以滿足各工作的 Dead line。</strong>有兩個排班則：
<ol type="1">
<li><strong>Rate-monotonic scheduling</strong></li>
<li><strong>EDF ( Eaeliest Deadline First )</strong></li>
</ol></li>
<li>如何排程，以滿足各工作的 deadline？</li>
</ul></li>
</ul>
<h4 id="rate-monotonic">Rate-monotonic</h4>
<ul>
<li>採取靜態的優先權值且可插隊( Preemptive )。</li>
<li><strong>Period time 愈小，優先權值愈高</strong>。</li>
<li>$Ex1. $</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Process</th>
<th style="text-align: center;">Period time</th>
<th style="text-align: center;">CPU time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P1</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">20</td>
</tr>
<tr class="even">
<td style="text-align: center;">P2</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">35</td>
</tr>
</tbody>
</table>
<ul>
<li>是否可排程化？
<ul>
<li><span class="math inline">\(\frac{20}{50}+\frac{35}{100}=0.4+0.35=0.75 \leq 1 \Rightarrow\)</span> OK</li>
</ul></li>
<li><strong>若規定 P2 優先權高</strong>，且為 preemptive，是否滿足 deadline？
<ul>
<li>甘特圖</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\Ratemonotonic.png" alt="Ratemonotonic" /><figcaption aria-hidden="true">Ratemonotonic</figcaption>
</figure>
<p>P1 未能滿足 deadline，P2 滿足 deadline。</p>
<ul>
<li>採用 Rate-monotinic 是否滿足 deadline？
<ul>
<li><strong>Period time 愈小，優先權愈高</strong>，所以 P1 的優先權高。</li>
<li>甘特圖</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1528099381692.png" alt="1528099381692" /><figcaption aria-hidden="true">1528099381692</figcaption>
</figure>
<p>P1 滿足 deadline，P2 滿足 deadline。</p>
<ul>
<li>$Ex2. $</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Process</th>
<th style="text-align: center;">Period time</th>
<th style="text-align: center;">CPU time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P1</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">25</td>
</tr>
<tr class="even">
<td style="text-align: center;">P2</td>
<td style="text-align: center;">80</td>
<td style="text-align: center;">35</td>
</tr>
</tbody>
</table>
<ul>
<li>採用 Rate-monotinic 是否滿足 deadline？
<ul>
<li><strong>Period time 愈小，優先權愈高</strong>，所以 P1 的優先權高。</li>
<li>甘特圖</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1528099949133.png" alt="1528099949133" /><figcaption aria-hidden="true">1528099949133</figcaption>
</figure>
<ul>
<li>分析：
<ul>
<li>並不保證可以滿足 deadline。</li>
<li><strong>在靜態的優先權值要求下，是最佳的狀況( optimal )。(若該手法無法滿足 deadline，其他針對靜態優先權值的排班也無法滿足。)</strong></li>
</ul></li>
</ul>
<h4 id="earliest-deadline-first-edf">Earliest deadline First (EDF)</h4>
<ul>
<li>採用<strong>動態優先權值</strong>，且為<strong>可插隊</strong>。</li>
<li><strong>規定 deadline 愈早，優先權愈高</strong>。</li>
<li><span class="math inline">\(Ex 1.\)</span></li>
</ul>
<table>
<thead>
<tr class="header">
<th>Process</th>
<th>Period time</th>
<th>CPU time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>P1</td>
<td>50</td>
<td>25</td>
</tr>
<tr class="even">
<td>P2</td>
<td>80</td>
<td>35</td>
</tr>
</tbody>
</table>
<ul>
<li>以 Rate-monotinic 是否不牴觸 Deadline？
<ul>
<li>P1 的 Period time：50 &lt; P2 的 Period time：80，P1的優先權大於 P2 的優先權。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1528701363468.png" alt="1528701363468" /><figcaption aria-hidden="true">1528701363468</figcaption>
</figure>
<ul>
<li>以 EDF 是否滿足 Deadline？
<ul>
<li>﹙1﹚ P1 的 Deadline：50 &lt; P2 的 Deadline：80，P1的優先權大於 P2 的優先權。</li>
<li>﹙2﹚ P1 的 Deadline：100 &gt; P2 的 Deadline：80，P2的優先權大於 P1 的優先權。</li>
<li>﹙3﹚ P1 的 Deadline：100 &lt; P2 的 Deadline：160，P1的優先權大於 P2 的優先權。</li>
<li>﹙4﹚ P1 的 Deadline：150 &lt; P2 的 Deadline：160，P1的優先權大於 P2 的優先權。</li>
<li>﹙5﹚ P1 的 Deadline：200 &lt; P2 的 Deadline：240，P1的優先權大於 P2 的優先權。</li>
<li>﹙6﹚ P1 的 Deadline：250 &lt; P2 的 Deadline：240，P2的優先權大於 P1 的優先權。</li>
<li>﹙7﹚ P1 的 Deadline：300 &lt; P2 的 Deadline：320，P1的優先權大於 P2 的優先權。</li>
<li>﹙8﹚ P1 的 Deadline：350 &lt; P2 的 Deadline：400，P1的優先權大於 P2 的優先權。</li>
<li><strong>﹙8﹚ P1 的 Deadline：400 = P2 的 Deadline：400，P1的優先權等於 P2 的優先權。</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1528704009904.png" alt="1528704009904" /><figcaption aria-hidden="true">1528704009904</figcaption>
</figure>
<ul>
<li><span class="math inline">\(Ex 2.\)</span></li>
</ul>
<table>
<thead>
<tr class="header">
<th>Process</th>
<th>Period time</th>
<th>CPU time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>P1</td>
<td>50</td>
<td>25</td>
</tr>
<tr class="even">
<td>P2</td>
<td>75</td>
<td>30</td>
</tr>
</tbody>
</table>
<ul>
<li>以 Rate-monotinic 是否滿足 Deadline？
<ul>
<li>P1 的 Period time：50 &lt; P2 的 Period time：75，P1的優先權大於 P2 的優先權。</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1528704266407.png" alt="1528704266407" /><figcaption aria-hidden="true">1528704266407</figcaption>
</figure>
<ul>
<li>以 EDF 是否滿足 Deadline？
<ul>
<li>﹙1﹚ P1 的 Deadline：50 &lt; P2 的 Deadline：75，P1的優先權大於 P2 的優先權。</li>
<li>﹙2﹚ P1 的 Deadline：100 &gt; P2 的 Deadline：75，P2的優先權大於 P1 的優先權。</li>
<li>﹙3﹚ P1 的 Deadline：100 &lt; P2 的 Deadline：150，P1的優先權大於 P2 的優先權。</li>
<li>﹙4﹚ <strong>P1 的 Deadline：150 = P2 的 Deadline：150，P1的優先權等於 P2 的優先權。</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1528705571205.png" alt="1528705571205" /><figcaption aria-hidden="true">1528705571205</figcaption>
</figure>
<ul>
<li><strong>分析</strong>
<ul>
<li><strong>在可排程的情況之下必 EDF 保證最佳 (optimal)。(任何工作皆不違反 deadline)</strong></li>
<li>理論上，CPU utilization 可達 100%，<strong>但實際上不可能達 100% ，因為還要再加上 Context switching、interrupt handling 等額外付擔。</strong></li>
</ul></li>
</ul>
<h3 id="soft-real-time-system">Soft real-time system</h3>
<ul>
<li><p><strong>就 CPU scheduling design必須要具備：</strong></p>
<ul>
<li>支援 preemptive-priority 法則。</li>
<li>不支援「Aging」技術。</li>
<li><strong>盡可能降低 kernel dispatch latency time，可得 read-time process 可以即早工作。</strong></li>
</ul></li>
<li><p>降低 lermel latency 的困難處：</p>
<ul>
<li><p><strong>大部分的作業桶接不允許 kernel 整在執行 system call 或其他 system processes 時被 user process 任意的插隊 (preemption)，目的是要確保 kernel data structures 的正確性(就是避免有 race condition)，但是這種做法對於 soft real-time system 極為不利。</strong></p></li>
<li><p>假設目前 kernel 正在執行一個「long-time」system call ( I/O-operation ) 而此時有一個 soft real-time process 到達(或是 fork())，但是他必須到 kernel 完成此 long-time system call 後才能取得 CPU。(<strong>Dispatch latency 太長</strong>)。<strong>要解決此問題原則是：必須插隊 kernal 且要保障 kernel data structure之正確性。</strong></p>
<ul>
<li><strong>方法一 - Preemptive point</strong></li>
</ul>
<p>在 system call code 中加入一些「preemptive point」( <strong>在此時點將 kernel 插隊是安全的</strong> )，將來system call 執行時若遇到 preemptive point，system call 會先暫停 kernel 會檢查此時是否有 real-time process 到達。<strong>若有，方才的 kernel system call 會暫停執行， CPU 分派給 real-time process 使用</strong>；若無，方才的 kernel system call 繼續執行直到遇見下一個 preemptive point。</p>
<p>Cons：system call 中可以加入的 preemption point 數目不夠多(插入點有限)，Dispatch latency 仍然很長。</p>
<ul>
<li><strong>方法二 - kernel 可隨時被 real-time process 插隊</strong></li>
</ul>
<p><strong>需要具備有對於 kernel 的共享 data structure/resource 提供嚴謹的「互斥存取」( synchronization機制 )，以確保資料之正確性。</strong></p>
<p>Cons：使用互斥存取可能造成<strong>「優先權反轉 ( Priority inversion )」問題。</strong></p></li>
</ul></li>
</ul>
<h4 id="priority-inversion---優先權反轉">Priority inversion - 優先權反轉</h4>
<ul>
<li><strong>高優先權的 process 所需要的共享 data/resourses 恰巧被一些低優先全 process 所把持</strong>，無法存取 (因為互斥存取控制)，<strong>造成高優先權等待低優先權 process 之情況，再加上低優先權 process 往往無法很快的取得 CPU ，已完成對共享 data/resources 之使用進而釋放資源，所以高優先權 process 被迫要等一段很久的時間。</strong></li>
<li>解決方法：<strong>讓低優先權 process 暫時繼承高優先權的權值</strong>，使得低優先權 process 可以很快的 取得 CPU 完成共享 data/resource 之使用並釋放資源，<strong>同時也立刻恢復其原本的低權值</strong>。</li>
</ul>
<h3 id="real-time-system-之-dipatch-latency-的架構">Real-time system 之 dipatch latency 的架構</h3>
<p>由兩個 phases 組成：</p>
<ul>
<li><strong>Conflict phase</strong>
<ul>
<li><strong>Preempts kernel</strong></li>
<li><strong>低優先權釋放高優先權之 data/resource</strong></li>
</ul></li>
<li>Disoatch phase
<ul>
<li>Context switching</li>
<li>Change mode to user mode</li>
<li>Jump</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1528637800281.png" alt="1528637800281" /><figcaption aria-hidden="true">1528637800281</figcaption>
</figure>
<h1 id="thread-management">Thread management</h1>
<ul>
<li>Thread：又稱之為「Lightweight proces」，為作業系統分配 CPU time 之基本單位 (It's a basic unit of CPU utilization)。( Process 是分配資源如：I/O, memory，的最基本單位 )</li>
<li>Thread 建立後，其私有的內容 ( 紀錄於TCB - thread control block 之中 ) 組成有：
<ul>
<li><strong>Programming counter</strong></li>
<li><strong>CPU registers value</strong></li>
<li><strong>Stack</strong></li>
<li>Thread ID, state ...</li>
</ul></li>
<li><strong>此外，同一個 process 內之不同 threads 彼此共享此 process 的：</strong>
<ul>
<li><strong>Code section</strong></li>
<li><strong>Data section</strong></li>
<li><strong>Other OS resources</strong> (Open files, I/O resources, siginal, ...)</li>
<li><strong>Code section 與 Data section 合稱為 Memory address space。</strong></li>
</ul></li>
<li>Tradition process (Single-thread model)</li>
</ul>
<figure>
<img src="\willywangkaa\images\1528638942439.png" alt="1528638942439" /><figcaption aria-hidden="true">1528638942439</figcaption>
</figure>
<ul>
<li>Multithreading mode</li>
</ul>
<figure>
<img src="\willywangkaa\images\1528639073333.png" alt="1528639073333" /><figcaption aria-hidden="true">1528639073333</figcaption>
</figure>
<ul>
<li>Pros
<ul>
<li>Responsiveness：當 process 內執行中的 thread 被 blocked，則 CPU 可以交給此 process 內其他可執行的 threads 執行，<strong>故整個 process 不會被 blocked，</strong>仍持續執行，所以若將 multithreading 用在 user-interactive application，可增加對使用者之回應程度。</li>
<li>Resource sharing：因為 process 內之多條 threads 共享此 process code section，所以在同一個 memory space 上可有多個工作同時執行。</li>
<li>Economy：<strong>因為同一個 process 內之不同 threads 彼此共享此 process 的 memory 及其他作業系統的資源，所以 thread 之私有成份量少，故 thread 之 creation、context switching 更快、Thread 的管理成本更少。</strong></li>
<li>Scalability (Utilization of multiprocessors Architecture)：<strong>可以做到同一個 Process 內之不同 threads 可在不同 CPUs 上平行執行，所以可以增加對 multiprocessors system 之效益(平行程度)提升。</strong></li>
</ul></li>
</ul>
<h2 id="process-vs.-thread">Process VS. Thread</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Thread</th>
<th style="text-align: center;">Process</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Light weight Process</td>
<td style="text-align: center;">Heavy weight process</td>
</tr>
<tr class="even">
<td style="text-align: center;">Multithreading model</td>
<td style="text-align: center;">Single-threaded model</td>
</tr>
<tr class="odd">
<td style="text-align: center;">是作業系統分配<strong>資源( Resource )</strong>的最基本單位。</td>
<td style="text-align: center;">是作業系統分配 <strong>CPU time</strong> 的最基本單位。</td>
</tr>
<tr class="even">
<td style="text-align: center;">不同的 Processes 不會有共享的 Memory 以及其他資源，除非在 shared memory 的情形下。</td>
<td style="text-align: center;"><strong>同一個 process 內之 threads 彼此共享此 process 之 memory 與其他資源。</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">若 process 內的 single thread 被 blocked，則整個 process 也被 blocked。</td>
<td style="text-align: center;"><strong>只要 process 內尚有可執行的 threads 就不會被 blocked。</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">process 之 creation、context switching 慢，管理成本<em>高</em>。</td>
<td style="text-align: center;"><strong>process 之 creation、context switching 快，管理成本低。</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">對於 multiprocessors 架構之效益發揮<em>較差</em>。</td>
<td style="text-align: center;"><strong>對於 multiprocessors 架構之效益發揮較加。</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">Process 較無 race condition 問題。( 除非是採用「Shared memory」溝通 )</td>
<td style="text-align: center;"><strong>因為同一個 Process 內之 Thread 彼此共享此 Process data section，所以必須對共享的資料提供互斥存取的機制，防止 Race condition。</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>適合使用 Multithread 開發的程式。
<ul>
<li><strong>一個時間點有多個工作要同時執行</strong>。如：Client-server model。</li>
</ul></li>
<li>不適合使用 Multithread 開發的程式。( 以傳統 process 開發即可 )
<ul>
<li><strong>一個時間點最多只有一個工作可執行</strong>。如：命令解譯器 ( UNIX 的 Shell )。</li>
</ul></li>
</ul>
<h2 id="user-thread-and-kernel-thread">User thread and Kernel thread</h2>
<p>Thread management 的工作 (如：thread creation、thread destory、thread suspend、thread wakeup、thread scheduling、thread context switching) 由誰負責。</p>
<h3 id="user-level-thread">User-level Thread</h3>
<p>Thread management 是由在 User mode 之 thread library 提供的 APIs 以讓 user process 呼叫使用、管理。<strong>Kernel 完全不知道( be unknowed with ) user level threads 的存在。(只知道有 process 的 single thread)</strong>所以 thread management 不須 kernel 介入干預。</p>
<ul>
<li>Pros
<ul>
<li>Thread creation、context switching ...等管理成本低，速度快。</li>
</ul></li>
<li>Cons
<ul>
<li><strong>當 Process 內某條執行中的 user-thread 是被 blocked 的，會導致整個 porcess 亦被 blocked。( 即使 process 內還是有其他可執行的 thread。)</strong></li>
<li><strong>因為無法做到 process 內之多條 user-threads 的平行執行，導致 Multprocessors 的效能發揮較差。</strong></li>
</ul></li>
<li>$Ex. $
<ul>
<li><strong>舉凡 Thread liberary 皆是 user threads。</strong></li>
<li>如：POSIX 的 pthread library ( <strong>是只在UNIX、Linux系統上的規格</strong> )、Mach 的 c-thread library、Solaris 2以上的 UI thread library、Green thread library。</li>
</ul></li>
</ul>
<h3 id="kernel-level-thread">Kernel-level thread</h3>
<p><strong>Thread managemet 完全由 Kernel 負責，kernel 知道每一條 thread 之存在並進行為護理。</strong></p>
<ul>
<li><strong>★不需要 Kernel 的任何協助。( With no support from kernel. )</strong></li>
<li>Pros
<ul>
<li><strong>當 Process 內某條執行中的 kernel-thread 是被 blocked 的，不會導致整個 porcess 亦被 blocked。( 若 process 內有其他可執行的 thread 時。)</strong></li>
<li><strong>可以管理 process 內之多條 kernel-threads 的平行執行，導致 Multprocessors 的效能發揮較差。</strong></li>
</ul></li>
<li>Cons
<ul>
<li>Thread creation、context switching ...等管理成本<strong>較高</strong>，速度<strong>較慢</strong>。</li>
</ul></li>
<li><span class="math inline">\(Ex .\)</span>
<ul>
<li>大部分作業系統都支援。</li>
<li>Windows (2000、NT)</li>
<li>UNIX、Linux ...</li>
<li>Solaris</li>
</ul></li>
<li>[ Modern例題 ]：CPU time 依照分配對象數平均分配 thread，<span class="math inline">\(P_a\)</span> 有三條 threads ，<span class="math inline">\(P_b\)</span> 有兩條 threads，則 <span class="math inline">\(P_a, P_b\)</span> 各分到多少趴的 CPU time。
<ul>
<li>若全部的執行序皆為 User thread。<br><strong>Kernel 只知道有兩個 Process ，所以分配 CPU time 給</strong><span class="math inline">\(P_a, P_b\)</span> <strong>各 50%。</strong></li>
<li>若全部的執行序皆為 Kernel thread。<br><strong>Kernel 知道有 5 條執行序要來分配 CPU time，所以</strong> <span class="math inline">\(P_a\)</span> <strong>分到 60 %</strong>，<span class="math inline">\(P_b\)</span> <strong>分到 40 %。</strong></li>
</ul></li>
</ul>
<h3 id="multithreading-model">Multithreading model</h3>
<ul>
<li>User thread to Kernel thread</li>
</ul>
<h4 id="many-to-one-user-thread">Many to one ( User thread )</h4>
<figure>
<img src="\willywangkaa\images\1528718261665.png" alt="1528718261665" /><figcaption aria-hidden="true">1528718261665</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1528718722383.png" alt="1528718722383" /><figcaption aria-hidden="true">1528718722383</figcaption>
</figure>
<p>This model maps <strong>many</strong> user threads to one kernel thread. Thread management is done in <strong>User space.</strong></p>
<ul>
<li><p>與 User thread 一致，不同解釋法。</p></li>
<li><p>Pros</p>
<ul>
<li>Thread creation、context switching ...等管理成本低，速度快。</li>
</ul></li>
<li><p>Cons</p>
<ul>
<li><strong>當 Process 內某條執行中的 user-thread 是被 blocked 的，會導致整個 porcess 亦被 blocked。( 即使 process 內還是有其他可執行的 thread。)</strong></li>
<li><strong>因為無法做到 process 內之多條 user-threads 的平行執行，導致 Multprocessors 的效能發揮較差。</strong></li>
</ul></li>
<li><p>$Ex. $</p>
<ul>
<li><strong>舉凡 Thread liberary 皆是 user threads。</strong></li>
<li>如：POSIX 的 pthread library ( <strong>是只在UNIX、Linux系統上的規格</strong> )、Mach 的 c-thread library、Solaris 2以上的 UI thread library、Green thread library。</li>
</ul></li>
</ul>
<h4 id="one-to-one-kernel-thread">One to one ( Kernel thread )</h4>
<figure>
<img src="\willywangkaa\images\1528718998029.png" alt="1528718998029" /><figcaption aria-hidden="true">1528718998029</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1528719859725.png" alt="1528719859725" /><figcaption aria-hidden="true">1528719859725</figcaption>
</figure>
<p>This model maps <strong>each</strong> user threads to <strong>a</strong> kernel thread.</p>
<ul>
<li>與 kernal thread <strong>不盡相同。</strong></li>
<li>Pros
<ul>
<li><strong>當 Process 內某條執行中的 kernel-thread 是被 blocked 的，不會導致整個 porcess 亦被 blocked。( 若 process 內有其他可執行的 thread 時。)</strong></li>
<li><strong>可以管理 process 內之多條 kernel-threads 的平行執行，導致 Multprocessors 的效能發揮較差。</strong></li>
</ul></li>
<li>Cons
<ul>
<li>Thread creation、context switching ...等管理成本<strong>較高</strong>，速度<strong>較慢</strong>。</li>
<li>*<strong>Process 每建立一條 User-thread，作業系統就必須配合產生一條 Kernel-thread 與 User-thread 搭配，所以若 User-thread 數產生眾多，則會讓作業系統負擔太大，耗資源大。</strong></li>
</ul></li>
<li><span class="math inline">\(Ex .\)</span>
<ul>
<li>大部分作業系統都支援。</li>
<li>Windows (2000、NT)</li>
<li>UNIX、Linux ...</li>
<li>Solaris</li>
<li>OS/2</li>
</ul></li>
</ul>
<h4 id="many-to-many-kernel-thread">Many to many ( Kernel thread )</h4>
<figure>
<img src="\willywangkaa\images\1528719979394.png" alt="1528719979394" /><figcaption aria-hidden="true">1528719979394</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1528720444327.png" alt="1528720444327" /><figcaption aria-hidden="true">1528720444327</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1530181565681.png" alt="1530181565681" /><figcaption aria-hidden="true">1530181565681</figcaption>
</figure>
<p>This model maps <strong>many</strong> user threads to <strong>a small or equal number of</strong> kernel thread.</p>
<ul>
<li>Pros
<ul>
<li><strong>當 Process 內某條執行中的 kernel-thread 是被 blocked 的，不會導致整個 porcess 亦被 blocked。( 若 process 內有其他可執行的 thread 時。)</strong></li>
<li><strong>可以管理 process 內之多條 kernel-threads 的平行執行，導致 Multprocessors 的效能發揮較差。</strong></li>
<li><strong>負擔不和 one-to-one model 大。</strong></li>
</ul></li>
<li>Cons
<ul>
<li>Thread creation、context switching ...等管理成本<strong>較高</strong>，速度<strong>較慢</strong>。</li>
<li><strong>製作、設計較為複雜。</strong></li>
</ul></li>
<li><span class="math inline">\(Ex .\)</span>
<ul>
<li><strong>Solaris 2 以上 ( Two-level modeling )</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530181715559.png" alt="1530181715559" /><figcaption aria-hidden="true">1530181715559</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1530182120849.png" alt="1530182120849" /><figcaption aria-hidden="true">1530182120849</figcaption>
</figure>
<h2 id="multithreading-issues">Multithreading issues</h2>
<h3 id="fork-issue">fork() issue</h3>
<figure>
<img src="\willywangkaa\images\1530178012484.png" alt="1530178012484" /><figcaption aria-hidden="true">1530178012484</figcaption>
</figure>
<ul>
<li><strong>Child1：適用在「子程序」工作與「父程序」相同時。</strong></li>
<li><strong>Child2：適用於「子程序」與「父程序」不同時，也就是說「子程序」出生後立即呼叫「execl」system call。</strong></li>
</ul>
<h3 id="signal-delivery-issue">Signal delivery issue</h3>
<figure>
<img src="\willywangkaa\images\1530178614262.png" alt="1530178614262" /><figcaption aria-hidden="true">1530178614262</figcaption>
</figure>
<h4 id="signal">Signal</h4>
<figure>
<img src="\willywangkaa\images\1530178832898.png" alt="1530178832898" /><figcaption aria-hidden="true">1530178832898</figcaption>
</figure>
<p><strong>It's used in UNIX to notify the process that a particular event has occurred.</strong></p>
<ul>
<li>當 process 收到 siginal 通知後，他必須處理 ( <strong>可交 process 自行處理或交付給 default signal handler kernel 處理</strong> )</li>
<li><strong>Synchronous signal</strong>
<ul>
<li>Divide-by-zero</li>
<li>Illegal memory access</li>
</ul></li>
<li><strong>Asynchronous signal</strong>
<ul>
<li>「ctrl - c」 by administrator</li>
<li>Time-out by timer</li>
</ul></li>
</ul>
<h4 id="signal-delivery-issue-1">Signal Delivery Issue</h4>
<ul>
<li><strong>Case 1 ( Ex. Synchronous signal )</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\Signalisssue.png" alt="Signalisssue" /><figcaption aria-hidden="true">Signalisssue</figcaption>
</figure>
<ul>
<li><strong>Case 2 ( Ex.「Ctrl-break」)</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530179630741.png" alt="1530179630741" /><figcaption aria-hidden="true">1530179630741</figcaption>
</figure>
<ul>
<li><strong>Case 3</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530179857612.png" alt="1530179857612" /><figcaption aria-hidden="true">1530179857612</figcaption>
</figure>
<ul>
<li><strong>Case 4 ( Set a default signal handler. Ex. Solaris )</strong></li>
</ul>
<figure>
<img src="\willywangkaa\images\1530180057880.png" alt="1530180057880" /><figcaption aria-hidden="true">1530180057880</figcaption>
</figure>
<h3 id="thread-pool">Thread pool</h3>
<p>在 client-server model 中，當 server 收到 client 的 request 後，server <strong>才建立 thread 以服務此一請求，然而 thread creation 仍需耗用一些時間，所以對 client 的回應不能非常即時，以「Thread pool」解決。</strong>Process ( server ) 事先建立一些 threads 置於「thread pool」中，當收到 client 的 request 後，就從「thread pool 」中指派一條可使用的 thread 以服務此請求，<strong>不須重新建立 thread ，回應較為即時，</strong>當此 thread 完成工作之後，再回到 thread pool 中待命，如果 thread pool 中沒有可用的 thread 則 client 的 request 需要等待。</p>
<ul>
<li><strong>Cons</strong>
<ul>
<li>萬一 process 事先在 thread pool 中產出過多 threads，對作業系統負擔較大，所以作業系統通常會限制 thread pool 的大小。</li>
</ul></li>
</ul>
<h2 id="thread-程式追蹤">Thread 程式追蹤</h2>
<ul>
<li>pthread library</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum; <span class="comment">/* this data is shared by the thread(s) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">runner</span><span class="params">(<span class="keyword">void</span> *param)</span></span>; <span class="comment">/* threads call this function */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid; <span class="comment">/* the thread identifier */</span></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr; <span class="comment">/* set of thread attributes */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;usage: a.out &lt;integer value&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">atoi</span>(argv[<span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;%d must be &gt;= 0\n&quot;</span>,<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* get the default attributes */</span></span><br><span class="line">    <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line"><span class="comment">/* create the thread. 根據 attr 屬性值建立一條 thread，ID 記錄在 tid 中，執行 runner() 副程式*/</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, &amp;attr, runner, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">/* wait for the thread to exit */</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum); <span class="comment">// 輸出應為 15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The thread will begin control in this function */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">runner</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//若為 static 變數就為全域共享變數。</span></span><br><span class="line">    <span class="keyword">int</span> i, upper = <span class="built_in">atoi</span>(param);</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= upper; i++)</span><br><span class="line">    	sum += i;</span><br><span class="line">    <span class="comment">/*Thread 終止*/</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;types.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">runner</span><span class="params">(<span class="keyword">void</span> *param)</span></span>; <span class="comment">/* the thread */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* child process */</span></span><br><span class="line">        <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid,&amp;attr,runner,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_join</span>(tid,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CHILD: value = %d&quot;</span>,value); <span class="comment">/* LINE C -&gt; 5 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">/* parent process */</span></span><br><span class="line">    	<span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;PARENT: value = %d&quot;</span>,value); <span class="comment">/* LINE P -&gt; 0 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">runner</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    value = <span class="number">5</span>;</span><br><span class="line">    <span class="function">pthread <span class="title">exit</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="補充例題">補充例題</h1>
<p><strong>Example</strong></p>
<ul>
<li>Which following is <strong>shared by thread ?</strong>
<ul>
<li>Static local variable <strong>共享</strong></li>
<li>Program text/executable binary (code section) <strong>共享</strong></li>
<li>Registers value of CPU <strong>私有</strong></li>
<li>Heap memory (code + data section memory space) <strong>共享</strong></li>
<li>Programming counter <strong>私有</strong></li>
<li>Stack memory <strong>私有</strong></li>
<li>Open files <strong>共享</strong></li>
<li>I/O-resources <strong>共享</strong></li>
<li>Local variables <strong>私有</strong></li>
<li>Global variables <strong>共享</strong></li>
</ul></li>
</ul>
<p><strong>Example（104 成功大學計算機組織與系統）</strong></p>
<ul>
<li><p>Assume that a process currently runs in the user mode of <strong>x86 system</strong></p></li>
<li><p>Which of the following situation(s) always cause a transition from the user mode to the kernel mode?</p></li>
<li><p>Please briefly explain your answer</p>
<ul>
<li>（a）A timer occurs and the time quantum has not expired
<ul>
<li>直接使用「倒錶服務程序」將「Time quantum」遞減</li>
</ul></li>
<li><strong>（b）A timer occurs and the time quantum has expired</strong>
<ul>
<li>系統執行排程器尋找下個程序</li>
</ul></li>
<li>（c）TLB hits</li>
<li>（d）TLB miss</li>
<li>（e）The process executes a memory access instruction
<ul>
<li><strong>執行記憶體存取的指令只需經過 MMU 以確認是否越界</strong></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>TLB miss</strong></p>
<ul>
<li><strong>硬體式管理 TLB</strong>
<ul>
<li><strong>x86 架構採用</strong></li>
<li>CPU 自行遍歷「Page table」，檢視是否存在「包含指定的虛擬位址」之有效分頁表條目
<ul>
<li><strong>存在於分頁表</strong>
<ul>
<li>將此分頁表條目存入 TLB</li>
<li>重新執行 TLB 存取
<ul>
<li>此次存取必尋中，程序可正常執行</li>
</ul></li>
</ul></li>
<li><strong>不存在於分頁表</strong>
<ul>
<li>觸發「Page fault interrupt」，使作業系統必須對應處理
<ul>
<li>處理分頁錯誤通常是<strong>把被請求的資料載入實體記憶體中</strong>，並將該分頁表條目對映正確的實體位址，並重新啟動程式（詳見<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E9%A0%81%E9%8C%AF%E8%AA%A4">分頁錯誤</a>）</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>軟體管理式 TLB</strong>
<ul>
<li><strong>MIPS 架構採用</strong></li>
<li>觸發「TLB miss interrupt」
<ul>
<li>作業系統會遍歷「Page table」，以軟體方式進行虛實位址轉譯</li>
<li><strong>存在於分頁表</strong>
<ul>
<li>作業系統將分頁表中對應的條目載入 TLB</li>
<li>從「觸發 TLB miss interrupt 」之指令處重新啟動該程序</li>
</ul></li>
<li><strong>不存在於分頁表</strong>
<ul>
<li>觸發「Page fault interrupt」，使作業系統必須對應處理
<ul>
<li>處理分頁錯誤通常是<strong>把被請求的資料載入實體記憶體中</strong>，並將該分頁表條目對映正確的實體位址，並重新啟動程式（詳見<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E9%A0%81%E9%8C%AF%E8%AA%A4">分頁錯誤</a>）</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h1 id="參考">參考</h1>
<h3 id="operating-systems-internals-and-design-principles"><a href="http://dinus.ac.id/repository/docs/ajar/Operating_System.pdf">Operating Systems: Internals and Design Principles</a></h3>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Process</tag>
        <tag>Thread</tag>
        <tag>Management</tag>
      </tags>
  </entry>
</search>
