<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-tw,en,default">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/willywangkaa/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/willywangkaa/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/willywangkaa/images/apple-touch-icon-next_cat.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/willywangkaa/images/favicon-32x32-next_cat.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/willywangkaa/images/favicon-16x16-next_cat.png?v=6.0.4">


  <link rel="mask-icon" href="/willywangkaa/images/logo_cat.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '6.0.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Search,Sort," />


<meta name="description" content="Binary search Example n 筆資料作「Binary search」最多比較次數？ \(\lceil \lg (n+1) \rceil\)   200 筆資料：最多 8 次的搜尋 1024 筆資料：最多 11 次的搜尋   Example  n 筆資料作「Binary search」  其「Worst case」為 O(log n)  n 筆資料以「Binary search t">
<meta property="og:type" content="article">
<meta property="og:title" content="Data structure - Search and sort">
<meta property="og:url" content="http://wangwilly.github.io/willywangkaa/2018/11/17/Data-structure-Search-and-sort/index.html">
<meta property="og:site_name" content="WillyWangkaa">
<meta property="og:description" content="Binary search Example n 筆資料作「Binary search」最多比較次數？ \(\lceil \lg (n+1) \rceil\)   200 筆資料：最多 8 次的搜尋 1024 筆資料：最多 11 次的搜尋   Example  n 筆資料作「Binary search」  其「Worst case」為 O(log n)  n 筆資料以「Binary search t">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541038370084.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541092068950.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541092807581.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541093304800.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541094481788.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541094963273.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541214129532.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542454674621.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542455003562.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541935896940.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541215583779.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541216603304.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541217794632.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541218724819.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541765950716.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541766239354.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541766394245.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541766823939.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541816631365.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541816965630.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541818660118.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541927350444.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541927780299.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1541928492844.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542449916157.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542450245855.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542451499380.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542450561714.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542450928741.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542088579919.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542088930143.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542089353231.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542090860348.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542091456582.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542091906501.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542092026110.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542092171261.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542092353259.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542092514867.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542093764103.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542093996385.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542095449837.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542097917874.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542105475686.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542105714121.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542105818821.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542105935299.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542106039971.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542106445237.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542447949542.png">
<meta property="og:image" content="http://wangwilly.github.io/willywangkaa/images/1542448961965.png">
<meta property="article:published_time" content="2018-11-17T11:47:00.000Z">
<meta property="article:modified_time" content="2019-02-04T08:13:15.577Z">
<meta property="article:author" content="Wang Yu Li">
<meta property="article:tag" content="Search">
<meta property="article:tag" content="Sort">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wangwilly.github.io/willywangkaa/images/1541038370084.png">






  <link rel="canonical" href="http://WangWilly.github.io/willywangkaa/2018/11/17/Data-structure-Search-and-sort/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>Data structure - Search and sort | WillyWangkaa</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-tw">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/willywangkaa/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WillyWangkaa</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The higher up, the greater the fall.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/willywangkaa/%20" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/willywangkaa/archives/%20" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/willywangkaa/categories/%20" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/willywangkaa/tags/%20" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />Search</a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://WangWilly.github.io/willywangkaa/willywangkaa/2018/11/17/Data-structure-Search-and-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/willywangkaa/images/avatar_me.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WillyWangkaa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Data structure - Search and sort</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-17T19:47:00+08:00">2018-11-17</time>
            

            
            
              
                
              
            

            
              
              <span class="post-meta-divider">|</span>
              

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2019-02-04T16:13:15+08:00">2019-02-04</time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/willywangkaa/categories/Data-Structure/" itemprop="url" rel="index"><span itemprop="name">Data Structure</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/willywangkaa/2018/11/17/Data-structure-Search-and-sort/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/11/17/Data-structure-Search-and-sort/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="binary-search">Binary search</h1>
<p>Example</p>
<p>n 筆資料作「Binary search」最多比較次數？</p>
<p><span class="math inline">\(\lceil \lg (n+1) \rceil\)</span></p>
<blockquote>
<ul>
<li><p>200 筆資料：最多 8 次的搜尋</p></li>
<li><p>1024 筆資料：最多 11 次的搜尋</p></li>
</ul>
</blockquote>
<p><strong>Example</strong></p>
<ol type="1">
<li>n 筆資料作「Binary search」
<ul>
<li>其「Worst case」為 O(log n)</li>
</ul></li>
<li>n 筆資料以「Binary search tree」作查找
<ul>
<li>其「Worst case」為 <strong>O( n )</strong> ( Skew tree )</li>
<li>其「Best case」為 <strong>O( log n )</strong></li>
</ul></li>
</ol>
<h1 id="internal-sort-and-external-sort">Internal sort and external sort</h1>
<h2 id="internal-sort">Internal sort</h2>
<p>資料量少可一次載入到記憶體中進行排序</p>
<h2 id="external-sort">External sort</h2>
<p>資料量太多無法一次全部置入記憶體之中，需藉由外部儲存體 ( Disk ) 來保存再進行排序</p>
<ul>
<li>常用的「External sorting method」
<ul>
<li><strong>Merge sort</strong> ( Selection tree 輔佐 )</li>
<li>M-way search tree、B-tree、B<span class="math inline">\(^+\)</span>-tree</li>
</ul></li>
</ul>
<h1 id="排序性質比較表">排序性質比較表</h1>
<blockquote>
<p>此表為方便比較用圖，欲瞭解其推倒原因詳見下方細述</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>Sort algorithm</th>
<th>T.C. (Best)</th>
<th>T.C. (Worst)</th>
<th>T.C. (Avg.)</th>
<th>S.C.</th>
<th>Stable</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insertion</td>
<td><strong>O(n)</strong></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>O(1)</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Selection</td>
<td><span class="math inline">\(O(n^2)\)</span>☆</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>O(1)</td>
<td>No</td>
</tr>
<tr class="odd">
<td>Bubble</td>
<td>O(n)</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>O(1)</td>
<td><strong>Yes</strong></td>
</tr>
<tr class="even">
<td>Shell</td>
<td><span class="math inline">\(O(n^\frac 32)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>O(1)</td>
<td>No</td>
</tr>
<tr class="odd">
<td>Quick</td>
<td>O(nlogn)</td>
<td><span class="math inline">\(O(n^2)\)</span>☆</td>
<td>O(nlogn)</td>
<td><strong>O(lgn)~O(n)☆</strong></td>
<td>No</td>
</tr>
<tr class="even">
<td>Merge</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Heap</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td><strong>O(1)☆</strong></td>
<td>No</td>
</tr>
<tr class="even">
<td>Radix</td>
<td>N/A</td>
<td>N/A</td>
<td>O(d×(n+r))</td>
<td><strong>O(r×n)☆</strong></td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Counting</td>
<td>N/A</td>
<td>N/A</td>
<td>O(n+k)</td>
<td><strong>O(n+k)☆</strong></td>
<td>Yes</td>
</tr>
</tbody>
</table>
<ul>
<li>註
<ul>
<li>T.C. = Time complecity</li>
<li>S.C. = Space complexity</li>
<li>r 為「Redix sort」的基數大小</li>
<li>d 為「Redix sort」以 r 作為基數之位數最大值</li>
<li>k 為「Counting sort」之資料值域範圍</li>
</ul></li>
</ul>
<h1 id="初等排序">初等排序</h1>
<h2 id="insertion-sort">Insertion sort</h2>
<ul>
<li>演算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 將資料 r 插入到已排好的區塊 A[0] ~ A[i]</span></span><br><span class="line"><span class="built_in">Insert</span>(A[], r, i) &#123;</span><br><span class="line">    j = i;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; A[j]) &#123;</span><br><span class="line">        A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">        j = j<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A[j+<span class="number">1</span>] = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Insort</span>(A[], n) &#123;</span><br><span class="line">    A[<span class="number">0</span>] = -oo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">Insert</span>(A, A[i], i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity</p>
<ul>
<li>Best case：O(n)
<ul>
<li>當「Input data」恰巧為小到大，每回合檢查一次即可確定 r 的插入位置，共作 n-1 回合所以 O(n)</li>
</ul></li>
<li>Worst case：O( <span class="math inline">\(n^2\)</span> )
<ul>
<li>當「Input data」恰巧為大到小，<span class="math inline">\(Total = 1+2+ \ldots+n-1 \\=\frac{n(n-1)}{2} = O(n^2)\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541038370084.png" alt="1541038370084" /><figcaption aria-hidden="true">1541038370084</figcaption>
</figure>
<ul>
<li>Avg. case：O( <span class="math inline">\(n^2\)</span> )
<ul>
<li>利用遞迴時間函數，令第 n 筆資料之平均比較次數 (Time complexity) 為 O(n)</li>
<li><span class="math inline">\(T(n) = T(n-1) + \frac n2 \\ = T(n-2) + \frac{n-1}2 + \frac n2 \\ \vdots \\ = \frac{1+2+\ldots+n}{2} = \frac{n(n+1)}{4} = O(n^2)\)</span></li>
</ul></li>
<li>Space complexity ( 除了「Input data」之外所需空間 )
<ul>
<li>O( 1 )</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541092068950.png" alt="1541092068950" /><figcaption aria-hidden="true">1541092068950</figcaption>
</figure>
<ul>
<li>Stable
<ul>
<li>因為這行程式碼<code>while(r &lt; A[j]) do...</code>所以不會交換一樣大小的資料</li>
</ul></li>
</ul>
<h2 id="selection-sort">Selection sort</h2>
<ul>
<li>演算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// Iterate through array elements </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;   </span><br><span class="line">        <span class="keyword">int</span> min = i; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">            <span class="keyword">if</span> (a[min] &gt; a[j]) </span><br><span class="line">                min = j;</span><br><span class="line">        <span class="keyword">if</span>(min != i) <span class="built_in">swap</span>(a[i], a[min]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure>
<img src="\willywangkaa\images\1541092807581.png" alt="1541092807581" /><figcaption aria-hidden="true">1541092807581</figcaption>
</figure>
<ul>
<li>Time complexity
<ul>
<li>Best case：<span class="math inline">\(O(n^2)\)</span></li>
<li>Worst case：<span class="math inline">\(O(n^2)\)</span></li>
<li>Avg. case：<span class="math inline">\(O(n^2)\)</span></li>
</ul></li>
<li>Space complexity
<ul>
<li>O( 1 )</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541093304800.png" alt="1541093304800" /><figcaption aria-hidden="true">1541093304800</figcaption>
</figure>
<ul>
<li><p>Unstable</p></li>
<li><p>多用在大型紀錄( 由多欄位組成之資料 ) 之排序</p>
<ul>
<li><strong>每回合最多一次資料交換 ( Swap )</strong>，不會吃太多資料存取較有優勢</li>
</ul></li>
<li><p><code>if(min != i) do...</code> 如果省略，可以省下比較之次數但是會多增加一次資料交換，所以適用於大多資料皆未落在正確位置之上時</p></li>
</ul>
<h2 id="bubble-sort">☆Bubble sort</h2>
<h3 id="版本一">版本一</h3>
<p>由左而右，兩兩互相比較，<strong>若前者大於後者交換之</strong></p>
<blockquote>
<p>當某一回合在檢查時，未發生資料交換 ( Swap ) 則可以提早結束演算法</p>
</blockquote>
<blockquote>
<p>此演算法稱為「Bubble」是因為在每一回合檢查完，當時「Sublist」中最大值會往最高位置走，形同大泡泡往水上浮起一般</p>
</blockquote>
<ul>
<li>演算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(A[], n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j]&gt;A[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[j], A[j+<span class="number">1</span>]);</span><br><span class="line">                f = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="\willywangkaa\images\1541094481788.png" alt="1541094481788" /><figcaption aria-hidden="true">1541094481788</figcaption>
</figure>
<h3 id="版本二">版本二</h3>
<p>由左而右，<strong>兩兩互相比較如果後者小於前者交換之</strong></p>
<blockquote>
<p>此處之「Bubble」是將最小值往最小位置走</p>
</blockquote>
<ul>
<li>演算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(A[], n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[j], A[j<span class="number">-1</span>]);</span><br><span class="line">                f = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="\willywangkaa\images\1541094963273.png" alt="1541094963273" /><figcaption aria-hidden="true">1541094963273</figcaption>
</figure>
<ul>
<li>Time complexity
<ul>
<li>Best case：O( n )
<ul>
<li>在第一回合檢查時<strong>歷經 (n-1) 次比較</strong>，但無須作「Swap」即可將排序完成</li>
<li><span class="math inline">\(T(n) = 0 + (n-1), T(1) = 0\)</span> ( 第一回合之比較次數 + 剩下 n-1 筆資料之「Bubble sort」)</li>
</ul></li>
<li>Avg. case：O( <span class="math inline">\(n^2\)</span> )
<ul>
<li><span class="math inline">\(T(n) = O(n) + T(n-1)\)</span> ( 每回合之平均比較次數 + 剩下 n-1 筆資料之「Bubble sort」)</li>
<li><span class="math inline">\(T(n) = O(n) + T(n-1) \\ \vdots \\ = T(1) + c \cdot(2 + \ldots + n) = O(n^2)\)</span></li>
</ul></li>
<li>Worst case：O( <span class="math inline">\(n^2\)</span> )
<ul>
<li>在「Input data」恰巧為大至小之狀況 (見下圖)</li>
<li>處理 n 筆資料時則為 <span class="math inline">\(n + (n-1) + \ldots + 1 = O(n^2)\)</span></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541214129532.png" alt="1541214129532" /><figcaption aria-hidden="true">1541214129532</figcaption>
</figure>
<ul>
<li>Space complexity
<ul>
<li>O( 1 )</li>
</ul></li>
<li>Stable
<ul>
<li>因為 <code>if(A[j]&gt;A[j+1])</code> 必須要大於才會交換資料所以為穩定排序法</li>
</ul></li>
</ul>
<h2 id="weiss-版本-shell-sort">[Weiss 版本] Shell sort</h2>
<p>從 1 元素到 n-span 元素，比較 A[i] 與 A[i+span] ，若前者大於後者則交換；每一回合需持續到<strong>沒有交換</strong>為止，再進入下一回合</p>
<ul>
<li>Span 型式（將會決定總回合數）
<ul>
<li>( 一般型 ) <span class="math inline">\(\lceil \frac {n}{2^k}\rceil\)</span> 或 <span class="math inline">\([\frac{n}{2^k}]\)</span>
<ul>
<li>第一回合 span 等於 <span class="math inline">\(\frac n2\)</span></li>
<li>第二回合 span 等於 <span class="math inline">\(\frac n4\)</span></li>
<li>以此類推，<strong>最後一回合 span 為 1</strong></li>
</ul></li>
<li><span class="math inline">\(2^k-1\)</span>
<ul>
<li>第一回合 span 等於 15</li>
<li>第二回合 span 等於 7</li>
<li>以此類推，<strong>最後一回合 span 為 1</strong></li>
</ul></li>
<li>（自訂型）
<ul>
<li>第一回合 span 等於 7</li>
<li>第二回合 span 等於 5</li>
<li>第三回合 span 等於 2</li>
<li><strong>最後一回合 span 為 1</strong></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>最後一回合 span 必須為 1</p>
</blockquote>
<blockquote>
<p>當此回合的 span 值為 k 時，則表示有 k 條「Sublist」要排序，</p>
</blockquote>
<p>Example ( Span型：5、3、2、1 )</p>
<p>排序：9 8 7 2 3 5 1 4 6</p>
<figure>
<img src="\willywangkaa\images\1542454674621.png" alt="1542454674621" /><figcaption aria-hidden="true">1542454674621</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// span 型態 =&gt; n/(2^k)</span></span><br><span class="line"><span class="built_in">Shellsort</span>(A[], n) &#123;</span><br><span class="line">    span = n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(span &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            f = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n-span); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i] &gt; A[i+span]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(A[i], A[i+span]);</span><br><span class="line">                    f = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(f != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>Avg. case：<span class="math inline">\(O(n^2)\)</span></li>
<li>Worst case：<span class="math inline">\(O(n^2)\)</span></li>
<li>Best case：目前無定論，與「Span 型態」有關
<ul>
<li><span class="math inline">\(O(n^{\frac 32})、O(n^{\frac 54})、O(n^{\frac 76})\)</span></li>
</ul></li>
</ul></li>
<li>Space complexity
<ul>
<li>O(1)</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542455003562.png" alt="1542455003562" /><figcaption aria-hidden="true">1542455003562</figcaption>
</figure>
<ul>
<li>Unstable</li>
</ul>
<h1 id="高等排序">高等排序</h1>
<h2 id="comparesion-based-comparsion-and-swap-sort-研究與探討">Comparesion based ( Comparsion and swap ) sort 研究與探討</h2>
<p>使用比較大小的方式進行排序可以使用一個「Decision tree」來表達</p>
<p>Example</p>
<p>三筆資料 R1, R2, R3 不知其大小關係，在排序之後之所有可能</p>
<figure>
<img src="\willywangkaa\images\1541935896940.png" alt="1541935896940" /><figcaption aria-hidden="true">1541935896940</figcaption>
</figure>
<blockquote>
<p>根據上圖之「Decision tree」：</p>
<ol type="1">
<li>為一個「Binary tree」
<ul>
<li>非葉節點：「比較過程之節點」( Comparsion node )</li>
<li>葉節點：「某個排序的結果」</li>
</ul></li>
<li>假設排序 n 筆資料：會產生 n! 之排序可能結果，會有 n! 個葉節點
<ul>
<li><span class="math inline">\(\because 總節點數量 = 葉節點數量 + 非葉節點數量 = 2\times 非葉節點數量 + 1 \\有\; n! \;個葉節點 \Rightarrow n! -1 \;個非葉節點\)</span></li>
<li><span class="math inline">\(\because 有\; n! \;個葉節點，又為「Binary \;tree」 \\ Tree \;height (h) \Rightarrow 2^{h-1} \geq n! \\ \Rightarrow h-1 \geq \lceil \lg n! \rceil \\ \Rightarrow h \geq \lceil \lg n! \rceil +1 \Rightarrow \\ \therefore 總共的比較需要大於等於 \lceil n \lg n \rceil \approx n\lg n \\ 「Comparsion\;based \; sort」 最快之\; Time \;complexity= \Omega ( n\lg n )\)</span></li>
</ul></li>
</ol>
</blockquote>
<p><strong>Example</strong></p>
<p><strong>五筆資料排序之比較次數至少為何？</strong></p>
<p><del>5 × lg 5 =&gt; 10</del></p>
<p><span class="math inline">\(\lceil \lg n!\rceil = \lceil\lg 5!\rceil = \lceil \lg 120 \rceil \approx 7\)</span></p>
<blockquote>
<p>若非使用「Comparsion based」則可以不受到此限制，<strong>時間複雜度最快可達到線性時間</strong></p>
</blockquote>
<h2 id="quick-sort">Quick sort</h2>
<ul>
<li>Avg. case 在實際排序時間最快的方法</li>
<li>採用「Divide and conquer」作法</li>
</ul>
<p>令陣列最左資料 A[1] 作為「Pivot key」，經過「分割」( Partition ) 動作後，將「Pivot」置於大小關係"最正確"的位置上</p>
<figure>
<img src="\willywangkaa\images\1541215583779.png" alt="1541215583779" /><figcaption aria-hidden="true">1541215583779</figcaption>
</figure>
<blockquote>
<p>可用多線程電腦加速執行</p>
</blockquote>
<h3 id="quicksort1-hoare-partition">Quicksort1 ( Hoare partition )</h3>
<figure>
<img src="\willywangkaa\images\1541216603304.png" alt="1541216603304" /><figcaption aria-hidden="true">1541216603304</figcaption>
</figure>
<p>Example</p>
<p>排序：6, 8, 3, 7, 5, 9, 4, 1, 10, 2</p>
<figure>
<img src="\willywangkaa\images\1541217794632.png" alt="1541217794632" /><figcaption aria-hidden="true">1541217794632</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序陣列 A[l] ~ A[u]</span></span><br><span class="line"><span class="built_in">Qsort</span>(A[], l, u) &#123;</span><br><span class="line">    <span class="comment">// Partition</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt; u) &#123;</span><br><span class="line">        i = l;</span><br><span class="line">        j = u+<span class="number">1</span>;</span><br><span class="line">        p = A[l];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">while</span>(A[i] &lt; p);</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">while</span>(A[j] &gt; p);</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>( i &lt;= j ) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[i], A[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(i &lt;= j);</span><br><span class="line">        <span class="built_in">swap</span>(A[l], A[j]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Qsort</span>(A[], l, j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">Qsort</span>(A[], j+<span class="number">1</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example</p>
<p>排序：<span class="math inline">\(5^＊, 5, 5, 5, 5\)</span></p>
<figure>
<img src="\willywangkaa\images\1541218724819.png" alt="1541218724819" /><figcaption aria-hidden="true">1541218724819</figcaption>
</figure>
<ul>
<li><p><strong>Unstable</strong></p></li>
<li><p><strong>Time complexity</strong></p>
<ul>
<li><strong>Best case：O( n log n ) (下圖一)</strong>
<ul>
<li>「Partition」恰將「Input data」分成兩等分</li>
<li><span class="math inline">\(T(n) = O(n) + T(\frac n2) + T(\frac n2)\)</span>：<strong>Partition time + 左右邊作「Quick sort」</strong></li>
<li><span class="math inline">\(T(n) = 2T(\frac n2) + cn\\ =nT(1) +c\cdot n\log n = O(n \log n)\)</span></li>
</ul></li>
<li><strong>Avg. case：O( n log n ) (下圖二)</strong>
<ul>
<li><span class="math inline">\(T(n) = c\cdot n + \frac 1n\cdot \sum_{s = 1}^n (T(s) + T(n-s))\)</span>
<ul>
<li><strong>Partition time + 全部狀況之平均</strong></li>
</ul></li>
<li><strong>（1）</strong>$nT(n) = c n^2 + _{s = 1}^n(T(s) + T(n-s))\ = [(T(1)+T(n-1)) + (T(2)+T(n-2)) + + (T(n)+ T(0))] + cn^2 \ = 2 [T(1)+T(2)++T(n-1)] + T(n) + cn^2 $</li>
<li><strong>以 (n-1) 代入式（1）成為式（2） </strong></li>
<li><strong>（2）</strong>$(n-1)T(n-1) = 2[T(1)+ T(2)++T(n-2)]+T(n-1)+c(n-1)^2 $</li>
<li><strong>式（1）— 式（2）</strong></li>
<li><span class="math inline">\(\Rightarrow nT(n) - (n-1)T(n-1) = 2T(n-1)+T(n)-T(n-1)+c(n^2 - (n-1)^2) \\ \Rightarrow nT(n) - nT(n-1) + T(n-1) = T(n-1) + T(n) + c(n^2-(n-1)^2) \\ \Rightarrow (n-1)T(n) = nT(n-1) + c(n^2- (n-1)^2) \\ \Rightarrow \frac{T(n)}{n} = \frac{T(n-1)}{n-1} + c (\frac{2n-1}{n(n-1)}) \Rightarrow \frac{T(n)}{n} = \frac{T(n-1)}{n-1} + c (\frac 1n + \frac{1}{n-1}) \\ \Rightarrow \frac{T(n)}{n} = c(\frac 1n+\frac 1{n-1} + \ldots+\frac 12) + c (\frac 1{n-1} + \frac 1{n-2} + \ldots + \frac 11) \\ \Rightarrow\frac{T(n)}{n} = c(H_n -1) + c(H_n + \frac 1n) \\ \Rightarrow T(n) = 2 c\cdot n \cdot H_n - cn -c \\ = 2\cdot c \cdot n \log n - cn -c = O(n\log n)\)</span></li>
<li>上述遞迴時間表示式<strong>忽略執行「Partition」後，右邊會多少一筆資料</strong>（下圖二）
<ul>
<li>完整表示應該為 <span class="math inline">\(T(n) = \frac 1n \sum_{s = 0}^{n-1}(T(s) + T(n-1-s)) + c\cdot n\)</span></li>
</ul></li>
</ul></li>
<li><strong>Worst case：O(</strong> <span class="math inline">\(n^2\)</span> <strong>) (下圖三)</strong>
<ul>
<li><strong>當 Pivot 恰為最小最大值時</strong>，作「Partition」不會使「Divide and conquer」的優點顯現
<ul>
<li><strong>整體資料為「由小到大」或「由大到小」時會發生「Worst case」</strong></li>
<li><span class="math inline">\(T(n) = O(n) + T(n-1) \\ = T(1) + (2 + 3 + \ldots + n) \cdot c \\ = c \cdot \frac{(n+2)(n-1)}{2} = O(n^2)\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541765950716.png" alt="1541765950716" /><figcaption aria-hidden="true">1541765950716</figcaption>
</figure>
<p>圖一</p>
<figure>
<img src="\willywangkaa\images\1541766239354.png" alt="1541766239354" /><figcaption aria-hidden="true">1541766239354</figcaption>
</figure>
<p>圖二</p>
<figure>
<img src="\willywangkaa\images\1541766394245.png" alt="1541766394245" /><figcaption aria-hidden="true">1541766394245</figcaption>
</figure>
<p>圖三</p>
<blockquote>
<p>如何避免「Worst case」發生？</p>
<p>避免 Pivot 為最小值或最大值</p>
<p><strong>Randomized quicksort</strong></p>
<ul>
<li>亂數挑一個數作為 Pivot</li>
<li><strong>仍有可能發生「Worst case」( 無法完全解決問題 )</strong></li>
</ul>
<p><strong>Middle of three</strong> （下圖）</p>
<ul>
<li>做法
<ol type="1">
<li><span class="math inline">\(M = \frac {L+U}{2}\)</span></li>
<li>比較 A[L], A[M], A[U] 找出三者中之中間值，以<strong>此中間值與 A[l] 交換</strong></li>
<li>選擇 A[L] 作為 Pivot（中間值），作「Quicksort partition」</li>
</ol></li>
<li>可以解決「Worst case」問題</li>
</ul>
<figure>
<img src="\willywangkaa\images\1541766823939.png" alt="1541766823939" /><figcaption aria-hidden="true">1541766823939</figcaption>
</figure>
<p><strong>Median of medians</strong></p>
<p><strong>＜下方細述＞</strong></p>
</blockquote>
<ul>
<li><strong>Space complexity（遞迴所需的「Stack space」）</strong>
<ul>
<li>Best case (下圖一)：O( log n )</li>
<li>Worst case (下圖二)：O( n )</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541816631365.png" alt="1541816631365" /><figcaption aria-hidden="true">1541816631365</figcaption>
</figure>
<p>圖一</p>
<figure>
<img src="\willywangkaa\images\1541816965630.png" alt="1541816965630" /><figcaption aria-hidden="true">1541816965630</figcaption>
</figure>
<p>圖二</p>
<h3 id="quicksort2-algorithm書中版本">Quicksort2 ( 「Algorithm」書中版本 )</h3>
<p>Example</p>
<p>2 8 7 1 3 5 6 4 之第一次「Partition」</p>
<figure>
<img src="\willywangkaa\images\1541818660118.png" alt="1541818660118" /><figcaption aria-hidden="true">1541818660118</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Quicksort</span>(A[], p, r) &#123;               <span class="comment">// 排序 A[p] ~ A[r]</span></span><br><span class="line">    <span class="keyword">if</span>(p &lt; r) &#123;</span><br><span class="line">        q = <span class="built_in">Partition</span>(A[], p, r);    <span class="comment">// 見下圖一</span></span><br><span class="line">        <span class="built_in">Quicksort</span>(A[], p, q<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">Quicksort</span>(A[], q+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Partition</span>(A[], p, r) &#123;</span><br><span class="line">    pivot = A[r];</span><br><span class="line">    i = p<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = p; i &lt;= r<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(A[i], A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(A[i+<span class="number">1</span>], A[r]);</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example</p>
<p>The output of quicksort pass1</p>
<ul>
<li>1 2 3 4 5</li>
</ul>
<figure>
<img src="\willywangkaa\images\1541927350444.png" alt="1541927350444" /><figcaption aria-hidden="true">1541927350444</figcaption>
</figure>
<ul>
<li>5 4 3 2 1</li>
</ul>
<figure>
<img src="\willywangkaa\images\1541927780299.png" alt="1541927780299" /><figcaption aria-hidden="true">1541927780299</figcaption>
</figure>
<ul>
<li><span class="math inline">\(5 \;5 \;5 \;5 \;5^＊\)</span>
<ul>
<li><strong>在「Quicksort 2」演算情況下會是「Worst case」</strong>（O(<strong><span class="math inline">\(n^2\)</span></strong>)）</li>
<li><strong>在「Quicksort 1」演算情況下會是「Best case」</strong></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1541928492844.png" alt="1541928492844" /><figcaption aria-hidden="true">1541928492844</figcaption>
</figure>
<blockquote>
<p><strong>改善上述問題</strong></p>
<ol type="1">
<li>在「Partition」執行前<strong>檢查該陣列中元素是否相同</strong>：O( n )</li>
<li>改採用「 Hoare partition」：「Best case」O( n log n )</li>
</ol>
</blockquote>
<h3 id="問題與討論selection-problem">問題與討論—Selection problem</h3>
<p>問題概要：想要在一個<strong>未排序的一維陣列</strong>中，找到其最大值與最小值</p>
<ul>
<li>Native solution
<ol type="1">
<li>歷經 n-1 次比較後找出最大值</li>
<li>剩下 n-1 筆資料中歷經 n-2 次比較找出最小值
<ul>
<li>總<strong>比較</strong>次數：(n-1) + (n-2) = <strong>2n-3 次比較</strong></li>
</ul></li>
</ol></li>
<li>改良解法
<ol type="1">
<li><strong>A[1] 與 A[2] 比較一次知道兩數大小</strong>
<ul>
<li>令兩者之大數為 m 、小數為 n</li>
</ul></li>
<li>針對<strong>後面 n-2 筆資料以遞迴找出最大值與最小值</strong>（A[3]、A[4]、A[n-4]）
<ul>
<li>令 n-2 筆資料的最大值為 x、最小值為 y</li>
</ul></li>
<li>『m 與 x <strong>比較一次</strong>找出最大值』、『n 與 y <strong>比較一次</strong>找出最小值』</li>
</ol>
<ul>
<li>初值
<ul>
<li>T(0) = T(1) = 0</li>
<li>T(2) = 1</li>
</ul></li>
<li>總<strong>比較</strong>次數
<ul>
<li>T(n) = T(n-2) +（<strong>A[i] 與 A[i+1] 比較一次</strong> + <strong>m 與 x 比較</strong> + <strong>n 與 y 比較一次</strong>）</li>
<li><span class="math inline">\(T(n) = T(n-2) + 3 \\ = T(n-4) + 6 \\= T(n-6) + 9 \\ \vdots \\= T(0) + 3 \cdot \frac n2 &lt; 2n-3\)</span></li>
</ul></li>
<li><strong>稍微減少比較次數</strong></li>
</ul></li>
</ul>
<h3 id="問題與討論select-i-th-item-among-n-unsorted-data-array">問題與討論—Select i-th item among n unsorted data array</h3>
<p><strong>在未排序的陣列中找到第 i 小的資料</strong></p>
<blockquote>
<p>學過的演算法中：</p>
<ul>
<li>不知道其值域
<ul>
<li>以「Quick sort」等算法求取資料各個大小的資訊</li>
<li><strong>O(n log n)</strong></li>
</ul></li>
<li>知道資料範圍
<ul>
<li>以「Radix sort」等算法求取資料的大小資訊</li>
<li><strong>O(n)</strong></li>
</ul></li>
</ul>
<p><strong>如果以「Comparison based」來解決這個問題有無更快的算法？</strong></p>
<ul>
<li><strong>利用「Quick sort」中的「Partition」為此算法基底</strong></li>
</ul>
</blockquote>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 A[p]~A[r] 中找到第 i 小的資料</span></span><br><span class="line"><span class="built_in">Select</span>(A[], p, r, i) &#123;</span><br><span class="line">    q = <span class="built_in">Partition</span>(A, p, r); <span class="comment">// 將 pivot 大小定位在 q 點</span></span><br><span class="line">    k = q-p+<span class="number">1</span>;              <span class="comment">// 算出 pivot 是第 k 小的資料</span></span><br><span class="line">    <span class="keyword">if</span>(i == k) &#123;            <span class="comment">// pivot 即為 A[p]~A[r] 中第 k 小的資料</span></span><br><span class="line">        <span class="keyword">return</span> A[q];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; k) &#123;</span><br><span class="line">        <span class="built_in">Select</span>(A, p, q<span class="number">-1</span>, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Select</span>(A, q+<span class="number">1</span>, r, i-q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Time complexity</strong></p>
<ul>
<li>Best case：<strong>Pivot 的定位恰將資料切為兩等分</strong>
<ul>
<li>對左半或是右半作「Selection」+ 「Partition」</li>
<li><span class="math inline">\(T(n) = T(\frac n2) + cn \\ = c(n + \frac n2 + \frac n4 + \ldots+1) = \Theta(n)\)</span></li>
</ul></li>
<li>Average case
<ul>
<li><span class="math inline">\(T(n) = \frac 1n\sum_{s = 0}^{n-1} T(s)+ cn = O(n)\)</span></li>
</ul></li>
<li>Worst case
<ul>
<li><strong>當 Pivot 恰為最大或是最小值</strong></li>
<li><span class="math inline">\(T(n) = T(n-1) + cn\\ = n + (n-1) + (n-2) + \dots + 1 = O(n^2)\)</span></li>
<li><strong>解決辦法</strong>
<ul>
<li><strong>採取「Median of medians」選擇 Pivot ，將 Worst case 弭平為 O(n)</strong></li>
</ul></li>
</ul></li>
</ul>
<h4 id="selection-with-median-of-medians">Selection with median of medians</h4>
<figure>
<img src="\willywangkaa\images\1542449916157.png" alt="1542449916157" /><figcaption aria-hidden="true">1542449916157</figcaption>
</figure>
<p>步驟</p>
<ol type="1">
<li><p>先將 n 筆資料分成 <span class="math inline">\(\lceil \frac n5 \rceil\)</span> 個群組，每個群組有<strong>五筆資料</strong>（可能有一群組不足 5 筆資料）</p>
<ul>
<li>時間複雜度
<ul>
<li>O(n)</li>
</ul></li>
</ul></li>
<li><p>針對每個群組各自排序（如：Insertion sort）</p>
<ul>
<li>時間複雜度
<ul>
<li>每個群組最多花費 O(25) 次比較</li>
<li>共有 <span class="math inline">\(\lceil \frac n5 \rceil\)</span> 個群組</li>
<li>總共需 O(n)</li>
</ul></li>
</ul></li>
<li><p>每個已排序群組中<strong>第三個資料為該群組之中間值</strong></p>
<ul>
<li>對 <span class="math inline">\(\lceil \frac n5 \rceil\)</span> 個群組的中間值作「Selection with median」
<ul>
<li><strong>這些中間值中的中間值即為「Median of medians」</strong></li>
</ul></li>
<li>時間複雜度
<ul>
<li>遞迴呼叫「Selection with median」函式</li>
<li>在中間值中找第 <span class="math inline">\(\frac{\lceil\frac{n}{5}\rceil}{2}\)</span> 小的中間值
<ul>
<li><span class="math inline">\(T(\lceil\frac n5\rceil)\)</span></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>以「Median of medians」作為「Pivot」進行「Partition」</p>
<ul>
<li>時間複雜度
<ul>
<li>O(n)</li>
</ul></li>
</ul></li>
<li><p>繼續尋找 i 大小的值</p>
<ul>
<li>時間複雜度
<ul>
<li><strong>取決於「Median of medians」作為「Pivot」將資料切割之程度</strong></li>
</ul></li>
</ul></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">k = q-p+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i == k) &#123;</span><br><span class="line">    <span class="keyword">return</span> A&#123;q];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">    <span class="built_in">Select</span>(A, p, q<span class="number">-1</span>, i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">Select</span>(A, q+<span class="number">1</span>, r, i-k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>扣除「Pivot」所在的群組以及不滿五筆資料之群組
<ul>
<li><p><strong>約有一半的群中組必有 3 筆資料</strong> ≧「Pivot」</p></li>
<li><p>比「Pivot」大的資料個數 $( n5)  =   $</p></li>
<li><p>相反的會有 <span class="math inline">\(\lceil \frac{7n}{10}\rceil +6\)</span> 筆資料 ≦「Pivot」</p></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542450245855.png" alt="1542450245855" /><figcaption aria-hidden="true">1542450245855</figcaption>
</figure>
</blockquote>
<ul>
<li>Time comlexity
<ul>
<li>（下圖）最糟糕的情況
<ul>
<li><strong>在資料比較多的地方作「Select」</strong></li>
<li>在 <span class="math inline">\(\lceil \frac{7n}{10}\rceil +6\)</span> 中遞迴找出目標值
<ul>
<li>第五步的遞迴最壞需要 <span class="math inline">\(T(\lceil \frac{7n}{10}\rceil + 6)\)</span></li>
</ul></li>
</ul></li>
<li><span class="math inline">\(T(n) = T(\lceil\frac n5\rceil) + T(\lceil \frac{7n}{10}\rceil+6)+O(n) \\ = T(\frac 15n)+ T(\frac 7{10}n) + cn = O(n)\)</span>（以樹狀結構解此遞迴）</li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542451499380.png" alt="1542451499380" /><figcaption aria-hidden="true">1542451499380</figcaption>
</figure>
<blockquote>
<ul>
<li>（下圖）如果以<strong>七筆資料為一群組</strong>
<ul>
<li>至少有 <span class="math inline">\((\frac 12\cdot\lceil\frac n7\rceil -2)\cdot 4\)</span> 筆資料 ≧「Pivot」
<ul>
<li><span class="math inline">\(\frac{2n}{7}-8\)</span> 筆 ≧「Pivot」</li>
<li><span class="math inline">\(\lceil \frac {5n}{7}\rceil+8\)</span> 筆 ≦「Pivot」</li>
</ul></li>
<li><span class="math inline">\(T(n) = O(n) + O(n) + T(\lceil\frac n7\rceil) +O(n) + T(\lceil \frac{5n}{7}\rceil+8) \\ = T(\frac n7)+ T(\frac 57n)+cn = O(n)\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542450561714.png" alt="1542450561714" /><figcaption aria-hidden="true">1542450561714</figcaption>
</figure>
<ul>
<li>（下圖）如果以<strong>三筆資料為一群組</strong>
<ul>
<li>至少有 <span class="math inline">\((\frac 12\cdot\lceil\frac n3\rceil -2)\cdot 2\)</span> 筆資料 ≧ 「Pivot」
<ul>
<li><span class="math inline">\(\frac{n}{3}-4\)</span> 筆 ≧「Pivot」</li>
<li><span class="math inline">\(\lceil \frac {2n}{3}\rceil+4\)</span> 筆 ≦「Pivot」</li>
</ul></li>
<li><span class="math inline">\(T(n) = O(n) + O(n) + T(\lceil\frac n3\rceil) +O(n) + T(\lceil \frac{2n}{3}\rceil+4) \\ = T(\frac n3)+ T(\frac 23n)+cn = O(n\log n)\)</span></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542450928741.png" alt="1542450928741" /><figcaption aria-hidden="true">1542450928741</figcaption>
</figure>
</blockquote>
<h2 id="merge-sort">Merge sort</h2>
<p>適用於「External sort」，所以可以又稱為「External merge sort」；其特性可讀入一些能放在內存內的數據量，在內存中排序後輸出為一個順串（即是內部數據有序的臨時文件），處理完所有的數據後再進行歸併</p>
<p>(見<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E5%A4%96%E6%8E%92%E5%BA%8F">外排序- 維基百科，自由的百科全書 - Wikipedia</a>)</p>
<ul>
<li>名詞
<ul>
<li>「Run」：<strong>順串</strong>；排序好的片段資料</li>
<li>「Run」的長度：順串中的資料量</li>
</ul></li>
</ul>
<blockquote>
<p>計算機科學家 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%90%89%E5%A7%86%C2%B7%E6%A0%BC%E9%9B%B7&amp;action=edit&amp;redlink=1">吉姆·格雷</a> 的 <a target="_blank" rel="noopener" href="http://sortbenchmark.org/">Sort Benchmark</a> 網站用不同的硬體、軟體環境測試了實現方法不同的多種外排序算法的效率。效率較高的算法具有以下的特徵：</p>
<ul>
<li><strong>並行計算</strong>
<ul>
<li>用多個磁碟驅動器<strong>並行處理數據</strong>，可以加速順序磁碟讀寫</li>
<li>在<strong>計算機上使用多執行緒</strong>，可在多核心的計算機上得到優化</li>
<li>使用異步輸入輸出，可以<strong>同時排序和歸併，同時讀寫</strong></li>
<li>使用多台計算機用高速網絡連接，分擔計算任務</li>
</ul></li>
<li><strong>提高硬體速度</strong>
<ul>
<li><strong>增大內存，減小磁碟讀寫次數，減小歸併次數</strong></li>
<li>使用快速的外存設備，比如15000 RPM的硬碟或固態硬碟</li>
<li>使用性能更優良個各種設備，比如使用多核心 CPU 和延遲時間更短的內存</li>
</ul></li>
<li><strong>提高軟體速度</strong>
<ul>
<li>對於某些特殊數據，在第一階段的排序中使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基數排序</a></li>
<li>壓縮輸入輸出文件和臨時文件</li>
</ul></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>外歸併排序法並不是唯一的「External sort」，另外有<strong>「外分配排序」</strong>，其原理類似於內排序中的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序（Bucket sort）</a></p></li>
<li><p>「Merge sort」和「Bucket sort」之間存在數學上的某種對偶性</p></li>
</ul>
<p>Example（106 清華大學資工基礎計算機科學第 6 題）</p>
<ul>
<li>簡述
<ul>
<li>比較兩個「External sort」分別的特性，並且個別適合什麼類型的資料型態
<ul>
<li>Merge sort</li>
<li>Bucket sort</li>
</ul></li>
</ul></li>
<li>Merge sort
<ul>
<li>因為其特性，適合大量資料的排序，可以將資料從「Second storage」中取得資料存於 RAM 中，再進行排序，歸併後再輸出至「Second storage」</li>
</ul></li>
<li>Bucket sort
<ul>
<li>與「Merge sort」一樣，經過調整的演算法可以作為「外分配排序」，同樣可以處理大量資料，但還有包含另一個性質，若資料位數很大時，或是基底很小時，也建議採用「MSD radix sort」</li>
</ul></li>
</ul>
</blockquote>
<h3 id="iterative-merge-sorttwo-way-merge">Iterative merge sort（Two way merge）</h3>
<p>Example</p>
<figure>
<img src="\willywangkaa\images\1542088579919.png" alt="1542088579919" /><figcaption aria-hidden="true">1542088579919</figcaption>
</figure>
<ul>
<li>Algorithm（Merge 2 runs）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A[l....m]: 子陣列「順串一」</span></span><br><span class="line"><span class="comment">// A[m+1..n]: 子陣列「順串二」</span></span><br><span class="line"><span class="built_in">Merge</span>(A[], l, m, n) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = l, q = m+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tmp[n-l+<span class="number">1</span>];   <span class="comment">// 暫存陣列 [1..(n-l+1)]</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 當 run1 與 run2 皆未掃描完</span></span><br><span class="line">    <span class="keyword">while</span>(p &lt;= m &amp;&amp; q &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[p] &lt;= A[q]) &#123;</span><br><span class="line">            tmp[i++] = A[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[i++] = A[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// run1 未掃描完</span></span><br><span class="line">    <span class="keyword">while</span>(p &lt;= m) &#123;</span><br><span class="line">        tmp[i++] = A[p++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// run2 未掃描完</span></span><br><span class="line">    <span class="keyword">while</span>(q &lt;= n) &#123;</span><br><span class="line">        tmp[i++] = A[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(A[l..n], tmp[<span class="number">1.</span>.(n-l+<span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity：O( n log n )
<ul>
<li>「順串一」的長度為 m、「順串二」的長度為 n，合併兩順串：
<ul>
<li><span class="math inline">\(\left\{\begin{matrix}最少比較次數： &amp; m \;or \;n\\ 最多比較次數（有一方先掃描完）：&amp; m+n-1\end{matrix}\right.\)</span></li>
</ul></li>
<li>（下圖一）所以假設整體要排序的資料總量為 n ，合併一次所有的順串需 O(n)
<ul>
<li>n 筆資料作「2-way merge sort」</li>
<li>（下圖二）可以看成一棵「Completed binary search tree」</li>
<li>因為<strong>「Merge」回合數 = 樹高 - 1</strong>
<ul>
<li><span class="math inline">\(\Rightarrow 2^{k-1} = n \Rightarrow k = \lceil \lg n\rceil +1\)</span></li>
<li><span class="math inline">\(\Rightarrow 「Merge」回合數 = \lceil \lg n\rceil \\ \because 每個回合作「Merge」需\; O(n) \; \\ \therefore 總共的時間複雜度為\; O(n \log n)\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542088930143.png" alt="1542088930143" /><figcaption aria-hidden="true">1542088930143</figcaption>
</figure>
<p>圖一</p>
<figure>
<img src="\willywangkaa\images\1542089353231.png" alt="1542089353231" /><figcaption aria-hidden="true">1542089353231</figcaption>
</figure>
<p>圖二</p>
<h3 id="recursive-merge-sorttwo-way-merge">Recursive merge sort（Two way merge）</h3>
<p>採用「Devide and conquer」的技巧</p>
<p>步驟：</p>
<ol type="1">
<li><p>一律切割成兩等分之「子串列」（Sublist）</p>
<ul>
<li>O( 1 )</li>
</ul></li>
<li><p>左右子串列各自作「Merge sort」，算出左右之「順串」</p>
<ul>
<li><span class="math inline">\(2 \times T(\frac n2)\)</span></li>
</ul></li>
<li><p>對左右順串作「Merge」</p>
<ul>
<li>O( n )</li>
</ul></li>
</ol>
<blockquote>
<p>「Quicksort」相比</p>
<ul>
<li>「Mergesort」把時間（O(n)）<strong>花在合併的階段</strong></li>
<li>「Quicksort」把時間（O(n)）<strong>花在分割階段</strong></li>
</ul>
</blockquote>
<figure>
<img src="\willywangkaa\images\1542090860348.png" alt="1542090860348" /><figcaption aria-hidden="true">1542090860348</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A[l....m]: 子陣列「順串一」</span></span><br><span class="line"><span class="comment">// A[m+1..n]: 子陣列「順串二」</span></span><br><span class="line"><span class="built_in">Merge</span>(A[], l, m, n) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = l, q = m+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tmp[n-l+<span class="number">1</span>];   <span class="comment">// 暫存陣列 [1..(n-l+1)]</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 當 run1 與 run2 皆未掃描完</span></span><br><span class="line">    <span class="keyword">while</span>(p &lt;= m &amp;&amp; q &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[p] &lt;= A[q]) &#123;</span><br><span class="line">            tmp[i++] = A[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[i++] = A[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// run1 未掃描完</span></span><br><span class="line">    <span class="keyword">while</span>(p &lt;= m) &#123;</span><br><span class="line">        tmp[i++] = A[p++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// run2 未掃描完</span></span><br><span class="line">    <span class="keyword">while</span>(q &lt;= n) &#123;</span><br><span class="line">        tmp[i++] = A[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(A[l..n], tmp[<span class="number">1.</span>.(n-l+<span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 對 A[L]~A[R] 排序</span></span><br><span class="line"><span class="built_in">Mergesort</span>(A[], L, R) &#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt; R) &#123;</span><br><span class="line">        m = (l+u)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">Mergesort</span>(A, L  , m);</span><br><span class="line">        <span class="built_in">Mergesort</span>(A, m+<span class="number">1</span>, R);</span><br><span class="line">        <span class="built_in">Merge</span>(A, L, m, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>Best / Worst / Avg.：O( nlogn )
<ul>
<li><span class="math inline">\(\because T(n) = 2\times T(\frac n2) + cn \Rightarrow T(n) = O(n\log n)\)</span></li>
</ul></li>
</ul></li>
<li>Space complexity
<ul>
<li>O( n )
<ul>
<li>在作「Merge」的時候為了<strong>暫存合併的結果</strong>
<ul>
<li>空間占用大小等於資料量（n）</li>
<li>空間需求高</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Stable</strong>
<ul>
<li>因為在作「Merge」時，<code>if(A[p]&lt;=A[q])..</code> <strong>會讓左順串與右順串在有兩個同樣大小的值時，左順串優先進入新的順串之中</strong></li>
</ul></li>
</ul>
<h3 id="輔助結構-selection-tree">[輔助結構] Selection tree</h3>
<p>如果在「Mergesort」中一次合併多個順串（k 個順串），稱之為「K-way mergesort」</p>
<p>Example</p>
<p><strong>4-way merge</strong></p>
<figure>
<img src="\willywangkaa\images\1542091456582.png" alt="1542091456582" /><figcaption aria-hidden="true">1542091456582</figcaption>
</figure>
<ul>
<li>每次要對 k 個順串作合併時
<ul>
<li>資料總量為 n</li>
<li><strong>每次從 k 個順串中找到最小的值必須花 k-1 次比較</strong></li>
<li>最多要<strong>歷經 n-1 個回合</strong></li>
<li><strong>作一次「k-way merge」之時間複雜度為 O(n×k)</strong></li>
</ul></li>
</ul>
<blockquote>
<p>減少比較的次數</p>
<ul>
<li>以資料結構輔佐
<ul>
<li>「Winner tree」、「Loser tree」</li>
</ul></li>
<li>在實現上多採用「Loser tree」</li>
</ul>
</blockquote>
<h4 id="winner-tree">Winner tree</h4>
<p>Example</p>
<p><strong>8-way merge with winner tree</strong></p>
<figure>
<img src="\willywangkaa\images\1542091906501.png" alt="1542091906501" /><figcaption aria-hidden="true">1542091906501</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542092026110.png" alt="1542092026110" /><figcaption aria-hidden="true">1542092026110</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542092171261.png" alt="1542092171261" /><figcaption aria-hidden="true">1542092171261</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542092353259.png" alt="1542092353259" /><figcaption aria-hidden="true">1542092353259</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542092514867.png" alt="1542092514867" /><figcaption aria-hidden="true">1542092514867</figcaption>
</figure>
<p>（重複動作直到「新順串」建立完）</p>
<ul>
<li>Time complexity（假設為「k-way merge」、總資料數為 n）
<ul>
<li>建立「Winner tree」：O( k )
<ul>
<li>分別從 k 個順串中複製出<strong>最小值</strong>作為「Winner tree」的葉節點
<ul>
<li>O( k )</li>
</ul></li>
<li>在「Winner tree」中的葉節點，以 k-1 次的比較找出最小值節點作為「根節點」
<ul>
<li>O( k )</li>
</ul></li>
</ul></li>
<li>輸出「根節點」至「新順串」中，被輸出的順串之下一筆資料遞補，重複 n-1 回合：O( n×log k )
<ul>
<li>決定根節點（最小值）
<ul>
<li>假設 <span class="math inline">\(l\)</span> 為葉節點數量
<ul>
<li>「Winner tree」之葉節點為<span class="math inline">\(l = k = 8\)</span></li>
<li>「Winner tree」樹高 h 為 <span class="math inline">\(O(\lceil\log l\rceil+1)\)</span></li>
</ul></li>
<li>決定根節點需要歷經 <span class="math inline">\(O(h-1) \equiv O(\lceil\lg(l)\rceil+1-1)\)</span>
<ul>
<li><span class="math inline">\(O(\log k)\)</span></li>
</ul></li>
</ul></li>
<li>輸出根節點：O( 1 )</li>
<li>被輸出之順串下一筆資料遞補：O( 1 )</li>
</ul></li>
<li>總體時間複雜度
<ul>
<li>O(k) + O( nlogk ) = O( nlogk )</li>
</ul></li>
</ul></li>
</ul>
<h4 id="loser-tree">Loser tree</h4>
<p>Example</p>
<p>8-way merge with loser tree</p>
<figure>
<img src="\willywangkaa\images\1542093764103.png" alt="1542093764103" /><figcaption aria-hidden="true">1542093764103</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542093996385.png" alt="1542093996385" /><figcaption aria-hidden="true">1542093996385</figcaption>
</figure>
<p>（執行直到「新順串」建立完成）</p>
<p>Time complexity （假設為「k-way merge」、總資料數為 n）</p>
<ul>
<li>建立「Loser tree」：O( k )
<ul>
<li>分別從 k 個順串中複製出<strong>最小值</strong>作為「Loser tree」的「葉節點」：O( k )</li>
<li>在「Loser tree」中的葉節點，以 k-1 次的比較找出最小值節點作為「根節點」：O( k )</li>
</ul></li>
<li>輸出「根節點」至「新順串」中，被輸出的順串之下一筆資料遞補，重複 n-1 回合：O( n×log k )
<ul>
<li>決定根節點（最小值）
<ul>
<li>假設 <span class="math inline">\(l\)</span> 為葉節點數量
<ul>
<li>「Winner tree」之葉節點為<span class="math inline">\(l = k = 8\)</span></li>
<li>「Winner tree」樹高 h 為 <span class="math inline">\(O(\lceil\log l\rceil+1)\)</span></li>
</ul></li>
<li>決定根節點需要歷經 <span class="math inline">\(O(h-1) \equiv O(\lceil\lg(l)\rceil+1-1)\)</span>
<ul>
<li><span class="math inline">\(O(\log k)\)</span></li>
</ul></li>
</ul></li>
<li>輸出根節點：O( 1 )</li>
<li>被輸出之順串下一筆資料遞補：O( 1 )</li>
</ul></li>
<li>總體時間複雜度
<ul>
<li>O(k) + O( nlogk ) = O( nlogk )</li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>「External merge sort」
<ul>
<li>排序資料：n
<ul>
<li>「K-way merging on m runs」</li>
</ul></li>
<li>使用「Selection tree」其時間複雜度
<ul>
<li>O( n lg m )</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="\willywangkaa\images\1542095449837.png" alt="1542095449837" /><figcaption aria-hidden="true">1542095449837</figcaption>
</figure>
<ul>
<li>假設 m 個順串被 k-way 分成了<strong>兩堆</strong>
<ul>
<li>由「Selection tree」得知
<ul>
<li>作「k-way merge」之時間複雜度
<ul>
<li><span class="math inline">\(O( \frac n2 \times \lg k )\)</span></li>
</ul></li>
</ul></li>
<li>因為有兩堆所以「Merge」總共需要
<ul>
<li>O( n lg k )</li>
</ul></li>
<li>推廣後無論分幾堆作「Merge」之時間複雜度
<ul>
<li><strong>O( n lg k )</strong></li>
</ul></li>
</ul></li>
</ul>
<p><strong>因為『回合數 = 樹高 - 1』（見下圖），在「Sorting」時需要執行</strong> <span class="math inline">\(\lceil log_km \rceil\)</span> <strong>回合</strong></p>
<figure>
<img src="\willywangkaa\images\1542097917874.png" alt="1542097917874" /><figcaption aria-hidden="true">1542097917874</figcaption>
</figure>
<ul>
<li>Time complexity
<ul>
<li>以樹的觀點
<ul>
<li>Degree = k</li>
<li>Number of leaves = m
<ul>
<li><span class="math inline">\(\Rightarrow k^{h-1} = m \\ \Rightarrow h = \lceil\log_k m\rceil +1\\ 回合數 = h -1 = O(\log_k m)\)</span></li>
</ul></li>
</ul></li>
<li>總共時間複雜度
<ul>
<li><span class="math inline">\(O((n \cdot \lg k) \times \log_k m) \\ = O(n \cdot \frac{\log k}{\log 2}\cdot\frac{\log m}{\log k})\\ = O(n\cdot\lg m)\)</span></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h2 id="heap-sort">Heap sort</h2>
<p>步驟：</p>
<ol type="1">
<li>先將 n 筆資料建構成「Max heap」
<ul>
<li>Time complexity：O(n)</li>
</ul></li>
<li>執行「Del-max」並將取出資料放置於陣列最後端資料被移除處（見「Binary heap」之刪除節點）</li>
<li>動作（2）重複 n-1 回合</li>
</ol>
<p>Example</p>
<p>排序：5 3 8 2 6 9 1 4 10 7</p>
<figure>
<img src="\willywangkaa\images\1542105475686.png" alt="1542105475686" /><figcaption aria-hidden="true">1542105475686</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542105714121.png" alt="1542105714121" /><figcaption aria-hidden="true">1542105714121</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542105818821.png" alt="1542105818821" /><figcaption aria-hidden="true">1542105818821</figcaption>
</figure>
<figure>
<img src="\willywangkaa\images\1542105935299.png" alt="1542105935299" /><figcaption aria-hidden="true">1542105935299</figcaption>
</figure>
<p>（重複動作）</p>
<figure>
<img src="\willywangkaa\images\1542106039971.png" alt="1542106039971" /><figcaption aria-hidden="true">1542106039971</figcaption>
</figure>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tree: Array[1..n]</span></span><br><span class="line"><span class="comment">// n   : 元素個數</span></span><br><span class="line"><span class="comment">// i   : 節點編號 (調整以 i 為樹根之子樹)</span></span><br><span class="line"><span class="built_in">Heapify</span>(tree, i, n) &#123;</span><br><span class="line">    x = tree[i];</span><br><span class="line">    j = <span class="number">2</span> * i                     <span class="comment">//左子</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; n)                 <span class="comment">// 具有右子</span></span><br><span class="line">            <span class="keyword">if</span>(tree[j]&lt;tree[j+<span class="number">1</span>])</span><br><span class="line">                j = j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= tree[j])          <span class="comment">// 已經為 heap</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tree[j/<span class="number">2</span>] = tree[j];</span><br><span class="line">            j = <span class="number">2</span> * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[j/<span class="number">2</span>] = x;                <span class="comment">// 將資料 x 置於正確位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tree[]: 目標排序資料</span></span><br><span class="line"><span class="comment">// n: 排序資料數量</span></span><br><span class="line"><span class="built_in">Heapsort</span>(tree[], n) &#123;</span><br><span class="line">    <span class="comment">// Build heap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(tree, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 執行 n-1 回合之 heap sorting</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i&gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(tree[<span class="number">1</span>], tree[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">heapify</span>(tree, <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>Best case / Worst case / Avg. case = O(n log n)
<ol type="1">
<li>Build heap：O( n )</li>
<li>執行 n-1 回合「Del max」：O ( n log n )</li>
</ol></li>
</ul></li>
<li>Space complexity
<ul>
<li>O(1)</li>
</ul></li>
</ul>
<p>Example</p>
<p>排序： 5 5* 1</p>
<figure>
<img src="\willywangkaa\images\1542106445237.png" alt="1542106445237" /><figcaption aria-hidden="true">1542106445237</figcaption>
</figure>
<ul>
<li><strong>Unstable</strong></li>
</ul>
<h1 id="linear-time-sorting-method">Linear time sorting method</h1>
<p><strong>不採用「Comparison based」技巧之排序手法</strong></p>
<blockquote>
<p>在探討線性時間複雜度之排序技術前，要知道這類排序都要有一個前提，<strong>資料值域必須有範圍限制</strong>，才能將排序降低為線性時間</p>
<ul>
<li>Example：當排序資料只有 0 與 1 兩種類型資料時，最快的排序方法
<ul>
<li><strong>「Counting sort」、「Radix sort」</strong></li>
</ul></li>
<li>Example：當資料只有 -1、0、1 三種資料做排序，最快的排序方法
<ul>
<li><strong>「Counting sort」、「Radix sort」</strong></li>
</ul></li>
</ul>
</blockquote>
<h2 id="radix-sort-基數排序法-data-structure-書上版本">Radix sort 基數排序法 ( Data structure 書上版本 )</h2>
<p>又稱為「Bucket sort」，採取「Distribution and merge」之技巧</p>
<ul>
<li>書本名詞差異</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">[DS 版]（Radix = Bucket）</th>
<th style="text-align: center;">[Algorithm 版]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">LSD radix sort</td>
<td style="text-align: center;"><strong>Radix sort</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">MSD radix sort</td>
<td style="text-align: center;"><strong>Bucket sort</strong></td>
</tr>
</tbody>
</table>
<h3 id="lsd-radix-sortleast-significant-digital">LSD radix sort（Least significant digital）</h3>
<p>步驟：</p>
<ol type="1">
<li>令 r 為基底（Base）
<ul>
<li>準備 r 個「Bucket」編號為 0 ~ (r-1)</li>
</ul></li>
<li>令 d 為「Input data」<strong>中所有值以 r 為基底之最大位數個數</strong>：O( n )
<ul>
<li><strong>之後在執行排序時只需要 d 回合即可完成</strong></li>
</ul></li>
<li>由最低位元至最高位元執行：
<ol type="1">
<li>分派（Distribution）
<ul>
<li>依各個資料之該位元分派到對應的「Bucket」</li>
</ul></li>
<li>合併（Merge）
<ul>
<li>將所有「Bucket」由小到大（0 ~ (r-1)）合併</li>
</ul></li>
</ol></li>
</ol>
<p>Example（基底為 10；十進位）</p>
<p>排序：329、457、657、839、436、720、355</p>
<figure>
<img src="\willywangkaa\images\1542447949542.png" alt="1542447949542" /><figcaption aria-hidden="true">1542447949542</figcaption>
</figure>
<ul>
<li>Time complexity
<ul>
<li>作 d 回合 <span class="math inline">\(\left\{\begin{matrix} 分派：O(n) \\ 合併：O(r) \end{matrix}\right. \\ \Rightarrow 一回合需要\; O(n+r) \\ \Rightarrow 總共時間複雜度：O( d \times (n+r) )\)</span></li>
<li>為「Linear time」：r 可以視為常數 c1 ，而因為值域受到限制，所以 d 為固定值亦為常數 c2
<ul>
<li>O(c2 × (n+c1)) = O( c2 × n + c2 × c1 ) = O( n )</li>
</ul></li>
</ul></li>
<li>Space complexity
<ul>
<li>額外空間需求為「Bucket space」，而有 r 個大小為 n 的「Bucket」：O( r × n )</li>
</ul></li>
<li>Stable</li>
</ul>
<h3 id="msd-radix-sortmost-significant-digital">MSD radix sort（Most significant digital）</h3>
<p>步驟：</p>
<ol type="1">
<li>令 r 為基底（Base） ，準備 r 個「Bucket」編號為 0 ~ (r-1)</li>
<li>依照「最高位元」的數值分派資料至「Bucket」中</li>
<li>每個「Bucket」內各自排序</li>
<li>由小到大合併所有「Bucket」</li>
</ol>
<blockquote>
<p>「LSD radix sort」最大的區別</p>
<ul>
<li>「MSD radix sort」
<ul>
<li>作「分派」與「合併」各一次</li>
<li>若「資料位數很大」或「基底很小」時
<ul>
<li>建議採用「MSD radix sort」</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h4 id="bucket-sortalgorithm-書上版本">Bucket sort（Algorithm 書上版本）</h4>
<p>步驟：</p>
<ol type="1">
<li>將資料轉化成「純小數」</li>
<li>以各個純小數之小數後第一位值有序的插入「Bucket」中</li>
<li>由小到大合併所有「Bucket」</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo code</span></span><br><span class="line">Array bucket-<span class="built_in">sort</span>(array, n) &#123;</span><br><span class="line">    Array buckets[n];</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> <span class="built_in">to</span> (<span class="built_in">length</span>(array)<span class="number">-1</span>) &#123;</span><br><span class="line">        buckets[<span class="built_in">msbits</span>(array[i], k)].<span class="built_in">insert</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span> </span><br><span class="line">        next-<span class="built_in">sort</span>(buckets[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">concatenation</span>(buckets[<span class="number">0</span>], ..., buckets[n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在實作裡，可用每個桶內部用連結串列表示，在資料入桶的同時<strong>插入排序</strong>，然後把各個桶中的資料合併</p>
</blockquote>
<p>Example</p>
<p>排序：179、208、306、93、859、984、55、9、271、33</p>
<figure>
<img src="\willywangkaa\images\1542448961965.png" alt="1542448961965" /><figcaption aria-hidden="true">1542448961965</figcaption>
</figure>
<h2 id="counting-sort">Counting sort</h2>
<p>假設 n 為欲排序資料之總數，且該資料範圍介於 1 ~ k 之間</p>
<p>步驟</p>
<ol type="1">
<li>統計各個鍵值出現次數，並記錄在 count[1...k] 之中</li>
<li>利用 count[1...k] 求出各個鍵值<strong>未來</strong>排序時之起始位置，紀錄在 start[1...k] 中</li>
<li>依據 start[1...k] 之指示，將「Input array」置入「Output array」中對應的位置</li>
</ol>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A: 欲排序陣列</span></span><br><span class="line"><span class="comment">// n: 資料個數</span></span><br><span class="line"><span class="comment">// k: 值域範圍</span></span><br><span class="line"><span class="built_in">Countingsort</span>(A[], n, k) &#123;</span><br><span class="line">    <span class="keyword">new</span> count[<span class="number">1.</span>..k];</span><br><span class="line">    <span class="keyword">new</span> start[<span class="number">1.</span>..k];</span><br><span class="line">    <span class="keyword">new</span> output[<span class="number">1.</span>..n];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;         <span class="comment">// Time complexity: O(k)</span></span><br><span class="line">        count[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步驟一：統計鍵值出現個數</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;         <span class="comment">// Time complexity: O(n)</span></span><br><span class="line">        count[A[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步驟二：計算每個鍵值排序時之起點位置</span></span><br><span class="line">    start[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; i++) &#123;         <span class="comment">// Time complexity: O(k)</span></span><br><span class="line">        start[i] = start[i<span class="number">-1</span>]+count[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步驟三：依照指示放置資料</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;         <span class="comment">// Time complexity: O(n)</span></span><br><span class="line">        <span class="comment">// 先使用 start[A[i]] 原本資料後，</span></span><br><span class="line">        <span class="comment">// 將 start[A[i]]+=1</span></span><br><span class="line">        output[start[A[i]]++] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Time complexity
<ul>
<li>O(k) + O(n) +O(k) + O(n) = O(n+k)</li>
</ul></li>
</ul>
<blockquote>
<p>探討為何 <code>O(k)+O(n)+O(k)+O(n)</code> 為線性時間複雜度</p>
<ul>
<li>觀點一
<ul>
<li>若鍵值值域之範圍變化是 O(n)
<ul>
<li>此處的 O(n) 為資料範圍
<ul>
<li><strong>意旨「Input array」中每一個元素在資料範圍中均勻分布</strong></li>
</ul></li>
<li>此觀點來看時間複雜度為
<ul>
<li><strong>O(n+k) =&gt; O(n+O(n)) =&gt; O(n)</strong></li>
</ul></li>
</ul></li>
</ul></li>
<li>觀點二
<ul>
<li>若「Input array」之值域受到限制
<ul>
<li>k 可以視為一個常數
<ul>
<li>O(n+k) = O(n)</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>Space complexity
<ul>
<li><code>count[1...k]、start[1...k]、output[1...n]</code>，O(n+k)</li>
</ul></li>
<li>Stable</li>
</ul>
<h3 id="counting-sort-問題與探討">Counting sort 問題與探討</h3>
<p>延續上面探討時間複雜度之觀點一，已知「Counting sort」之時間複雜度為 O(n+k)，若<strong>資料範圍</strong> k 為線性等級 O(k) ，則整理排序時間複雜度為 O(n)</p>
<ul>
<li>倘若<strong>資料範圍</strong> k 為平方等級 O(<span class="math inline">\(n^2\)</span>)
<ul>
<li><strong>意旨「Input array」中的元素在資料範圍超出原本「Counting sort」可執行排序的資料範圍</strong></li>
</ul></li>
<li>必須探討其時間複雜度之變化 O(n + O(<span class="math inline">\(n^2\)</span>))</li>
</ul>
<p>Example（用例子解釋）</p>
<ul>
<li>一「Counting sort」只能對值域 0 ~ 9 的資料集合<strong>（O(n)）</strong>作排序
<ul>
<li>要如何對一個值域為 0 ~ 99 <strong>（O(</strong><span class="math inline">\(n^2\)</span><strong>)）</strong>的資料集合作排序？</li>
</ul></li>
</ul>
<p>以<strong>「基數排序法」的想法為基礎</strong>，則可以在兩回合中將排序完成</p>
<ol type="1">
<li><p>對每個鍵值作「mod n」</p>
<ul>
<li>n 為「Counting sort」能夠排序的範圍，亦可以視為「基底」</li>
<li>取其作為排序鍵值，對每個資料以新排序鍵值作「Counting sort」
<ul>
<li>將結果以類似<strong>「『Radix sort』每回合最後之合併動作」</strong>收尾</li>
</ul></li>
<li>因為值域介於 0 ~ (n-1) 之間
<ul>
<li>第一回合使用「Counting sort」的排序時間複雜度為 O(n)</li>
</ul></li>
</ul></li>
<li><p>以第一回合之「Output array」作為「Input array」</p>
<ul>
<li>對每個鍵值作「÷ n」再作「mod n」取其作為排序鍵值</li>
<li>對每個資料以新排序鍵值作「Counting sort」
<ul>
<li>將結果以類似「『Radix sort』每回合最後之合併動作」收尾</li>
</ul></li>
<li>採用「基數排序法」作為基礎
<ul>
<li>每回合的排序必須是「Stable」才能正確排序
<ul>
<li>「Counting sort」為「Stable」</li>
<li>排序執行成功，</li>
</ul></li>
<li>第二回合之時間複雜度為 O(n)</li>
</ul></li>
</ul></li>
</ol>
<ul>
<li><strong>總時間複雜度為 2 × O(n) = O(n) ，仍為線性時間複雜度</strong></li>
</ul>
<blockquote>
<p>若資料範圍為 O(<span class="math inline">\(n^3\)</span>) 則依照上述想法， 三回合即可排序完成</p>
<ol type="1">
<li>第一回合的排序鍵值為 $原本鍵值i ;％; n $ 作為「Counting sort」排序鍵值（時間複雜度為 O(n)）</li>
<li>第一回合的排序鍵值為 $;％; n $ 作為「Counting sort」排序鍵值（時間複雜度為 O(n)）</li>
<li>第一回合的排序鍵值為 <span class="math inline">\(\lceil\frac{原本鍵值i}{n^2}\rceil \;％ \;n ​\)</span> 作為「Counting sort」排序鍵值（時間複雜度為 O(n)）</li>
</ol>
<ul>
<li>當資料範圍為 <span class="math inline">\(O(n^4)、O(n^5)\)</span> 亦可以以此類推</li>
</ul>
</blockquote>

      
    </div>

    
      


    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/willywangkaa/tags/Search/" rel="tag"># Search</a>
          
            <a href="/willywangkaa/tags/Sort/" rel="tag"># Sort</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/willywangkaa/2018/10/31/Data-structure-Advance-heap/" rel="next" title="Data structure - Advance heap">
                <i class="fa fa-chevron-left"></i> Data structure - Advance heap
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/willywangkaa/2018/12/02/Data-structure-graph/" rel="prev" title="Data structure - Graph">
                Data structure - Graph <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/willywangkaa/images/avatar_me.gif"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/willywangkaa/archives/%20%7C%7C%20archive">
                
                    <span class="site-state-item-count">61</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/willywangkaa/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/willywangkaa/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">76</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://typora.io/" title="Typora" target="_blank">Typora</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.geeksforgeeks.org/" title="GeeksforGeeks" target="_blank">GeeksforGeeks</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.codecogs.com/latex/eqneditor.php" title="Online LaTeX Equation Editor" target="_blank">Online LaTeX Equation Editor</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://allem40306.github.io/blog/" title="CodingJack" target="_blank">CodingJack</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#binary-search"><span class="nav-number">1.</span> <span class="nav-text">Binary search</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#internal-sort-and-external-sort"><span class="nav-number">2.</span> <span class="nav-text">Internal sort and external sort</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#internal-sort"><span class="nav-number">2.1.</span> <span class="nav-text">Internal sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#external-sort"><span class="nav-number">2.2.</span> <span class="nav-text">External sort</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%80%A7%E8%B3%AA%E6%AF%94%E8%BC%83%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">排序性質比較表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9D%E7%AD%89%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">初等排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#insertion-sort"><span class="nav-number">4.1.</span> <span class="nav-text">Insertion sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#selection-sort"><span class="nav-number">4.2.</span> <span class="nav-text">Selection sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bubble-sort"><span class="nav-number">4.3.</span> <span class="nav-text">☆Bubble sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E4%B8%80"><span class="nav-number">4.3.1.</span> <span class="nav-text">版本一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E4%BA%8C"><span class="nav-number">4.3.2.</span> <span class="nav-text">版本二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#weiss-%E7%89%88%E6%9C%AC-shell-sort"><span class="nav-number">4.4.</span> <span class="nav-text">[Weiss 版本] Shell sort</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%AD%89%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">高等排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#comparesion-based-comparsion-and-swap-sort-%E7%A0%94%E7%A9%B6%E8%88%87%E6%8E%A2%E8%A8%8E"><span class="nav-number">5.1.</span> <span class="nav-text">Comparesion based ( Comparsion and swap ) sort 研究與探討</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#quick-sort"><span class="nav-number">5.2.</span> <span class="nav-text">Quick sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#quicksort1-hoare-partition"><span class="nav-number">5.2.1.</span> <span class="nav-text">Quicksort1 ( Hoare partition )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quicksort2-algorithm%E6%9B%B8%E4%B8%AD%E7%89%88%E6%9C%AC"><span class="nav-number">5.2.2.</span> <span class="nav-text">Quicksort2 ( 「Algorithm」書中版本 )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E8%88%87%E8%A8%8E%E8%AB%96selection-problem"><span class="nav-number">5.2.3.</span> <span class="nav-text">問題與討論—Selection problem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E8%88%87%E8%A8%8E%E8%AB%96select-i-th-item-among-n-unsorted-data-array"><span class="nav-number">5.2.4.</span> <span class="nav-text">問題與討論—Select i-th item among n unsorted data array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#selection-with-median-of-medians"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">Selection with median of medians</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#merge-sort"><span class="nav-number">5.3.</span> <span class="nav-text">Merge sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#iterative-merge-sorttwo-way-merge"><span class="nav-number">5.3.1.</span> <span class="nav-text">Iterative merge sort（Two way merge）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recursive-merge-sorttwo-way-merge"><span class="nav-number">5.3.2.</span> <span class="nav-text">Recursive merge sort（Two way merge）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BC%94%E5%8A%A9%E7%B5%90%E6%A7%8B-selection-tree"><span class="nav-number">5.3.3.</span> <span class="nav-text">[輔助結構] Selection tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#winner-tree"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">Winner tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loser-tree"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">Loser tree</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#heap-sort"><span class="nav-number">5.4.</span> <span class="nav-text">Heap sort</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linear-time-sorting-method"><span class="nav-number">6.</span> <span class="nav-text">Linear time sorting method</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#radix-sort-%E5%9F%BA%E6%95%B8%E6%8E%92%E5%BA%8F%E6%B3%95-data-structure-%E6%9B%B8%E4%B8%8A%E7%89%88%E6%9C%AC"><span class="nav-number">6.1.</span> <span class="nav-text">Radix sort 基數排序法 ( Data structure 書上版本 )</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lsd-radix-sortleast-significant-digital"><span class="nav-number">6.1.1.</span> <span class="nav-text">LSD radix sort（Least significant digital）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#msd-radix-sortmost-significant-digital"><span class="nav-number">6.1.2.</span> <span class="nav-text">MSD radix sort（Most significant digital）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bucket-sortalgorithm-%E6%9B%B8%E4%B8%8A%E7%89%88%E6%9C%AC"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">Bucket sort（Algorithm 書上版本）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#counting-sort"><span class="nav-number">6.2.</span> <span class="nav-text">Counting sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#counting-sort-%E5%95%8F%E9%A1%8C%E8%88%87%E6%8E%A2%E8%A8%8E"><span class="nav-number">6.2.1.</span> <span class="nav-text">Counting sort 問題與探討</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Yu Li</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  



  
  
    <script type="text/javascript" src="/willywangkaa/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/willywangkaa/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/willywangkaa/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/willywangkaa/lib/reading_progress/reading_progress.js"></script>
  


  


  <script type="text/javascript" src="/willywangkaa/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/willywangkaa/js/src/motion.js?v=6.0.4"></script>



  
  


  <script type="text/javascript" src="/willywangkaa/js/src/affix.js?v=6.0.4"></script>

  <script type="text/javascript" src="/willywangkaa/js/src/schemes/pisces.js?v=6.0.4"></script>



  
  <script type="text/javascript" src="/willywangkaa/js/src/scrollspy.js?v=6.0.4"></script>
<script type="text/javascript" src="/willywangkaa/js/src/post-details.js?v=6.0.4"></script>



  


  <script type="text/javascript" src="/willywangkaa/js/src/bootstrap.js?v=6.0.4"></script>



  

  
    <script id="dsq-count-scr" src="https://https-wangwilly-github-io-blog.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://wangwilly.github.io/willywangkaa/2018/11/17/Data-structure-Search-and-sort/';
        this.page.identifier = '2018/11/17/Data-structure-Search-and-sort/';
        this.page.title = 'Data structure - Search and sort';
      };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://https-wangwilly-github-io-blog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





	





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/willywangkaa/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  
  
  
  <script src="/willywangkaa/lib/bookmark/bookmark.min.js?v=1.0"></script>
  <script type="text/javascript">
  
    bookmark.scrollToMark('auto', "#more");
  
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>
